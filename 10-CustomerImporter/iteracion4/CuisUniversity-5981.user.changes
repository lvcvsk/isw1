

----QUIT----(13 August 2023 19:14:09) CuisUniversity-5981.image priorSource: 5713367!

----STARTUP---- (13 August 2023 19:14:10) as /Users/hernan/Documents/Cuis/5.0-64Bits/Cuis-University-Installer/CuisUniversity-5981.image!


----QUIT----(13 August 2023 19:14:10) CuisUniversity-5981.image priorSource: 10197065!

----STARTUP---- (19 September 2023 00:44:39) as C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\CuisUniversity-5981.image!


----End fileIn of C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\ejs\Clase 2.st----!

!classRemoval: #Pepe stamp: 'LK 9/19/2023 00:46:12'!
DenotativeObject subclass: #Pepe
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 2'!

----End fileIn of C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\ejs\Clase 3.st----!

----End fileIn of C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\ejs\ISW1.st----!

----End fileIn of C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\repo\isw1\00-NumerosNaturales\Clase 3.st----!

!classRemoval: #IIIII stamp: 'LK 9/19/2023 00:47:54'!
II subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classRemoval: #IIII stamp: 'LK 9/19/2023 00:47:55'!
II subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classRemoval: #III stamp: 'LK 9/19/2023 00:47:55'!
II subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classRemoval: #II stamp: 'LK 9/19/2023 00:47:55'!
DenotativeObject subclass: #II
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classRemoval: #I stamp: 'LK 9/19/2023 00:47:55'!
DenotativeObject subclass: #I
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

----End fileIn of C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\ejs\Clase 3.st----!

----End fileIn of C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\repo\isw1\01-CodigoRepetido\CodigoRepetido-Ejercicio.st----!

----End fileIn of C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\repo\isw1\03-Stack\Stack-Exercise.st----!

----End fileIn of C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\ejs\02\Numero-Solution-4.st----!

----End fileIn of C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\ejs\02\Numero-Solution-3.st----!

!classRemoval: #Fraccion stamp: 'LK 9/19/2023 00:51:24'!
Numero subclass: #Fraccion
	instanceVariableNames: 'numerator denominator'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Solution-3'!

!classRemoval: #Uno stamp: 'LK 9/19/2023 00:51:25'!
Entero subclass: #Uno
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Solution-3'!

!classRemoval: #PositivoMayorAUno stamp: 'LK 9/19/2023 00:51:25'!
EnteroMenosCeroYUno subclass: #PositivoMayorAUno
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Solution-3'!

!classRemoval: #Negativo stamp: 'LK 9/19/2023 00:51:25'!
EnteroMenosCeroYUno subclass: #Negativo
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Solution-3'!

!classRemoval: #EnteroMenosCeroYUno stamp: 'LK 9/19/2023 00:51:25'!
Entero subclass: #EnteroMenosCeroYUno
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Solution-3'!

!classRemoval: #Cero stamp: 'LK 9/19/2023 00:51:26'!
Entero subclass: #Cero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Solution-3'!

!classRemoval: #Entero stamp: 'LK 9/19/2023 00:51:26'!
Numero subclass: #Entero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Solution-3'!

!classRemoval: #Numero stamp: 'LK 9/19/2023 00:51:26'!
Object subclass: #Numero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Solution-3'!

!classRemoval: #NumeroTest stamp: 'LK 9/19/2023 00:51:27'!
TestCase subclass: #NumeroTest
	instanceVariableNames: 'zero one two four oneFifth oneHalf five twoFifth twoTwentyfifth fiveHalfs three eight negativeOne negativeTwo'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Solution-3'!

----End fileIn of C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\ejs\02\Numero-Solution-3.st----!

----STARTUP---- (19 September 2023 00:55:13) as C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\CuisUniversity-5981.image!


!classDefinition: #Falso category: 'Clase 2' stamp: 'LK 9/19/2023 00:55:25'!
DenotativeObject subclass: #Falso
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 2'!

!classDefinition: #Falso category: 'Clase 2' stamp: 'LK 9/19/2023 00:55:25'!
DenotativeObject subclass: #Falso
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 2'!

!classDefinition: 'Falso class' category: 'Clase 2' stamp: 'LK 9/19/2023 00:55:25'!
Falso class
	instanceVariableNames: ''!

!classDefinition: 'Falso class' category: 'Clase 2' stamp: 'LK 9/19/2023 00:55:25'!
Falso class
	instanceVariableNames: ''!
!Falso class methodsFor: 'as yet unclassified' stamp: 'LK 8/17/2023 20:55:18'!
no
	^Verdadero! !
!Falso class methodsFor: 'as yet unclassified' stamp: 'LK 8/17/2023 21:15:02'!
o:unBooleano
	^unBooleano! !
!Falso class methodsFor: 'as yet unclassified' stamp: 'LK 8/17/2023 21:26:50'!
siEsFalso: aClosure
	^aClosure value! !
!Falso class methodsFor: 'as yet unclassified' stamp: 'LK 8/17/2023 21:53:55'!
siEsVerdadero: aClosure
	^self.! !
!Falso class methodsFor: 'as yet unclassified' stamp: 'LK 8/17/2023 20:59:43'!
y:unBooleano
	^Falso! !

!classDefinition: #Pepe category: 'Clase 2' stamp: 'LK 9/19/2023 00:55:25'!
DenotativeObject subclass: #Pepe
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 2'!

!classDefinition: #Pepe category: 'Clase 2' stamp: 'LK 9/19/2023 00:55:25'!
DenotativeObject subclass: #Pepe
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 2'!

!classDefinition: #Verdadero category: 'Clase 2' stamp: 'LK 9/19/2023 00:55:25'!
DenotativeObject subclass: #Verdadero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 2'!

!classDefinition: #Verdadero category: 'Clase 2' stamp: 'LK 9/19/2023 00:55:25'!
DenotativeObject subclass: #Verdadero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 2'!

!classDefinition: 'Verdadero class' category: 'Clase 2' stamp: 'LK 9/19/2023 00:55:25'!
Verdadero class
	instanceVariableNames: ''!

!classDefinition: 'Verdadero class' category: 'Clase 2' stamp: 'LK 9/19/2023 00:55:25'!
Verdadero class
	instanceVariableNames: ''!
!Verdadero class methodsFor: 'as yet unclassified' stamp: 'LK 8/17/2023 20:55:25'!
no
	^Falso! !
!Verdadero class methodsFor: 'as yet unclassified' stamp: 'LK 8/17/2023 21:04:31'!
o:unBooleano
	^Verdadero! !
!Verdadero class methodsFor: 'as yet unclassified' stamp: 'LK 8/17/2023 21:53:44'!
siEsFalso: aClosure
	^self.! !
!Verdadero class methodsFor: 'as yet unclassified' stamp: 'LK 8/17/2023 21:27:02'!
siEsVerdadero: aClosure
	^aClosure value! !
!Verdadero class methodsFor: 'as yet unclassified' stamp: 'LK 8/17/2023 21:14:30'!
y:unBooleano
	^unBooleano! !

!classDefinition: #VerdaderoFalsoTests category: 'Clase 2' stamp: 'LK 9/19/2023 00:55:26'!
DenotativeObject subclass: #VerdaderoFalsoTests
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 2'!

!classDefinition: #VerdaderoFalsoTests category: 'Clase 2' stamp: 'LK 9/19/2023 00:55:26'!
DenotativeObject subclass: #VerdaderoFalsoTests
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 2'!

!classDefinition: 'VerdaderoFalsoTests class' category: 'Clase 2' stamp: 'LK 9/19/2023 00:55:26'!
VerdaderoFalsoTests class
	instanceVariableNames: ''!

!classDefinition: 'VerdaderoFalsoTests class' category: 'Clase 2' stamp: 'LK 9/19/2023 00:55:26'!
VerdaderoFalsoTests class
	instanceVariableNames: ''!
!VerdaderoFalsoTests class methodsFor: 'as yet unclassified' stamp: 'LK 8/17/2023 20:48:44'!
test01NoVerdaderoEsFalso
	Assert that: Verdadero no isEqualTo: Falso ! !
!VerdaderoFalsoTests class methodsFor: 'as yet unclassified' stamp: 'LK 8/17/2023 20:54:06'!
test02NoFalsoEsVerdadero
	Assert that: Falso no isEqualTo: Verdadero ! !
!VerdaderoFalsoTests class methodsFor: 'as yet unclassified' stamp: 'LK 8/17/2023 21:17:52'!
test03FalsoYVerdaderoEsFalso
	Assert that: (Falso y:Verdadero) isEqualTo: Falso ! !
!VerdaderoFalsoTests class methodsFor: 'as yet unclassified' stamp: 'LK 8/17/2023 21:18:10'!
test04FalsoYFalsoEsFalso
	Assert that: (Falso y:Falso) isEqualTo: Falso ! !
!VerdaderoFalsoTests class methodsFor: 'as yet unclassified' stamp: 'LK 8/17/2023 21:18:39'!
test05VerdaderoYFalsoEsFalso
	Assert that: (Verdadero y:Falso) isEqualTo: Falso ! !
!VerdaderoFalsoTests class methodsFor: 'as yet unclassified' stamp: 'LK 8/17/2023 21:18:59'!
test06VerdaderoYVerdaderoEsVerdadero
	Assert that: (Verdadero y:Verdadero) isEqualTo: Verdadero ! !
!VerdaderoFalsoTests class methodsFor: 'as yet unclassified' stamp: 'LK 8/17/2023 21:19:27'!
test07VerdaderoOVerdaderoEsVerdadero
	Assert that: (Verdadero o:Verdadero) isEqualTo: Verdadero ! !
!VerdaderoFalsoTests class methodsFor: 'as yet unclassified' stamp: 'LK 8/17/2023 21:19:52'!
test08VerdaderoOFalsoEsVerdadero
	Assert that: (Verdadero o:Falso) isEqualTo: Verdadero ! !
!VerdaderoFalsoTests class methodsFor: 'as yet unclassified' stamp: 'LK 8/17/2023 21:20:25'!
test09FalsoOFalsoEsFalso
	Assert that: (Falso o:Falso) isEqualTo: Falso ! !
!VerdaderoFalsoTests class methodsFor: 'as yet unclassified' stamp: 'LK 8/17/2023 21:20:45'!
test09FalsoOVerdaderoEsVerdadero
	Assert that: (Falso o:Verdadero) isEqualTo: Verdadero! !
!VerdaderoFalsoTests class methodsFor: 'as yet unclassified' stamp: 'LK 8/17/2023 21:34:17'!
test10FalsoOVerdaderoEsVerdadero
	Assert that: (Falso o:Verdadero) isEqualTo: Verdadero! !
!VerdaderoFalsoTests class methodsFor: 'as yet unclassified' stamp: 'LK 8/17/2023 21:35:50'!
test11FalsoSiesFalso
	Assert that: (Falso siEsFalso:['hola']) isEqualTo: 'hola'! !
!VerdaderoFalsoTests class methodsFor: 'as yet unclassified' stamp: 'LK 8/17/2023 21:37:41'!
test12FalsoSiesVerdadero
	Assert that: (Falso siEsVerdadero:['hola']) isNotEqualTo: 'hola'! !
!VerdaderoFalsoTests class methodsFor: 'as yet unclassified' stamp: 'LK 8/17/2023 21:39:40'!
test13FalsoSiesVerdaderobis
	Assert that: [Falso siEsVerdadero:['hola'].^1] value isEqualTo: 1! !
!VerdaderoFalsoTests class methodsFor: 'as yet unclassified' stamp: 'LK 8/17/2023 21:43:48'!
test14VerdaderoSiEsVerdadero
	Assert that: (Verdadero siEsVerdadero:['hola']) isEqualTo: 'hola'! !
!VerdaderoFalsoTests class methodsFor: 'as yet unclassified' stamp: 'LK 8/17/2023 21:45:14'!
test15VerdaderoSiEsFalso
	Assert that: (Verdadero siEsFalso:['hola']) isNotEqualTo: 'hola'! !
!VerdaderoFalsoTests class methodsFor: 'as yet unclassified' stamp: 'LK 8/17/2023 21:56:36'!
test16VerdaderoSiEsFalso

	| aClosure n1 |
	n1 := 0.
	aClosure := [n1 := 5].
	
	Verdadero siEsVerdadero: aClosure .
	Assert that: n1 isEqualTo: 0! !

!classRemoval: #Pepe stamp: 'LK 9/19/2023 00:55:28'!
DenotativeObject subclass: #Pepe
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 2'!

!classDefinition: #I category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:28'!
DenotativeObject subclass: #I
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classDefinition: #I category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:28'!
DenotativeObject subclass: #I
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classDefinition: 'I class' category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:28'!
I class
	instanceVariableNames: ''!

!classDefinition: 'I class' category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:28'!
I class
	instanceVariableNames: ''!
!I class methodsFor: 'as yet unclassified' stamp: 'LK 8/28/2023 12:26:00'!
* aNaturalNumber
	^aNaturalNumber! !
!I class methodsFor: 'as yet unclassified' stamp: 'lk 8/24/2023 21:01:54'!
+ aNaturalNumber
	
	^aNaturalNumber next! !
!I class methodsFor: 'as yet unclassified' stamp: 'LK 9/3/2023 18:09:02'!
- aNaturalNumber
	^self error: self descripcionDeErrorDeNumerosNegativosNoSoportados! !
!I class methodsFor: 'as yet unclassified' stamp: 'LK 9/3/2023 18:11:14'!
/ aNaturalNumber
	self = aNaturalNumber ifTrue:[^self.].
	^self error: self descripcionDeErrorDeNoSePuedeDividirPorUnNumeroMayor.! !
!I class methodsFor: 'as yet unclassified' stamp: 'LK 9/3/2023 18:45:28'!
descripcionDeErrorDeNoSePuedeDividirPorUnNumeroMayor
	^'No puedo dividir por un número mayor!!!!!!'.! !
!I class methodsFor: 'as yet unclassified' stamp: 'LK 9/3/2023 18:45:38'!
descripcionDeErrorDeNumerosNegativosNoSoportados
	^'No soporto a los numeros negativos'.! !
!I class methodsFor: 'as yet unclassified' stamp: 'LK 9/3/2023 18:15:54'!
next
	^II.! !
!I class methodsFor: 'as yet unclassified' stamp: 'lk 8/24/2023 21:57:00'!
restateA: aNaturalNumber

	^aNaturalNumber previous.! !

!classDefinition: #II category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:29'!
DenotativeObject subclass: #II
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classDefinition: #II category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:29'!
DenotativeObject subclass: #II
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classDefinition: 'II class' category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:30'!
II class
	instanceVariableNames: 'next previous'!

!classDefinition: 'II class' category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:30'!
II class
	instanceVariableNames: 'next previous'!
!II class methodsFor: 'as yet unclassified' stamp: 'LK 8/28/2023 21:00:36'!
* aNaturalNumber
	^(self previous * aNaturalNumber) + aNaturalNumber
	! !
!II class methodsFor: 'as yet unclassified' stamp: 'LK 8/28/2023 20:39:54'!
+ aNaturalNumber
	^self previous + aNaturalNumber next.! !
!II class methodsFor: 'as yet unclassified' stamp: 'LK 9/3/2023 17:39:44'!
- aNaturalNumber
	^aNaturalNumber restateA: self! !
!II class methodsFor: 'as yet unclassified' stamp: 'LK 9/3/2023 18:37:59'!
/ aNaturalNumber
	
	| resultado |
	self = aNaturalNumber ifTrue: [^I].
	[resultado := self - aNaturalNumber] on: Error do: [^self error: self descripcionDeErrorDeNoSePuedeDividirPorUnNumeroMayor].
	^ I + (resultado / aNaturalNumber).
	
! !
!II class methodsFor: 'as yet unclassified' stamp: 'LK 9/3/2023 18:44:07'!
descripcionDeErrorDeNoSePuedeDividirPorUnNumeroMayor
	^'No puedo dividir por un número mayor!!!!!!'.! !
!II class methodsFor: 'as yet unclassified' stamp: 'LK 9/3/2023 18:44:19'!
descripcionDeErrorDeNumerosNegativosNoSoportados
	^'No soporto a los numeros negativos'.! !
!II class methodsFor: 'as yet unclassified' stamp: 'LK 8/28/2023 21:18:51'!
next
	next ifNotNil: [^next].
	next := II createChildNamed: self name , 'I'.
	next previous: self.
	^next.! !
!II class methodsFor: 'as yet unclassified' stamp: 'lk 8/24/2023 21:22:03'!
previous
	
	^ previous.! !
!II class methodsFor: 'as yet unclassified' stamp: 'lk 8/24/2023 21:27:05'!
previous: aNaturalNumber
	
	previous := aNaturalNumber! !
!II class methodsFor: 'as yet unclassified' stamp: 'LK 9/3/2023 17:39:44'!
restateA: aNaturalNumber

	^aNaturalNumber  previous - self previous.! !
!II class methodsFor: '--** private fileout/in **--' stamp: 'LK 9/3/2023 18:50:43' overrides: 50637315!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := III.
	previous := I.! !

!classDefinition: #III category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:31'!
II subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classDefinition: #III category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:31'!
II subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classDefinition: 'III class' category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:31'!
III class
	instanceVariableNames: ''!

!classDefinition: 'III class' category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:31'!
III class
	instanceVariableNames: ''!
!III class methodsFor: '--** private fileout/in **--' stamp: 'LK 9/3/2023 18:50:43' overrides: 50656200!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := IIII.
	previous := II.! !

!classDefinition: #IIII category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:31'!
II subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classDefinition: #IIII category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:31'!
II subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classDefinition: 'IIII class' category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:31'!
IIII class
	instanceVariableNames: ''!

!classDefinition: 'IIII class' category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:31'!
IIII class
	instanceVariableNames: ''!
!IIII class methodsFor: '--** private fileout/in **--' stamp: 'LK 9/3/2023 18:50:43' overrides: 50656200!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := IIIII.
	previous := III.! !

!classDefinition: #IIIII category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:31'!
II subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classDefinition: #IIIII category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:31'!
II subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classDefinition: 'IIIII class' category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:31'!
IIIII class
	instanceVariableNames: ''!

!classDefinition: 'IIIII class' category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:31'!
IIIII class
	instanceVariableNames: ''!
!IIIII class methodsFor: '--** private fileout/in **--' stamp: 'LK 9/3/2023 18:50:43' overrides: 50656200!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := nil.
	previous := IIII.! !

!methodRemoval: II class #initializeCollaboratorsFromFile stamp: 'LK 9/19/2023 00:55:31'!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := III.
	previous := I.!

!methodRemoval: III class #initializeCollaboratorsFromFile stamp: 'LK 9/19/2023 00:55:32'!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := IIII.
	previous := II.!

!methodRemoval: IIII class #initializeCollaboratorsFromFile stamp: 'LK 9/19/2023 00:55:32'!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := IIIII.
	previous := III.!

!methodRemoval: IIIII class #initializeCollaboratorsFromFile stamp: 'LK 9/19/2023 00:55:32'!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := nil.
	previous := IIII.!

!classDefinition: #XXX category: 'ISW1' stamp: 'LK 9/19/2023 00:55:32'!
Object subclass: #XXX
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1'!

!classDefinition: #XXX category: 'ISW1' stamp: 'LK 9/19/2023 00:55:32'!
Object subclass: #XXX
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1'!
!XXX methodsFor: 'as yet unclassified' stamp: 'LK 8/31/2023 21:47:22'!
extractVowels
 'sidashdiahsdnienweq' select: [ :char | char isVowel]
	
! !
!XXX methodsFor: 'as yet unclassified' stamp: 'LK 8/31/2023 21:22:57'!
findDoubles

        | elements |

        elements:= #(1 2 5 6 9).

	^elements collect:[ :element | element * 2].
! !
!XXX methodsFor: 'as yet unclassified' stamp: 'LK 8/31/2023 21:36:09'!
findFirstEven

        | elements |

        elements:= #(1 2 5 6 9).

	^elements detect: [:element | element even]! !
!XXX methodsFor: 'as yet unclassified' stamp: 'LK 8/31/2023 21:36:37'!
findFirstEvenWithoutMatching

        | elements |

        elements:= #(1 5 9).

	^elements detect:[ :element | element even] ifNone: [42].
! !
!XXX methodsFor: 'as yet unclassified' stamp: 'LK 8/31/2023 21:37:03'!
findFirstEvenWithoutMatchingReturningString

        | elements |

        elements:= #(1 5 9).

	^elements detect:[ :element | element even] ifNone: ['42'].
! !
!XXX methodsFor: 'as yet unclassified' stamp: 'LK 8/31/2023 20:48:26'!
findOddsPart0

        | elements index odds |

        elements:= #(1 2 5 6 9).

        odds := OrderedCollection new.
        index := 1.

        [index <= elements size]
        whileTrue: [
                ((elements at: index) odd) ifTrue: [odds add: (elements at: index)].
                index := index +1.
                ].
        ^odds! !
!XXX methodsFor: 'as yet unclassified' stamp: 'LK 8/31/2023 21:16:17'!
findOddsPart1

        | elements odds |

        elements:= #(1 2 5 6 9).

        odds := OrderedCollection new.

	elements do:[ :element | 
		
                element odd ifTrue: [odds add: element]].              
  
        ^odds! !
!XXX methodsFor: 'as yet unclassified' stamp: 'LK 8/31/2023 21:16:32'!
findOddsPart2

        | elements |

        elements:= #(1 2 5 6 9).

	^elements select:[ :element | element odd].                ! !
!XXX methodsFor: 'as yet unclassified' stamp: 'LK 8/31/2023 21:20:44'!
findOddsPart3

        | elements |

        elements:= #(1 2 5 6 9) asSet.

	^elements select:[ :element | element odd].                ! !
!XXX methodsFor: 'as yet unclassified' stamp: 'LK 8/31/2023 21:41:24'!
sumElementsInjecting
	
	| elements |
	
	elements := #(1 5 9).
	
	^elements inject: 0 into: [ :sum :element | sum + element].! !
!XXX methodsFor: 'as yet unclassified' stamp: 'LK 8/31/2023 21:46:32'!
sumElementsSum
	
	| elements |
	
	elements := #(1 5 9).
	
	^elements inject: 0 into: [ :sum :element | sum + element].! !

!classDefinition: #I category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:33'!
DenotativeObject subclass: #I
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classDefinition: #I category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:33'!
DenotativeObject subclass: #I
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classDefinition: 'I class' category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:33'!
I class
	instanceVariableNames: ''!

!classDefinition: 'I class' category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:33'!
I class
	instanceVariableNames: ''!
!I class methodsFor: 'as yet unclassified' stamp: 'LK 8/28/2023 12:26:00' prior: 50656082!
* aNaturalNumber
	^aNaturalNumber! !
!I class methodsFor: 'as yet unclassified' stamp: 'lk 8/24/2023 21:01:54' prior: 50656086!
+ aNaturalNumber
	
	^aNaturalNumber next! !
!I class methodsFor: 'as yet unclassified' stamp: 'LK 9/3/2023 18:09:02' prior: 50656090!
- aNaturalNumber
	^self error: self descripcionDeErrorDeNumerosNegativosNoSoportados! !
!I class methodsFor: 'as yet unclassified' stamp: 'LK 9/3/2023 18:11:14' prior: 50656096!
/ aNaturalNumber
	self = aNaturalNumber ifTrue:[^self.].
	^self error: self descripcionDeErrorDeNoSePuedeDividirPorUnNumeroMayor.! !
!I class methodsFor: 'as yet unclassified' stamp: 'LK 9/3/2023 18:45:28' prior: 50656103!
descripcionDeErrorDeNoSePuedeDividirPorUnNumeroMayor
	^'No puedo dividir por un número mayor!!!!!!'.! !
!I class methodsFor: 'as yet unclassified' stamp: 'LK 9/3/2023 18:45:38' prior: 50656109!
descripcionDeErrorDeNumerosNegativosNoSoportados
	^'No soporto a los numeros negativos'.! !
!I class methodsFor: 'as yet unclassified' stamp: 'LK 9/3/2023 18:15:54' prior: 50656115!
next
	^II.! !
!I class methodsFor: 'as yet unclassified' stamp: 'lk 8/24/2023 21:57:00' prior: 50656118!
restateA: aNaturalNumber

	^aNaturalNumber previous.! !

!classDefinition: #II category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:33'!
DenotativeObject subclass: #II
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classDefinition: #II category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:33'!
DenotativeObject subclass: #II
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classDefinition: 'II class' category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:33'!
II class
	instanceVariableNames: 'next previous'!

!classDefinition: 'II class' category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:33'!
II class
	instanceVariableNames: 'next previous'!
!II class methodsFor: 'as yet unclassified' stamp: 'LK 8/28/2023 21:00:36' prior: 50656143!
* aNaturalNumber
	^(self previous * aNaturalNumber) + aNaturalNumber
	! !
!II class methodsFor: 'as yet unclassified' stamp: 'LK 8/28/2023 20:39:54' prior: 50656148!
+ aNaturalNumber
	^self previous + aNaturalNumber next.! !
!II class methodsFor: 'as yet unclassified' stamp: 'LK 9/3/2023 17:39:44' prior: 50656153!
- aNaturalNumber
	^aNaturalNumber restateA: self! !
!II class methodsFor: 'as yet unclassified' stamp: 'LK 9/3/2023 18:37:59' prior: 50656157!
/ aNaturalNumber
	
	| resultado |
	self = aNaturalNumber ifTrue: [^I].
	[resultado := self - aNaturalNumber] on: Error do: [^self error: self descripcionDeErrorDeNoSePuedeDividirPorUnNumeroMayor].
	^ I + (resultado / aNaturalNumber).
	
! !
!II class methodsFor: 'as yet unclassified' stamp: 'LK 9/3/2023 18:44:07' prior: 50656167!
descripcionDeErrorDeNoSePuedeDividirPorUnNumeroMayor
	^'No puedo dividir por un número mayor!!!!!!'.! !
!II class methodsFor: 'as yet unclassified' stamp: 'LK 9/3/2023 18:44:19' prior: 50656173!
descripcionDeErrorDeNumerosNegativosNoSoportados
	^'No soporto a los numeros negativos'.! !
!II class methodsFor: 'as yet unclassified' stamp: 'LK 8/28/2023 21:18:51' prior: 50656179!
next
	next ifNotNil: [^next].
	next := II createChildNamed: self name , 'I'.
	next previous: self.
	^next.! !
!II class methodsFor: 'as yet unclassified' stamp: 'lk 8/24/2023 21:22:03' prior: 50656185!
previous
	
	^ previous.! !
!II class methodsFor: 'as yet unclassified' stamp: 'lk 8/24/2023 21:27:05' prior: 50656189!
previous: aNaturalNumber
	
	previous := aNaturalNumber! !
!II class methodsFor: 'as yet unclassified' stamp: 'LK 9/3/2023 17:39:44' prior: 50656194!
restateA: aNaturalNumber

	^aNaturalNumber  previous - self previous.! !
!II class methodsFor: '--** private fileout/in **--' stamp: 'LK 9/3/2023 18:50:43' overrides: 50637315!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := III.
	previous := I.! !

!classDefinition: #III category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:34'!
II subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classDefinition: #III category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:34'!
II subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classDefinition: 'III class' category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:34'!
III class
	instanceVariableNames: ''!

!classDefinition: 'III class' category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:34'!
III class
	instanceVariableNames: ''!
!III class methodsFor: '--** private fileout/in **--' stamp: 'LK 9/3/2023 18:50:43' overrides: 50656561!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := IIII.
	previous := II.! !

!classDefinition: #IIII category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:34'!
II subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classDefinition: #IIII category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:34'!
II subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classDefinition: 'IIII class' category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:34'!
IIII class
	instanceVariableNames: ''!

!classDefinition: 'IIII class' category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:34'!
IIII class
	instanceVariableNames: ''!
!IIII class methodsFor: '--** private fileout/in **--' stamp: 'LK 9/3/2023 18:50:43' overrides: 50656561!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := IIIII.
	previous := III.! !

!classDefinition: #IIIII category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:34'!
II subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classDefinition: #IIIII category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:34'!
II subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classDefinition: 'IIIII class' category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:34'!
IIIII class
	instanceVariableNames: ''!

!classDefinition: 'IIIII class' category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:34'!
IIIII class
	instanceVariableNames: ''!
!IIIII class methodsFor: '--** private fileout/in **--' stamp: 'LK 9/3/2023 18:50:43' overrides: 50656561!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := nil.
	previous := IIII.! !

!methodRemoval: II class #initializeCollaboratorsFromFile stamp: 'LK 9/19/2023 00:55:34'!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := III.
	previous := I.!

!methodRemoval: III class #initializeCollaboratorsFromFile stamp: 'LK 9/19/2023 00:55:34'!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := IIII.
	previous := II.!

!methodRemoval: IIII class #initializeCollaboratorsFromFile stamp: 'LK 9/19/2023 00:55:34'!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := IIIII.
	previous := III.!

!methodRemoval: IIIII class #initializeCollaboratorsFromFile stamp: 'LK 9/19/2023 00:55:34'!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := nil.
	previous := IIII.!

!classRemoval: #IIIII stamp: 'LK 9/19/2023 00:55:35'!
II subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classRemoval: #IIII stamp: 'LK 9/19/2023 00:55:35'!
II subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classRemoval: #III stamp: 'LK 9/19/2023 00:55:35'!
II subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classRemoval: #II stamp: 'LK 9/19/2023 00:55:35'!
DenotativeObject subclass: #II
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classRemoval: #I stamp: 'LK 9/19/2023 00:55:35'!
DenotativeObject subclass: #I
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classDefinition: #I category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:35'!
DenotativeObject subclass: #I
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classDefinition: #I category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:35'!
DenotativeObject subclass: #I
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classDefinition: 'I class' category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:35'!
I class
	instanceVariableNames: ''!

!classDefinition: 'I class' category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:36'!
I class
	instanceVariableNames: ''!
!I class methodsFor: 'as yet unclassified' stamp: 'LK 8/28/2023 12:26:00'!
* aNaturalNumber
	^aNaturalNumber! !
!I class methodsFor: 'as yet unclassified' stamp: 'lk 8/24/2023 21:01:54'!
+ aNaturalNumber
	
	^aNaturalNumber next! !
!I class methodsFor: 'as yet unclassified' stamp: 'LK 9/3/2023 18:09:02'!
- aNaturalNumber
	^self error: self descripcionDeErrorDeNumerosNegativosNoSoportados! !
!I class methodsFor: 'as yet unclassified' stamp: 'LK 9/3/2023 18:11:14'!
/ aNaturalNumber
	self = aNaturalNumber ifTrue:[^self.].
	^self error: self descripcionDeErrorDeNoSePuedeDividirPorUnNumeroMayor.! !
!I class methodsFor: 'as yet unclassified' stamp: 'LK 9/3/2023 18:45:28'!
descripcionDeErrorDeNoSePuedeDividirPorUnNumeroMayor
	^'No puedo dividir por un número mayor!!!!!!'.! !
!I class methodsFor: 'as yet unclassified' stamp: 'LK 9/3/2023 18:45:38'!
descripcionDeErrorDeNumerosNegativosNoSoportados
	^'No soporto a los numeros negativos'.! !
!I class methodsFor: 'as yet unclassified' stamp: 'LK 9/3/2023 18:15:54'!
next
	^II.! !
!I class methodsFor: 'as yet unclassified' stamp: 'lk 8/24/2023 21:57:00'!
restateA: aNaturalNumber

	^aNaturalNumber previous.! !

!classDefinition: #II category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:37'!
DenotativeObject subclass: #II
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classDefinition: #II category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:37'!
DenotativeObject subclass: #II
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classDefinition: 'II class' category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:37'!
II class
	instanceVariableNames: 'next previous'!

!classDefinition: 'II class' category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:37'!
II class
	instanceVariableNames: 'next previous'!
!II class methodsFor: 'as yet unclassified' stamp: 'LK 8/28/2023 21:00:36'!
* aNaturalNumber
	^(self previous * aNaturalNumber) + aNaturalNumber
	! !
!II class methodsFor: 'as yet unclassified' stamp: 'LK 8/28/2023 20:39:54'!
+ aNaturalNumber
	^self previous + aNaturalNumber next.! !
!II class methodsFor: 'as yet unclassified' stamp: 'LK 9/3/2023 17:39:44'!
- aNaturalNumber
	^aNaturalNumber restateA: self! !
!II class methodsFor: 'as yet unclassified' stamp: 'LK 9/3/2023 18:37:59'!
/ aNaturalNumber
	
	| resultado |
	self = aNaturalNumber ifTrue: [^I].
	[resultado := self - aNaturalNumber] on: Error do: [^self error: self descripcionDeErrorDeNoSePuedeDividirPorUnNumeroMayor].
	^ I + (resultado / aNaturalNumber).
	
! !
!II class methodsFor: 'as yet unclassified' stamp: 'LK 9/3/2023 18:44:07'!
descripcionDeErrorDeNoSePuedeDividirPorUnNumeroMayor
	^'No puedo dividir por un número mayor!!!!!!'.! !
!II class methodsFor: 'as yet unclassified' stamp: 'LK 9/3/2023 18:44:19'!
descripcionDeErrorDeNumerosNegativosNoSoportados
	^'No soporto a los numeros negativos'.! !
!II class methodsFor: 'as yet unclassified' stamp: 'LK 8/28/2023 21:18:51'!
next
	next ifNotNil: [^next].
	next := II createChildNamed: self name , 'I'.
	next previous: self.
	^next.! !
!II class methodsFor: 'as yet unclassified' stamp: 'lk 8/24/2023 21:22:03'!
previous
	
	^ previous.! !
!II class methodsFor: 'as yet unclassified' stamp: 'lk 8/24/2023 21:27:05'!
previous: aNaturalNumber
	
	previous := aNaturalNumber! !
!II class methodsFor: 'as yet unclassified' stamp: 'LK 9/3/2023 17:39:44'!
restateA: aNaturalNumber

	^aNaturalNumber  previous - self previous.! !
!II class methodsFor: '--** private fileout/in **--' stamp: 'LK 9/3/2023 18:50:43' overrides: 50637315!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := III.
	previous := I.! !

!classDefinition: #III category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:38'!
II subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classDefinition: #III category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:38'!
II subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classDefinition: 'III class' category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:38'!
III class
	instanceVariableNames: ''!

!classDefinition: 'III class' category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:38'!
III class
	instanceVariableNames: ''!
!III class methodsFor: '--** private fileout/in **--' stamp: 'LK 9/3/2023 18:50:43' overrides: 50656844!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := IIII.
	previous := II.! !

!classDefinition: #IIII category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:39'!
II subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classDefinition: #IIII category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:39'!
II subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classDefinition: 'IIII class' category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:39'!
IIII class
	instanceVariableNames: ''!

!classDefinition: 'IIII class' category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:39'!
IIII class
	instanceVariableNames: ''!
!IIII class methodsFor: '--** private fileout/in **--' stamp: 'LK 9/3/2023 18:50:43' overrides: 50656844!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := IIIII.
	previous := III.! !

!classDefinition: #IIIII category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:39'!
II subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classDefinition: #IIIII category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:39'!
II subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classDefinition: 'IIIII class' category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:39'!
IIIII class
	instanceVariableNames: ''!

!classDefinition: 'IIIII class' category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:39'!
IIIII class
	instanceVariableNames: ''!
!IIIII class methodsFor: '--** private fileout/in **--' stamp: 'LK 9/3/2023 18:50:43' overrides: 50656844!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := nil.
	previous := IIII.! !

!methodRemoval: II class #initializeCollaboratorsFromFile stamp: 'LK 9/19/2023 00:55:39'!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := III.
	previous := I.!

!methodRemoval: III class #initializeCollaboratorsFromFile stamp: 'LK 9/19/2023 00:55:39'!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := IIII.
	previous := II.!

!methodRemoval: IIII class #initializeCollaboratorsFromFile stamp: 'LK 9/19/2023 00:55:39'!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := IIIII.
	previous := III.!

!methodRemoval: IIIII class #initializeCollaboratorsFromFile stamp: 'LK 9/19/2023 00:55:39'!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := nil.
	previous := IIII.!

!classDefinition: #CantSuspend category: 'CodigoRepetido-Ejercicio' stamp: 'LK 9/19/2023 00:55:39'!
Error subclass: #CantSuspend
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CodigoRepetido-Ejercicio'!

!classDefinition: #CantSuspend category: 'CodigoRepetido-Ejercicio' stamp: 'LK 9/19/2023 00:55:39'!
Error subclass: #CantSuspend
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CodigoRepetido-Ejercicio'!

!classDefinition: #NotFound category: 'CodigoRepetido-Ejercicio' stamp: 'LK 9/19/2023 00:55:39'!
Error subclass: #NotFound
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CodigoRepetido-Ejercicio'!

!classDefinition: #NotFound category: 'CodigoRepetido-Ejercicio' stamp: 'LK 9/19/2023 00:55:39'!
Error subclass: #NotFound
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CodigoRepetido-Ejercicio'!

!classDefinition: #CustomerBookTest category: 'CodigoRepetido-Ejercicio' stamp: 'LK 9/19/2023 00:55:39'!
TestCase subclass: #CustomerBookTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CodigoRepetido-Ejercicio'!

!classDefinition: #CustomerBookTest category: 'CodigoRepetido-Ejercicio' stamp: 'LK 9/19/2023 00:55:39'!
TestCase subclass: #CustomerBookTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CodigoRepetido-Ejercicio'!
!CustomerBookTest methodsFor: 'testing' stamp: 'LK 9/12/2023 13:37:54'!
assertCantidadEn: aCustomerBook activos: activeNumber suspendidos: suspendedNumber
	
	
	self assert: activeNumber equals: aCustomerBook numberOfActiveCustomers.
	self assert: suspendedNumber equals: aCustomerBook numberOfSuspendedCustomers.
	self assert:(suspendedNumber  + activeNumber) equals: aCustomerBook numberOfCustomers.


	
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'LK 9/12/2023 13:11:51'!
assertQueClosureCorra: aClosureToMeasure enMenosQueMs: aTimeLimitInMs
	
	self assert: (self tomarTiempoA: aClosureToMeasure ) < ( aTimeLimitInMs * millisecond)
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'LK 9/12/2023 13:30:47'!
shouldDo: aClosureQueFalla on: anError thenDo: aClosureCatch

	[ aClosureQueFalla value
	self fail ]
		on: anError
		do: aClosureCatch! !
!CustomerBookTest methodsFor: 'testing' stamp: 'LK 9/7/2023 20:15:32'!
test01AddingCustomerShouldNotTakeMoreThan50Milliseconds

	| customerBook |
	
	customerBook := CustomerBook new.
	
	self assertQueClosureCorra: [customerBook addCustomerNamed: 'John Lennon'.] enMenosQueMs: 50.
	
	
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'LK 9/7/2023 20:15:32'!
test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds

	| customerBook paulMcCartney |
	
	customerBook := CustomerBook new.
	paulMcCartney := 'Paul McCartney'.
	
	customerBook addCustomerNamed: paulMcCartney.
	  
	
	self assertQueClosureCorra:[customerBook removeCustomerNamed: paulMcCartney.] enMenosQueMs: 100.

	
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'LK 9/12/2023 13:30:48'!
test03CanNotAddACustomerWithEmptyName 

	| customerBook |
			
	customerBook := CustomerBook new.
	
	self shouldDo:[customerBook addCustomerNamed: ''.] on: Error thenDo: [ :anError | 
			self assert: anError messageText = CustomerBook customerCanNotBeEmptyErrorMessage.
			self assert: customerBook isEmpty ]
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'LK 9/12/2023 13:30:48'!
test04CanNotRemoveAnInvalidCustomer
	
	| customerBook johnLennon |
			
	customerBook := CustomerBook new.
	johnLennon := 'John Lennon'.
	customerBook addCustomerNamed: johnLennon.
	
	self shouldDo: [customerBook removeCustomerNamed: 'Paul McCartney'] on:NotFound thenDo:[ :anError | 
			self assert: customerBook numberOfCustomers = 1.
			self assert: (customerBook includesCustomerNamed: johnLennon)].
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'LK 9/12/2023 13:39:13'!
test05SuspendingACustomerShouldNotRemoveItFromCustomerBook

	| customerBook paulMcCartney|
	
	customerBook := CustomerBook new.
	paulMcCartney := 'Paul McCartney'.
	
	customerBook addCustomerNamed: paulMcCartney.
	customerBook suspendCustomerNamed: paulMcCartney.
	
	self assertCantidadEn: customerBook activos:  0 suspendidos: 1.
	self assert: (customerBook includesCustomerNamed: paulMcCartney).
	

	
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'LK 9/12/2023 13:38:40'!
test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook

	| customerBook paulMcCartney|
	
	customerBook := CustomerBook new.
	paulMcCartney := 'Paul McCartney'.
	
	customerBook addCustomerNamed: paulMcCartney.
	customerBook suspendCustomerNamed: paulMcCartney.
	customerBook removeCustomerNamed: paulMcCartney.
	
	self assertCantidadEn: customerBook activos: 0 suspendidos: 0.
	self deny: (customerBook includesCustomerNamed: paulMcCartney).


	
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'LK 9/12/2023 13:46:40'!
test07CanNotSuspendAnInvalidCustomer
	
	| customerBook johnLennon |
			
	customerBook := CustomerBook new.
	johnLennon := 'John Lennon'.
	customerBook addCustomerNamed: johnLennon.
	
	self shouldDo: [ customerBook suspendCustomerNamed: 'George Harrison'] on:CantSuspend thenDo: 
	[ :anError | 
			self assert: customerBook numberOfCustomers = 1.
			self assert: (customerBook includesCustomerNamed: johnLennon)].

! !
!CustomerBookTest methodsFor: 'testing' stamp: 'LK 9/12/2023 13:46:44'!
test08CanNotSuspendAnAlreadySuspendedCustomer
	
	| customerBook johnLennon |
			
	customerBook := CustomerBook new.
	johnLennon := 'John Lennon'.
	customerBook addCustomerNamed: johnLennon.
	customerBook suspendCustomerNamed: johnLennon.
	
	self shouldDo: [ customerBook suspendCustomerNamed: johnLennon] on: CantSuspend thenDo: 
	[ :anError | 
			self assert: customerBook numberOfCustomers = 1.
			self assert: (customerBook includesCustomerNamed: johnLennon)].
	
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'LK 9/12/2023 13:27:41'!
tomarTiempoA: aClosureToMeasure

	| millisecondsBeforeRunning millisecondsAfterRunning|
	
	millisecondsBeforeRunning := Time millisecondClockValue * millisecond.
	aClosureToMeasure value.
	millisecondsAfterRunning := Time millisecondClockValue * millisecond.
	
	^millisecondsAfterRunning-millisecondsBeforeRunning
! !

!classDefinition: #CustomerBook category: 'CodigoRepetido-Ejercicio' stamp: 'LK 9/19/2023 00:55:41'!
Object subclass: #CustomerBook
	instanceVariableNames: 'suspended active'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CodigoRepetido-Ejercicio'!

!classDefinition: #CustomerBook category: 'CodigoRepetido-Ejercicio' stamp: 'LK 9/19/2023 00:55:41'!
Object subclass: #CustomerBook
	instanceVariableNames: 'suspended active'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CodigoRepetido-Ejercicio'!
!CustomerBook methodsFor: 'testing' stamp: 'NR 4/3/2019 10:14:26'!
includesCustomerNamed: aName

	^(active includes: aName) or: [ suspended includes: aName ]! !
!CustomerBook methodsFor: 'testing' stamp: 'NR 4/3/2019 10:14:26'!
isEmpty
	
	^active isEmpty and: [ suspended isEmpty ]! !
!CustomerBook methodsFor: 'initialization' stamp: 'NR 9/17/2020 07:23:04' overrides: 16920235!
initialize

	active := OrderedCollection new.
	suspended:= OrderedCollection new.! !
!CustomerBook methodsFor: 'customer management' stamp: 'NR 4/3/2019 10:14:26'!
addCustomerNamed: aName

	aName isEmpty ifTrue: [ self signalCustomerNameCannotBeEmpty ].
	((active includes: aName) or: [suspended includes: aName]) ifTrue: [ self signalCustomerAlreadyExists ].
	
	active add: aName ! !
!CustomerBook methodsFor: 'customer management' stamp: 'NR 4/3/2019 10:14:26'!
numberOfActiveCustomers
	
	^active size! !
!CustomerBook methodsFor: 'customer management' stamp: 'NR 4/3/2019 10:14:26'!
numberOfCustomers
	
	^active size + suspended size! !
!CustomerBook methodsFor: 'customer management' stamp: 'NR 9/19/2018 17:36:09'!
numberOfSuspendedCustomers
	
	^suspended size! !
!CustomerBook methodsFor: 'customer management' stamp: 'LK 9/12/2023 13:46:06'!
remove: elem from: aCollectionToRemove ifAbsent: aClosure
 
	1 to: aCollectionToRemove size do: 
	[ :index |
		elem = (aCollectionToRemove at: index)
			ifTrue: [
				aCollectionToRemove removeAt: index.
				^ elem 
			] 
	].

	^ aClosure value.
	
! !
!CustomerBook methodsFor: 'customer management' stamp: 'LK 9/12/2023 13:42:06'!
removeCustomerNamed: aName 

	^self remove: aName from: active ifAbsent: 
		[self remove: aName from: suspended ifAbsent: 
			[^NotFound signal.]]
	
! !
!CustomerBook methodsFor: 'customer management' stamp: 'HernanWilkinson 7/6/2011 17:52'!
signalCustomerAlreadyExists 

	self error: self class customerAlreadyExistsErrorMessage! !
!CustomerBook methodsFor: 'customer management' stamp: 'HernanWilkinson 7/6/2011 17:51'!
signalCustomerNameCannotBeEmpty 

	self error: self class customerCanNotBeEmptyErrorMessage ! !
!CustomerBook methodsFor: 'customer management' stamp: 'LK 9/12/2023 13:26:40'!
suspendCustomerNamed: aName 
	
	self remove: aName from: active ifAbsent: [^CantSuspend signal].
	
	suspended add: aName.! !

!classDefinition: 'CustomerBook class' category: 'CodigoRepetido-Ejercicio' stamp: 'LK 9/19/2023 00:55:43'!
CustomerBook class
	instanceVariableNames: ''!

!classDefinition: 'CustomerBook class' category: 'CodigoRepetido-Ejercicio' stamp: 'LK 9/19/2023 00:55:43'!
CustomerBook class
	instanceVariableNames: ''!
!CustomerBook class methodsFor: 'error messages' stamp: 'NR 9/4/2023 17:02:48'!
customerAlreadyExistsErrorMessage

	^'Customer already exists!!!!!!'! !
!CustomerBook class methodsFor: 'error messages' stamp: 'NR 9/4/2023 17:02:52'!
customerCanNotBeEmptyErrorMessage

	^'Customer name cannot be empty!!!!!!'! !

!classDefinition: #OOStackTest category: 'Stack-Exercise' stamp: 'LK 9/19/2023 00:55:43'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: 'Stack-Exercise' stamp: 'LK 9/19/2023 00:55:43'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'HernanWilkinson 5/7/2012 11:30'!
test01StackShouldBeEmptyWhenCreated

	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:29:55'!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:01'!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:09'!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	
	self assert: stack pop = pushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'NR 9/16/2021 17:40:17'!
test05StackBehavesLIFO

	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'firstSomething'.
	secondPushedObject := 'secondSomething'.
	
	stack push: firstPushedObject.
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	self assert: stack pop = firstPushedObject.
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:20'!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack top = pushedObject.
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:24'!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	stack top.
	self assert: stack size = 1.
	! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:26'!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:31'!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:44'!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack top ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !

!classDefinition: #SentenceFinderByPrefixTest category: 'Stack-Exercise' stamp: 'LK 9/19/2023 00:55:44'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: 'stackTest finderTest'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefixTest category: 'Stack-Exercise' stamp: 'LK 9/19/2023 00:55:44'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: 'stackTest finderTest'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!SentenceFinderByPrefixTest methodsFor: 'as yet unclassified' stamp: 'LK 9/18/2023 16:02:29' overrides: 16961394!
setUp

	stackTest := OOStack new.
	
	stackTest push: 'hola'.
	stackTest push: 'holanda'.
	stackTest push: 'chau'.
	stackTest push: 'Hola'.
	
	finderTest := SentenceFinderByPrefix new.
! !
!SentenceFinderByPrefixTest methodsFor: 'as yet unclassified' stamp: 'LK 9/18/2023 16:02:44'!
test01findEncuentraEnElStack

	| matchingPrefix|

	finderTest initializeWith: stackTest andPrefix: 'hola'.
	
	matchingPrefix := finderTest find.
	
	self assert: matchingPrefix size = 2.
	self assert: (matchingPrefix first) = 'holanda'.
	self assert: (matchingPrefix last) = 'hola'
! !
!SentenceFinderByPrefixTest methodsFor: 'as yet unclassified' stamp: 'LK 9/18/2023 16:02:56'!
test02findNoEncuentraEnElStack

	| matchingPrefix |

	finderTest := SentenceFinderByPrefix new.
	finderTest initializeWith: stackTest andPrefix: 'wint'.
	
	matchingPrefix := finderTest find.
	
	self assert: matchingPrefix isEmpty.! !
!SentenceFinderByPrefixTest methodsFor: 'as yet unclassified' stamp: 'LK 9/18/2023 16:03:05'!
test03findEsCaseSensitive

	| matchingPrefix |	

	finderTest initializeWith: stackTest andPrefix: 'H'.
	
	matchingPrefix := finderTest find.
	self assert: matchingPrefix first = 'Hola'.
	self assert: matchingPrefix size = 1.
	! !
!SentenceFinderByPrefixTest methodsFor: 'as yet unclassified' stamp: 'LK 9/18/2023 16:03:11'!
test04findNoAceptaPrefijoVacio
	
	self
		should: [ finderTest initializeWith: stackTest andPrefix: ''.]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = SentenceFinderByPrefix cannotUseEmptyPrefix ].
	
! !
!SentenceFinderByPrefixTest methodsFor: 'as yet unclassified' stamp: 'LK 9/18/2023 16:03:27'!
test05findNoModificaElStack

	| matchingPrefix staticStack|
	
	staticStack := stackTest .
	
	finderTest := SentenceFinderByPrefix new.
	finderTest initializeWith: stackTest andPrefix: 'hola'.
	matchingPrefix := finderTest find.
	
	self assert: staticStack = stackTest .
	

	
	
! !
!SentenceFinderByPrefixTest methodsFor: 'as yet unclassified' stamp: 'LK 9/18/2023 16:03:35'!
test06assertErrorNoAceptaEspaciosEnBlanco
	
	self
		should: [ finderTest initializeWith: stackTest andPrefix: ' hola'.]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = SentenceFinderByPrefix cannotUseWhiteSpacesInPrefix].
	
! !
!SentenceFinderByPrefixTest methodsFor: 'as yet unclassified' stamp: 'LK 9/18/2023 16:03:53'!
test07inicializarConStackVacio

	| emptyStack |
	
	emptyStack := OOStack new.
	
	self
		should: [ finderTest initializeWith: emptyStack andPrefix: 'hola'.]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = SentenceFinderByPrefix cannotInitializeWithEmptyStack ].
	
! !

!classDefinition: #ContentStack category: 'Stack-Exercise' stamp: 'LK 9/19/2023 00:55:46'!
Object subclass: #ContentStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #ContentStack category: 'Stack-Exercise' stamp: 'LK 9/19/2023 00:55:46'!
Object subclass: #ContentStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!ContentStack methodsFor: 'as yet unclassified' stamp: 'LK 9/17/2023 21:11:48'!
isEmpty

	^self subclassResponsibility ! !
!ContentStack methodsFor: 'as yet unclassified' stamp: 'LK 9/17/2023 21:11:51' overrides: 16901663!
size

	^self subclassResponsibility ! !
!ContentStack methodsFor: 'as yet unclassified' stamp: 'LK 9/17/2023 21:11:37'!
top
	^self subclassResponsibility ! !
!ContentStack methodsFor: 'as yet unclassified' stamp: 'LK 9/17/2023 21:10:09'!
withoutTop
	^self subclassResponsibility ! !

!classDefinition: #ContentNode category: 'Stack-Exercise' stamp: 'LK 9/19/2023 00:55:46'!
ContentStack subclass: #ContentNode
	instanceVariableNames: 'nodo previous'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #ContentNode category: 'Stack-Exercise' stamp: 'LK 9/19/2023 00:55:46'!
ContentStack subclass: #ContentNode
	instanceVariableNames: 'nodo previous'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!ContentNode methodsFor: 'as yet unclassified' stamp: 'LK 9/17/2023 21:21:17' overrides: 50657511!
isEmpty
	^false! !
!ContentNode methodsFor: 'as yet unclassified' stamp: 'LK 9/17/2023 21:15:39' overrides: 50657516!
size
	^ 1+ previous size.! !
!ContentNode methodsFor: 'as yet unclassified' stamp: 'LK 9/17/2023 21:15:48' overrides: 50657520!
top
	^nodo! !
!ContentNode methodsFor: 'as yet unclassified' stamp: 'LK 9/18/2023 00:12:42'!
with: anElement onTopOf: aPreviousStack

	nodo := anElement .
	previous := aPreviousStack ! !
!ContentNode methodsFor: 'as yet unclassified' stamp: 'LK 9/18/2023 15:47:15' overrides: 50657524!
withoutTop
	^previous ! !

!classDefinition: #EmptyNode category: 'Stack-Exercise' stamp: 'LK 9/19/2023 00:55:47'!
ContentStack subclass: #EmptyNode
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #EmptyNode category: 'Stack-Exercise' stamp: 'LK 9/19/2023 00:55:47'!
ContentStack subclass: #EmptyNode
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!EmptyNode methodsFor: 'as yet unclassified' stamp: 'LK 9/17/2023 21:23:53' overrides: 50657511!
isEmpty
	^true! !
!EmptyNode methodsFor: 'as yet unclassified' stamp: 'LK 9/17/2023 21:12:10' overrides: 50657516!
size
	^0! !
!EmptyNode methodsFor: 'as yet unclassified' stamp: 'LK 9/17/2023 21:14:09' overrides: 50657520!
top
	^self error: OOStack stackEmptyErrorDescription! !
!EmptyNode methodsFor: 'as yet unclassified' stamp: 'LK 9/18/2023 16:05:17' overrides: 50657524!
withoutTop

	^self error: OOStack stackEmptyErrorDescription! !

!classDefinition: #OOStack category: 'Stack-Exercise' stamp: 'LK 9/19/2023 00:55:48'!
Object subclass: #OOStack
	instanceVariableNames: 'content'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: 'Stack-Exercise' stamp: 'LK 9/19/2023 00:55:48'!
Object subclass: #OOStack
	instanceVariableNames: 'content'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'as yet unclassified' stamp: 'LK 9/18/2023 15:45:50' overrides: 16920235!
initialize

	content := EmptyNode new.
	
! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'LK 9/18/2023 15:45:54'!
isEmpty
		
	^content isEmpty
! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'LK 9/18/2023 15:46:02'!
pop

	|last|
	
	last := content top.
	
	content := content withoutTop.
	
	^last
	! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'LK 9/18/2023 15:46:40'!
push: somethingToPush

	content := ContentNode new with: somethingToPush onTopOf: content.! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'LK 9/18/2023 15:46:44' overrides: 16901663!
size
	^content size! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'LK 9/18/2023 15:46:48'!
top

	^content top! !

!classDefinition: 'OOStack class' category: 'Stack-Exercise' stamp: 'LK 9/19/2023 00:55:49'!
OOStack class
	instanceVariableNames: ''!

!classDefinition: 'OOStack class' category: 'Stack-Exercise' stamp: 'LK 9/19/2023 00:55:49'!
OOStack class
	instanceVariableNames: ''!
!OOStack class methodsFor: 'error descriptions' stamp: 'NR 9/14/2023 08:12:21'!
stackEmptyErrorDescription
	
	^ 'stack is empty!!!!!!'! !

!classDefinition: #SentenceFinderByPrefix category: 'Stack-Exercise' stamp: 'LK 9/19/2023 00:55:49'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: 'originalStack prefixToFind found reversedStack'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefix category: 'Stack-Exercise' stamp: 'LK 9/19/2023 00:55:49'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: 'originalStack prefixToFind found reversedStack'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'LK 9/18/2023 15:38:46'!
filterPrefix: aPrefix

	|hasWhitespace|
	
	(aPrefix = '') ifTrue: [^self error: SentenceFinderByPrefix cannotUseEmptyPrefix].
	
	hasWhitespace := aPrefix includesAnyOf: ' '.
	
	(hasWhitespace) ifTrue:
			 [^self error: SentenceFinderByPrefix cannotUseWhiteSpacesInPrefix].
	! !
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'LK 9/18/2023 15:29:14'!
find
	
	[(originalStack isEmpty) not] whileTrue: [self getIfTopMatchesPrefix].
	
	self recoverStack.
	
	^found.! !
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'LK 9/18/2023 15:29:14'!
getIfTopMatchesPrefix

	| currentString | 
	
	currentString := originalStack pop.
	
	(self matchesPrefix: currentString ) ifTrue: [found add: currentString].
	
	reversedStack push: currentString.! !
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'LK 9/18/2023 14:23:00'!
initializeWith: aStack andPrefix: aPrefix
	
	
	(self filterPrefix: aPrefix).
	
	(aStack isEmpty) ifTrue: [^self error: SentenceFinderByPrefix cannotInitializeWithEmptyStack].
	
	originalStack := aStack.
	
	prefixToFind := aPrefix.
	
	reversedStack := OOStack new.
	
	found := OrderedCollection new.! !
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'LK 9/18/2023 12:10:41'!
matchesPrefix: aStringToMatch

	| prefixToFindLength sameSize|
	
	prefixToFindLength := prefixToFind size.
	
	(aStringToMatch size < prefixToFindLength) ifTrue: [^false].

	sameSize := aStringToMatch copyFrom: 1 to: (prefixToFind size).
	
	^(sameSize = prefixToFind).
	! !
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'LK 9/18/2023 15:29:38'!
recoverStack

	[reversedStack isEmpty] whileFalse: 
		[originalStack push: (reversedStack pop)].! !

!classDefinition: 'SentenceFinderByPrefix class' category: 'Stack-Exercise' stamp: 'LK 9/19/2023 00:55:50'!
SentenceFinderByPrefix class
	instanceVariableNames: ''!

!classDefinition: 'SentenceFinderByPrefix class' category: 'Stack-Exercise' stamp: 'LK 9/19/2023 00:55:50'!
SentenceFinderByPrefix class
	instanceVariableNames: ''!
!SentenceFinderByPrefix class methodsFor: 'as yet unclassified' stamp: 'LK 9/18/2023 14:20:55'!
cannotInitializeWithEmptyStack
	^ 'No acepto stacks vacios'! !
!SentenceFinderByPrefix class methodsFor: 'as yet unclassified' stamp: 'LK 9/18/2023 12:17:55'!
cannotUseEmptyPrefix
	^ 'No acepto el prefijo vacio'! !
!SentenceFinderByPrefix class methodsFor: 'as yet unclassified' stamp: 'oa 9/18/2023 12:56:04'!
cannotUseWhiteSpacesInPrefix
	^ 'No acepto prefijos con espacios vacios'! !

!classDefinition: #NumeroTest category: 'Numero-Solution-4' stamp: 'LK 9/19/2023 00:55:50'!
TestCase subclass: #NumeroTest
	instanceVariableNames: 'zero one two four oneFifth oneHalf five twoFifth twoTwentyfifth fiveHalfs eight negativeOne negativeTwo three'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Solution-4'!

!classDefinition: #NumeroTest category: 'Numero-Solution-4' stamp: 'LK 9/19/2023 00:55:50'!
TestCase subclass: #NumeroTest
	instanceVariableNames: 'zero one two four oneFifth oneHalf five twoFifth twoTwentyfifth fiveHalfs eight negativeOne negativeTwo three'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Solution-4'!
!NumeroTest methodsFor: 'setup' stamp: 'NR 9/30/2018 18:29:17' overrides: 16961394!
setUp

	zero := Entero with: 0.
	one := Entero with: 1.
	two := Entero with: 2.
	three:= Entero with: 3.
	four := Entero with: 4.
	five := Entero with: 5.
	eight := Entero with: 8.
	negativeOne := Entero with: -1.
	negativeTwo := Entero with: -2.
	
	oneHalf := one / two.
	oneFifth := one / five.
	twoFifth := two / five.
	twoTwentyfifth := two / (Entero with: 25).
	fiveHalfs := five / two.
	! !
!NumeroTest methodsFor: 'tests' stamp: 'HAW 5/3/2017 15:49:20'!
shouldRaiseDivideByZeroException: aBlock

	self 
		should: aBlock
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | self assert: anError messageText equals: Numero canNotDivideByZeroErrorDescription ]
	! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 20:11'!
test01isCeroReturnsTrueWhenAskToZero

	self assert: zero isZero! !
!NumeroTest methodsFor: 'tests' stamp: 'HAW 5/3/2017 15:37:57'!
test02isCeroReturnsFalseWhenAskToOthersButZero

	self deny: one isZero.
	self deny: two isZero.! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 20:13'!
test03isOneReturnsTrueWhenAskToOne

	self assert: one isOne! !
!NumeroTest methodsFor: 'tests' stamp: 'HAW 5/3/2017 15:37:46'!
test04isOneReturnsFalseWhenAskToOtherThanOne

	self deny: zero isOne.
	self deny: two isOne.! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 9/30/2018 23:19:11'!
test05EnteroAddsWithEnteroCorrectly

	"Lo correcto seria hacer un test por cada uno de estos asserts ya que son casos distintos.
	Lo hago todo aca para no modificar mucho la estructura del test suite - Hernan"
	self assert: zero + zero equals: zero.
	self assert: zero + one equals: one.
	self assert: zero + two equals: two.
	self assert: zero + negativeTwo equals: negativeTwo.
	
	self assert: one + zero equals: one.
	self assert: one + one equals: two.
	self assert: one + two equals: three.
	self assert: one + negativeTwo equals: negativeOne.
	
	self assert: two + zero equals: two.
	self assert: two + one equals: three.
	self assert: two + two equals: four.
	self assert: two + negativeTwo equals: zero.
	
	self assert: negativeTwo + zero equals: negativeTwo.
	self assert: negativeTwo + one equals: negativeOne.
	self assert: negativeTwo + two equals: zero.
	self assert: negativeTwo + negativeTwo equals: (Entero with: -4).! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 9/30/2018 23:21:17'!
test06EnteroMultipliesWithEnteroCorrectly

	"Lo correcto seria hacer un test por cada uno de estos asserts ya que son casos distintos.
	Lo hago todo aca para no modificar mucho la estructura del test suite - Hernan"
	self assert: zero * zero equals: zero.
	self assert: zero * one equals: zero.
	self assert: zero * two equals: zero.
	self assert: zero * negativeTwo equals: zero.
	
	self assert: one * zero equals: zero.
	self assert: one * one equals: one.
	self assert: one * two equals: two.
	self assert: one * negativeTwo equals: negativeTwo.
	
	self assert: two * zero equals: zero.
	self assert: two * one equals: two.
	self assert: two * two equals: four.
	self assert: two * negativeTwo equals: (Entero with: -4).
	
	self assert: negativeTwo * zero equals: zero.
	self assert: negativeTwo * one equals: negativeTwo.
	self assert: negativeTwo * two equals: (Entero with: -4).
	self assert: negativeTwo * negativeTwo equals: four! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 9/30/2018 23:25:58'!
test07EnteroDividesEnteroCorrectly

	"Lo correcto seria hacer un test por cada uno de estos asserts ya que son casos distintos.
	Lo hago todo aca para no modificar mucho la estructura del test suite - Hernan"
	self shouldRaiseDivideByZeroException: [ zero / zero ].
	self assert: zero / one equals: zero.
	self assert: zero / two equals: zero.
	self assert: zero / negativeTwo equals: zero.
	
	self shouldRaiseDivideByZeroException: [ one / zero ].
	self assert: one / one equals: one.
	self assert: one / two equals: oneHalf.
	self assert: one / negativeTwo equals: oneHalf negated.
	
	self shouldRaiseDivideByZeroException: [ two / zero ].
	self assert: two / one equals: two.
	self assert: two / two equals: one.
	self assert: two / negativeTwo equals: one negated.
	
	self shouldRaiseDivideByZeroException: [ negativeTwo / zero ].
	self assert: negativeTwo / one equals: negativeTwo.
	self assert: negativeTwo / two equals: negativeOne.
	self assert: negativeTwo / negativeTwo equals: one.
	! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 20:38'!
test08FraccionAddsWithFraccionCorrectly
"
    La suma de fracciones es:
	 
	a/b + c/d = (a.d + c.b) / (b.d)
	 
	SI ESTAN PENSANDO EN LA REDUCCION DE FRACCIONES NO SE PREOCUPEN!!
	TODAVIA NO SE ESTA TESTEANDO ESE CASO
"
	| sevenTenths |

	sevenTenths := (Entero with: 7) / (Entero with: 10).

	self assert: oneFifth + oneHalf equals: sevenTenths! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 20:52'!
test09FraccionMultipliesWithFraccionCorrectly
"
    La multiplicacion de fracciones es:
	 
	(a/b) * (c/d) = (a.c) / (b.d)
"

	self assert: oneFifth * twoFifth equals: twoTwentyfifth! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 20:56'!
test10FraccionDividesFraccionCorrectly
"
    La division de fracciones es:
	 
	(a/b) / (c/d) = (a.d) / (b.c)
"

	self assert: oneHalf / oneFifth equals: fiveHalfs! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 9/30/2018 23:27:57'!
test11EnteroAddsFraccionCorrectly

	"Ahora empieza la diversion!!

	Lo correcto seria hacer un test por cada uno de estos asserts ya que son casos distintos.
	Lo hago todo aca para no modificar mucho la estructura del test suite - Hernan"

	self assert: zero + oneFifth equals: oneFifth.
	self assert: one + oneFifth equals:  (Entero with: 6) / five.
	self assert: two + oneFifth equals: (Entero with: 11) / five.
	self assert: negativeTwo + oneFifth equals: (Entero with: -9) / five
	! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 9/30/2018 23:28:45'!
test12FraccionAddsEnteroCorrectly

	"Lo correcto seria hacer un test por cada uno de estos asserts ya que son casos distintos.
	Lo hago todo aca para no modificar mucho la estructura del test suite - Hernan"

	self assert: oneFifth + zero equals: oneFifth.
	self assert: oneFifth + one equals:  (Entero with: 6) / five.
	self assert: oneFifth + two equals: (Entero with: 11) / five.
	self assert: oneFifth + negativeTwo equals: (Entero with: -9) / five.
	! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 9/30/2018 23:29:16'!
test13EnteroMultipliesFraccionCorrectly
	
	"Lo correcto seria hacer un test por cada uno de estos asserts ya que son casos distintos.
	Lo hago todo aca para no modificar mucho la estructura del test suite - Hernan"

	self assert: zero * oneFifth equals: zero.
	self assert: one * oneFifth equals: oneFifth.
	self assert: two * oneFifth equals: twoFifth.
	self assert: negativeTwo * oneFifth equals: twoFifth negated ! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 9/30/2018 23:30:36'!
test14FraccionMultipliesEnteroCorrectly

	"Lo correcto seria hacer un test por cada uno de estos asserts ya que son casos distintos.
	Lo hago todo aca para no modificar mucho la estructura del test suite - Hernan"

	self assert: oneFifth * zero equals: zero.
	self assert: oneFifth * one  equals:  oneFifth.
	self assert: oneFifth * two equals: twoFifth.
	self assert: oneFifth * negativeTwo equals: twoFifth negated ! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 9/30/2018 23:31:12'!
test15EnteroDividesFraccionCorrectly

	"Lo correcto seria hacer un test por cada uno de estos asserts ya que son casos distintos.
	Lo hago todo aca para no modificar mucho la estructura del test suite - Hernan"

	self assert: zero / oneFifth equals: zero.
	self assert: one / oneFifth equals: five.
	self assert: two / oneFifth equals: (Entero with: 10).
	self assert: negativeTwo / oneFifth equals: (Entero with: -10)
! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 9/30/2018 23:32:05'!
test16FraccionDividesEnteroCorrectly

	"Lo correcto seria hacer un test por cada uno de estos asserts ya que son casos distintos.
	Lo hago todo aca para no modificar mucho la estructura del test suite - Hernan"

	self shouldRaiseDivideByZeroException: [ oneFifth / zero ].
	self assert: oneFifth / one equals: oneFifth.
	self assert: oneFifth / two equals: one/ (Entero with: 10).
	self assert: oneFifth / negativeTwo equals: one/ (Entero with: -10)
	

	! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 22:38'!
test17AFraccionCanBeEqualToAnEntero

	self assert: two equals: four / two! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 22:39'!
test18AparentFraccionesAreEqual

	self assert: oneHalf equals: two / four! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 22:40'!
test19AddingFraccionesCanReturnAnEntero

	self assert: oneHalf + oneHalf equals: one! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 22:42'!
test20MultiplyingFraccionesCanReturnAnEntero

	self assert: (two/five) * (five/two) equals: one! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 22:42'!
test21DividingFraccionesCanReturnAnEntero

	self assert: oneHalf / oneHalf equals: one! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 22:43'!
test22DividingEnterosCanReturnAFraccion

	self assert: two / four equals: oneHalf! !
!NumeroTest methodsFor: 'tests' stamp: 'HAW 5/3/2017 15:35:56'!
test23CanNotDivideEnteroByZero

	"Este test ya no tiene sentido porque se esta verificando en los tests de division.
	Lo dejo solo para que se vea que ya no tiene sentido - Hernan
	self 
		should: [ one / zero ]
		raise: Error
		withExceptionDo: [ :anError | self assert: anError messageText equals: Numero canNotDivideByZeroErrorDescription ]
	"! !
!NumeroTest methodsFor: 'tests' stamp: 'HAW 5/3/2017 15:36:09'!
test24CanNotDivideFraccionByZero

	"Este test ya no tiene sentido porque se esta verificando en los tests de division.
	Lo dejo solo para que se vea que ya no tiene sentido - Hernan
	self 
		should: [ oneHalf / zero ]
		raise: Error
		withExceptionDo: [ :anError | self assert: anError messageText equals: Numero canNotDivideByZeroErrorDescription ]
	"	! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 22:50'!
test25AFraccionCanNotBeZero

	self deny: oneHalf isZero! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 22:50'!
test26AFraccionCanNotBeOne

	self deny: oneHalf isOne! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 10/1/2018 00:09:23'!
test27BisEnteroSubstractsEnteroCorrecty
	
	"Lo correcto seria hacer un test por cada uno de estos asserts ya que son casos distintos.
	Lo hago todo aca para no modificar mucho la estructura del test suite "
	
	self assert: zero - zero equals: zero.
	self assert: zero - one equals: negativeOne.
	self assert: zero - two equals: negativeTwo.
	self assert: zero - negativeTwo equals: two.
	
	self assert: one - zero equals: one.
	self assert: one - one equals: zero.
	self assert: one - two equals: negativeOne.
	self assert: one - negativeTwo equals: three.
	
	self assert: two - zero equals: two.
	self assert: two - one equals: one.
	self assert: two - two equals: zero.
	self assert: two - negativeTwo equals: four.
	
	self assert: negativeTwo - zero equals: negativeTwo.
	self assert: negativeTwo - one equals: three negated.
	self assert: negativeTwo - two equals: four negated.
	self assert: negativeTwo - negativeTwo equals: zero! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 9/30/2018 23:37:54'!
test27ZeroDivideAnythingIsZero

	"Este test ya no tiene sentido porque se esta verificando en los tests de division.
	Lo dejo solo para que se vea que ya no tiene sentido - Hernan
	
	self assert: zero / one equals: zero
	"! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 9/30/2018 18:27:15'!
test28FraccionSubstractsFraccionCorrectly
	
	self assert: twoFifth - oneFifth equals: oneFifth.! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 9/30/2018 23:52:59'!
test29EnteroSubstractsFraccionCorrectly

	"Lo correcto seria hacer un test por cada uno de estos asserts ya que son casos distintos.
	Lo hago todo aca para no modificar mucho la estructura del test suite"

	self assert: zero - oneHalf equals: oneHalf negated.
	self assert: one - oneHalf equals: oneHalf.
	self assert: two - oneHalf equals: three / two.
	self assert: negativeTwo - oneHalf equals: five negated / two! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 9/30/2018 23:58:36'!
test30FraccionSubstractsEnteroCorrectly

	"Lo correcto seria hacer un test por cada uno de estos asserts ya que son casos distintos.
	Lo hago todo aca para no modificar mucho la estructura del test suite"

	| sixFifth |
	
	sixFifth := (Entero with: 6) / (Entero with: 5).
	
	self assert: sixFifth - zero equals: sixFifth.
	self assert: sixFifth - one equals: oneFifth.
	self assert: sixFifth - two equals: (Entero with: -4) / (Entero with: 5).
	self assert: sixFifth - negativeTwo equals: (Entero with: 16) / (Entero with: 5)
	! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 9/30/2018 18:27:51'!
test31SubstractingFraccionesCanReturnAnEntero

	| threeHalfs |
	
	threeHalfs := (Entero with: 3) / (Entero with: 2).
	
	self assert: threeHalfs - oneHalf equals: one.! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 9/30/2018 18:28:02'!
test32SubstractingSameEnterosReturnsZero

	self assert: one - one equals: zero.! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 9/30/2018 18:28:10'!
test33SubstractingSameFraccionesReturnsZero

	self assert: oneHalf - oneHalf equals: zero.! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 9/30/2018 18:28:17'!
test34SubstractingAHigherValueToANumberReturnsANegativeNumber

	| negativeThreeHalfs |
	
	negativeThreeHalfs := (Entero with: -3) / (Entero with: 2).	

	self assert: one - fiveHalfs equals: negativeThreeHalfs.! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 9/30/2018 18:28:24'!
test35FibonacciZeroIsOne

	self assert: zero fibonacci equals: one! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 9/30/2018 18:28:31'!
test36FibonacciOneIsOne

	self assert: one fibonacci equals: one! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 9/30/2018 18:29:42'!
test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros

	self assert: four fibonacci equals: five.
	self assert: three fibonacci equals: three. 
	self assert: five fibonacci equals: four fibonacci + three fibonacci.! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 9/30/2018 18:29:51'!
test38FibonacciNotDefinedForNegativeNumbers

	self 
		should: [negativeOne fibonacci]
		raise: Error
		withExceptionDo: [ :anError | self assert: anError messageText equals: Entero negativeFibonacciErrorDescription ].! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 9/30/2018 18:29:58'!
test39NegationOfEnteroIsCorrect

	self assert: two negated equals: negativeTwo.! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 9/30/2018 18:30:05'!
test40NegationOfFraccionIsCorrect

	self assert: oneHalf negated equals: negativeOne / two.
		! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 9/30/2018 18:30:27'!
test41SignIsCorrectlyAssignedToFractionWithTwoNegatives

	self assert: oneHalf equals: (negativeOne / negativeTwo)
		! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 9/30/2018 18:30:37'!
test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor

	self assert: oneHalf negated equals: (one / negativeTwo)
	
		! !

!classDefinition: #Numero category: 'Numero-Solution-4' stamp: 'LK 9/19/2023 00:55:56'!
Object subclass: #Numero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Solution-4'!

!classDefinition: #Numero category: 'Numero-Solution-4' stamp: 'LK 9/19/2023 00:55:56'!
Object subclass: #Numero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Solution-4'!
!Numero methodsFor: 'arithmetic operations' stamp: 'HernanWilkinson 5/7/2016 22:48'!
* aMultiplier

	self subclassResponsibility ! !
!Numero methodsFor: 'arithmetic operations' stamp: 'HernanWilkinson 5/7/2016 22:49'!
+ anAdder

	self subclassResponsibility ! !
!Numero methodsFor: 'arithmetic operations' stamp: 'NR 9/30/2018 20:22:19'!
- anAdder

	self subclassResponsibility ! !
!Numero methodsFor: 'arithmetic operations' stamp: 'HernanWilkinson 5/7/2016 22:49'!
/ aDivisor

	self subclassResponsibility ! !
!Numero methodsFor: 'arithmetic operations' stamp: 'NR 9/30/2018 20:21:50'!
negated
	
	^self * (Entero with: -1)! !
!Numero methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:53:47'!
addToEnteroMenosUnoYCeroNegativo: anAdder

	self subclassResponsibility ! !
!Numero methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:54:02'!
addToEnteroMenosUnoYCeroPositivo: anAdder

	self subclassResponsibility ! !
!Numero methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:54:20'!
addToFraccion: anAdder

	self subclassResponsibility ! !
!Numero methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:54:42'!
addToUno: anAdder

	self subclassResponsibility ! !
!Numero methodsFor: 'arithmetic operations - private' stamp: 'HAW 5/3/2017 18:05:01'!
divideCero: aDividend

	self subclassResponsibility ! !
!Numero methodsFor: 'arithmetic operations - private' stamp: 'NR 10/1/2018 00:11:50'!
divideEnteroMenosUnoYCeroNegativo: aDividend

	self subclassResponsibility ! !
!Numero methodsFor: 'arithmetic operations - private' stamp: 'NR 10/1/2018 00:11:41'!
divideEnteroMenosUnoYCeroPositivo: aDividend

	self subclassResponsibility ! !
!Numero methodsFor: 'arithmetic operations - private' stamp: 'HernanWilkinson 5/7/2016 23:10'!
divideFraccion: aDividend

	self subclassResponsibility ! !
!Numero methodsFor: 'arithmetic operations - private' stamp: 'HAW 5/3/2017 18:05:35'!
divideUno: aDividend

	self subclassResponsibility ! !
!Numero methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:55:08'!
multiplyToEnteroMenosUnoYCeroNegativo: aMultiplier

	self subclassResponsibility ! !
!Numero methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:55:26'!
multiplyToEnteroMenosUnoYCeroPositivo: aMultiplier

	self subclassResponsibility ! !
!Numero methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:55:17'!
multiplyToFraccion: aMultiplier

	self subclassResponsibility ! !
!Numero methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:55:52'!
substractFromEnteroMenosUnoYCeroNegativo: aMinuend

	self subclassResponsibility ! !
!Numero methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:56:36'!
substractFromEnteroMenosUnoYCeroPositivo: aMinuend

	self subclassResponsibility ! !
!Numero methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:56:02'!
substractFromFraccion: aMinuend

	self subclassResponsibility ! !
!Numero methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:56:11'!
substractFromUno: aMinuend

	self subclassResponsibility ! !
!Numero methodsFor: 'testing' stamp: 'NR 10/1/2018 01:31:46'!
isNegative

	self subclassResponsibility ! !
!Numero methodsFor: 'testing' stamp: 'HernanWilkinson 5/7/2016 22:49'!
isOne

	self subclassResponsibility ! !
!Numero methodsFor: 'testing' stamp: 'HernanWilkinson 5/7/2016 22:49'!
isZero

	self subclassResponsibility ! !

!classDefinition: 'Numero class' category: 'Numero-Solution-4' stamp: 'LK 9/19/2023 00:56:00'!
Numero class
	instanceVariableNames: ''!

!classDefinition: 'Numero class' category: 'Numero-Solution-4' stamp: 'LK 9/19/2023 00:56:00'!
Numero class
	instanceVariableNames: ''!
!Numero class methodsFor: 'error descriptions' stamp: 'HernanWilkinson 5/7/2016 22:45'!
canNotDivideByZeroErrorDescription

	^'No se puede dividir por cero'! !

!classDefinition: #Entero category: 'Numero-Solution-4' stamp: 'LK 9/19/2023 00:56:00'!
Numero subclass: #Entero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Solution-4'!

!classDefinition: #Entero category: 'Numero-Solution-4' stamp: 'LK 9/19/2023 00:56:00'!
Numero subclass: #Entero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Solution-4'!
!Entero methodsFor: 'arithmetic operations' stamp: 'HAW 5/2/2017 17:13:09'!
// aDivisor 
	
	^self class with: self integerValue // aDivisor integerValue
	! !
!Entero methodsFor: 'arithmetic operations' stamp: 'NR 9/30/2018 20:26:03'!
fibonacci

	self subclassResponsibility ! !
!Entero methodsFor: 'arithmetic operations' stamp: 'HAW 5/2/2017 17:19:13'!
greatestCommonDivisorWith: anEntero 
	
	self subclassResponsibility ! !
!Entero methodsFor: 'arithmetic operations - private' stamp: 'HAW 5/2/2017 17:43:13'!
asDenominatorOf: aNumerator

	self subclassResponsibility ! !
!Entero methodsFor: 'value' stamp: 'HAW 5/2/2017 17:21:12'!
integerValue

	"Usamos integerValue en vez de value para que no haya problemas con el mensaje value implementado en Object - Hernan"
	
	self subclassResponsibility ! !
!Entero methodsFor: 'printing' stamp: 'NR 10/1/2018 09:19:26' overrides: 16902975!
printOn: aStream

	aStream print: self integerValue ! !

!classDefinition: 'Entero class' category: 'Numero-Solution-4' stamp: 'LK 9/19/2023 00:56:01'!
Entero class
	instanceVariableNames: ''!

!classDefinition: 'Entero class' category: 'Numero-Solution-4' stamp: 'LK 9/19/2023 00:56:01'!
Entero class
	instanceVariableNames: ''!
!Entero class methodsFor: 'error descriptions' stamp: 'NR 9/30/2018 20:12:01'!
negativeFibonacciErrorDescription
	
	^ ' Fibonacci no está definido aquí para enteros negativos'! !
!Entero class methodsFor: 'instance creation' stamp: 'NR 10/1/2018 16:05:03'!
with: aValue 
	
	"Esta verificacion esta puesta por si se equivocan y quieren crear un Entero pasando otra cosa que un Integer - Hernan"
	aValue isInteger ifFalse: [  self error: 'aValue debe ser anInteger' ].
	
	aValue = 0 ifTrue: [ ^Cero new ].
	aValue = 1 ifTrue: [ ^Uno new ].
	aValue < 0 ifTrue: [ ^Negativo safeWith: aValue].
	 
	^ PositivoMayorAUno safeWith: aValue
	! !

!classDefinition: #Cero category: 'Numero-Solution-4' stamp: 'LK 9/19/2023 00:56:01'!
Entero subclass: #Cero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Solution-4'!

!classDefinition: #Cero category: 'Numero-Solution-4' stamp: 'LK 9/19/2023 00:56:01'!
Entero subclass: #Cero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Solution-4'!
!Cero methodsFor: 'arithmetic operations' stamp: 'HAW 5/2/2017 17:31:30' overrides: 50658298!
* aMultiplier 
	
	^self! !
!Cero methodsFor: 'arithmetic operations' stamp: 'HAW 5/2/2017 17:31:48' overrides: 50658303!
+ anAdder 
	
	^anAdder! !
!Cero methodsFor: 'arithmetic operations' stamp: 'NR 9/30/2018 20:21:13' overrides: 50658307!
- aSubtrahend
	
	^aSubtrahend negated! !
!Cero methodsFor: 'arithmetic operations' stamp: 'HAW 5/3/2017 12:40:57' overrides: 50658312!
/ aDivisor 
	
	^aDivisor divideCero: self! !
!Cero methodsFor: 'arithmetic operations' stamp: 'HAW 5/3/2017 18:14:09' overrides: 50658447!
// aDivisor

	^self! !
!Cero methodsFor: 'arithmetic operations' stamp: 'NR 9/30/2018 20:27:31' overrides: 50658452!
fibonacci

	^ Entero with: 1! !
!Cero methodsFor: 'arithmetic operations' stamp: 'HAW 5/2/2017 17:14:45' overrides: 50658456!
greatestCommonDivisorWith: anEntero 
	
	^ anEntero ! !
!Cero methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:53:47' overrides: 50658320!
addToEnteroMenosUnoYCeroNegativo: anAdder

	^ anAdder 
	
	! !
!Cero methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:54:02' overrides: 50658326!
addToEnteroMenosUnoYCeroPositivo: anAdder

	^ anAdder 
	
	! !
!Cero methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:54:20' overrides: 50658332!
addToFraccion: anAdder 
	
	^ anAdder ! !
!Cero methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:54:42' overrides: 50658337!
addToUno: anAdder 
	
	^ anAdder ! !
!Cero methodsFor: 'arithmetic operations - private' stamp: 'HAW 5/3/2017 15:56:43' overrides: 50658461!
asDenominatorOf: aNumerator

	self signalCanNotDivideByZero ! !
!Cero methodsFor: 'arithmetic operations - private' stamp: 'HAW 5/3/2017 15:56:50' overrides: 50658342!
divideCero: aCero 
	
	self signalCanNotDivideByZero ! !
!Cero methodsFor: 'arithmetic operations - private' stamp: 'NR 9/30/2018 18:37:05' overrides: 50658347!
divideEnteroMenosUnoYCeroNegativo: aDividend

	self signalCanNotDivideByZero ! !
!Cero methodsFor: 'arithmetic operations - private' stamp: 'NR 9/30/2018 18:37:00' overrides: 50658353!
divideEnteroMenosUnoYCeroPositivo: aDividend

	self signalCanNotDivideByZero ! !
!Cero methodsFor: 'arithmetic operations - private' stamp: 'HAW 5/3/2017 15:57:14' overrides: 50658359!
divideFraccion: aDividend

	self signalCanNotDivideByZero ! !
!Cero methodsFor: 'arithmetic operations - private' stamp: 'HAW 5/3/2017 15:49:51' overrides: 50658364!
divideUno: anUno 
	
	self signalCanNotDivideByZero! !
!Cero methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:55:08' overrides: 50658369!
multiplyToEnteroMenosUnoYCeroNegativo: aMultiplier

	^self! !
!Cero methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:55:26' overrides: 50658375!
multiplyToEnteroMenosUnoYCeroPositivo: aMultiplier

	^self! !
!Cero methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:55:17' overrides: 50658381!
multiplyToFraccion: aMultiplier

	^self
	! !
!Cero methodsFor: 'arithmetic operations - private' stamp: 'HAW 5/3/2017 15:50:07'!
signalCanNotDivideByZero
	
	self error: self class canNotDivideByZeroErrorDescription ! !
!Cero methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:55:52' overrides: 50658386!
substractFromEnteroMenosUnoYCeroNegativo: aMinuend

	^ aMinuend 
	
	! !
!Cero methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:56:36' overrides: 50658392!
substractFromEnteroMenosUnoYCeroPositivo: aMinuend

	^ aMinuend 
	
	! !
!Cero methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:56:02' overrides: 50658398!
substractFromFraccion: aMinuend

	^ aMinuend 
	
	! !
!Cero methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:56:11' overrides: 50658403!
substractFromUno: aMinuend

	^ aMinuend 
	
	! !
!Cero methodsFor: 'value' stamp: 'HAW 5/2/2017 17:11:32' overrides: 50658465!
integerValue

	^0! !
!Cero methodsFor: 'testing' stamp: 'NR 10/1/2018 01:32:56' overrides: 50658407!
isNegative
	
	^false! !
!Cero methodsFor: 'testing' stamp: 'HAW 5/2/2017 17:22:15' overrides: 50658411!
isOne

	^false! !
!Cero methodsFor: 'testing' stamp: 'HAW 5/2/2017 17:22:09' overrides: 50658415!
isZero

	^true! !

!classDefinition: 'Cero class' category: 'Numero-Solution-4' stamp: 'LK 9/19/2023 00:56:05'!
Cero class
	instanceVariableNames: 'uniqueInstance'!

!classDefinition: 'Cero class' category: 'Numero-Solution-4' stamp: 'LK 9/19/2023 00:56:05'!
Cero class
	instanceVariableNames: 'uniqueInstance'!
!Cero class methodsFor: 'initialization' stamp: 'HAW 5/3/2017 18:11:21' overrides: 16904184!
initialize

	uniqueInstance := self basicNew! !
!Cero class methodsFor: 'instance creation' stamp: 'HAW 5/3/2017 18:10:38' overrides: 16785646!
new

	^uniqueInstance! !

!classDefinition: #EnteroMenosCeroYUno category: 'Numero-Solution-4' stamp: 'LK 9/19/2023 00:56:05'!
Entero subclass: #EnteroMenosCeroYUno
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Solution-4'!

!classDefinition: #EnteroMenosCeroYUno category: 'Numero-Solution-4' stamp: 'LK 9/19/2023 00:56:05'!
Entero subclass: #EnteroMenosCeroYUno
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Solution-4'!
!EnteroMenosCeroYUno methodsFor: 'comparing' stamp: 'NR 10/1/2018 00:21:11' overrides: 16901772!
= anObject

	^(anObject isKindOf: self class) and: [ value = anObject integerValue ]! !
!EnteroMenosCeroYUno methodsFor: 'comparing' stamp: 'NR 10/1/2018 00:24:26' overrides: 16901788!
hash

	^value hash! !
!EnteroMenosCeroYUno methodsFor: 'arithmetic operations' stamp: 'NR 10/1/2018 00:23:08' overrides: 50658456!
greatestCommonDivisorWith: anEntero 
	
	^self class with: (value gcd: anEntero integerValue)! !
!EnteroMenosCeroYUno methodsFor: 'testing' stamp: 'NR 10/1/2018 00:24:50' overrides: 50658411!
isOne

	^false! !
!EnteroMenosCeroYUno methodsFor: 'testing' stamp: 'NR 10/1/2018 00:25:00' overrides: 50658415!
isZero

	^false! !
!EnteroMenosCeroYUno methodsFor: 'value' stamp: 'NR 10/1/2018 00:29:16' overrides: 50658465!
integerValue
	
	^value! !
!EnteroMenosCeroYUno methodsFor: 'initialization' stamp: 'NR 10/1/2018 00:31:00'!
initializeSafeWith: aValue 
	
	value := aValue! !

!classDefinition: 'EnteroMenosCeroYUno class' category: 'Numero-Solution-4' stamp: 'LK 9/19/2023 00:56:06'!
EnteroMenosCeroYUno class
	instanceVariableNames: ''!

!classDefinition: 'EnteroMenosCeroYUno class' category: 'Numero-Solution-4' stamp: 'LK 9/19/2023 00:56:06'!
EnteroMenosCeroYUno class
	instanceVariableNames: ''!
!EnteroMenosCeroYUno class methodsFor: 'instance creation - private' stamp: 'NR 10/1/2018 00:30:31'!
safeWith: anIntegerValue

	"Solo debe ser enviado este mensaje cuando es seguro que anIntegerValue es distinto de 0 y 1,
	y solo debe ser enviado desde la misma jerarquia - Hernan"
	
	^self new initializeSafeWith: anIntegerValue ! !

!classDefinition: #Negativo category: 'Numero-Solution-4' stamp: 'LK 9/19/2023 00:56:06'!
EnteroMenosCeroYUno subclass: #Negativo
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Solution-4'!

!classDefinition: #Negativo category: 'Numero-Solution-4' stamp: 'LK 9/19/2023 00:56:06'!
EnteroMenosCeroYUno subclass: #Negativo
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Solution-4'!
!Negativo methodsFor: 'arithmetic operations' stamp: 'NR 9/14/2023 07:55:08' overrides: 50658298!
* aMultiplier 
	
	^aMultiplier multiplyToEnteroMenosUnoYCeroNegativo: self ! !
!Negativo methodsFor: 'arithmetic operations' stamp: 'NR 9/14/2023 07:53:47' overrides: 50658303!
+ anAdder 
	
	^anAdder addToEnteroMenosUnoYCeroNegativo: self.
	! !
!Negativo methodsFor: 'arithmetic operations' stamp: 'NR 9/14/2023 07:55:52' overrides: 50658307!
- anAdder 
	
	^anAdder substractFromEnteroMenosUnoYCeroNegativo: self.
	! !
!Negativo methodsFor: 'arithmetic operations' stamp: 'NR 9/30/2018 20:59:18' overrides: 50658312!
/ aDivisor 
	
	^aDivisor divideEnteroMenosUnoYCeroNegativo: self! !
!Negativo methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:53:47' overrides: 50658320!
addToEnteroMenosUnoYCeroNegativo: anAdder

	^self class safeWith: value + anAdder integerValue ! !
!Negativo methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:54:02' overrides: 50658326!
addToEnteroMenosUnoYCeroPositivo: anAdder

	^Entero with: value + anAdder integerValue ! !
!Negativo methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:54:20' overrides: 50658332!
addToFraccion: anAdder

	^self + anAdder 
	! !
!Negativo methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:54:42' overrides: 50658337!
addToUno: anAdder 
	
	"Si soy -1 daria 0, por eso envia mensaje a Entero y no a self class - Hernan"
	
	^Entero with: 1 + value ! !
!Negativo methodsFor: 'arithmetic operations - private' stamp: 'NR 9/30/2018 19:36:31' overrides: 50658342!
divideCero: aDividend 
	
	^ aDividend ! !
!Negativo methodsFor: 'arithmetic operations - private' stamp: 'NR 9/30/2018 20:27:56' overrides: 50658347!
divideEnteroMenosUnoYCeroNegativo: aDividend 
	
	^ aDividend negated / self negated ! !
!Negativo methodsFor: 'arithmetic operations - private' stamp: 'NR 9/30/2018 20:22:05' overrides: 50658353!
divideEnteroMenosUnoYCeroPositivo: aDividend 
	
	^ aDividend negated / self negated ! !
!Negativo methodsFor: 'arithmetic operations - private' stamp: 'NR 9/30/2018 20:33:02' overrides: 50658359!
divideFraccion: aDividend

	^aDividend numerator negated / (aDividend denominator * self negated) ! !
!Negativo methodsFor: 'arithmetic operations - private' stamp: 'NR 9/30/2018 20:32:28' overrides: 50658364!
divideUno: aDividend
	
	^Fraccion safeWith: aDividend negated over: self negated! !
!Negativo methodsFor: 'arithmetic operations - private' stamp: 'NR 9/30/2018 22:47:27' overrides: 50658452!
fibonacci
	
	^ self error: Entero negativeFibonacciErrorDescription ! !
!Negativo methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:55:08' overrides: 50658369!
multiplyToEnteroMenosUnoYCeroNegativo: aMultiplier

	^PositivoMayorAUno safeWith: value * aMultiplier integerValue ! !
!Negativo methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:55:26' overrides: 50658375!
multiplyToEnteroMenosUnoYCeroPositivo: aMultiplier

	^self class safeWith: value * aMultiplier integerValue ! !
!Negativo methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:55:17' overrides: 50658381!
multiplyToFraccion: aMultiplier

	^self * aMultiplier ! !
!Negativo methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:55:52' overrides: 50658386!
substractFromEnteroMenosUnoYCeroNegativo: aMinuend

	^Entero with: aMinuend integerValue - value ! !
!Negativo methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:56:36' overrides: 50658392!
substractFromEnteroMenosUnoYCeroPositivo: aMinuend

	^PositivoMayorAUno safeWith: aMinuend integerValue - value ! !
!Negativo methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:56:02' overrides: 50658398!
substractFromFraccion: aMinuend

	^aMinuend numerator - (self * aMinuend denominator) / (aMinuend denominator)
	! !
!Negativo methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:56:11' overrides: 50658403!
substractFromUno: aMinuend

	^PositivoMayorAUno safeWith: 1 - value ! !
!Negativo methodsFor: 'testing' stamp: 'NR 10/1/2018 01:34:37' overrides: 50658407!
isNegative
	
	^true! !

!classDefinition: #PositivoMayorAUno category: 'Numero-Solution-4' stamp: 'LK 9/19/2023 00:56:09'!
EnteroMenosCeroYUno subclass: #PositivoMayorAUno
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Solution-4'!

!classDefinition: #PositivoMayorAUno category: 'Numero-Solution-4' stamp: 'LK 9/19/2023 00:56:09'!
EnteroMenosCeroYUno subclass: #PositivoMayorAUno
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Solution-4'!
!PositivoMayorAUno methodsFor: 'arithmetic operations' stamp: 'NR 9/14/2023 07:55:26' overrides: 50658298!
* aMultiplier 
	
	^aMultiplier multiplyToEnteroMenosUnoYCeroPositivo: self ! !
!PositivoMayorAUno methodsFor: 'arithmetic operations' stamp: 'NR 9/14/2023 07:54:03' overrides: 50658303!
+ anAdder 
	
	^anAdder addToEnteroMenosUnoYCeroPositivo: self.
	! !
!PositivoMayorAUno methodsFor: 'arithmetic operations' stamp: 'NR 9/14/2023 07:56:37' overrides: 50658307!
- anAdder 
	
	^anAdder substractFromEnteroMenosUnoYCeroPositivo: self.
	! !
!PositivoMayorAUno methodsFor: 'arithmetic operations' stamp: 'NR 9/30/2018 21:49:30' overrides: 50658312!
/ aDivisor 
	
	^aDivisor divideEnteroMenosUnoYCeroPositivo: self! !
!PositivoMayorAUno methodsFor: 'arithmetic operations' stamp: 'NR 9/30/2018 22:48:12' overrides: 50658452!
fibonacci

	| one two |
	
	one := Entero with: 1.
	two := Entero with: 2.

	^ (self - one) fibonacci + (self - two) fibonacci! !
!PositivoMayorAUno methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:53:47' overrides: 50658320!
addToEnteroMenosUnoYCeroNegativo: anAdder

	^Entero with: value + anAdder integerValue ! !
!PositivoMayorAUno methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:54:02' overrides: 50658326!
addToEnteroMenosUnoYCeroPositivo: anAdder

	^self class safeWith: value + anAdder integerValue ! !
!PositivoMayorAUno methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:54:20' overrides: 50658332!
addToFraccion: anAdder

	^self + anAdder 
	! !
!PositivoMayorAUno methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:54:42' overrides: 50658337!
addToUno: anAdder 
	
	^self class safeWith: 1 + value ! !
!PositivoMayorAUno methodsFor: 'arithmetic operations - private' stamp: 'NR 9/30/2018 22:09:09' overrides: 50658461!
asDenominatorOf: aNumerator

	^Fraccion safeWith: aNumerator over: self
! !
!PositivoMayorAUno methodsFor: 'arithmetic operations - private' stamp: 'NR 9/30/2018 21:36:02' overrides: 50658342!
divideCero: aDividend 
	
	^ aDividend ! !
!PositivoMayorAUno methodsFor: 'arithmetic operations - private' stamp: 'NR 9/30/2018 22:32:03' overrides: 50658347!
divideEnteroMenosUnoYCeroNegativo: aDividend 
	
	| denominator greatestCommonDivisor numerator |
	
	greatestCommonDivisor := aDividend greatestCommonDivisorWith: self. 
	numerator := aDividend // greatestCommonDivisor.
	denominator := self // greatestCommonDivisor.
	
	^denominator asDenominatorOf: numerator	! !
!PositivoMayorAUno methodsFor: 'arithmetic operations - private' stamp: 'NR 9/30/2018 22:31:36' overrides: 50658353!
divideEnteroMenosUnoYCeroPositivo: aDividend 
	
 	| denominator greatestCommonDivisor numerator |
	
	greatestCommonDivisor := aDividend greatestCommonDivisorWith: self. 
	numerator := aDividend // greatestCommonDivisor.
	denominator := self // greatestCommonDivisor.
	
	^denominator asDenominatorOf: numerator	 ! !
!PositivoMayorAUno methodsFor: 'arithmetic operations - private' stamp: 'NR 9/30/2018 22:10:20' overrides: 50658359!
divideFraccion: aDividend

	^aDividend numerator / (aDividend denominator * self) ! !
!PositivoMayorAUno methodsFor: 'arithmetic operations - private' stamp: 'NR 9/30/2018 22:10:30' overrides: 50658364!
divideUno: aDividend
	
	^Fraccion safeWith: aDividend over: self! !
!PositivoMayorAUno methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:55:08' overrides: 50658369!
multiplyToEnteroMenosUnoYCeroNegativo: aMultiplier

	^Negativo safeWith: value * aMultiplier integerValue ! !
!PositivoMayorAUno methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:55:26' overrides: 50658375!
multiplyToEnteroMenosUnoYCeroPositivo: aMultiplier

	^self class safeWith: value * aMultiplier integerValue ! !
!PositivoMayorAUno methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:55:17' overrides: 50658381!
multiplyToFraccion: aMultiplier

	^self * aMultiplier ! !
!PositivoMayorAUno methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:55:52' overrides: 50658386!
substractFromEnteroMenosUnoYCeroNegativo: aMinuend

	^Negativo safeWith: aMinuend integerValue - value ! !
!PositivoMayorAUno methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:56:36' overrides: 50658392!
substractFromEnteroMenosUnoYCeroPositivo: aMinuend

	^Entero with: aMinuend integerValue - value ! !
!PositivoMayorAUno methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:56:02' overrides: 50658398!
substractFromFraccion: aMinuend

	^aMinuend numerator - (self * aMinuend denominator) / (aMinuend denominator). 
	! !
!PositivoMayorAUno methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:56:11' overrides: 50658403!
substractFromUno: aMinuend

	^Entero with: 1 - value ! !
!PositivoMayorAUno methodsFor: 'testing' stamp: 'NR 10/1/2018 01:35:52' overrides: 50658407!
isNegative
	
	^false! !

!classDefinition: #Uno category: 'Numero-Solution-4' stamp: 'LK 9/19/2023 00:56:13'!
Entero subclass: #Uno
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Solution-4'!

!classDefinition: #Uno category: 'Numero-Solution-4' stamp: 'LK 9/19/2023 00:56:13'!
Entero subclass: #Uno
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Solution-4'!
!Uno methodsFor: 'arithmetic operations' stamp: 'HAW 5/2/2017 17:33:00' overrides: 50658298!
* aMultiplier 
	
	^aMultiplier ! !
!Uno methodsFor: 'arithmetic operations' stamp: 'NR 9/14/2023 07:54:42' overrides: 50658303!
+ anAdder 
	
	^anAdder addToUno: self.
	! !
!Uno methodsFor: 'arithmetic operations' stamp: 'NR 9/14/2023 07:56:11' overrides: 50658307!
- anAdder 
	
	^anAdder substractFromUno: self.
	! !
!Uno methodsFor: 'arithmetic operations' stamp: 'HAW 5/3/2017 12:56:15' overrides: 50658312!
/ aDivisor 
	
	^aDivisor divideUno: self! !
!Uno methodsFor: 'arithmetic operations' stamp: 'HAW 5/2/2017 17:15:00' overrides: 50658456!
greatestCommonDivisorWith: anEntero 
	
	^self 
	! !
!Uno methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:53:47' overrides: 50658320!
addToEnteroMenosUnoYCeroNegativo: anAdder

	^Entero with: 1 + anAdder integerValue ! !
!Uno methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:54:02' overrides: 50658326!
addToEnteroMenosUnoYCeroPositivo: anAdder

	^PositivoMayorAUno safeWith: 1 + anAdder integerValue ! !
!Uno methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:54:20' overrides: 50658332!
addToFraccion: anAdder

	^ anAdder denominator + anAdder numerator / anAdder denominator ! !
!Uno methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:54:42' overrides: 50658337!
addToUno: anAdder

	^PositivoMayorAUno safeWith: 2! !
!Uno methodsFor: 'arithmetic operations - private' stamp: 'HAW 5/2/2017 17:42:16' overrides: 50658461!
asDenominatorOf: aNumerator

	^aNumerator ! !
!Uno methodsFor: 'arithmetic operations - private' stamp: 'HAW 5/3/2017 16:03:52' overrides: 50658342!
divideCero: aDividend 
	
	^aDividend ! !
!Uno methodsFor: 'arithmetic operations - private' stamp: 'NR 9/30/2018 19:44:42' overrides: 50658347!
divideEnteroMenosUnoYCeroNegativo: aDividend

	^aDividend ! !
!Uno methodsFor: 'arithmetic operations - private' stamp: 'NR 9/30/2018 19:44:28' overrides: 50658353!
divideEnteroMenosUnoYCeroPositivo: aDividend

	^aDividend ! !
!Uno methodsFor: 'arithmetic operations - private' stamp: 'HAW 5/2/2017 17:57:49' overrides: 50658359!
divideFraccion: aDividend

	^aDividend ! !
!Uno methodsFor: 'arithmetic operations - private' stamp: 'HAW 5/3/2017 16:04:05' overrides: 50658364!
divideUno: aDividend 
	
	^self! !
!Uno methodsFor: 'arithmetic operations - private' stamp: 'NR 9/30/2018 22:48:43' overrides: 50658452!
fibonacci
	
	^ self		! !
!Uno methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:55:08' overrides: 50658369!
multiplyToEnteroMenosUnoYCeroNegativo: aMultiplier

	^aMultiplier ! !
!Uno methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:55:26' overrides: 50658375!
multiplyToEnteroMenosUnoYCeroPositivo: aMultiplier

	^aMultiplier ! !
!Uno methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:55:17' overrides: 50658381!
multiplyToFraccion: aMultiplier

	^aMultiplier ! !
!Uno methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:55:52' overrides: 50658386!
substractFromEnteroMenosUnoYCeroNegativo: aMinuend

	^Negativo safeWith: aMinuend integerValue - 1  ! !
!Uno methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:56:37' overrides: 50658392!
substractFromEnteroMenosUnoYCeroPositivo: aMinuend

	^Entero with: aMinuend integerValue - 1 ! !
!Uno methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:56:02' overrides: 50658398!
substractFromFraccion: aMinuend

	^ aMinuend numerator - aMinuend denominator / aMinuend denominator ! !
!Uno methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:56:11' overrides: 50658403!
substractFromUno: anAdder

	^Entero with: 0! !
!Uno methodsFor: 'value' stamp: 'HAW 5/2/2017 17:11:39' overrides: 50658465!
integerValue

	^1! !
!Uno methodsFor: 'testing' stamp: 'NR 10/1/2018 01:33:27' overrides: 50658407!
isNegative

	^false! !
!Uno methodsFor: 'testing' stamp: 'HAW 5/2/2017 17:22:43' overrides: 50658411!
isOne

	^true! !
!Uno methodsFor: 'testing' stamp: 'HAW 5/2/2017 17:22:39' overrides: 50658415!
isZero

	^false! !

!classDefinition: 'Uno class' category: 'Numero-Solution-4' stamp: 'LK 9/19/2023 00:56:17'!
Uno class
	instanceVariableNames: 'uniqueInstance'!

!classDefinition: 'Uno class' category: 'Numero-Solution-4' stamp: 'LK 9/19/2023 00:56:17'!
Uno class
	instanceVariableNames: 'uniqueInstance'!
!Uno class methodsFor: 'initialization' stamp: 'HAW 5/3/2017 18:12:13' overrides: 16904184!
initialize

	uniqueInstance := self basicNew ! !
!Uno class methodsFor: 'instance creation' stamp: 'HAW 5/3/2017 18:11:48' overrides: 16785646!
new

	^uniqueInstance! !

!classDefinition: #Fraccion category: 'Numero-Solution-4' stamp: 'LK 9/19/2023 00:56:18'!
Numero subclass: #Fraccion
	instanceVariableNames: 'numerator denominator'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Solution-4'!

!classDefinition: #Fraccion category: 'Numero-Solution-4' stamp: 'LK 9/19/2023 00:56:18'!
Numero subclass: #Fraccion
	instanceVariableNames: 'numerator denominator'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Solution-4'!
!Fraccion methodsFor: 'initialization' stamp: 'HAW 5/3/2017 16:16:31'!
initializeSafeWith: aNumerator over: aDenominator

	"Estas precondiciones estan por si se comenten errores en la implementacion durante la 
	realizacion del ejercicio, sino por como creacion esto no podria pasar - Hernan"
	aNumerator isZero ifTrue: [ self error: 'una fraccion no puede ser cero' ].
	aDenominator isOne ifTrue: [ self error: 'una fraccion no puede tener denominador 1 porque sino es un entero' ].
	
	numerator := aNumerator.
	denominator := aDenominator ! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'NR 9/14/2023 07:55:17' overrides: 50658298!
* aMultiplier 
	
	^aMultiplier multiplyToFraccion: self! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'NR 9/14/2023 07:54:20' overrides: 50658303!
+ anAdder 
	
	^anAdder addToFraccion: self! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'NR 9/14/2023 07:56:02' overrides: 50658307!
- anAdder 
	
	^anAdder substractFromFraccion: self! !

----STARTUP---- (19 September 2023 00:56:49) as C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\CuisUniversity-5981.image!


----End fileIn of C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\ejs\Clase 3.st----!

----End fileIn of C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\ejs\Clase 2.st----!

----End fileIn of C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\ejs\ISW1.st----!

----End fileIn of C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\repo\isw1\01-CodigoRepetido\CodigoRepetido-Ejercicio.st----!

----End fileIn of C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\repo\isw1\03-Stack\Stack-Exercise.st----!

----End fileIn of C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\repo\isw1\02-Numeros\Numeros-ejercicio.st----!

----QUIT----(19 September 2023 00:59:10) CuisUniversity-5981.image priorSource: 10197292!

----STARTUP---- (24 September 2023 21:23:11) as C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\CuisUniversity-5981.image!


----End fileIn of C:\Users\lucas\OneDrive\Desktop\ISW1-2023-1C-Parcial-1.st----!

!testRun: #TestDePerforación #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'LK 9/24/2023 21:24:05'!
PASSED!

!testRun: #TestDePerforación #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'LK 9/24/2023 21:24:06'!
PASSED!

!testRun: #TestDePerforación #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'LK 9/24/2023 21:24:07'!
PASSED!

!testRun: #TestDePerforación #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'LK 9/24/2023 21:24:07'!
PASSED!

!testRun: #TestDePerforación #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'LK 9/24/2023 21:24:07'!
PASSED!

!testRun: #TestDePerforación #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'LK 9/24/2023 21:24:07'!
PASSED!

!testRun: #TestDePerforación #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'LK 9/24/2023 21:24:07'!
PASSED!

!testRun: #TestDePerforación #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'LK 9/24/2023 21:24:07'!
PASSED!

!testRun: #TestDePerforación #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'LK 9/24/2023 21:24:07'!
PASSED!

!testRun: #TestDePerforación #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'LK 9/24/2023 21:24:07'!
PASSED!

!testRun: #TestDePerforación #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'LK 9/24/2023 21:24:07'!
PASSED!

!testRun: #TestDePerforación #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'LK 9/24/2023 21:24:07'!
PASSED!

!testRun: #TestDePerforación #test12NoPuedePerforarSinMecha stamp: 'LK 9/24/2023 21:24:07'!
PASSED!

!testRun: #TestDePerforación #test13PuedeCalcularProfundidadDelSuelo stamp: 'LK 9/24/2023 21:24:07'!
PASSED!

!testRun: #TestDePerforación #test14PuedeContarLasCapasDeTipoArenoso stamp: 'LK 9/24/2023 21:24:07'!
PASSED!

!testRun: #TestDePerforación #test15PuedeContarLasCapasDeTipoTierra stamp: 'LK 9/24/2023 21:24:07'!
PASSED!

!testRun: #TestDePerforación #test16PuedeContarLasCapasDeTipoConcreto stamp: 'LK 9/24/2023 21:24:07'!
PASSED!

!testRun: #TestDePerforación #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'LK 9/24/2023 21:24:07'!
PASSED!

!testRun: #TestDePerforación #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'LK 9/24/2023 21:24:07'!
PASSED!

!testRun: #TestDePerforación #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'LK 9/24/2023 21:24:07'!
PASSED!

----End fileIn of C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\Packages\TerseGuide.pck.st----!
!Perforadora methodsFor: 'scan' stamp: 'LK 9/24/2023 21:40:24' prior: 50661917!
calcularProfundidadDelSuelo
	
	| acc altura |

	acc := 0.
	
	capasDeSueloDebajo do: [:capaActual | 	altura := capaActual altura.
									altura = nil ifTrue: [ altura := 0 ]. 
									acc := acc + altura.].
	"
	[ix <= capasDeSueloDebajo size] whileTrue: [ | capa altura |
		capa := capasDeSueloDebajo at: ix.
		altura := capa altura.
		altura = nil ifTrue: [ altura := 0 ].
		acc := acc + altura.
		ix := ix + 1.		
	]."

	^ acc.
	
	 ! !

!testRun: #TestDePerforación #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'LK 9/24/2023 21:40:31'!
PASSED!

!testRun: #TestDePerforación #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'LK 9/24/2023 21:40:31'!
PASSED!

!testRun: #TestDePerforación #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'LK 9/24/2023 21:40:31'!
PASSED!

!testRun: #TestDePerforación #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'LK 9/24/2023 21:40:31'!
PASSED!

!testRun: #TestDePerforación #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'LK 9/24/2023 21:40:31'!
PASSED!

!testRun: #TestDePerforación #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'LK 9/24/2023 21:40:31'!
PASSED!

!testRun: #TestDePerforación #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'LK 9/24/2023 21:40:31'!
PASSED!

!testRun: #TestDePerforación #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'LK 9/24/2023 21:40:31'!
PASSED!

!testRun: #TestDePerforación #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'LK 9/24/2023 21:40:31'!
PASSED!

!testRun: #TestDePerforación #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'LK 9/24/2023 21:40:31'!
PASSED!

!testRun: #TestDePerforación #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'LK 9/24/2023 21:40:31'!
PASSED!

!testRun: #TestDePerforación #test12NoPuedePerforarSinMecha stamp: 'LK 9/24/2023 21:40:31'!
PASSED!

!testRun: #TestDePerforación #test13PuedeCalcularProfundidadDelSuelo stamp: 'LK 9/24/2023 21:40:31'!
PASSED!

!testRun: #TestDePerforación #test14PuedeContarLasCapasDeTipoArenoso stamp: 'LK 9/24/2023 21:40:31'!
PASSED!

!testRun: #TestDePerforación #test15PuedeContarLasCapasDeTipoTierra stamp: 'LK 9/24/2023 21:40:31'!
PASSED!

!testRun: #TestDePerforación #test16PuedeContarLasCapasDeTipoConcreto stamp: 'LK 9/24/2023 21:40:31'!
PASSED!

!testRun: #TestDePerforación #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'LK 9/24/2023 21:40:31'!
PASSED!

!testRun: #TestDePerforación #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'LK 9/24/2023 21:40:31'!
PASSED!

!testRun: #TestDePerforación #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'LK 9/24/2023 21:40:31'!
PASSED!
!Perforadora methodsFor: 'scan' stamp: 'LK 9/24/2023 21:47:46' prior: 50661948!
contarCapas: tipoDeCapa
	
	"Cuenta las capas de tipo tipoDeCapa. Recordar que para identificar cada capa se utiliza el valor de scan que retorna. Por ej. un capa tipo Arenoso retorna 7 al scan"
	
	| capitas valor |
	
	valor := 0.
	tipoDeCapa = #Arenoso ifTrue: [ valor := 7 ].
	tipoDeCapa = #Tierra ifTrue: [ valor := 10 ].
	tipoDeCapa = #Concreto ifTrue: [ valor := 50].	
	
	"capasDeSueloDebajo do: [ :capaActual | valor = capaActual scan ifTrue: [acc := acc + 1]. ^acc"
		
	capitas := capasDeSueloDebajo select: [ :capaActual | valor = capaActual scan].
	
	 ^capitas size.
	
	"
	[ix <= capasDeSueloDebajo size] whileTrue: [ | capa |
		capa := capasDeSueloDebajo at: ix.
		valor = capa scan ifTrue: [ acc := acc + 1 ].
		ix := ix + 1.		
	]."
! !

!testRun: #TestDePerforación #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'LK 9/24/2023 21:47:55'!
PASSED!

!testRun: #TestDePerforación #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'LK 9/24/2023 21:47:55'!
PASSED!

!testRun: #TestDePerforación #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'LK 9/24/2023 21:47:55'!
PASSED!

!testRun: #TestDePerforación #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'LK 9/24/2023 21:47:55'!
PASSED!

!testRun: #TestDePerforación #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'LK 9/24/2023 21:47:55'!
PASSED!

!testRun: #TestDePerforación #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'LK 9/24/2023 21:47:55'!
PASSED!

!testRun: #TestDePerforación #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'LK 9/24/2023 21:47:55'!
PASSED!

!testRun: #TestDePerforación #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'LK 9/24/2023 21:47:55'!
PASSED!

!testRun: #TestDePerforación #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'LK 9/24/2023 21:47:55'!
PASSED!

!testRun: #TestDePerforación #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'LK 9/24/2023 21:47:55'!
PASSED!

!testRun: #TestDePerforación #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'LK 9/24/2023 21:47:55'!
PASSED!

!testRun: #TestDePerforación #test12NoPuedePerforarSinMecha stamp: 'LK 9/24/2023 21:47:55'!
PASSED!

!testRun: #TestDePerforación #test13PuedeCalcularProfundidadDelSuelo stamp: 'LK 9/24/2023 21:47:55'!
PASSED!

!testRun: #TestDePerforación #test14PuedeContarLasCapasDeTipoArenoso stamp: 'LK 9/24/2023 21:47:55'!
PASSED!

!testRun: #TestDePerforación #test15PuedeContarLasCapasDeTipoTierra stamp: 'LK 9/24/2023 21:47:55'!
PASSED!

!testRun: #TestDePerforación #test16PuedeContarLasCapasDeTipoConcreto stamp: 'LK 9/24/2023 21:47:55'!
PASSED!

!testRun: #TestDePerforación #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'LK 9/24/2023 21:47:55'!
PASSED!

!testRun: #TestDePerforación #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'LK 9/24/2023 21:47:55'!
PASSED!

!testRun: #TestDePerforación #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'LK 9/24/2023 21:47:55'!
PASSED!
!Perforadora methodsFor: 'scan' stamp: 'LK 9/24/2023 21:48:02' prior: 50665077!
contarCapas: tipoDeCapa
	
	"Cuenta las capas de tipo tipoDeCapa. Recordar que para identificar cada capa se utiliza el valor de scan que retorna. Por ej. un capa tipo Arenoso retorna 7 al scan"
	
	| capitas valor |
	
	valor := 0.
	tipoDeCapa = #Arenoso ifTrue: [ valor := 7 ].
	tipoDeCapa = #Tierra ifTrue: [ valor := 10 ].
	tipoDeCapa = #Concreto ifTrue: [ valor := 50].	
	
	"capasDeSueloDebajo do: [ :capaActual | valor = capaActual scan ifTrue: [acc := acc + 1]. ^acc"
		
	capitas := capasDeSueloDebajo select: [ :capaActual | valor = capaActual scan].
	
	 ^capitas size + 1.
	
	"
	[ix <= capasDeSueloDebajo size] whileTrue: [ | capa |
		capa := capasDeSueloDebajo at: ix.
		valor = capa scan ifTrue: [ acc := acc + 1 ].
		ix := ix + 1.		
	]."
! !

!testRun: #TestDePerforación #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'LK 9/24/2023 21:48:03'!
PASSED!

!testRun: #TestDePerforación #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'LK 9/24/2023 21:48:03'!
PASSED!

!testRun: #TestDePerforación #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'LK 9/24/2023 21:48:03'!
PASSED!

!testRun: #TestDePerforación #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'LK 9/24/2023 21:48:03'!
PASSED!

!testRun: #TestDePerforación #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'LK 9/24/2023 21:48:03'!
PASSED!

!testRun: #TestDePerforación #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'LK 9/24/2023 21:48:03'!
PASSED!

!testRun: #TestDePerforación #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'LK 9/24/2023 21:48:03'!
PASSED!

!testRun: #TestDePerforación #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'LK 9/24/2023 21:48:03'!
PASSED!

!testRun: #TestDePerforación #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'LK 9/24/2023 21:48:03'!
PASSED!

!testRun: #TestDePerforación #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'LK 9/24/2023 21:48:03'!
PASSED!

!testRun: #TestDePerforación #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'LK 9/24/2023 21:48:03'!
PASSED!

!testRun: #TestDePerforación #test12NoPuedePerforarSinMecha stamp: 'LK 9/24/2023 21:48:03'!
PASSED!

!testRun: #TestDePerforación #test13PuedeCalcularProfundidadDelSuelo stamp: 'LK 9/24/2023 21:48:03'!
PASSED!

!testRun: #TestDePerforación #test14PuedeContarLasCapasDeTipoArenoso stamp: 'LK 9/24/2023 21:48:03'!
FAILURE!

!testRun: #TestDePerforación #test15PuedeContarLasCapasDeTipoTierra stamp: 'LK 9/24/2023 21:48:03'!
FAILURE!

!testRun: #TestDePerforación #test16PuedeContarLasCapasDeTipoConcreto stamp: 'LK 9/24/2023 21:48:03'!
FAILURE!

!testRun: #TestDePerforación #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'LK 9/24/2023 21:48:03'!
PASSED!

!testRun: #TestDePerforación #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'LK 9/24/2023 21:48:03'!
PASSED!

!testRun: #TestDePerforación #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'LK 9/24/2023 21:48:03'!
PASSED!
!Perforadora methodsFor: 'scan' stamp: 'LK 9/24/2023 21:48:10' prior: 50665179!
contarCapas: tipoDeCapa
	
	"Cuenta las capas de tipo tipoDeCapa. Recordar que para identificar cada capa se utiliza el valor de scan que retorna. Por ej. un capa tipo Arenoso retorna 7 al scan"
	
	| capitas valor |
	
	valor := 0.
	tipoDeCapa = #Arenoso ifTrue: [ valor := 7 ].
	tipoDeCapa = #Tierra ifTrue: [ valor := 10 ].
	tipoDeCapa = #Concreto ifTrue: [ valor := 50].	
	
	"capasDeSueloDebajo do: [ :capaActual | valor = capaActual scan ifTrue: [acc := acc + 1]. ^acc"
		
	capitas := capasDeSueloDebajo select: [ :capaActual | valor = capaActual scan].
	
	 ^capitas size.
	
	"
	[ix <= capasDeSueloDebajo size] whileTrue: [ | capa |
		capa := capasDeSueloDebajo at: ix.
		valor = capa scan ifTrue: [ acc := acc + 1 ].
		ix := ix + 1.		
	]."
! !
!Perforadora methodsFor: 'scan' stamp: 'LK 9/24/2023 21:48:28' prior: 50665281!
contarCapas: tipoDeCapa
	
	"Cuenta las capas de tipo tipoDeCapa. Recordar que para identificar cada capa se utiliza el valor de scan que retorna. Por ej. un capa tipo Arenoso retorna 7 al scan"
	
	| capitas valor |
	
	valor := 0.
	tipoDeCapa = #Arenoso ifTrue: [ valor := 7 ].
	tipoDeCapa = #Tierra ifTrue: [ valor := 10 ].
	tipoDeCapa = #Concreto ifTrue: [ valor := 50].	
	
	"capasDeSueloDebajo do: [ :capaActual | valor = capaActual scan ifTrue: [acc := acc + 1]. ^acc"
		
	"capitas := capasDeSueloDebajo select: [ :capaActual | valor = capaActual scan].
	
	 ^capitas size."
	
	"
	[ix <= capasDeSueloDebajo size] whileTrue: [ | capa |
		capa := capasDeSueloDebajo at: ix.
		valor = capa scan ifTrue: [ acc := acc + 1 ].
		ix := ix + 1.		
	]."
! !
!Perforadora methodsFor: 'scan' stamp: 'LK 9/24/2023 21:49:18' prior: 50665307!
contarCapas: tipoDeCapa
	
	"Cuenta las capas de tipo tipoDeCapa. Recordar que para identificar cada capa se utiliza el valor de scan que retorna. Por ej. un capa tipo Arenoso retorna 7 al scan"
	
	| acc valor |
	
	valor := 0.
	tipoDeCapa = #Arenoso ifTrue: [ valor := 7 ].
	tipoDeCapa = #Tierra ifTrue: [ valor := 10 ].
	tipoDeCapa = #Concreto ifTrue: [ valor := 50].	
	
	acc := 0.
	
	capasDeSueloDebajo do: [ :capaActual | valor = capaActual scan ifTrue: [acc := acc + 1]]. 
		
	^acc
		
	"capitas := capasDeSueloDebajo select: [ :capaActual | valor = capaActual scan].
	
	 ^capitas size."
	
	"
	[ix <= capasDeSueloDebajo size] whileTrue: [ | capa |
		capa := capasDeSueloDebajo at: ix.
		valor = capa scan ifTrue: [ acc := acc + 1 ].
		ix := ix + 1.		
	]."! !

!testRun: #TestDePerforación #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'LK 9/24/2023 21:49:23'!
PASSED!

!testRun: #TestDePerforación #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'LK 9/24/2023 21:49:23'!
PASSED!

!testRun: #TestDePerforación #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'LK 9/24/2023 21:49:23'!
PASSED!

!testRun: #TestDePerforación #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'LK 9/24/2023 21:49:23'!
PASSED!

!testRun: #TestDePerforación #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'LK 9/24/2023 21:49:23'!
PASSED!

!testRun: #TestDePerforación #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'LK 9/24/2023 21:49:23'!
PASSED!

!testRun: #TestDePerforación #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'LK 9/24/2023 21:49:23'!
PASSED!

!testRun: #TestDePerforación #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'LK 9/24/2023 21:49:23'!
PASSED!

!testRun: #TestDePerforación #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'LK 9/24/2023 21:49:23'!
PASSED!

!testRun: #TestDePerforación #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'LK 9/24/2023 21:49:23'!
PASSED!

!testRun: #TestDePerforación #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'LK 9/24/2023 21:49:23'!
PASSED!

!testRun: #TestDePerforación #test12NoPuedePerforarSinMecha stamp: 'LK 9/24/2023 21:49:23'!
PASSED!

!testRun: #TestDePerforación #test13PuedeCalcularProfundidadDelSuelo stamp: 'LK 9/24/2023 21:49:23'!
PASSED!

!testRun: #TestDePerforación #test14PuedeContarLasCapasDeTipoArenoso stamp: 'LK 9/24/2023 21:49:23'!
PASSED!

!testRun: #TestDePerforación #test15PuedeContarLasCapasDeTipoTierra stamp: 'LK 9/24/2023 21:49:23'!
PASSED!

!testRun: #TestDePerforación #test16PuedeContarLasCapasDeTipoConcreto stamp: 'LK 9/24/2023 21:49:23'!
PASSED!

!testRun: #TestDePerforación #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'LK 9/24/2023 21:49:23'!
PASSED!

!testRun: #TestDePerforación #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'LK 9/24/2023 21:49:23'!
PASSED!

!testRun: #TestDePerforación #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'LK 9/24/2023 21:49:23'!
PASSED!
!Perforadora methodsFor: 'scan' stamp: 'LK 9/24/2023 21:49:40' prior: 50665333!
contarCapas: tipoDeCapa
	
	"Cuenta las capas de tipo tipoDeCapa. Recordar que para identificar cada capa se utiliza el valor de scan que retorna. Por ej. un capa tipo Arenoso retorna 7 al scan"
	
	| capitas valor |
	
	valor := 0.
	tipoDeCapa = #Arenoso ifTrue: [ valor := 7 ].
	tipoDeCapa = #Tierra ifTrue: [ valor := 10 ].
	tipoDeCapa = #Concreto ifTrue: [ valor := 50].	
	
	"capasDeSueloDebajo do: [ :capaActual | valor = capaActual scan ifTrue: [acc := acc + 1]]. 
		
	^acc"
		
	capitas := capasDeSueloDebajo select: [ :capaActual | valor = capaActual scan].
	
	 ^capitas size.
	
	"
	[ix <= capasDeSueloDebajo size] whileTrue: [ | capa |
		capa := capasDeSueloDebajo at: ix.
		valor = capa scan ifTrue: [ acc := acc + 1 ].
		ix := ix + 1.		
	]."! !
!Perforadora methodsFor: 'scan' stamp: 'LK 9/24/2023 21:49:51' prior: 50665435!
contarCapas: tipoDeCapa
	
	"Cuenta las capas de tipo tipoDeCapa. Recordar que para identificar cada capa se utiliza el valor de scan que retorna. Por ej. un capa tipo Arenoso retorna 7 al scan"
	
	| capitas valor |
	
	valor := 0.
	tipoDeCapa = #Arenoso ifTrue: [ valor := 7 ].
	tipoDeCapa = #Tierra ifTrue: [ valor := 10 ].
	tipoDeCapa = #Concreto ifTrue: [ valor := 50].	
	
	capitas := capasDeSueloDebajo select: [ :capaActual | valor = capaActual scan].
	
	 ^capitas size.
! !
!Perforadora methodsFor: 'scan' stamp: 'LK 9/24/2023 22:42:48' prior: 50661929!
calcularProfundidadDelSueloHasta: tipoDeCapa
	
	| valor acc altura |
	
	valor := 0.
	tipoDeCapa = #Arenoso ifTrue: [ valor := 7 ].
	tipoDeCapa = #Tierra ifTrue: [ valor := 10 ].
	tipoDeCapa = #Concreto ifTrue: [ valor := 50].	
	
	acc := 0.
	capasDeSueloDebajo do: [ :capaActual | valor = capaActual scan ifTrue: [ ^ acc ].
							altura := capaActual altura.
							altura = nil ifTrue: [ altura := 0 ].
							acc := acc + altura.].
						
	"
	[ix <= capasDeSueloDebajo size] whileTrue: [ | capa altura |
		capa := capasDeSueloDebajo at: ix.
		
		valor = capa scan ifTrue: [ ^ acc ].
		
		altura := capa altura.
		altura = nil ifTrue: [ altura := 0 ].
		acc := acc + altura.
		ix := ix + 1.		
	].

	^ acc.
	
	 "! !

!testRun: #TestDePerforación #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'LK 9/24/2023 22:42:54'!
PASSED!

!testRun: #TestDePerforación #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'LK 9/24/2023 22:42:54'!
PASSED!

!testRun: #TestDePerforación #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'LK 9/24/2023 22:42:54'!
PASSED!

!testRun: #TestDePerforación #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'LK 9/24/2023 22:42:54'!
PASSED!

!testRun: #TestDePerforación #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'LK 9/24/2023 22:42:54'!
PASSED!

!testRun: #TestDePerforación #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'LK 9/24/2023 22:42:54'!
PASSED!

!testRun: #TestDePerforación #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'LK 9/24/2023 22:42:54'!
PASSED!

!testRun: #TestDePerforación #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'LK 9/24/2023 22:42:54'!
PASSED!

!testRun: #TestDePerforación #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'LK 9/24/2023 22:42:54'!
PASSED!

!testRun: #TestDePerforación #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'LK 9/24/2023 22:42:54'!
PASSED!

!testRun: #TestDePerforación #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'LK 9/24/2023 22:42:54'!
PASSED!

!testRun: #TestDePerforación #test12NoPuedePerforarSinMecha stamp: 'LK 9/24/2023 22:42:54'!
PASSED!

!testRun: #TestDePerforación #test13PuedeCalcularProfundidadDelSuelo stamp: 'LK 9/24/2023 22:42:54'!
PASSED!

!testRun: #TestDePerforación #test14PuedeContarLasCapasDeTipoArenoso stamp: 'LK 9/24/2023 22:42:54'!
PASSED!

!testRun: #TestDePerforación #test15PuedeContarLasCapasDeTipoTierra stamp: 'LK 9/24/2023 22:42:54'!
PASSED!

!testRun: #TestDePerforación #test16PuedeContarLasCapasDeTipoConcreto stamp: 'LK 9/24/2023 22:42:54'!
PASSED!

!testRun: #TestDePerforación #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'LK 9/24/2023 22:42:54'!
PASSED!

!testRun: #TestDePerforación #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'LK 9/24/2023 22:42:54'!
PASSED!

!testRun: #TestDePerforación #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'LK 9/24/2023 22:42:54'!
PASSED!

Object subclass: #TipoDeSuelo
	instanceVariableNames: 'tipo resistencia altura'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classDefinition: #TipoDeSuelo category: 'ISW1-2023-1C-Parcial-1' stamp: 'LK 9/24/2023 22:43:44'!
Object subclass: #TipoDeSuelo
	instanceVariableNames: 'tipo resistencia altura'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

TipoDeSuelo subclass: #Arenoso
	instanceVariableNames: 'tipo resistencia altura'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

TipoDeSuelo subclass: #Arenoso
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classDefinition: #Arenoso category: 'ISW1-2023-1C-Parcial-1' stamp: 'LK 9/24/2023 22:44:00'!
TipoDeSuelo subclass: #Arenoso
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

TipoDeSuelo subclass: #Tierra
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classDefinition: #Tierra category: 'ISW1-2023-1C-Parcial-1' stamp: 'LK 9/24/2023 22:44:09'!
TipoDeSuelo subclass: #Tierra
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

TipoDeSuelo subclass: #Concreto
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classDefinition: #Concreto category: 'ISW1-2023-1C-Parcial-1' stamp: 'LK 9/24/2023 22:44:12'!
TipoDeSuelo subclass: #Concreto
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

Perforadora subclass: #MechaSoft
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classDefinition: #MechaSoft category: 'ISW1-2023-1C-Parcial-1' stamp: 'LK 9/24/2023 22:44:43'!
Perforadora subclass: #MechaSoft
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

Perforadora subclass: #MechaWidia
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classDefinition: #MechaWidia category: 'ISW1-2023-1C-Parcial-1' stamp: 'LK 9/24/2023 22:44:49'!
Perforadora subclass: #MechaWidia
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

Perforadora subclass: #MechaDiamante
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classDefinition: #MechaDiamante category: 'ISW1-2023-1C-Parcial-1' stamp: 'LK 9/24/2023 22:44:56'!
Perforadora subclass: #MechaDiamante
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

Perforadora subclass: #SinMecha
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classDefinition: #SinMecha category: 'ISW1-2023-1C-Parcial-1' stamp: 'LK 9/24/2023 22:46:30'!
Perforadora subclass: #SinMecha
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

Perforadora subclass: #MechaRota
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classDefinition: #MechaRota category: 'ISW1-2023-1C-Parcial-1' stamp: 'LK 9/24/2023 22:47:07'!
Perforadora subclass: #MechaRota
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!
!SinMecha methodsFor: 'no messages' stamp: 'LK 9/24/2023 22:50:16' overrides: 50661825!
darGolpeDeTaladro
		
	self error: 'No puede perforar'.! !
!SinMecha class methodsFor: 'nil' stamp: 'LK 9/24/2023 22:50:53'!
errorSinMecha
	^'No puede perforar'.! !
!SinMecha methodsFor: 'as yet unclassified' stamp: 'LK 9/24/2023 22:51:23' prior: 50665694 overrides: 50661825!
darGolpeDeTaladro
		
	self error: self errorSinMecha.! !
!SinMecha methodsFor: 'as yet unclassified' stamp: 'LK 9/24/2023 22:52:14' prior: 50665703 overrides: 50661825!
darGolpeDeTaladro
		
	self error: SinMecha errorSinMecha.! !

!testRun: #TestDePerforación #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'LK 9/24/2023 22:52:23'!
PASSED!

!testRun: #TestDePerforación #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'LK 9/24/2023 22:52:23'!
PASSED!

!testRun: #TestDePerforación #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'LK 9/24/2023 22:52:23'!
PASSED!

!testRun: #TestDePerforación #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'LK 9/24/2023 22:52:23'!
PASSED!

!testRun: #TestDePerforación #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'LK 9/24/2023 22:52:23'!
PASSED!

!testRun: #TestDePerforación #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'LK 9/24/2023 22:52:23'!
PASSED!

!testRun: #TestDePerforación #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'LK 9/24/2023 22:52:23'!
PASSED!

!testRun: #TestDePerforación #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'LK 9/24/2023 22:52:23'!
PASSED!

!testRun: #TestDePerforación #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'LK 9/24/2023 22:52:23'!
PASSED!

!testRun: #TestDePerforación #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'LK 9/24/2023 22:52:23'!
PASSED!

!testRun: #TestDePerforación #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'LK 9/24/2023 22:52:23'!
PASSED!

!testRun: #TestDePerforación #test12NoPuedePerforarSinMecha stamp: 'LK 9/24/2023 22:52:23'!
PASSED!

!testRun: #TestDePerforación #test13PuedeCalcularProfundidadDelSuelo stamp: 'LK 9/24/2023 22:52:23'!
PASSED!

!testRun: #TestDePerforación #test14PuedeContarLasCapasDeTipoArenoso stamp: 'LK 9/24/2023 22:52:23'!
PASSED!

!testRun: #TestDePerforación #test15PuedeContarLasCapasDeTipoTierra stamp: 'LK 9/24/2023 22:52:23'!
PASSED!

!testRun: #TestDePerforación #test16PuedeContarLasCapasDeTipoConcreto stamp: 'LK 9/24/2023 22:52:23'!
PASSED!

!testRun: #TestDePerforación #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'LK 9/24/2023 22:52:23'!
PASSED!

!testRun: #TestDePerforación #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'LK 9/24/2023 22:52:23'!
PASSED!

!testRun: #TestDePerforación #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'LK 9/24/2023 22:52:23'!
PASSED!
!Perforadora methodsFor: 'excavation' stamp: 'LK 9/24/2023 22:53:20' prior: 50661825!
darGolpeDeTaladro

	vecesQueGolpeoCapaActual := vecesQueGolpeoCapaActual + 1.
	
	self sobreSueloArenoso ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Widia ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Diamante ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
		^self].
	
	self sobreSueloTierra ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 2 ifTrue: [ ^self transformarCapaEnArenoso ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ ^self pasarAProximaCapa ]].
	
	self sobreSueloConcreto ifTrue: [
		mechaPuesta = #Soft ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió'  ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 3 ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ 
			vecesQueGolpeoCapaActual even ifTrue: [ capasDeSueloDebajo first bajaUnDecimoDeResistencia].
			capasDeSueloDebajo first sinResistencia ifTrue: [ ^self transformarCapaEnArenoso].
			^vecesQueGolpeoCapaActual ]].
	
	self error: 'error'! !

Object subclass: #TipoDeSuelo
	instanceVariableNames: 'altura'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classDefinition: #TipoDeSuelo category: 'ISW1-2023-1C-Parcial-1' stamp: 'LK 9/24/2023 22:54:13'!
Object subclass: #TipoDeSuelo
	instanceVariableNames: 'altura'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

TipoDeSuelo subclass: #Concreto
	instanceVariableNames: 'resistencia'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classDefinition: #Concreto category: 'ISW1-2023-1C-Parcial-1' stamp: 'LK 9/24/2023 22:54:18'!
TipoDeSuelo subclass: #Concreto
	instanceVariableNames: 'resistencia'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!
!Concreto methodsFor: 'no messages' stamp: 'LK 9/24/2023 22:54:28'!
bajaUnDecimoDeResistencia
	resistencia := resistencia - 1! !
!Tierra methodsFor: 'no messages' stamp: 'LK 9/24/2023 22:57:24'!
esTierra
	^true! !
!Tierra methodsFor: 'as yet unclassified' stamp: 'LK 9/24/2023 22:57:49'!
esConcreto
	^false! !
!Tierra methodsFor: 'as yet unclassified' stamp: 'LK 9/24/2023 22:57:56'!
esArenoso
	^false! !

!classRemoval: #Arenoso stamp: 'LK 9/24/2023 23:13:13'!
TipoDeSuelo subclass: #Arenoso
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classRemoval: #Tierra stamp: 'LK 9/24/2023 23:13:14'!
TipoDeSuelo subclass: #Tierra
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classRemoval: #Concreto stamp: 'LK 9/24/2023 23:13:14'!
TipoDeSuelo subclass: #Concreto
	instanceVariableNames: 'resistencia'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classRemoval: #TipoDeSuelo stamp: 'LK 9/24/2023 23:13:14'!
Object subclass: #TipoDeSuelo
	instanceVariableNames: 'altura'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

Object subclass: #CapaDeSuelo
	instanceVariableNames: 'altura'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classDefinition: #CapaDeSuelo category: 'ISW1-2023-1C-Parcial-1' stamp: 'LK 9/24/2023 23:15:22'!
Object subclass: #CapaDeSuelo
	instanceVariableNames: 'altura'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

CapaDeSuelo subclass: #Arenoso
	instanceVariableNames: 'altura'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

CapaDeSuelo subclass: #Arenoso
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classDefinition: #Arenoso category: 'ISW1-2023-1C-Parcial-1' stamp: 'LK 9/24/2023 23:15:36'!
CapaDeSuelo subclass: #Arenoso
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

CapaDeSuelo subclass: #Tierra
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classDefinition: #Tierra category: 'ISW1-2023-1C-Parcial-1' stamp: 'LK 9/24/2023 23:15:39'!
CapaDeSuelo subclass: #Tierra
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

CapaDeSuelo subclass: #Concreto
	instanceVariableNames: 'resistencia'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classDefinition: #Concreto category: 'ISW1-2023-1C-Parcial-1' stamp: 'LK 9/24/2023 23:15:48'!
CapaDeSuelo subclass: #Concreto
	instanceVariableNames: 'resistencia'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!
!Concreto methodsFor: 'nil' stamp: 'LK 9/24/2023 23:16:09' overrides: 50661739!
bajaUnDecimoDeResistencia
	resistencia := resistencia - 1! !
!Arenoso methodsFor: 'initialization' stamp: 'LK 9/24/2023 23:18:23' overrides: 50661700!
initializeArenoso
	
	tipo := #Arenoso.
	altura := nil.! !

!methodRemoval: CapaDeSuelo #initializeArenoso stamp: 'LK 9/24/2023 23:18:23'!
initializeArenoso
	
	tipo := #Arenoso.
	altura := nil.!
!Tierra methodsFor: 'initialization' stamp: 'LK 9/24/2023 23:18:38' overrides: 50661712!
initializeTierra
	
	tipo := #Tierra.
	altura := nil.! !

!methodRemoval: CapaDeSuelo #initializeTierra stamp: 'LK 9/24/2023 23:18:38'!
initializeTierra
	
	tipo := #Tierra.
	altura := nil.!
!Concreto methodsFor: 'initialization' stamp: 'LK 9/24/2023 23:18:47' overrides: 50661705!
initializeConcretoConResistencia: resistenciaInicial 

	resistencia := resistenciaInicial.
	tipo := #Concreto.
	altura := nil.! !

!methodRemoval: CapaDeSuelo #initializeConcretoConResistencia: stamp: 'LK 9/24/2023 23:18:47'!
initializeConcretoConResistencia: resistenciaInicial 

	resistencia := resistenciaInicial.
	tipo := #Concreto.
	altura := nil.!
!Concreto methodsFor: 'accessing' stamp: 'LK 9/24/2023 23:18:58' overrides: 50661751!
resistencia

	^ resistencia.! !

!methodRemoval: CapaDeSuelo #resistencia stamp: 'LK 9/24/2023 23:18:58'!
resistencia

	^ resistencia.!
!Arenoso methodsFor: 'scan' stamp: 'LK 9/24/2023 23:19:10' overrides: 50661758!
scan

	self esArenoso ifTrue: [ ^ 7 ].
	self esTierra ifTrue: [ ^ 10 ].
	^ 50. ! !
!Tierra methodsFor: 'scan' stamp: 'LK 9/24/2023 23:19:10' overrides: 50661758!
scan

	self esArenoso ifTrue: [ ^ 7 ].
	self esTierra ifTrue: [ ^ 10 ].
	^ 50. ! !
!Concreto methodsFor: 'scan' stamp: 'LK 9/24/2023 23:19:10' overrides: 50661758!
scan

	self esArenoso ifTrue: [ ^ 7 ].
	self esTierra ifTrue: [ ^ 10 ].
	^ 50. ! !
!CapaDeSuelo methodsFor: 'scan' stamp: 'LK 9/24/2023 23:19:10' prior: 50661758!
scan

	self subclassResponsibility! !
!Arenoso methodsFor: 'accessing' stamp: 'LK 9/24/2023 23:19:19' overrides: 50661755!
tipo

	^tipo! !
!Tierra methodsFor: 'accessing' stamp: 'LK 9/24/2023 23:19:19' overrides: 50661755!
tipo

	^tipo! !
!Concreto methodsFor: 'accessing' stamp: 'LK 9/24/2023 23:19:19' overrides: 50661755!
tipo

	^tipo! !
!CapaDeSuelo methodsFor: 'accessing' stamp: 'LK 9/24/2023 23:19:19' prior: 50661755!
tipo

	self subclassResponsibility! !
!Concreto methodsFor: 'bajar resistencia' stamp: 'LK 9/24/2023 23:19:36' overrides: 50661744!
sinResistencia
	^resistencia = 0! !

!methodRemoval: CapaDeSuelo #sinResistencia stamp: 'LK 9/24/2023 23:19:36'!
sinResistencia
	^resistencia = 0!
!Arenoso methodsFor: 'tipo' stamp: 'LK 9/24/2023 23:19:58' overrides: 50661716!
esArenoso
	^tipo = #Arenoso! !
!Tierra methodsFor: 'tipo' stamp: 'LK 9/24/2023 23:19:58' overrides: 50661716!
esArenoso
	^tipo = #Arenoso! !
!Concreto methodsFor: 'tipo' stamp: 'LK 9/24/2023 23:19:58' overrides: 50661716!
esArenoso
	^tipo = #Arenoso! !
!CapaDeSuelo methodsFor: 'tipo' stamp: 'LK 9/24/2023 23:19:58' prior: 50661716!
esArenoso

	self subclassResponsibility! !

!methodRemoval: CapaDeSuelo #bajaUnDecimoDeResistencia stamp: 'LK 9/24/2023 23:22:04'!
bajaUnDecimoDeResistencia
	resistencia := resistencia - 1!
!Arenoso methodsFor: 'tipo' stamp: 'LK 9/24/2023 23:22:51' overrides: 50661719!
esConcreto
	^tipo = #Concreto! !
!Tierra methodsFor: 'tipo' stamp: 'LK 9/24/2023 23:22:52' overrides: 50661719!
esConcreto
	^tipo = #Concreto! !
!Concreto methodsFor: 'tipo' stamp: 'LK 9/24/2023 23:22:52' overrides: 50661719!
esConcreto
	^tipo = #Concreto! !
!CapaDeSuelo methodsFor: 'tipo' stamp: 'LK 9/24/2023 23:22:52' prior: 50661719!
esConcreto

	self subclassResponsibility! !
!Arenoso methodsFor: 'tipo' stamp: 'LK 9/24/2023 23:23:00' overrides: 50661723!
esTierra
	^tipo = #Tierra! !
!Tierra methodsFor: 'tipo' stamp: 'LK 9/24/2023 23:23:00' overrides: 50661723!
esTierra
	^tipo = #Tierra! !
!Concreto methodsFor: 'tipo' stamp: 'LK 9/24/2023 23:23:00' overrides: 50661723!
esTierra
	^tipo = #Tierra! !
!CapaDeSuelo methodsFor: 'tipo' stamp: 'LK 9/24/2023 23:23:00' prior: 50661723!
esTierra

	self subclassResponsibility! !
!Arenoso methodsFor: 'tipo' stamp: 'LK 9/24/2023 23:23:53' prior: 50666036 overrides: 50666048!
esArenoso
	^true! !
!Arenoso methodsFor: 'tipo' stamp: 'LK 9/24/2023 23:23:58' prior: 50666057 overrides: 50666069!
esConcreto
	^false! !
!Arenoso methodsFor: 'tipo' stamp: 'LK 9/24/2023 23:24:01' prior: 50666073 overrides: 50666085!
esTierra
	^false! !
!Arenoso methodsFor: 'initialization' stamp: 'LK 9/24/2023 23:24:07' prior: 50665950!
initializeArenoso

	altura := nil.! !
!Arenoso methodsFor: 'scan' stamp: 'LK 9/24/2023 23:24:17' prior: 50665989 overrides: 50666007!
scan
	^7.! !
!Arenoso methodsFor: 'accessing' stamp: 'LK 9/24/2023 23:24:25' prior: 50666011 overrides: 50666023!
tipo
	^#Arenoso! !
!Concreto methodsFor: 'tipo' stamp: 'LK 9/24/2023 23:24:36' prior: 50666044 overrides: 50666048!
esArenoso
	^false! !
!Concreto methodsFor: 'tipo' stamp: 'LK 9/24/2023 23:24:40' prior: 50666065 overrides: 50666069!
esConcreto
	^true! !
!Concreto methodsFor: 'tipo' stamp: 'LK 9/24/2023 23:24:44' prior: 50666081 overrides: 50666085!
esTierra
	^false! !
!Concreto methodsFor: 'initialization' stamp: 'LK 9/24/2023 23:24:53' prior: 50665968!
initializeConcretoConResistencia: resistenciaInicial 

	resistencia := resistenciaInicial.
	altura := nil.! !
!Concreto methodsFor: 'scan' stamp: 'LK 9/24/2023 23:25:00' prior: 50666001 overrides: 50666007!
scan
	^ 50. ! !
!Concreto methodsFor: 'accessing' stamp: 'LK 9/24/2023 23:25:08' prior: 50666019 overrides: 50666023!
tipo

	^#Concreto! !
!Tierra methodsFor: 'tipo' stamp: 'LK 9/24/2023 23:25:14' prior: 50666040 overrides: 50666048!
esArenoso
	^false! !
!Tierra methodsFor: 'tipo' stamp: 'LK 9/24/2023 23:25:18' prior: 50666061 overrides: 50666069!
esConcreto
	^false! !
!Tierra methodsFor: 'tipo' stamp: 'LK 9/24/2023 23:25:25' prior: 50666077 overrides: 50666085!
esTierra
	^true! !
!CapaDeSuelo methodsFor: 'comparing' stamp: 'LK 9/24/2023 23:26:24' prior: 50661727 overrides: 16901772!
= unaCapaDeSuelo

	^(unaCapaDeSuelo isKindOf: self class) and: [self tipo = unaCapaDeSuelo tipo].! !
!Concreto methodsFor: 'bajar resistencia' stamp: 'LK 9/24/2023 23:26:42' overrides: 50666154!
= unaCapaDeSuelo

	^(unaCapaDeSuelo isKindOf: self class) and: [self tipo = unaCapaDeSuelo tipo and: [resistencia = unaCapaDeSuelo resistencia]].! !

!testRun: #TestDePerforación #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'LK 9/24/2023 23:28:38'!
ERROR!

!testRun: #TestDePerforación #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'LK 9/24/2023 23:28:38'!
ERROR!

!testRun: #TestDePerforación #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'LK 9/24/2023 23:28:38'!
ERROR!

!testRun: #TestDePerforación #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'LK 9/24/2023 23:28:38'!
ERROR!

!testRun: #TestDePerforación #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'LK 9/24/2023 23:28:38'!
ERROR!

!testRun: #TestDePerforación #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'LK 9/24/2023 23:28:38'!
ERROR!

!testRun: #TestDePerforación #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'LK 9/24/2023 23:28:39'!
ERROR!

!testRun: #TestDePerforación #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'LK 9/24/2023 23:28:39'!
ERROR!

!testRun: #TestDePerforación #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'LK 9/24/2023 23:28:39'!
ERROR!

!testRun: #TestDePerforación #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'LK 9/24/2023 23:28:39'!
ERROR!

!testRun: #TestDePerforación #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'LK 9/24/2023 23:28:39'!
ERROR!

!testRun: #TestDePerforación #test12NoPuedePerforarSinMecha stamp: 'LK 9/24/2023 23:28:39'!
ERROR!

!testRun: #TestDePerforación #test13PuedeCalcularProfundidadDelSuelo stamp: 'LK 9/24/2023 23:28:39'!
ERROR!

!testRun: #TestDePerforación #test14PuedeContarLasCapasDeTipoArenoso stamp: 'LK 9/24/2023 23:28:39'!
ERROR!

!testRun: #TestDePerforación #test15PuedeContarLasCapasDeTipoTierra stamp: 'LK 9/24/2023 23:28:39'!
ERROR!

!testRun: #TestDePerforación #test16PuedeContarLasCapasDeTipoConcreto stamp: 'LK 9/24/2023 23:28:39'!
ERROR!

!testRun: #TestDePerforación #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'LK 9/24/2023 23:28:39'!
ERROR!

!testRun: #TestDePerforación #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'LK 9/24/2023 23:28:39'!
ERROR!

!testRun: #TestDePerforación #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'LK 9/24/2023 23:28:39'!
ERROR!

DoIt

!
!CapaDeSuelo class methodsFor: 'instance creation' stamp: 'LK 9/24/2023 23:31:03' prior: 50661776!
arenoso

	^Arenoso new initializeArenoso! !
!CapaDeSuelo class methodsFor: 'instance creation' stamp: 'LK 9/24/2023 23:31:10' prior: 50661780!
concretoConResistencia: resistencia 

	^Concreto new initializeConcretoConResistencia: resistencia ! !
!CapaDeSuelo class methodsFor: 'instance creation' stamp: 'LK 9/24/2023 23:31:14' prior: 50661786!
tierra

	^Tierra new initializeTierra! !

!testRun: #TestDePerforación #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'LK 9/24/2023 23:31:23'!
PASSED!

!testRun: #TestDePerforación #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'LK 9/24/2023 23:31:23'!
PASSED!

!testRun: #TestDePerforación #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'LK 9/24/2023 23:31:23'!
PASSED!

!testRun: #TestDePerforación #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'LK 9/24/2023 23:31:23'!
PASSED!

!testRun: #TestDePerforación #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'LK 9/24/2023 23:31:23'!
PASSED!

!testRun: #TestDePerforación #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'LK 9/24/2023 23:31:23'!
PASSED!

!testRun: #TestDePerforación #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'LK 9/24/2023 23:31:23'!
PASSED!

!testRun: #TestDePerforación #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'LK 9/24/2023 23:31:23'!
PASSED!

!testRun: #TestDePerforación #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'LK 9/24/2023 23:31:23'!
PASSED!

!testRun: #TestDePerforación #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'LK 9/24/2023 23:31:23'!
PASSED!

!testRun: #TestDePerforación #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'LK 9/24/2023 23:31:23'!
PASSED!

!testRun: #TestDePerforación #test12NoPuedePerforarSinMecha stamp: 'LK 9/24/2023 23:31:23'!
FAILURE!

!testRun: #TestDePerforación #test13PuedeCalcularProfundidadDelSuelo stamp: 'LK 9/24/2023 23:31:23'!
PASSED!

!testRun: #TestDePerforación #test14PuedeContarLasCapasDeTipoArenoso stamp: 'LK 9/24/2023 23:31:23'!
PASSED!

!testRun: #TestDePerforación #test15PuedeContarLasCapasDeTipoTierra stamp: 'LK 9/24/2023 23:31:23'!
PASSED!

!testRun: #TestDePerforación #test16PuedeContarLasCapasDeTipoConcreto stamp: 'LK 9/24/2023 23:31:23'!
PASSED!

!testRun: #TestDePerforación #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'LK 9/24/2023 23:31:23'!
PASSED!

!testRun: #TestDePerforación #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'LK 9/24/2023 23:31:23'!
PASSED!

!testRun: #TestDePerforación #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'LK 9/24/2023 23:31:23'!
PASSED!

!testRun: #TestDePerforación #test12NoPuedePerforarSinMecha stamp: 'LK 9/24/2023 23:31:23'!
FAILURE!

!testRun: #TestDePerforación #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'LK 9/24/2023 23:31:36'!
PASSED!

!testRun: #TestDePerforación #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'LK 9/24/2023 23:31:38'!
PASSED!

!testRun: #TestDePerforación #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'LK 9/24/2023 23:31:39'!
PASSED!

!testRun: #TestDePerforación #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'LK 9/24/2023 23:31:41'!
PASSED!

!testRun: #TestDePerforación #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'LK 9/24/2023 23:31:42'!
PASSED!

!testRun: #TestDePerforación #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'LK 9/24/2023 23:31:44'!
PASSED!

!testRun: #TestDePerforación #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'LK 9/24/2023 23:31:47'!
PASSED!

!testRun: #TestDePerforación #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'LK 9/24/2023 23:31:47'!
PASSED!

!testRun: #TestDePerforación #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'LK 9/24/2023 23:31:47'!
PASSED!

!testRun: #TestDePerforación #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'LK 9/24/2023 23:31:47'!
PASSED!

!testRun: #TestDePerforación #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'LK 9/24/2023 23:31:47'!
PASSED!

!testRun: #TestDePerforación #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'LK 9/24/2023 23:31:47'!
PASSED!

!testRun: #TestDePerforación #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'LK 9/24/2023 23:31:47'!
PASSED!

!testRun: #TestDePerforación #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'LK 9/24/2023 23:31:47'!
PASSED!

!testRun: #TestDePerforación #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'LK 9/24/2023 23:31:47'!
PASSED!

!testRun: #TestDePerforación #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'LK 9/24/2023 23:31:47'!
PASSED!

!testRun: #TestDePerforación #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'LK 9/24/2023 23:31:47'!
PASSED!

!testRun: #TestDePerforación #test12NoPuedePerforarSinMecha stamp: 'LK 9/24/2023 23:31:47'!
FAILURE!

!testRun: #TestDePerforación #test13PuedeCalcularProfundidadDelSuelo stamp: 'LK 9/24/2023 23:31:47'!
PASSED!

!testRun: #TestDePerforación #test14PuedeContarLasCapasDeTipoArenoso stamp: 'LK 9/24/2023 23:31:47'!
PASSED!

!testRun: #TestDePerforación #test15PuedeContarLasCapasDeTipoTierra stamp: 'LK 9/24/2023 23:31:47'!
PASSED!

!testRun: #TestDePerforación #test16PuedeContarLasCapasDeTipoConcreto stamp: 'LK 9/24/2023 23:31:47'!
PASSED!

!testRun: #TestDePerforación #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'LK 9/24/2023 23:31:47'!
PASSED!

!testRun: #TestDePerforación #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'LK 9/24/2023 23:31:47'!
PASSED!

!testRun: #TestDePerforación #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'LK 9/24/2023 23:31:47'!
PASSED!

!testRun: #TestDePerforación #test12NoPuedePerforarSinMecha stamp: 'LK 9/24/2023 23:31:47'!
FAILURE!

!testRun: #TestDePerforación #test13PuedeCalcularProfundidadDelSuelo stamp: 'LK 9/24/2023 23:31:52'!
PASSED!

!testRun: #TestDePerforación #test14PuedeContarLasCapasDeTipoArenoso stamp: 'LK 9/24/2023 23:31:53'!
PASSED!

!testRun: #TestDePerforación #test15PuedeContarLasCapasDeTipoTierra stamp: 'LK 9/24/2023 23:31:54'!
PASSED!

!testRun: #TestDePerforación #test16PuedeContarLasCapasDeTipoConcreto stamp: 'LK 9/24/2023 23:31:56'!
PASSED!
!Perforadora methodsFor: 'scan' stamp: 'LK 9/24/2023 23:33:49' prior: 50664985!
calcularProfundidadDelSuelo
	
	| acc altura |

	acc := 0.
	
	capasDeSueloDebajo do: [:capaActual | 	altura := capaActual altura.
									altura = nil ifTrue: [ altura := 0 ]. 
									acc := acc + altura.].

	
	 ! !
!Perforadora methodsFor: 'scan' stamp: 'LK 9/24/2023 23:33:56' prior: 50665479!
calcularProfundidadDelSueloHasta: tipoDeCapa
	
	| valor acc altura |
	
	valor := 0.
	tipoDeCapa = #Arenoso ifTrue: [ valor := 7 ].
	tipoDeCapa = #Tierra ifTrue: [ valor := 10 ].
	tipoDeCapa = #Concreto ifTrue: [ valor := 50].	
	
	acc := 0.
	capasDeSueloDebajo do: [ :capaActual | valor = capaActual scan ifTrue: [ ^ acc ].
							altura := capaActual altura.
							altura = nil ifTrue: [ altura := 0 ].
							acc := acc + altura.].
! !
!Perforadora methodsFor: 'scan' stamp: 'LK 9/24/2023 23:34:32' prior: 50666467!
calcularProfundidadDelSueloHasta: tipoDeCapa
	
	| valor acc altura |
	
	valor := 3.
	tipoDeCapa = #Arenoso ifTrue: [ valor := 7 ].
	tipoDeCapa = #Tierra ifTrue: [ valor := 10 ].
	tipoDeCapa = #Concreto ifTrue: [ valor := 50].	
	
	acc := 0.
	capasDeSueloDebajo do: [ :capaActual | valor = capaActual scan ifTrue: [ ^ acc ].
							altura := capaActual altura.
							altura = nil ifTrue: [ altura := 0 ].
							acc := acc + altura.].
! !

!testRun: #TestDePerforación #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'LK 9/24/2023 23:34:37'!
PASSED!

!testRun: #TestDePerforación #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'LK 9/24/2023 23:34:37'!
PASSED!

!testRun: #TestDePerforación #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'LK 9/24/2023 23:34:37'!
PASSED!

!testRun: #TestDePerforación #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'LK 9/24/2023 23:34:37'!
PASSED!

!testRun: #TestDePerforación #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'LK 9/24/2023 23:34:37'!
PASSED!

!testRun: #TestDePerforación #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'LK 9/24/2023 23:34:37'!
PASSED!

!testRun: #TestDePerforación #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'LK 9/24/2023 23:34:37'!
PASSED!

!testRun: #TestDePerforación #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'LK 9/24/2023 23:34:37'!
PASSED!

!testRun: #TestDePerforación #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'LK 9/24/2023 23:34:37'!
PASSED!

!testRun: #TestDePerforación #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'LK 9/24/2023 23:34:37'!
PASSED!

!testRun: #TestDePerforación #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'LK 9/24/2023 23:34:37'!
PASSED!

!testRun: #TestDePerforación #test12NoPuedePerforarSinMecha stamp: 'LK 9/24/2023 23:34:37'!
FAILURE!

!testRun: #TestDePerforación #test13PuedeCalcularProfundidadDelSuelo stamp: 'LK 9/24/2023 23:34:37'!
FAILURE!

!testRun: #TestDePerforación #test14PuedeContarLasCapasDeTipoArenoso stamp: 'LK 9/24/2023 23:34:37'!
PASSED!

!testRun: #TestDePerforación #test15PuedeContarLasCapasDeTipoTierra stamp: 'LK 9/24/2023 23:34:37'!
PASSED!

!testRun: #TestDePerforación #test16PuedeContarLasCapasDeTipoConcreto stamp: 'LK 9/24/2023 23:34:37'!
PASSED!

!testRun: #TestDePerforación #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'LK 9/24/2023 23:34:37'!
PASSED!

!testRun: #TestDePerforación #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'LK 9/24/2023 23:34:37'!
PASSED!

!testRun: #TestDePerforación #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'LK 9/24/2023 23:34:37'!
PASSED!
!Perforadora methodsFor: 'scan' stamp: 'LK 9/24/2023 23:35:40' prior: 50666484!
calcularProfundidadDelSueloHasta: tipoDeCapa
	
	| valor acc altura |
	

	valor := tipoDeCapa scan.
	"tipoDeCapa = #Arenoso ifTrue: [ valor := 7 ].
	tipoDeCapa = #Tierra ifTrue: [ valor := 10 ].
	tipoDeCapa = #Concreto ifTrue: [ valor := 50].	"
	
	acc := 0.
	capasDeSueloDebajo do: [ :capaActual | valor = capaActual scan ifTrue: [ ^ acc ].
							altura := capaActual altura.
							altura = nil ifTrue: [ altura := 0 ].
							acc := acc + altura.].
! !

!testRun: #TestDePerforación #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'LK 9/24/2023 23:35:46'!
PASSED!

!testRun: #TestDePerforación #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'LK 9/24/2023 23:35:46'!
PASSED!

!testRun: #TestDePerforación #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'LK 9/24/2023 23:35:46'!
PASSED!

!testRun: #TestDePerforación #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'LK 9/24/2023 23:35:46'!
PASSED!

!testRun: #TestDePerforación #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'LK 9/24/2023 23:35:46'!
PASSED!

!testRun: #TestDePerforación #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'LK 9/24/2023 23:35:46'!
PASSED!

!testRun: #TestDePerforación #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'LK 9/24/2023 23:35:46'!
PASSED!

!testRun: #TestDePerforación #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'LK 9/24/2023 23:35:46'!
PASSED!

!testRun: #TestDePerforación #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'LK 9/24/2023 23:35:46'!
PASSED!

!testRun: #TestDePerforación #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'LK 9/24/2023 23:35:46'!
PASSED!

!testRun: #TestDePerforación #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'LK 9/24/2023 23:35:46'!
PASSED!

!testRun: #TestDePerforación #test12NoPuedePerforarSinMecha stamp: 'LK 9/24/2023 23:35:46'!
FAILURE!

!testRun: #TestDePerforación #test13PuedeCalcularProfundidadDelSuelo stamp: 'LK 9/24/2023 23:35:46'!
FAILURE!

!testRun: #TestDePerforación #test14PuedeContarLasCapasDeTipoArenoso stamp: 'LK 9/24/2023 23:35:46'!
PASSED!

!testRun: #TestDePerforación #test15PuedeContarLasCapasDeTipoTierra stamp: 'LK 9/24/2023 23:35:46'!
PASSED!

!testRun: #TestDePerforación #test16PuedeContarLasCapasDeTipoConcreto stamp: 'LK 9/24/2023 23:35:46'!
PASSED!

!testRun: #TestDePerforación #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'LK 9/24/2023 23:35:46'!
ERROR!

!testRun: #TestDePerforación #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'LK 9/24/2023 23:35:46'!
ERROR!

!testRun: #TestDePerforación #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'LK 9/24/2023 23:35:46'!
ERROR!
!Perforadora methodsFor: 'scan' stamp: 'LK 9/24/2023 23:36:17' prior: 50666576!
calcularProfundidadDelSueloHasta: tipoDeCapa
	
	| valor acc altura |
	

	valor := 0.
	tipoDeCapa = #Arenoso ifTrue: [ valor := 7 ].
	tipoDeCapa = #Tierra ifTrue: [ valor := 10 ].
	tipoDeCapa = #Concreto ifTrue: [ valor := 50].	
	
	acc := 0.
	capasDeSueloDebajo do: [ :capaActual | valor = capaActual scan ifTrue: [ ^ acc ].
							altura := capaActual altura.
							altura = nil ifTrue: [ altura := 0 ].
							acc := acc + altura.].
! !

!testRun: #TestDePerforación #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'LK 9/24/2023 23:36:20'!
PASSED!

!testRun: #TestDePerforación #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'LK 9/24/2023 23:36:21'!
PASSED!

!testRun: #TestDePerforación #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'LK 9/24/2023 23:36:21'!
PASSED!

!testRun: #TestDePerforación #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'LK 9/24/2023 23:36:21'!
PASSED!

!testRun: #TestDePerforación #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'LK 9/24/2023 23:36:21'!
PASSED!

!testRun: #TestDePerforación #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'LK 9/24/2023 23:36:21'!
PASSED!

!testRun: #TestDePerforación #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'LK 9/24/2023 23:36:21'!
PASSED!

!testRun: #TestDePerforación #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'LK 9/24/2023 23:36:21'!
PASSED!

!testRun: #TestDePerforación #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'LK 9/24/2023 23:36:21'!
PASSED!

!testRun: #TestDePerforación #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'LK 9/24/2023 23:36:21'!
PASSED!

!testRun: #TestDePerforación #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'LK 9/24/2023 23:36:21'!
PASSED!

!testRun: #TestDePerforación #test12NoPuedePerforarSinMecha stamp: 'LK 9/24/2023 23:36:21'!
FAILURE!

!testRun: #TestDePerforación #test13PuedeCalcularProfundidadDelSuelo stamp: 'LK 9/24/2023 23:36:21'!
FAILURE!

!testRun: #TestDePerforación #test14PuedeContarLasCapasDeTipoArenoso stamp: 'LK 9/24/2023 23:36:21'!
PASSED!

!testRun: #TestDePerforación #test15PuedeContarLasCapasDeTipoTierra stamp: 'LK 9/24/2023 23:36:21'!
PASSED!

!testRun: #TestDePerforación #test16PuedeContarLasCapasDeTipoConcreto stamp: 'LK 9/24/2023 23:36:21'!
PASSED!

!testRun: #TestDePerforación #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'LK 9/24/2023 23:36:21'!
PASSED!

!testRun: #TestDePerforación #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'LK 9/24/2023 23:36:21'!
PASSED!

!testRun: #TestDePerforación #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'LK 9/24/2023 23:36:21'!
PASSED!
!Perforadora methodsFor: 'scan' stamp: 'LK 9/24/2023 23:36:30' prior: 50666669!
calcularProfundidadDelSueloHasta: tipoDeCapa
	
	| valor acc altura |
	
	valor := 0.
	
	tipoDeCapa = #Arenoso ifTrue: [ valor := 7 ].
	tipoDeCapa = #Tierra ifTrue: [ valor := 10 ].
	tipoDeCapa = #Concreto ifTrue: [ valor := 50].	
	
	acc := 0.
	capasDeSueloDebajo do: [ :capaActual | valor = capaActual scan ifTrue: [ ^ acc ].
							altura := capaActual altura.
							altura = nil ifTrue: [ altura := 0 ].
							acc := acc + altura.].
! !

!testRun: #TestDePerforación #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'LK 9/24/2023 23:36:32'!
PASSED!

!testRun: #TestDePerforación #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'LK 9/24/2023 23:36:32'!
PASSED!

!testRun: #TestDePerforación #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'LK 9/24/2023 23:36:32'!
PASSED!

!testRun: #TestDePerforación #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'LK 9/24/2023 23:36:32'!
PASSED!

!testRun: #TestDePerforación #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'LK 9/24/2023 23:36:32'!
PASSED!

!testRun: #TestDePerforación #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'LK 9/24/2023 23:36:32'!
PASSED!

!testRun: #TestDePerforación #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'LK 9/24/2023 23:36:32'!
PASSED!

!testRun: #TestDePerforación #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'LK 9/24/2023 23:36:32'!
PASSED!

!testRun: #TestDePerforación #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'LK 9/24/2023 23:36:32'!
PASSED!

!testRun: #TestDePerforación #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'LK 9/24/2023 23:36:32'!
PASSED!

!testRun: #TestDePerforación #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'LK 9/24/2023 23:36:32'!
PASSED!

!testRun: #TestDePerforación #test12NoPuedePerforarSinMecha stamp: 'LK 9/24/2023 23:36:32'!
FAILURE!

!testRun: #TestDePerforación #test13PuedeCalcularProfundidadDelSuelo stamp: 'LK 9/24/2023 23:36:32'!
FAILURE!

!testRun: #TestDePerforación #test14PuedeContarLasCapasDeTipoArenoso stamp: 'LK 9/24/2023 23:36:32'!
PASSED!

!testRun: #TestDePerforación #test15PuedeContarLasCapasDeTipoTierra stamp: 'LK 9/24/2023 23:36:32'!
PASSED!

!testRun: #TestDePerforación #test16PuedeContarLasCapasDeTipoConcreto stamp: 'LK 9/24/2023 23:36:32'!
PASSED!

!testRun: #TestDePerforación #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'LK 9/24/2023 23:36:32'!
PASSED!

!testRun: #TestDePerforación #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'LK 9/24/2023 23:36:32'!
PASSED!

!testRun: #TestDePerforación #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'LK 9/24/2023 23:36:32'!
PASSED!
!Perforadora methodsFor: 'scan' stamp: 'LK 9/24/2023 23:33:56' prior: 50666761!
calcularProfundidadDelSueloHasta: tipoDeCapa
	
	| valor acc altura |
	
	valor := 0.
	tipoDeCapa = #Arenoso ifTrue: [ valor := 7 ].
	tipoDeCapa = #Tierra ifTrue: [ valor := 10 ].
	tipoDeCapa = #Concreto ifTrue: [ valor := 50].	
	
	acc := 0.
	capasDeSueloDebajo do: [ :capaActual | valor = capaActual scan ifTrue: [ ^ acc ].
							altura := capaActual altura.
							altura = nil ifTrue: [ altura := 0 ].
							acc := acc + altura.].
! !

!testRun: #TestDePerforación #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'LK 9/24/2023 23:37:06'!
PASSED!

!testRun: #TestDePerforación #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'LK 9/24/2023 23:37:06'!
PASSED!

!testRun: #TestDePerforación #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'LK 9/24/2023 23:37:06'!
PASSED!

!testRun: #TestDePerforación #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'LK 9/24/2023 23:37:06'!
PASSED!

!testRun: #TestDePerforación #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'LK 9/24/2023 23:37:06'!
PASSED!

!testRun: #TestDePerforación #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'LK 9/24/2023 23:37:06'!
PASSED!

!testRun: #TestDePerforación #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'LK 9/24/2023 23:37:06'!
PASSED!

!testRun: #TestDePerforación #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'LK 9/24/2023 23:37:06'!
PASSED!

!testRun: #TestDePerforación #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'LK 9/24/2023 23:37:06'!
PASSED!

!testRun: #TestDePerforación #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'LK 9/24/2023 23:37:06'!
PASSED!

!testRun: #TestDePerforación #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'LK 9/24/2023 23:37:06'!
PASSED!

!testRun: #TestDePerforación #test12NoPuedePerforarSinMecha stamp: 'LK 9/24/2023 23:37:06'!
FAILURE!

!testRun: #TestDePerforación #test13PuedeCalcularProfundidadDelSuelo stamp: 'LK 9/24/2023 23:37:06'!
FAILURE!

!testRun: #TestDePerforación #test14PuedeContarLasCapasDeTipoArenoso stamp: 'LK 9/24/2023 23:37:06'!
PASSED!

!testRun: #TestDePerforación #test15PuedeContarLasCapasDeTipoTierra stamp: 'LK 9/24/2023 23:37:07'!
PASSED!

!testRun: #TestDePerforación #test16PuedeContarLasCapasDeTipoConcreto stamp: 'LK 9/24/2023 23:37:07'!
PASSED!

!testRun: #TestDePerforación #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'LK 9/24/2023 23:37:07'!
PASSED!

!testRun: #TestDePerforación #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'LK 9/24/2023 23:37:07'!
PASSED!

!testRun: #TestDePerforación #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'LK 9/24/2023 23:37:07'!
PASSED!

!testRun: #TestDePerforación #test13PuedeCalcularProfundidadDelSuelo stamp: 'LK 9/24/2023 23:37:25'!
FAILURE!
!Perforadora methodsFor: 'scan' stamp: 'LK 9/24/2023 23:38:28' prior: 50666457!
calcularProfundidadDelSuelo
	
	| acc altura |

	acc := 0.
	
	capasDeSueloDebajo do: [:capaActual | 	altura := capaActual altura.
									altura = nil ifTrue: [ altura := 0 ]. 
									acc := acc + altura.].
								
	^acc.

	
	 ! !

!testRun: #TestDePerforación #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'LK 9/24/2023 23:38:32'!
PASSED!

!testRun: #TestDePerforación #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'LK 9/24/2023 23:38:32'!
PASSED!

!testRun: #TestDePerforación #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'LK 9/24/2023 23:38:32'!
PASSED!

!testRun: #TestDePerforación #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'LK 9/24/2023 23:38:33'!
PASSED!

!testRun: #TestDePerforación #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'LK 9/24/2023 23:38:33'!
PASSED!

!testRun: #TestDePerforación #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'LK 9/24/2023 23:38:33'!
PASSED!

!testRun: #TestDePerforación #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'LK 9/24/2023 23:38:33'!
PASSED!

!testRun: #TestDePerforación #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'LK 9/24/2023 23:38:33'!
PASSED!

!testRun: #TestDePerforación #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'LK 9/24/2023 23:38:33'!
PASSED!

!testRun: #TestDePerforación #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'LK 9/24/2023 23:38:33'!
PASSED!

!testRun: #TestDePerforación #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'LK 9/24/2023 23:38:33'!
PASSED!

!testRun: #TestDePerforación #test12NoPuedePerforarSinMecha stamp: 'LK 9/24/2023 23:38:33'!
FAILURE!

!testRun: #TestDePerforación #test13PuedeCalcularProfundidadDelSuelo stamp: 'LK 9/24/2023 23:38:33'!
PASSED!

!testRun: #TestDePerforación #test14PuedeContarLasCapasDeTipoArenoso stamp: 'LK 9/24/2023 23:38:33'!
PASSED!

!testRun: #TestDePerforación #test15PuedeContarLasCapasDeTipoTierra stamp: 'LK 9/24/2023 23:38:33'!
PASSED!

!testRun: #TestDePerforación #test16PuedeContarLasCapasDeTipoConcreto stamp: 'LK 9/24/2023 23:38:33'!
PASSED!

!testRun: #TestDePerforación #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'LK 9/24/2023 23:38:33'!
PASSED!

!testRun: #TestDePerforación #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'LK 9/24/2023 23:38:33'!
PASSED!

!testRun: #TestDePerforación #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'LK 9/24/2023 23:38:33'!
PASSED!

!testRun: #TestDePerforación #test12NoPuedePerforarSinMecha stamp: 'LK 9/24/2023 23:38:33'!
FAILURE!
!MechaSoft methodsFor: 'excavation' stamp: 'LK 9/24/2023 23:41:29' overrides: 50665790!
darGolpeDeTaladro

	vecesQueGolpeoCapaActual := vecesQueGolpeoCapaActual + 1.
	
	self sobreSueloArenoso ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Widia ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Diamante ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
		^self].
	
	self sobreSueloTierra ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 2 ifTrue: [ ^self transformarCapaEnArenoso ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ ^self pasarAProximaCapa ]].
	
	self sobreSueloConcreto ifTrue: [
		mechaPuesta = #Soft ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió'  ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 3 ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ 
			vecesQueGolpeoCapaActual even ifTrue: [ capasDeSueloDebajo first bajaUnDecimoDeResistencia].
			capasDeSueloDebajo first sinResistencia ifTrue: [ ^self transformarCapaEnArenoso].
			^vecesQueGolpeoCapaActual ]].
	
	self error: 'error'! !
!MechaWidia methodsFor: 'excavation' stamp: 'LK 9/24/2023 23:41:29' overrides: 50665790!
darGolpeDeTaladro

	vecesQueGolpeoCapaActual := vecesQueGolpeoCapaActual + 1.
	
	self sobreSueloArenoso ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Widia ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Diamante ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
		^self].
	
	self sobreSueloTierra ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 2 ifTrue: [ ^self transformarCapaEnArenoso ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ ^self pasarAProximaCapa ]].
	
	self sobreSueloConcreto ifTrue: [
		mechaPuesta = #Soft ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió'  ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 3 ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ 
			vecesQueGolpeoCapaActual even ifTrue: [ capasDeSueloDebajo first bajaUnDecimoDeResistencia].
			capasDeSueloDebajo first sinResistencia ifTrue: [ ^self transformarCapaEnArenoso].
			^vecesQueGolpeoCapaActual ]].
	
	self error: 'error'! !
!MechaDiamante methodsFor: 'excavation' stamp: 'LK 9/24/2023 23:41:29' overrides: 50665790!
darGolpeDeTaladro

	vecesQueGolpeoCapaActual := vecesQueGolpeoCapaActual + 1.
	
	self sobreSueloArenoso ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Widia ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Diamante ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
		^self].
	
	self sobreSueloTierra ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 2 ifTrue: [ ^self transformarCapaEnArenoso ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ ^self pasarAProximaCapa ]].
	
	self sobreSueloConcreto ifTrue: [
		mechaPuesta = #Soft ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió'  ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 3 ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ 
			vecesQueGolpeoCapaActual even ifTrue: [ capasDeSueloDebajo first bajaUnDecimoDeResistencia].
			capasDeSueloDebajo first sinResistencia ifTrue: [ ^self transformarCapaEnArenoso].
			^vecesQueGolpeoCapaActual ]].
	
	self error: 'error'! !
!SinMecha methodsFor: 'excavation' stamp: 'LK 9/24/2023 23:41:29' prior: 50665709 overrides: 50665790!
darGolpeDeTaladro

	vecesQueGolpeoCapaActual := vecesQueGolpeoCapaActual + 1.
	
	self sobreSueloArenoso ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Widia ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Diamante ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
		^self].
	
	self sobreSueloTierra ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 2 ifTrue: [ ^self transformarCapaEnArenoso ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ ^self pasarAProximaCapa ]].
	
	self sobreSueloConcreto ifTrue: [
		mechaPuesta = #Soft ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió'  ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 3 ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ 
			vecesQueGolpeoCapaActual even ifTrue: [ capasDeSueloDebajo first bajaUnDecimoDeResistencia].
			capasDeSueloDebajo first sinResistencia ifTrue: [ ^self transformarCapaEnArenoso].
			^vecesQueGolpeoCapaActual ]].
	
	self error: 'error'! !
!MechaRota methodsFor: 'excavation' stamp: 'LK 9/24/2023 23:41:29' overrides: 50665790!
darGolpeDeTaladro

	vecesQueGolpeoCapaActual := vecesQueGolpeoCapaActual + 1.
	
	self sobreSueloArenoso ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Widia ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Diamante ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
		^self].
	
	self sobreSueloTierra ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 2 ifTrue: [ ^self transformarCapaEnArenoso ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ ^self pasarAProximaCapa ]].
	
	self sobreSueloConcreto ifTrue: [
		mechaPuesta = #Soft ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió'  ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 3 ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ 
			vecesQueGolpeoCapaActual even ifTrue: [ capasDeSueloDebajo first bajaUnDecimoDeResistencia].
			capasDeSueloDebajo first sinResistencia ifTrue: [ ^self transformarCapaEnArenoso].
			^vecesQueGolpeoCapaActual ]].
	
	self error: 'error'! !
!Perforadora methodsFor: 'excavation' stamp: 'LK 9/24/2023 23:41:29' prior: 50665790!
darGolpeDeTaladro

	self subclassResponsibility! !
!SinMecha methodsFor: 'excavation' stamp: 'LK 9/24/2023 22:52:14' prior: 50667154 overrides: 50667230!
darGolpeDeTaladro
		
	self error: SinMecha errorSinMecha.! !
!MechaDiamante methodsFor: 'excavation' stamp: 'LK 9/24/2023 23:42:39' prior: 50667115 overrides: 50667230!
darGolpeDeTaladro

	vecesQueGolpeoCapaActual := vecesQueGolpeoCapaActual + 1.
	
	self sobreSueloArenoso ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió'.
		^self].
	
	self sobreSueloTierra ifTrue: [^self pasarAProximaCapa ].
	
	self sobreSueloConcreto ifTrue: [ 
			vecesQueGolpeoCapaActual even ifTrue: [ capasDeSueloDebajo first bajaUnDecimoDeResistencia].
			capasDeSueloDebajo first sinResistencia ifTrue: [ ^self transformarCapaEnArenoso].
			^vecesQueGolpeoCapaActual ].
	
	self error: 'error'! !
!MechaSoft methodsFor: 'excavation' stamp: 'LK 9/24/2023 23:44:20' prior: 50667038 overrides: 50667230!
darGolpeDeTaladro

	vecesQueGolpeoCapaActual := vecesQueGolpeoCapaActual + 1.
	
	self sobreSueloArenoso ifTrue: [^self pasarAProximaCapa].
	
	self sobreSueloTierra ifTrue: [^self].
	
	self sobreSueloConcreto ifTrue: [mechaPuesta := #Rota. self error: 'Se rompió'].
	
	self error: 'error'! !
!MechaWidia methodsFor: 'excavation' stamp: 'LK 9/24/2023 23:44:41' prior: 50667076 overrides: 50667230!
darGolpeDeTaladro

	vecesQueGolpeoCapaActual := vecesQueGolpeoCapaActual + 1.
	
	self sobreSueloArenoso ifTrue: [^self pasarAProximaCapa].
	
	self sobreSueloTierra ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 2 ifTrue: [ ^self transformarCapaEnArenoso ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ ^self pasarAProximaCapa ]].
	
	self sobreSueloConcreto ifTrue: [
		mechaPuesta = #Soft ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió'  ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 3 ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ 
			vecesQueGolpeoCapaActual even ifTrue: [ capasDeSueloDebajo first bajaUnDecimoDeResistencia].
			capasDeSueloDebajo first sinResistencia ifTrue: [ ^self transformarCapaEnArenoso].
			^vecesQueGolpeoCapaActual ]].
	
	self error: 'error'! !
!MechaWidia methodsFor: 'excavation' stamp: 'LK 9/24/2023 23:44:57' prior: 50667274 overrides: 50667230!
darGolpeDeTaladro

	vecesQueGolpeoCapaActual := vecesQueGolpeoCapaActual + 1.
	
	self sobreSueloArenoso ifTrue: [^self pasarAProximaCapa].
	
	self sobreSueloTierra ifTrue: [vecesQueGolpeoCapaActual = 2 ifTrue: [ ^self transformarCapaEnArenoso ].
			^self].
	
	self sobreSueloConcreto ifTrue: [
		mechaPuesta = #Soft ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió'  ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 3 ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ 
			vecesQueGolpeoCapaActual even ifTrue: [ capasDeSueloDebajo first bajaUnDecimoDeResistencia].
			capasDeSueloDebajo first sinResistencia ifTrue: [ ^self transformarCapaEnArenoso].
			^vecesQueGolpeoCapaActual ]].
	
	self error: 'error'! !
!MechaWidia methodsFor: 'excavation' stamp: 'LK 9/24/2023 23:45:17' prior: 50667307 overrides: 50667230!
darGolpeDeTaladro

	vecesQueGolpeoCapaActual := vecesQueGolpeoCapaActual + 1.
	
	self sobreSueloArenoso ifTrue: [^self pasarAProximaCapa].
	
	self sobreSueloTierra ifTrue: [vecesQueGolpeoCapaActual = 2 ifTrue: [ ^self transformarCapaEnArenoso ].
			^self].
	
	self sobreSueloConcreto ifTrue: [
			vecesQueGolpeoCapaActual = 3 ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
			^self ].
	
	self error: 'error'! !

CapaDeSuelo subclass: #Piedras
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classDefinition: #Piedras category: 'ISW1-2023-1C-Parcial-1' stamp: 'LK 9/24/2023 23:51:25'!
CapaDeSuelo subclass: #Piedras
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

Object subclass: #Mechas
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classDefinition: #Mechas category: 'ISW1-2023-1C-Parcial-1' stamp: 'LK 9/24/2023 23:51:41'!
Object subclass: #Mechas
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

Mechas subclass: #Diamante
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classDefinition: #Diamante category: 'ISW1-2023-1C-Parcial-1' stamp: 'LK 9/24/2023 23:59:58'!
Mechas subclass: #Diamante
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

Mechas subclass: #Widia
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classDefinition: #Widia category: 'ISW1-2023-1C-Parcial-1' stamp: 'LK 9/25/2023 00:00:01'!
Mechas subclass: #Widia
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

Mechas subclass: #Rota
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classDefinition: #Rota category: 'ISW1-2023-1C-Parcial-1' stamp: 'LK 9/25/2023 00:00:03'!
Mechas subclass: #Rota
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

Mechas subclass: #Soft
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classDefinition: #Soft category: 'ISW1-2023-1C-Parcial-1' stamp: 'LK 9/25/2023 00:00:16'!
Mechas subclass: #Soft
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

Mechas subclass: #SinMecha
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classDefinition: #SinMecha category: 'ISW1-2023-1C-Parcial-1' stamp: 'LK 9/25/2023 00:00:25'!
Mechas subclass: #SinMecha
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classRemoval: #MechaDiamante stamp: 'LK 9/25/2023 00:01:35'!
Perforadora subclass: #MechaDiamante
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classRemoval: #MechaRota stamp: 'LK 9/25/2023 00:01:37'!
Perforadora subclass: #MechaRota
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classRemoval: #MechaSoft stamp: 'LK 9/25/2023 00:01:39'!
Perforadora subclass: #MechaSoft
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classRemoval: #MechaWidia stamp: 'LK 9/25/2023 00:01:40'!
Perforadora subclass: #MechaWidia
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!
!Perforadora methodsFor: 'accessing' stamp: 'LK 9/25/2023 00:02:28' prior: 50661886!
sinMecha

	^mechaPuesta = SinMecha new.! !
!Perforadora methodsFor: 'accessing' stamp: 'LK 9/25/2023 00:02:45' prior: 50661878!
conMechaRota

	^mechaPuesta = Rota new.! !
!Perforadora methodsFor: 'colocar mecha' stamp: 'LK 9/25/2023 00:03:08' prior: 50661909!
ponerMechaSoft
	mechaPuesta := Soft new! !
!Perforadora methodsFor: 'colocar mecha' stamp: 'LK 9/25/2023 00:03:12' prior: 50661913!
ponerMechaWidia
	mechaPuesta := Widia new! !
!Perforadora methodsFor: 'colocar mecha' stamp: 'LK 9/25/2023 00:03:17' prior: 50661905!
ponerMechaDiamante
	mechaPuesta := Diamante new! !
!Perforadora methodsFor: 'initialization' stamp: 'LK 9/25/2023 00:03:31' prior: 50661865!
initializeSobreSuelo: capasDeSueloAExcavarInicialmente

	capasDeSueloDebajo := capasDeSueloAExcavarInicialmente.
	vecesQueGolpeoCapaActual := 0.
	container := OrderedCollection new.
	mechaPuesta := SinMecha new.! !
!Perforadora methodsFor: 'accessing' stamp: 'LK 9/25/2023 00:04:46' prior: 50667462!
conMechaRota

	^mechaPuesta class = Rota.! !
!Perforadora methodsFor: 'scan' stamp: 'LK 9/25/2023 00:06:27' prior: 50665461!
contarCapas: tipoDeCapa
	
	"Cuenta las capas de tipo tipoDeCapa. Recordar que para identificar cada capa se utiliza el valor de scan que retorna. Por ej. un capa tipo Arenoso retorna 7 al scan"
	
	| capitas valor |
	
	valor := tipoDeCapa scan.
	
	capitas := capasDeSueloDebajo count: [ :capaActual | valor = capaActual scan].
	
	 ^capitas.
! !
!Perforadora methodsFor: 'excavation' stamp: 'LK 9/25/2023 00:07:53' prior: 50667230!
darGolpeDeTaladro

	self sinMecha ifTrue: [self error: 'No puede perforar'].

	vecesQueGolpeoCapaActual := vecesQueGolpeoCapaActual + 1.

	self sobreSueloArenoso ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Widia ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Diamante ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
		^self].
	
	self sobreSueloTierra ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 2 ifTrue: [ ^self transformarCapaEnArenoso ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ ^self pasarAProximaCapa ]].
	
	self sobreSueloConcreto ifTrue: [
		mechaPuesta = #Soft ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió'  ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 3 ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ 
			vecesQueGolpeoCapaActual even ifTrue: [ capasDeSueloDebajo first bajaUnDecimoDeResistencia].
			capasDeSueloDebajo first sinResistencia ifTrue: [ ^self transformarCapaEnArenoso].
			^vecesQueGolpeoCapaActual ]].
	
	self error: 'error'! !
!Perforadora methodsFor: 'excavation' stamp: 'LK 9/25/2023 00:09:57' prior: 50667510!
darGolpeDeTaladro

	^mechaPuesta darGolpeCon: self.
	"
	self sinMecha ifTrue: [self error: 'No puede perforar'].

	vecesQueGolpeoCapaActual := vecesQueGolpeoCapaActual + 1.

	self sobreSueloArenoso ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Widia ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Diamante ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
		^self].
	
	self sobreSueloTierra ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 2 ifTrue: [ ^self transformarCapaEnArenoso ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ ^self pasarAProximaCapa ]].
	
	self sobreSueloConcreto ifTrue: [
		mechaPuesta = #Soft ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió'  ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 3 ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ 
			vecesQueGolpeoCapaActual even ifTrue: [ capasDeSueloDebajo first bajaUnDecimoDeResistencia].
			capasDeSueloDebajo first sinResistencia ifTrue: [ ^self transformarCapaEnArenoso].
			^vecesQueGolpeoCapaActual ]].
	
	self error: 'error'"! !
!SinMecha methodsFor: 'excavation' stamp: 'LK 9/25/2023 00:10:23'!
darGolpeCon: aPerforadora
		
	self error: SinMecha errorSinMecha.! !

!methodRemoval: SinMecha #darGolpeDeTaladro stamp: 'LK 9/25/2023 00:10:26'!
darGolpeDeTaladro
		
	self error: SinMecha errorSinMecha.!
!Rota methodsFor: 'no messages' stamp: 'LK 9/25/2023 00:10:52'!
darGolpeCon: aPerforadora
	^self error: 'no'.! !

Mechas subclass: #Funcional
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classDefinition: #Funcional category: 'ISW1-2023-1C-Parcial-1' stamp: 'LK 9/25/2023 00:11:48'!
Mechas subclass: #Funcional
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classRemoval: #Funcional stamp: 'LK 9/25/2023 00:12:42'!
Mechas subclass: #Funcional
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classDefinition: #Funcional category: 'ISW1-2023-1C-Parcial-1' stamp: 'LK 9/25/2023 00:12:49'!
Mechas subclass: #Funcional
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classDefinition: #Diamante category: 'ISW1-2023-1C-Parcial-1' stamp: 'LK 9/25/2023 00:12:49'!
Funcional subclass: #Diamante
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

Funcional subclass: #Rota
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classDefinition: #Rota category: 'ISW1-2023-1C-Parcial-1' stamp: 'LK 9/25/2023 00:13:19'!
Funcional subclass: #Rota
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

Mechas subclass: #Rota
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classDefinition: #Rota category: 'ISW1-2023-1C-Parcial-1' stamp: 'LK 9/25/2023 00:13:28'!
Mechas subclass: #Rota
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

Funcional subclass: #Soft
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classDefinition: #Soft category: 'ISW1-2023-1C-Parcial-1' stamp: 'LK 9/25/2023 00:13:35'!
Funcional subclass: #Soft
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

Funcional subclass: #Widia
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classDefinition: #Widia category: 'ISW1-2023-1C-Parcial-1' stamp: 'LK 9/25/2023 00:13:38'!
Funcional subclass: #Widia
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!
!Funcional methodsFor: 'nil' stamp: 'LK 9/25/2023 00:14:37'!
darGolpeCon: aPerforadora

	^aPerforadora darGolpeConMechaFuncional.! !
!Perforadora methodsFor: 'excavation' stamp: 'LK 9/25/2023 00:18:51'!
darGolpeConMechaFuncional

	vecesQueGolpeoCapaActual := vecesQueGolpeoCapaActual + 1.
	
	^(self capaDeSueloInmediata) darGolpeDesde: self con: mechaPuesta.
! !
!CapaDeSuelo methodsFor: 'comparing' stamp: 'LK 9/25/2023 00:20:48'!
darGolpeDesde: aPerforadora con: aMechaPuesta! !
!Arenoso methodsFor: 'comparing' stamp: 'LK 9/25/2023 00:20:53' overrides: 50667695!
darGolpeDesde: aPerforadora con: aMechaPuesta! !
!Tierra methodsFor: 'comparing' stamp: 'LK 9/25/2023 00:20:53' overrides: 50667695!
darGolpeDesde: aPerforadora con: aMechaPuesta! !
!Concreto methodsFor: 'comparing' stamp: 'LK 9/25/2023 00:20:53' overrides: 50667695!
darGolpeDesde: aPerforadora con: aMechaPuesta! !
!Piedras methodsFor: 'comparing' stamp: 'LK 9/25/2023 00:20:53' overrides: 50667695!
darGolpeDesde: aPerforadora con: aMechaPuesta! !
!CapaDeSuelo methodsFor: 'comparing' stamp: 'LK 9/25/2023 00:20:53' prior: 50667695!
darGolpeDesde: aPerforadora con: aMechaPuesta

	self subclassResponsibility! !
!Arenoso methodsFor: 'comparing' stamp: 'LK 9/25/2023 00:21:44' prior: 50667700 overrides: 50667720!
darGolpeDesde: aPerforadora con: aMechaPuesta
	^aMechaPuesta golpearSueloArenosoCon: aPerforadora.! !
!Concreto methodsFor: 'comparing' stamp: 'LK 9/25/2023 00:22:02' prior: 50667710 overrides: 50667720!
darGolpeDesde: aPerforadora con: aMechaPuesta
	^aMechaPuesta golpearSueloConcretoCon: aPerforadora.! !
!Tierra methodsFor: 'comparing' stamp: 'LK 9/25/2023 00:22:19' prior: 50667705 overrides: 50667720!
darGolpeDesde: aPerforadora con: aMechaPuesta
	^aMechaPuesta golpearSueloTierraCon: aPerforadora.! !
!Diamante methodsFor: 'nil' stamp: 'LK 9/25/2023 00:24:01'!
golpearSueloConcretoCon: aPerforadora
	^aPerforadora golpearSueloConcretoConMechaDiamante.
! !
!Diamante methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 00:24:14'!
golpearSueloArenosoCon: aPerforadora
	^aPerforadora golpearSueloArenosoConMechaDiamante.
! !
!Diamante methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 00:24:22'!
golpearSueloTierraCon: aPerforadora
	^aPerforadora golpearSueloTierraConMechaDiamante.
! !
!Soft methodsFor: 'nil' stamp: 'LK 9/25/2023 00:24:40'!
golpearSueloConcretoCon: aPerforadora
	^aPerforadora golpearSueloConcretoConMechaSoft.! !
!Soft methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 00:24:49'!
golpearSueloArenosoCon: aPerforadora
	^aPerforadora golpearSueloArenosoConMechaSoft.! !
!Soft methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 00:25:01'!
golpearSueloTierraCon: aPerforadora
	^aPerforadora golpearSueloTierraConMechaSoft.! !
!Widia methodsFor: 'no messages' stamp: 'LK 9/25/2023 00:25:37'!
golpearSueloTierraCon: aPerforadora
	^aPerforadora golpearSueloTierraConMechaWidia.! !
!Widia methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 00:25:45'!
golpearSueloArenosoCon: aPerforadora
	^aPerforadora golpearSueloArenosoConMechaWidia.! !
!Widia methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 00:26:00'!
golpearSueloConcretoCon: aPerforadora
	^aPerforadora golpearSueloConcretoConMechaWidia.! !
!Perforadora methodsFor: 'excavation' stamp: 'LK 9/25/2023 00:27:15'!
golpearSueloArenosoConMechaSoft
	^self pasarAProximaCapa
"
	self sobreSueloArenoso ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Widia ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Diamante ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
		^self].
	
	self sobreSueloTierra ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 2 ifTrue: [ ^self transformarCapaEnArenoso ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ ^self pasarAProximaCapa ]].
	
	self sobreSueloConcreto ifTrue: [
		mechaPuesta = #Soft ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió'  ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 3 ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ 
			vecesQueGolpeoCapaActual even ifTrue: [ capasDeSueloDebajo first bajaUnDecimoDeResistencia].
			capasDeSueloDebajo first sinResistencia ifTrue: [ ^self transformarCapaEnArenoso].
			^vecesQueGolpeoCapaActual ]].
	
	self error: 'error'"! !
!Perforadora methodsFor: 'excavation' stamp: 'LK 9/25/2023 00:27:21'!
golpearSueloArenosoConMechaWidia
	^self pasarAProximaCapa
"
	self sobreSueloArenoso ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Widia ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Diamante ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
		^self].
	
	self sobreSueloTierra ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 2 ifTrue: [ ^self transformarCapaEnArenoso ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ ^self pasarAProximaCapa ]].
	
	self sobreSueloConcreto ifTrue: [
		mechaPuesta = #Soft ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió'  ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 3 ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ 
			vecesQueGolpeoCapaActual even ifTrue: [ capasDeSueloDebajo first bajaUnDecimoDeResistencia].
			capasDeSueloDebajo first sinResistencia ifTrue: [ ^self transformarCapaEnArenoso].
			^vecesQueGolpeoCapaActual ]].
	
	self error: 'error'"! !
!Perforadora methodsFor: 'excavation' stamp: 'LK 9/25/2023 00:27:42'!
golpearSueloArenosoConMechaDiamante
	mechaPuesta := #Rota.
	 self error: 'Se rompió' 
"
	self sobreSueloArenoso ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Widia ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Diamante ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
		^self].
	
	self sobreSueloTierra ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 2 ifTrue: [ ^self transformarCapaEnArenoso ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ ^self pasarAProximaCapa ]].
	
	self sobreSueloConcreto ifTrue: [
		mechaPuesta = #Soft ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió'  ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 3 ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ 
			vecesQueGolpeoCapaActual even ifTrue: [ capasDeSueloDebajo first bajaUnDecimoDeResistencia].
			capasDeSueloDebajo first sinResistencia ifTrue: [ ^self transformarCapaEnArenoso].
			^vecesQueGolpeoCapaActual ]].
	
	self error: 'error'"! !
!Perforadora methodsFor: 'excavation' stamp: 'LK 9/25/2023 00:28:19' prior: 50667870!
golpearSueloArenosoConMechaDiamante
	self conMechaRota.
	self error: 'Se rompió'.
	^self
"
	self sobreSueloArenoso ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Widia ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Diamante ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
		^self].
	
	self sobreSueloTierra ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 2 ifTrue: [ ^self transformarCapaEnArenoso ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ ^self pasarAProximaCapa ]].
	
	self sobreSueloConcreto ifTrue: [
		mechaPuesta = #Soft ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió'  ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 3 ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ 
			vecesQueGolpeoCapaActual even ifTrue: [ capasDeSueloDebajo first bajaUnDecimoDeResistencia].
			capasDeSueloDebajo first sinResistencia ifTrue: [ ^self transformarCapaEnArenoso].
			^vecesQueGolpeoCapaActual ]].
	
	self error: 'error'"! !
!Perforadora methodsFor: 'excavation' stamp: 'LK 9/25/2023 00:28:35'!
golpearSueloTierraConMechaDiamante
	^self pasarAProximaCapa
"
	self sobreSueloArenoso ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Widia ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Diamante ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
		^self].
	
	self sobreSueloTierra ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 2 ifTrue: [ ^self transformarCapaEnArenoso ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ ^self pasarAProximaCapa ]].
	
	self sobreSueloConcreto ifTrue: [
		mechaPuesta = #Soft ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió'  ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 3 ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ 
			vecesQueGolpeoCapaActual even ifTrue: [ capasDeSueloDebajo first bajaUnDecimoDeResistencia].
			capasDeSueloDebajo first sinResistencia ifTrue: [ ^self transformarCapaEnArenoso].
			^vecesQueGolpeoCapaActual ]].
	
	self error: 'error'"! !
!Perforadora methodsFor: 'excavation' stamp: 'LK 9/25/2023 00:29:06' prior: 50667947!
golpearSueloTierraConMechaDiamante
	vecesQueGolpeoCapaActual = 2 ifTrue: [ ^self transformarCapaEnArenoso ].
	^self 
"
	self sobreSueloArenoso ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Widia ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Diamante ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
		^self].
	
	self sobreSueloTierra ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 2 ifTrue: [ ^self transformarCapaEnArenoso ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ ^self pasarAProximaCapa ]].
	
	self sobreSueloConcreto ifTrue: [
		mechaPuesta = #Soft ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió'  ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 3 ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ 
			vecesQueGolpeoCapaActual even ifTrue: [ capasDeSueloDebajo first bajaUnDecimoDeResistencia].
			capasDeSueloDebajo first sinResistencia ifTrue: [ ^self transformarCapaEnArenoso].
			^vecesQueGolpeoCapaActual ]].
	
	self error: 'error'"! !
!Perforadora methodsFor: 'excavation' stamp: 'LK 9/25/2023 00:29:26' prior: 50667985!
golpearSueloTierraConMechaDiamante
	^self pasarAProximaCapa.
"
	self sobreSueloArenoso ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Widia ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Diamante ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
		^self].
	
	self sobreSueloTierra ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 2 ifTrue: [ ^self transformarCapaEnArenoso ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ ^self pasarAProximaCapa ]].
	
	self sobreSueloConcreto ifTrue: [
		mechaPuesta = #Soft ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió'  ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 3 ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ 
			vecesQueGolpeoCapaActual even ifTrue: [ capasDeSueloDebajo first bajaUnDecimoDeResistencia].
			capasDeSueloDebajo first sinResistencia ifTrue: [ ^self transformarCapaEnArenoso].
			^vecesQueGolpeoCapaActual ]].
	
	self error: 'error'"! !
!Perforadora methodsFor: 'excavation' stamp: 'LK 9/25/2023 00:29:39'!
golpearSueloTierraConMechaWidia
	vecesQueGolpeoCapaActual = 2 ifTrue: [ ^self transformarCapaEnArenoso ].
	^self
"
	self sobreSueloArenoso ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Widia ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Diamante ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
		^self].
	
	self sobreSueloTierra ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 2 ifTrue: [ ^self transformarCapaEnArenoso ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ ^self pasarAProximaCapa ]].
	
	self sobreSueloConcreto ifTrue: [
		mechaPuesta = #Soft ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió'  ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 3 ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ 
			vecesQueGolpeoCapaActual even ifTrue: [ capasDeSueloDebajo first bajaUnDecimoDeResistencia].
			capasDeSueloDebajo first sinResistencia ifTrue: [ ^self transformarCapaEnArenoso].
			^vecesQueGolpeoCapaActual ]].
	
	self error: 'error'"! !
!Perforadora methodsFor: 'excavation' stamp: 'LK 9/25/2023 00:29:49'!
golpearSueloTierraConMechaSoft
	^self
"
	self sobreSueloArenoso ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Widia ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Diamante ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
		^self].
	
	self sobreSueloTierra ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 2 ifTrue: [ ^self transformarCapaEnArenoso ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ ^self pasarAProximaCapa ]].
	
	self sobreSueloConcreto ifTrue: [
		mechaPuesta = #Soft ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió'  ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 3 ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ 
			vecesQueGolpeoCapaActual even ifTrue: [ capasDeSueloDebajo first bajaUnDecimoDeResistencia].
			capasDeSueloDebajo first sinResistencia ifTrue: [ ^self transformarCapaEnArenoso].
			^vecesQueGolpeoCapaActual ]].
	
	self error: 'error'"! !
!Perforadora methodsFor: 'excavation' stamp: 'LK 9/25/2023 00:30:38'!
golpearSueloConcretoConMechaSoft
	self conMechaRota.
	^self error: 'Se rompió'.
"
	self sobreSueloArenoso ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Widia ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Diamante ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
		^self].
	
	self sobreSueloTierra ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 2 ifTrue: [ ^self transformarCapaEnArenoso ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ ^self pasarAProximaCapa ]].
	
	self sobreSueloConcreto ifTrue: [
		mechaPuesta = #Soft ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió'  ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 3 ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ 
			vecesQueGolpeoCapaActual even ifTrue: [ capasDeSueloDebajo first bajaUnDecimoDeResistencia].
			capasDeSueloDebajo first sinResistencia ifTrue: [ ^self transformarCapaEnArenoso].
			^vecesQueGolpeoCapaActual ]].
	
	self error: 'error'"! !
!Perforadora methodsFor: 'excavation' stamp: 'LK 9/25/2023 00:31:59'!
golpearSueloConcretoConMechaWidia
	vecesQueGolpeoCapaActual = 3 ifTrue: [self conMechaRota . ^self error: 'Se rompió'].
"
	self sobreSueloArenoso ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Widia ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Diamante ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
		^self].
	
	self sobreSueloTierra ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 2 ifTrue: [ ^self transformarCapaEnArenoso ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ ^self pasarAProximaCapa ]].
	
	self sobreSueloConcreto ifTrue: [
		mechaPuesta = #Soft ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió'  ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 3 ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ 
			vecesQueGolpeoCapaActual even ifTrue: [ capasDeSueloDebajo first bajaUnDecimoDeResistencia].
			capasDeSueloDebajo first sinResistencia ifTrue: [ ^self transformarCapaEnArenoso].
			^vecesQueGolpeoCapaActual ]].
	
	self error: 'error'"! !
!Perforadora methodsFor: 'excavation' stamp: 'LK 9/25/2023 00:33:08'!
golpearSueloConcretoConMechaDiamante
	vecesQueGolpeoCapaActual even ifTrue: [ capasDeSueloDebajo first bajaUnDecimoDeResistencia].
	capasDeSueloDebajo first sinResistencia ifTrue: [ ^self transformarCapaEnArenoso].
	^vecesQueGolpeoCapaActual
"
	self sobreSueloArenoso ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Widia ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Diamante ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
		^self].
	
	self sobreSueloTierra ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 2 ifTrue: [ ^self transformarCapaEnArenoso ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ ^self pasarAProximaCapa ]].
	
	self sobreSueloConcreto ifTrue: [
		mechaPuesta = #Soft ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió'  ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 3 ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ 
			vecesQueGolpeoCapaActual even ifTrue: [ capasDeSueloDebajo first bajaUnDecimoDeResistencia].
			capasDeSueloDebajo first sinResistencia ifTrue: [ ^self transformarCapaEnArenoso].
			^vecesQueGolpeoCapaActual ]].
	
	self error: 'error'"! !

!testRun: #TestDePerforación #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'LK 9/25/2023 00:33:40'!
PASSED!

!testRun: #TestDePerforación #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'LK 9/25/2023 00:33:40'!
PASSED!

!testRun: #TestDePerforación #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'LK 9/25/2023 00:33:40'!
FAILURE!

!testRun: #TestDePerforación #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'LK 9/25/2023 00:33:40'!
PASSED!

!testRun: #TestDePerforación #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'LK 9/25/2023 00:33:40'!
PASSED!

!testRun: #TestDePerforación #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'LK 9/25/2023 00:33:40'!
FAILURE!

!testRun: #TestDePerforación #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'LK 9/25/2023 00:33:40'!
FAILURE!

!testRun: #TestDePerforación #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'LK 9/25/2023 00:33:40'!
PASSED!

!testRun: #TestDePerforación #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'LK 9/25/2023 00:33:40'!
PASSED!

!testRun: #TestDePerforación #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'LK 9/25/2023 00:33:40'!
PASSED!

!testRun: #TestDePerforación #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'LK 9/25/2023 00:33:41'!
PASSED!

!testRun: #TestDePerforación #test12NoPuedePerforarSinMecha stamp: 'LK 9/25/2023 00:33:41'!
PASSED!

!testRun: #TestDePerforación #test13PuedeCalcularProfundidadDelSuelo stamp: 'LK 9/25/2023 00:33:41'!
PASSED!

!testRun: #TestDePerforación #test14PuedeContarLasCapasDeTipoArenoso stamp: 'LK 9/25/2023 00:33:41'!
ERROR!

!testRun: #TestDePerforación #test15PuedeContarLasCapasDeTipoTierra stamp: 'LK 9/25/2023 00:33:41'!
ERROR!

!testRun: #TestDePerforación #test16PuedeContarLasCapasDeTipoConcreto stamp: 'LK 9/25/2023 00:33:41'!
ERROR!

!testRun: #TestDePerforación #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'LK 9/25/2023 00:33:41'!
PASSED!

!testRun: #TestDePerforación #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'LK 9/25/2023 00:33:41'!
PASSED!

!testRun: #TestDePerforación #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'LK 9/25/2023 00:33:41'!
PASSED!

!testRun: #TestDePerforación #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'LK 9/25/2023 00:34:00'!
FAILURE!

!testRun: #TestDePerforación #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'LK 9/25/2023 00:34:00'!
FAILURE!
!Perforadora methodsFor: 'scan' stamp: 'LK 9/25/2023 00:34:46' prior: 50666853!
calcularProfundidadDelSueloHasta: tipoDeCapa
	
	| valor acc altura |
	
	valor := tipoDeCapa scan.
	
	acc := 0.
	capasDeSueloDebajo do: [ :capaActual | valor = capaActual scan ifTrue: [ ^ acc ].
							altura := capaActual altura.
							altura = nil ifTrue: [ altura := 0 ].
							acc := acc + altura.].
! !
!Perforadora methodsFor: 'colocar mecha' stamp: 'LK 9/25/2023 00:35:57'!
ponerMechaRota
	mechaPuesta := Rota new! !
!Perforadora methodsFor: 'excavation' stamp: 'LK 9/25/2023 00:36:35' prior: 50668176!
golpearSueloConcretoConMechaWidia
	vecesQueGolpeoCapaActual = 3 ifTrue: [self ponerMechaRota . ^self error: 'Se rompió'].
"
	self sobreSueloArenoso ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Widia ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Diamante ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
		^self].
	
	self sobreSueloTierra ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 2 ifTrue: [ ^self transformarCapaEnArenoso ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ ^self pasarAProximaCapa ]].
	
	self sobreSueloConcreto ifTrue: [
		mechaPuesta = #Soft ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió'  ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 3 ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ 
			vecesQueGolpeoCapaActual even ifTrue: [ capasDeSueloDebajo first bajaUnDecimoDeResistencia].
			capasDeSueloDebajo first sinResistencia ifTrue: [ ^self transformarCapaEnArenoso].
			^vecesQueGolpeoCapaActual ]].
	
	self error: 'error'"! !
!Perforadora methodsFor: 'excavation' stamp: 'LK 9/25/2023 00:36:41' prior: 50668138!
golpearSueloConcretoConMechaSoft
	self ponerMechaRota.
	^self error: 'Se rompió'.
"
	self sobreSueloArenoso ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Widia ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Diamante ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
		^self].
	
	self sobreSueloTierra ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 2 ifTrue: [ ^self transformarCapaEnArenoso ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ ^self pasarAProximaCapa ]].
	
	self sobreSueloConcreto ifTrue: [
		mechaPuesta = #Soft ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió'  ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 3 ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ 
			vecesQueGolpeoCapaActual even ifTrue: [ capasDeSueloDebajo first bajaUnDecimoDeResistencia].
			capasDeSueloDebajo first sinResistencia ifTrue: [ ^self transformarCapaEnArenoso].
			^vecesQueGolpeoCapaActual ]].
	
	self error: 'error'"! !
!Perforadora methodsFor: 'excavation' stamp: 'LK 9/25/2023 00:36:52' prior: 50667909!
golpearSueloArenosoConMechaDiamante
	self ponerMechaRota.
	self error: 'Se rompió'.
	^self
"
	self sobreSueloArenoso ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Widia ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Diamante ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
		^self].
	
	self sobreSueloTierra ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 2 ifTrue: [ ^self transformarCapaEnArenoso ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ ^self pasarAProximaCapa ]].
	
	self sobreSueloConcreto ifTrue: [
		mechaPuesta = #Soft ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió'  ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 3 ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ 
			vecesQueGolpeoCapaActual even ifTrue: [ capasDeSueloDebajo first bajaUnDecimoDeResistencia].
			capasDeSueloDebajo first sinResistencia ifTrue: [ ^self transformarCapaEnArenoso].
			^vecesQueGolpeoCapaActual ]].
	
	self error: 'error'"! !

!testRun: #TestDePerforación #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'LK 9/25/2023 00:36:54'!
PASSED!

!testRun: #TestDePerforación #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'LK 9/25/2023 00:36:54'!
PASSED!

!testRun: #TestDePerforación #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'LK 9/25/2023 00:36:54'!
PASSED!

!testRun: #TestDePerforación #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'LK 9/25/2023 00:36:54'!
PASSED!

!testRun: #TestDePerforación #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'LK 9/25/2023 00:36:54'!
PASSED!

!testRun: #TestDePerforación #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'LK 9/25/2023 00:36:54'!
PASSED!

!testRun: #TestDePerforación #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'LK 9/25/2023 00:36:54'!
PASSED!

!testRun: #TestDePerforación #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'LK 9/25/2023 00:36:54'!
PASSED!

!testRun: #TestDePerforación #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'LK 9/25/2023 00:36:54'!
PASSED!

!testRun: #TestDePerforación #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'LK 9/25/2023 00:36:54'!
PASSED!

!testRun: #TestDePerforación #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'LK 9/25/2023 00:36:54'!
PASSED!

!testRun: #TestDePerforación #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'LK 9/25/2023 00:36:54'!
PASSED!

!testRun: #TestDePerforación #test12NoPuedePerforarSinMecha stamp: 'LK 9/25/2023 00:36:54'!
PASSED!

!testRun: #TestDePerforación #test13PuedeCalcularProfundidadDelSuelo stamp: 'LK 9/25/2023 00:36:54'!
PASSED!

!testRun: #TestDePerforación #test14PuedeContarLasCapasDeTipoArenoso stamp: 'LK 9/25/2023 00:36:54'!
ERROR!

!testRun: #TestDePerforación #test15PuedeContarLasCapasDeTipoTierra stamp: 'LK 9/25/2023 00:36:54'!
ERROR!

!testRun: #TestDePerforación #test16PuedeContarLasCapasDeTipoConcreto stamp: 'LK 9/25/2023 00:36:54'!
ERROR!

!testRun: #TestDePerforación #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'LK 9/25/2023 00:36:54'!
ERROR!

!testRun: #TestDePerforación #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'LK 9/25/2023 00:36:54'!
ERROR!

!testRun: #TestDePerforación #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'LK 9/25/2023 00:36:54'!
ERROR!
!Tierra methodsFor: 'scan' stamp: 'LK 9/25/2023 00:37:47' prior: 50665995 overrides: 50666007!
scan
	^10.! !

!testRun: #TestDePerforación #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'LK 9/25/2023 00:37:56'!
PASSED!

!testRun: #TestDePerforación #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'LK 9/25/2023 00:37:56'!
PASSED!

!testRun: #TestDePerforación #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'LK 9/25/2023 00:37:56'!
PASSED!

!testRun: #TestDePerforación #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'LK 9/25/2023 00:37:56'!
PASSED!

!testRun: #TestDePerforación #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'LK 9/25/2023 00:37:56'!
PASSED!

!testRun: #TestDePerforación #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'LK 9/25/2023 00:37:56'!
PASSED!

!testRun: #TestDePerforación #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'LK 9/25/2023 00:37:56'!
PASSED!

!testRun: #TestDePerforación #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'LK 9/25/2023 00:37:56'!
PASSED!

!testRun: #TestDePerforación #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'LK 9/25/2023 00:37:56'!
PASSED!

!testRun: #TestDePerforación #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'LK 9/25/2023 00:37:56'!
PASSED!

!testRun: #TestDePerforación #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'LK 9/25/2023 00:37:56'!
PASSED!

!testRun: #TestDePerforación #test12NoPuedePerforarSinMecha stamp: 'LK 9/25/2023 00:37:56'!
PASSED!

!testRun: #TestDePerforación #test13PuedeCalcularProfundidadDelSuelo stamp: 'LK 9/25/2023 00:37:56'!
PASSED!

!testRun: #TestDePerforación #test14PuedeContarLasCapasDeTipoArenoso stamp: 'LK 9/25/2023 00:37:56'!
ERROR!

!testRun: #TestDePerforación #test15PuedeContarLasCapasDeTipoTierra stamp: 'LK 9/25/2023 00:37:56'!
ERROR!

!testRun: #TestDePerforación #test16PuedeContarLasCapasDeTipoConcreto stamp: 'LK 9/25/2023 00:37:56'!
ERROR!

!testRun: #TestDePerforación #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'LK 9/25/2023 00:37:56'!
ERROR!

!testRun: #TestDePerforación #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'LK 9/25/2023 00:37:56'!
ERROR!

!testRun: #TestDePerforación #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'LK 9/25/2023 00:37:56'!
ERROR!

!testRun: #TestDePerforación #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'LK 9/25/2023 00:39:19'!
PASSED!

!testRun: #TestDePerforación #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'LK 9/25/2023 00:39:19'!
PASSED!

!testRun: #TestDePerforación #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'LK 9/25/2023 00:39:19'!
PASSED!

!testRun: #TestDePerforación #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'LK 9/25/2023 00:39:19'!
PASSED!

!testRun: #TestDePerforación #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'LK 9/25/2023 00:39:19'!
PASSED!

!testRun: #TestDePerforación #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'LK 9/25/2023 00:39:19'!
PASSED!

!testRun: #TestDePerforación #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'LK 9/25/2023 00:39:19'!
PASSED!

!testRun: #TestDePerforación #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'LK 9/25/2023 00:39:19'!
PASSED!

!testRun: #TestDePerforación #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'LK 9/25/2023 00:39:19'!
PASSED!

!testRun: #TestDePerforación #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'LK 9/25/2023 00:39:19'!
PASSED!

!testRun: #TestDePerforación #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'LK 9/25/2023 00:39:19'!
PASSED!

!testRun: #TestDePerforación #test12NoPuedePerforarSinMecha stamp: 'LK 9/25/2023 00:39:19'!
PASSED!

!testRun: #TestDePerforación #test13PuedeCalcularProfundidadDelSuelo stamp: 'LK 9/25/2023 00:39:19'!
PASSED!

!testRun: #TestDePerforación #test14PuedeContarLasCapasDeTipoArenoso stamp: 'LK 9/25/2023 00:39:19'!
ERROR!

!testRun: #TestDePerforación #test15PuedeContarLasCapasDeTipoTierra stamp: 'LK 9/25/2023 00:39:19'!
ERROR!

!testRun: #TestDePerforación #test16PuedeContarLasCapasDeTipoConcreto stamp: 'LK 9/25/2023 00:39:19'!
ERROR!

!testRun: #TestDePerforación #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'LK 9/25/2023 00:39:19'!
ERROR!

!testRun: #TestDePerforación #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'LK 9/25/2023 00:39:19'!
ERROR!

!testRun: #TestDePerforación #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'LK 9/25/2023 00:39:19'!
ERROR!

!testRun: #TestDePerforación #test14PuedeContarLasCapasDeTipoArenoso stamp: 'LK 9/25/2023 00:39:27'!
ERROR!
!TestDePerforación methodsFor: 'test' stamp: 'LK 9/25/2023 00:42:08' prior: 50661602!
test14PuedeContarLasCapasDeTipoArenoso

	| excavadora sueloAExcavar |
	
	sueloAExcavar := { CapaDeSuelo arenoso setAltura: 2. CapaDeSuelo tierra setAltura: 40. CapaDeSuelo arenoso. CapaDeSuelo concretoConResistencia: 10 }.
	excavadora := Perforadora sobreSuelo: sueloAExcavar.
	
	self assert: 2 equals: (excavadora contarCapas: Arenoso).

	! !

!testRun: #TestDePerforación #test14PuedeContarLasCapasDeTipoArenoso stamp: 'LK 9/25/2023 00:42:09'!
ERROR!

!testRun: #TestDePerforación #test14PuedeContarLasCapasDeTipoArenoso stamp: 'LK 9/25/2023 00:42:09'!
ERROR!

!testRun: #TestDePerforación #test14PuedeContarLasCapasDeTipoArenoso stamp: 'LK 9/25/2023 00:44:18'!
ERROR!
!TestDePerforación methodsFor: 'test' stamp: 'LK 9/25/2023 00:44:47' prior: 50668714!
test14PuedeContarLasCapasDeTipoArenoso

	| excavadora sueloAExcavar |
	
	sueloAExcavar := { CapaDeSuelo arenoso setAltura: 2. CapaDeSuelo tierra setAltura: 40. CapaDeSuelo arenoso. CapaDeSuelo concretoConResistencia: 10 }.
	excavadora := Perforadora sobreSuelo: sueloAExcavar.
	
	self assert: 2 equals: (excavadora contarCapas: Arenoso new).

	! !

!testRun: #TestDePerforación #test14PuedeContarLasCapasDeTipoArenoso stamp: 'LK 9/25/2023 00:44:48'!
PASSED!

!testRun: #TestDePerforación #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'LK 9/25/2023 00:44:48'!
PASSED!

!testRun: #TestDePerforación #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'LK 9/25/2023 00:44:48'!
PASSED!

!testRun: #TestDePerforación #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'LK 9/25/2023 00:44:48'!
PASSED!

!testRun: #TestDePerforación #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'LK 9/25/2023 00:44:48'!
PASSED!

!testRun: #TestDePerforación #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'LK 9/25/2023 00:44:48'!
PASSED!

!testRun: #TestDePerforación #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'LK 9/25/2023 00:44:48'!
PASSED!

!testRun: #TestDePerforación #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'LK 9/25/2023 00:44:48'!
PASSED!

!testRun: #TestDePerforación #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'LK 9/25/2023 00:44:48'!
PASSED!

!testRun: #TestDePerforación #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'LK 9/25/2023 00:44:48'!
PASSED!

!testRun: #TestDePerforación #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'LK 9/25/2023 00:44:48'!
PASSED!

!testRun: #TestDePerforación #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'LK 9/25/2023 00:44:48'!
PASSED!

!testRun: #TestDePerforación #test12NoPuedePerforarSinMecha stamp: 'LK 9/25/2023 00:44:48'!
PASSED!

!testRun: #TestDePerforación #test13PuedeCalcularProfundidadDelSuelo stamp: 'LK 9/25/2023 00:44:48'!
PASSED!

!testRun: #TestDePerforación #test14PuedeContarLasCapasDeTipoArenoso stamp: 'LK 9/25/2023 00:44:48'!
PASSED!

!testRun: #TestDePerforación #test15PuedeContarLasCapasDeTipoTierra stamp: 'LK 9/25/2023 00:44:48'!
ERROR!

!testRun: #TestDePerforación #test16PuedeContarLasCapasDeTipoConcreto stamp: 'LK 9/25/2023 00:44:48'!
ERROR!

!testRun: #TestDePerforación #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'LK 9/25/2023 00:44:48'!
ERROR!

!testRun: #TestDePerforación #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'LK 9/25/2023 00:44:48'!
ERROR!

!testRun: #TestDePerforación #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'LK 9/25/2023 00:44:48'!
ERROR!
!TestDePerforación methodsFor: 'test' stamp: 'LK 9/25/2023 00:44:57' prior: 50661615!
test15PuedeContarLasCapasDeTipoTierra

	| excavadora sueloAExcavar |
	
	sueloAExcavar := { CapaDeSuelo arenoso setAltura: 2. CapaDeSuelo tierra setAltura: 40. CapaDeSuelo arenoso. CapaDeSuelo concretoConResistencia: 10 }.
	excavadora := Perforadora sobreSuelo: sueloAExcavar.
	
	self assert: 1 equals: (excavadora contarCapas: Tierra new).

	! !
!TestDePerforación methodsFor: 'test' stamp: 'LK 9/25/2023 00:45:03' prior: 50661628!
test16PuedeContarLasCapasDeTipoConcreto

	| excavadora sueloAExcavar |
	
	sueloAExcavar := { CapaDeSuelo arenoso setAltura: 2. CapaDeSuelo tierra setAltura: 40. CapaDeSuelo arenoso. CapaDeSuelo concretoConResistencia: 10 }.
	excavadora := Perforadora sobreSuelo: sueloAExcavar.
	
	self assert: 1 equals: (excavadora contarCapas: Concreto new).

	! !
!TestDePerforación methodsFor: 'test' stamp: 'LK 9/25/2023 00:45:10' prior: 50661642!
test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso

	| excavadora sueloAExcavar |
	
	sueloAExcavar := { CapaDeSuelo arenoso setAltura: 2. CapaDeSuelo tierra setAltura: 40. CapaDeSuelo arenoso. CapaDeSuelo concretoConResistencia: 10 }.
	excavadora := Perforadora sobreSuelo: sueloAExcavar.
	
	self assert: 0 equals: (excavadora calcularProfundidadDelSueloHasta: Arenoso new).

	! !
!TestDePerforación methodsFor: 'test' stamp: 'LK 9/25/2023 00:45:18' prior: 50661657!
test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra

	| excavadora sueloAExcavar |
	
	sueloAExcavar := { CapaDeSuelo arenoso setAltura: 2. CapaDeSuelo tierra setAltura: 40. CapaDeSuelo arenoso. CapaDeSuelo concretoConResistencia: 10 }.
	excavadora := Perforadora sobreSuelo: sueloAExcavar.
	
	self assert: 2 equals: (excavadora calcularProfundidadDelSueloHasta: Tierra new).

	! !
!TestDePerforación methodsFor: 'test' stamp: 'LK 9/25/2023 00:45:23' prior: 50661672!
test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto

	| excavadora sueloAExcavar |
	
	sueloAExcavar := { CapaDeSuelo arenoso setAltura: 2. CapaDeSuelo tierra setAltura: 40. CapaDeSuelo arenoso. CapaDeSuelo concretoConResistencia: 10 }.
	excavadora := Perforadora sobreSuelo: sueloAExcavar.
	
	self assert: 42 equals: (excavadora calcularProfundidadDelSueloHasta: Concreto new).

	! !

!testRun: #TestDePerforación #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'LK 9/25/2023 00:45:24'!
PASSED!

!testRun: #TestDePerforación #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'LK 9/25/2023 00:45:24'!
PASSED!

!testRun: #TestDePerforación #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'LK 9/25/2023 00:45:24'!
PASSED!

!testRun: #TestDePerforación #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'LK 9/25/2023 00:45:24'!
PASSED!

!testRun: #TestDePerforación #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'LK 9/25/2023 00:45:24'!
PASSED!

!testRun: #TestDePerforación #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'LK 9/25/2023 00:45:25'!
PASSED!

!testRun: #TestDePerforación #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'LK 9/25/2023 00:45:25'!
PASSED!

!testRun: #TestDePerforación #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'LK 9/25/2023 00:45:25'!
PASSED!

!testRun: #TestDePerforación #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'LK 9/25/2023 00:45:25'!
PASSED!

!testRun: #TestDePerforación #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'LK 9/25/2023 00:45:25'!
PASSED!

!testRun: #TestDePerforación #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'LK 9/25/2023 00:45:25'!
PASSED!

!testRun: #TestDePerforación #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'LK 9/25/2023 00:45:25'!
PASSED!

!testRun: #TestDePerforación #test12NoPuedePerforarSinMecha stamp: 'LK 9/25/2023 00:45:25'!
PASSED!

!testRun: #TestDePerforación #test13PuedeCalcularProfundidadDelSuelo stamp: 'LK 9/25/2023 00:45:25'!
PASSED!

!testRun: #TestDePerforación #test14PuedeContarLasCapasDeTipoArenoso stamp: 'LK 9/25/2023 00:45:25'!
PASSED!

!testRun: #TestDePerforación #test15PuedeContarLasCapasDeTipoTierra stamp: 'LK 9/25/2023 00:45:25'!
PASSED!

!testRun: #TestDePerforación #test16PuedeContarLasCapasDeTipoConcreto stamp: 'LK 9/25/2023 00:45:25'!
PASSED!

!testRun: #TestDePerforación #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'LK 9/25/2023 00:45:25'!
PASSED!

!testRun: #TestDePerforación #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'LK 9/25/2023 00:45:25'!
PASSED!

!testRun: #TestDePerforación #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'LK 9/25/2023 00:45:25'!
PASSED!

!methodRemoval: CapaDeSuelo #hash stamp: 'LK 9/25/2023 00:45:40'!
hash

	^tipo hash + resistencia hash!

!methodRemoval: CapaDeSuelo #tipo stamp: 'LK 9/25/2023 00:45:49'!
tipo

	self subclassResponsibility!

!methodRemoval: Arenoso #tipo stamp: 'LK 9/25/2023 00:45:58'!
tipo
	^#Arenoso!

!methodRemoval: Concreto #tipo stamp: 'LK 9/25/2023 00:46:05'!
tipo

	^#Concreto!

!methodRemoval: Tierra #tipo stamp: 'LK 9/25/2023 00:46:09'!
tipo

	^tipo!

!testRun: #TestDePerforación #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'LK 9/25/2023 00:46:13'!
ERROR!

!testRun: #TestDePerforación #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'LK 9/25/2023 00:46:13'!
ERROR!

!testRun: #TestDePerforación #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'LK 9/25/2023 00:46:13'!
PASSED!

!testRun: #TestDePerforación #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'LK 9/25/2023 00:46:13'!
ERROR!

!testRun: #TestDePerforación #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'LK 9/25/2023 00:46:13'!
ERROR!

!testRun: #TestDePerforación #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'LK 9/25/2023 00:46:13'!
PASSED!

!testRun: #TestDePerforación #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'LK 9/25/2023 00:46:13'!
PASSED!

!testRun: #TestDePerforación #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'LK 9/25/2023 00:46:13'!
ERROR!

!testRun: #TestDePerforación #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'LK 9/25/2023 00:46:13'!
ERROR!

!testRun: #TestDePerforación #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'LK 9/25/2023 00:46:13'!
PASSED!

!testRun: #TestDePerforación #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'LK 9/25/2023 00:46:13'!
PASSED!

!testRun: #TestDePerforación #test12NoPuedePerforarSinMecha stamp: 'LK 9/25/2023 00:46:13'!
ERROR!

!testRun: #TestDePerforación #test13PuedeCalcularProfundidadDelSuelo stamp: 'LK 9/25/2023 00:46:13'!
PASSED!

!testRun: #TestDePerforación #test14PuedeContarLasCapasDeTipoArenoso stamp: 'LK 9/25/2023 00:46:13'!
PASSED!

!testRun: #TestDePerforación #test15PuedeContarLasCapasDeTipoTierra stamp: 'LK 9/25/2023 00:46:13'!
PASSED!

!testRun: #TestDePerforación #test16PuedeContarLasCapasDeTipoConcreto stamp: 'LK 9/25/2023 00:46:13'!
PASSED!

!testRun: #TestDePerforación #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'LK 9/25/2023 00:46:13'!
PASSED!

!testRun: #TestDePerforación #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'LK 9/25/2023 00:46:13'!
PASSED!

!testRun: #TestDePerforación #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'LK 9/25/2023 00:46:13'!
PASSED!

!testRun: #TestDePerforación #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'LK 9/25/2023 00:46:43'!
ERROR!

!testRun: #TestDePerforación #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'LK 9/25/2023 00:46:43'!
ERROR!

!testRun: #TestDePerforación #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'LK 9/25/2023 00:46:43'!
PASSED!

!testRun: #TestDePerforación #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'LK 9/25/2023 00:46:43'!
ERROR!

!testRun: #TestDePerforación #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'LK 9/25/2023 00:46:43'!
ERROR!

!testRun: #TestDePerforación #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'LK 9/25/2023 00:46:43'!
PASSED!

!testRun: #TestDePerforación #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'LK 9/25/2023 00:46:43'!
PASSED!

!testRun: #TestDePerforación #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'LK 9/25/2023 00:46:43'!
ERROR!

!testRun: #TestDePerforación #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'LK 9/25/2023 00:46:43'!
ERROR!

!testRun: #TestDePerforación #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'LK 9/25/2023 00:46:43'!
PASSED!

!testRun: #TestDePerforación #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'LK 9/25/2023 00:46:43'!
PASSED!

!testRun: #TestDePerforación #test12NoPuedePerforarSinMecha stamp: 'LK 9/25/2023 00:46:43'!
ERROR!

!testRun: #TestDePerforación #test13PuedeCalcularProfundidadDelSuelo stamp: 'LK 9/25/2023 00:46:43'!
PASSED!

!testRun: #TestDePerforación #test14PuedeContarLasCapasDeTipoArenoso stamp: 'LK 9/25/2023 00:46:43'!
PASSED!

!testRun: #TestDePerforación #test15PuedeContarLasCapasDeTipoTierra stamp: 'LK 9/25/2023 00:46:43'!
PASSED!

!testRun: #TestDePerforación #test16PuedeContarLasCapasDeTipoConcreto stamp: 'LK 9/25/2023 00:46:43'!
PASSED!

!testRun: #TestDePerforación #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'LK 9/25/2023 00:46:43'!
PASSED!

!testRun: #TestDePerforación #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'LK 9/25/2023 00:46:43'!
PASSED!

!testRun: #TestDePerforación #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'LK 9/25/2023 00:46:43'!
PASSED!
!CapaDeSuelo methodsFor: 'scan' stamp: 'LK 9/25/2023 00:46:51'!
tipo
	self subclassResponsibility ! !
!Arenoso methodsFor: 'scan' stamp: 'LK 9/25/2023 00:47:04' overrides: 50669148!
tipo
	^#Arenoso! !
!Concreto methodsFor: 'comparing' stamp: 'LK 9/25/2023 00:47:18' overrides: 50669148!
tipo
	^#Concreto! !
!Tierra methodsFor: 'tipo' stamp: 'LK 9/25/2023 00:47:32' overrides: 50669148!
tipo
	^#Tierra! !

!testRun: #TestDePerforación #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'LK 9/25/2023 00:47:39'!
PASSED!

!testRun: #TestDePerforación #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'LK 9/25/2023 00:47:39'!
PASSED!

!testRun: #TestDePerforación #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'LK 9/25/2023 00:47:39'!
PASSED!

!testRun: #TestDePerforación #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'LK 9/25/2023 00:47:39'!
PASSED!

!testRun: #TestDePerforación #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'LK 9/25/2023 00:47:39'!
PASSED!

!testRun: #TestDePerforación #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'LK 9/25/2023 00:47:39'!
PASSED!

!testRun: #TestDePerforación #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'LK 9/25/2023 00:47:39'!
PASSED!

!testRun: #TestDePerforación #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'LK 9/25/2023 00:47:39'!
PASSED!

!testRun: #TestDePerforación #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'LK 9/25/2023 00:47:39'!
PASSED!

!testRun: #TestDePerforación #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'LK 9/25/2023 00:47:39'!
PASSED!

!testRun: #TestDePerforación #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'LK 9/25/2023 00:47:39'!
PASSED!

!testRun: #TestDePerforación #test12NoPuedePerforarSinMecha stamp: 'LK 9/25/2023 00:47:39'!
PASSED!

!testRun: #TestDePerforación #test13PuedeCalcularProfundidadDelSuelo stamp: 'LK 9/25/2023 00:47:39'!
PASSED!

!testRun: #TestDePerforación #test14PuedeContarLasCapasDeTipoArenoso stamp: 'LK 9/25/2023 00:47:39'!
PASSED!

!testRun: #TestDePerforación #test15PuedeContarLasCapasDeTipoTierra stamp: 'LK 9/25/2023 00:47:39'!
PASSED!

!testRun: #TestDePerforación #test16PuedeContarLasCapasDeTipoConcreto stamp: 'LK 9/25/2023 00:47:39'!
PASSED!

!testRun: #TestDePerforación #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'LK 9/25/2023 00:47:39'!
PASSED!

!testRun: #TestDePerforación #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'LK 9/25/2023 00:47:39'!
PASSED!

!testRun: #TestDePerforación #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'LK 9/25/2023 00:47:39'!
PASSED!
!Perforadora methodsFor: 'excavation' stamp: 'LK 9/25/2023 00:48:16' prior: 50667550!
darGolpeDeTaladro

	^mechaPuesta darGolpeCon: self.
	! !
!Perforadora methodsFor: 'excavation' stamp: 'LK 9/25/2023 00:48:27' prior: 50668438!
golpearSueloArenosoConMechaDiamante
	self ponerMechaRota.
	self error: 'Se rompió'.
	^self
! !
!Perforadora methodsFor: 'excavation' stamp: 'LK 9/25/2023 00:48:33' prior: 50667796!
golpearSueloArenosoConMechaSoft
	^self pasarAProximaCapa
! !
!Perforadora methodsFor: 'excavation' stamp: 'LK 9/25/2023 00:48:42' prior: 50667833!
golpearSueloArenosoConMechaWidia
	^self pasarAProximaCapa
! !
!Perforadora methodsFor: 'excavation' stamp: 'LK 9/25/2023 00:48:48' prior: 50668215!
golpearSueloConcretoConMechaDiamante
	vecesQueGolpeoCapaActual even ifTrue: [ capasDeSueloDebajo first bajaUnDecimoDeResistencia].
	capasDeSueloDebajo first sinResistencia ifTrue: [ ^self transformarCapaEnArenoso].
	^vecesQueGolpeoCapaActual
! !
!Perforadora methodsFor: 'excavation' stamp: 'LK 9/25/2023 00:48:57' prior: 50668399!
golpearSueloConcretoConMechaSoft
	self ponerMechaRota.
	^self error: 'Se rompió'.
! !
!Perforadora methodsFor: 'excavation' stamp: 'LK 9/25/2023 00:49:02' prior: 50668359!
golpearSueloConcretoConMechaWidia
	vecesQueGolpeoCapaActual = 3 ifTrue: [self ponerMechaRota . ^self error: 'Se rompió'].
! !
!Perforadora methodsFor: 'excavation' stamp: 'LK 9/25/2023 00:49:11' prior: 50668025!
golpearSueloTierraConMechaDiamante
	^self pasarAProximaCapa.
! !
!Perforadora methodsFor: 'excavation' stamp: 'LK 9/25/2023 00:49:17' prior: 50668101!
golpearSueloTierraConMechaSoft
	^self
! !
!Perforadora methodsFor: 'excavation' stamp: 'LK 9/25/2023 00:49:22' prior: 50668062!
golpearSueloTierraConMechaWidia
	vecesQueGolpeoCapaActual = 2 ifTrue: [ ^self transformarCapaEnArenoso ].
	^self
! !

----QUIT----(25 September 2023 00:52:57) CuisUniversity-5981.image priorSource: 10551361!

----STARTUP---- (25 September 2023 11:43:22) as C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\CuisUniversity-5981.image!


----End fileIn of C:\Users\lucas\OneDrive\Desktop\ISW1-2022-2C-1erParcial.st----!
!Map methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 11:54:43' prior: 50669849!
lastPosition
	
	^ startPosition + (steps sum: [ :pasos | pasos]).
	"
	acc := startPosition.
	ix := 1.
	
	[ix <= steps size] whileTrue: [
		acc := acc + (steps at: ix)	.
		ix := ix + 1.
	].

	^ acc"
	
	! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'LK 9/25/2023 11:54:45'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'LK 9/25/2023 11:54:45'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'LK 9/25/2023 11:54:45'!
ERROR!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'LK 9/25/2023 11:54:45'!
ERROR!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'LK 9/25/2023 11:54:45'!
ERROR!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'LK 9/25/2023 11:54:45'!
ERROR!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'LK 9/25/2023 11:54:45'!
ERROR!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'LK 9/25/2023 11:54:45'!
ERROR!
!Map methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 11:55:17' prior: 50669905!
lastPosition
	
	|acc ix|
	
	"^ startPosition + (steps sum: [ :pasos | pasos])."
	
	acc := startPosition.
	ix := 1.
	
	[ix <= steps size] whileTrue: [
		acc := acc + (steps at: ix)	.
		ix := ix + 1.
	].

	^ acc
	
	! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'LK 9/25/2023 11:55:19'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'LK 9/25/2023 11:55:19'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'LK 9/25/2023 11:55:19'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'LK 9/25/2023 11:55:19'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'LK 9/25/2023 11:55:19'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'LK 9/25/2023 11:55:19'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'LK 9/25/2023 11:55:19'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'LK 9/25/2023 11:55:19'!
PASSED!
!Map methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 11:58:59' prior: 50669940!
lastPosition
	
	|acc |
	
	acc := startPosition.
	steps do: [ :algo | acc := acc + algo]. 

	^ acc
	
	! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'LK 9/25/2023 11:59:00'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'LK 9/25/2023 11:59:00'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'LK 9/25/2023 11:59:00'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'LK 9/25/2023 11:59:00'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'LK 9/25/2023 11:59:00'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'LK 9/25/2023 11:59:01'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'LK 9/25/2023 11:59:01'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'LK 9/25/2023 11:59:01'!
PASSED!
!Island methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 12:02:35' prior: 50669753!
clearTerrainAt: aPosition

	| arbol|
	
	arbol = treesAt findFirst: [ :position | aPosition = position].
	^treesAt remove: arbol.
	"ix := 1.
	[ix <= treesAt size] whileTrue: [ | pos |
		pos := treesAt at: ix.
		(aPosition = pos) ifTrue: [ ^ treesAt removeIndex: ix ].
		
		ix := ix + 1.
	].
	
"! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'LK 9/25/2023 12:02:40'!
ERROR!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'LK 9/25/2023 12:02:40'!
ERROR!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'LK 9/25/2023 12:02:40'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'LK 9/25/2023 12:02:40'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'LK 9/25/2023 12:02:40'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'LK 9/25/2023 12:02:40'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'LK 9/25/2023 12:02:40'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'LK 9/25/2023 12:02:40'!
PASSED!
!Island methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 12:03:37' prior: 50670007!
clearTerrainAt: aPosition

	| arbol|
	
	arbol = treesAt findFirst: [ :position | aPosition = position].
	^(treesAt remove: arbol ifAbsent: []).
	
	
	"ix := 1.
	[ix <= treesAt size] whileTrue: [ | pos |
		pos := treesAt at: ix.
		(aPosition = pos) ifTrue: [ ^ treesAt removeIndex: ix ].
		
		ix := ix + 1.
	].
	
"! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'LK 9/25/2023 12:03:43'!
ERROR!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'LK 9/25/2023 12:03:43'!
ERROR!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'LK 9/25/2023 12:03:43'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'LK 9/25/2023 12:03:43'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'LK 9/25/2023 12:03:43'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'LK 9/25/2023 12:03:43'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'LK 9/25/2023 12:03:43'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'LK 9/25/2023 12:03:43'!
PASSED!
!Island methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 12:07:23' prior: 50670045!
clearTerrainAt: aPosition

	| arbol|
	
	arbol = treesAt indexOf: aPosition ifAbsent: [0].
	^treesAt removeIndex: arbol.
	
	
	"ix := 1.
	[ix <= treesAt size] whileTrue: [ | pos |
		pos := treesAt at: ix.
		(aPosition = pos) ifTrue: [ ^ treesAt removeIndex: ix ].
		
		ix := ix + 1.
	].
	
"! !
!Island methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 12:07:31' prior: 50670084!
clearTerrainAt: aPosition

	| arbol|
	
	arbol := treesAt indexOf: aPosition ifAbsent: [0].
	^treesAt removeIndex: arbol.
	
	
	"ix := 1.
	[ix <= treesAt size] whileTrue: [ | pos |
		pos := treesAt at: ix.
		(aPosition = pos) ifTrue: [ ^ treesAt removeIndex: ix ].
		
		ix := ix + 1.
	].
	
"! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'LK 9/25/2023 12:07:40'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'LK 9/25/2023 12:07:40'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'LK 9/25/2023 12:07:40'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'LK 9/25/2023 12:07:40'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'LK 9/25/2023 12:07:40'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'LK 9/25/2023 12:07:40'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'LK 9/25/2023 12:07:40'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'LK 9/25/2023 12:07:40'!
PASSED!
!Island methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 12:08:37' prior: 50670096!
clearTerrainAt: aPosition

	^treesAt remove: aPosition ifAbsent:[].

	
	
	"ix := 1.
	[ix <= treesAt size] whileTrue: [ | pos |
		pos := treesAt at: ix.
		(aPosition = pos) ifTrue: [ ^ treesAt removeIndex: ix ].
		
		ix := ix + 1.
	].
	
"! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'LK 9/25/2023 12:08:38'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'LK 9/25/2023 12:08:38'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'LK 9/25/2023 12:08:38'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'LK 9/25/2023 12:08:38'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'LK 9/25/2023 12:08:38'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'LK 9/25/2023 12:08:38'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'LK 9/25/2023 12:08:39'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'LK 9/25/2023 12:08:39'!
PASSED!
!Island methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 12:08:45' prior: 50670134!
clearTerrainAt: aPosition

	^treesAt remove: aPosition ifAbsent:[].

! !
!Island methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 12:11:01' prior: 50669777!
isEmptyAt: aPosition

	treesAt detect: [:a | a = aPosition] ifNone: [^false].
	^true.
	! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'LK 9/25/2023 12:11:03'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'LK 9/25/2023 12:11:03'!
FAILURE!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'LK 9/25/2023 12:11:03'!
FAILURE!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'LK 9/25/2023 12:11:03'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'LK 9/25/2023 12:11:03'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'LK 9/25/2023 12:11:03'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'LK 9/25/2023 12:11:03'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'LK 9/25/2023 12:11:03'!
PASSED!
!Island methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 12:11:31' prior: 50670176!
isEmptyAt: aPosition

	| x |
	 x := treesAt detect: [:a | a = aPosition] ifNone: [^false].
	^true.
	! !
!Island methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 12:12:33' prior: 50670208!
isEmptyAt: aPosition

	| x |
	 x := treesAt indexOf: aPosition ifAbsent: [^false].
	^true.
	! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'LK 9/25/2023 12:12:39'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'LK 9/25/2023 12:12:39'!
FAILURE!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'LK 9/25/2023 12:12:39'!
FAILURE!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'LK 9/25/2023 12:12:39'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'LK 9/25/2023 12:12:39'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'LK 9/25/2023 12:12:39'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'LK 9/25/2023 12:12:39'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'LK 9/25/2023 12:12:39'!
PASSED!
!Island methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 12:13:38' prior: 50670215!
isEmptyAt: aPosition

	| x |
	 x := treesAt indexOf: aPosition ifAbsent: [0].
	^(x = 0)
	! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'LK 9/25/2023 12:13:40'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'LK 9/25/2023 12:13:40'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'LK 9/25/2023 12:13:40'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'LK 9/25/2023 12:13:40'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'LK 9/25/2023 12:13:40'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'LK 9/25/2023 12:13:40'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'LK 9/25/2023 12:13:40'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'LK 9/25/2023 12:13:40'!
PASSED!
!Island methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 12:18:56' prior: 50669791!
terrainAt: aPosition


	(treesAt includes: aPosition) ifTrue: [ ^#Tree].
	
	(digsAt includes: aPosition) ifTrue: [ ^#Diggable].


	^ #Empty.
	
! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'LK 9/25/2023 12:18:57'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'LK 9/25/2023 12:18:57'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'LK 9/25/2023 12:18:57'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'LK 9/25/2023 12:18:57'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'LK 9/25/2023 12:18:57'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'LK 9/25/2023 12:18:57'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'LK 9/25/2023 12:18:57'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'LK 9/25/2023 12:18:57'!
PASSED!

Pirate subclass: #Bucanero
	instanceVariableNames: 'rank'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #Bucanero category: 'ISW1-2022-2C-1erParcial' stamp: 'LK 9/25/2023 12:44:39'!
Pirate subclass: #Bucanero
	instanceVariableNames: 'rank'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

Pirate subclass: #Corsario
	instanceVariableNames: 'rank map'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #Corsario category: 'ISW1-2022-2C-1erParcial' stamp: 'LK 9/25/2023 12:44:44'!
Pirate subclass: #Corsario
	instanceVariableNames: 'rank map'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

Pirate subclass: #Filibustero
	instanceVariableNames: 'rank'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #Filibustero category: 'ISW1-2022-2C-1erParcial' stamp: 'LK 9/25/2023 12:44:50'!
Pirate subclass: #Filibustero
	instanceVariableNames: 'rank'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

Object subclass: #PirateRank
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #PirateRank category: 'ISW1-2022-2C-1erParcial' stamp: 'LK 9/25/2023 12:45:09'!
Object subclass: #PirateRank
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

PirateRank subclass: #SimplePirate
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #SimplePirate category: 'ISW1-2022-2C-1erParcial' stamp: 'LK 9/25/2023 12:45:38'!
PirateRank subclass: #SimplePirate
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

PirateRank subclass: #Captain
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #Captain category: 'ISW1-2022-2C-1erParcial' stamp: 'LK 9/25/2023 12:45:42'!
PirateRank subclass: #Captain
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #Bucanero category: 'ISW1-2022-2C-1erParcial' stamp: 'LK 9/25/2023 12:48:08'!
Pirate subclass: #Bucanero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #Corsario category: 'ISW1-2022-2C-1erParcial' stamp: 'LK 9/25/2023 12:48:08'!
Pirate subclass: #Corsario
	instanceVariableNames: 'map'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #Filibustero category: 'ISW1-2022-2C-1erParcial' stamp: 'LK 9/25/2023 12:48:08'!
Pirate subclass: #Filibustero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #Pirate category: 'ISW1-2022-2C-1erParcial' stamp: 'LK 9/25/2023 12:48:08'!
Object subclass: #Pirate
	instanceVariableNames: 'rank'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!
!Pirate methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 12:48:08'!
aCaptainIWasMeantToBe

	rank := #Captain! !

!methodRemoval: Bucanero #aCaptainIWasMeantToBe stamp: 'LK 9/25/2023 12:48:08'!
aCaptainIWasMeantToBe

	rank := #Captain!

!methodRemoval: Corsario #aCaptainIWasMeantToBe stamp: 'LK 9/25/2023 12:48:08'!
aCaptainIWasMeantToBe

	rank := #Captain!

!methodRemoval: Filibustero #aCaptainIWasMeantToBe stamp: 'LK 9/25/2023 12:48:08'!
aCaptainIWasMeantToBe

	rank := #Captain!
!Pirate methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 12:48:21' prior: 50670414!
aCaptainIWasMeantToBe

	rank := Captain new.! !
!Bucanero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 12:48:30' prior: 50669524 overrides: 16920235!
initialize

	rank := SimplePirate new! !
!Pirate methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 12:48:56' overrides: 16920235!
initialize

	rank := #NoRank! !

!methodRemoval: Corsario #initialize stamp: 'LK 9/25/2023 12:48:56'!
initialize

	rank := #NoRank!
!Pirate methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 12:49:06' prior: 50670440 overrides: 16920235!
initialize

	rank := SimplePirate new! !

!methodRemoval: Filibustero #initialize stamp: 'LK 9/25/2023 12:49:21'!
initialize

	rank := #SimplePirate!

!methodRemoval: Bucanero #initialize stamp: 'LK 9/25/2023 12:49:54'!
initialize

	rank := SimplePirate new!

Object subclass: #Terreno
	instanceVariableNames: 'rank'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #Terreno category: 'ISW1-2022-2C-1erParcial' stamp: 'LK 9/25/2023 12:50:11'!
Object subclass: #Terreno
	instanceVariableNames: 'rank'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

Terreno subclass: #Tree
	instanceVariableNames: 'rank'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

Terreno subclass: #Tree
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #Tree category: 'ISW1-2022-2C-1erParcial' stamp: 'LK 9/25/2023 12:50:47'!
Terreno subclass: #Tree
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

Terreno subclass: #Dig
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #Dig category: 'ISW1-2022-2C-1erParcial' stamp: 'LK 9/25/2023 12:50:51'!
Terreno subclass: #Dig
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

Terreno subclass: #Empty
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #Empty category: 'ISW1-2022-2C-1erParcial' stamp: 'LK 9/25/2023 12:50:59'!
Terreno subclass: #Empty
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

Object subclass: #Terreno
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #Terreno category: 'ISW1-2022-2C-1erParcial' stamp: 'LK 9/25/2023 12:51:01'!
Object subclass: #Terreno
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!
!Corsario methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 12:53:02' prior: 50669584!
initializeWith: aMap

	rank := SimplePirate new.
	map := aMap! !
!Pirate methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 12:53:52'!
searchTreasureIn: island with: aMap

	rank = #SimplePirate ifTrue: [ self error: 'I am a simple pirate!!' ].
	rank = #Captain ifTrue: [ ^ true "Aye, Aye!! La implementación está fuera del scope del parcial." ].
	! !

!methodRemoval: Corsario #searchTreasureIn:with: stamp: 'LK 9/25/2023 12:53:52'!
searchTreasureIn: island with: aMap

	rank = #SimplePirate ifTrue: [ self error: 'I am a simple pirate!!' ].
	rank = #Captain ifTrue: [ ^ true "Aye, Aye!! La implementación está fuera del scope del parcial." ].
	!

!methodRemoval: Bucanero #searchTreasureIn:with: stamp: 'LK 9/25/2023 12:53:52'!
searchTreasureIn: island with: aMap

	rank = #SimplePirate ifTrue: [ self error: 'I am a simple pirate!!' ].
	rank = #Captain ifTrue: [ ^ true "Aye, Aye!! La implementación está fuera del scope del parcial." ].
	!

!methodRemoval: Filibustero #searchTreasureIn:with: stamp: 'LK 9/25/2023 12:53:52'!
searchTreasureIn: island with: aMap

	rank = #SimplePirate ifTrue: [ self error: 'I am a simple pirate!!' ].
	rank = #Captain ifTrue: [ ^ true "Aye, Aye!! La implementación está fuera del scope del parcial." ].
	!
!Pirate methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 12:54:33' prior: 50670526!
searchTreasureIn: island with: aMap

	rank searchTreasureIn: island with: aMap being: self.
! !
!Captain methodsFor: 'nil' stamp: 'LK 9/25/2023 12:55:11'!
searchTreasureIn: island with: aMap being: rank
	^ true "Aye, Aye!! La implementación está fuera del scope del parcial."
	! !
!SimplePirate methodsFor: 'nil' stamp: 'LK 9/25/2023 12:55:53'!
searchTreasureIn: island with: aMap being: rank
	^self error: 'I am a simple pirate!!'! !
!PirateRank methodsFor: 'nil' stamp: 'LK 9/25/2023 12:56:07'!
searchTreasureIn: island with: aMap being: rank
	self subclassResponsibility ! !
!Island methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 12:59:57' prior: 50670279!
terrainAt: aPosition


	(treesAt includes: aPosition) ifTrue: [ ^Tree new].
	
	(digsAt includes: aPosition) ifTrue: [ ^Dig new].

	^ Empty new.
	
! !
!Crew methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:02:05' prior: 50669623!
buryTreasureAt: aPosition

	| terrain |
	
	terrain := island terrainAt: aPosition.
	
	pirates do: [:pirate | pirate buryTreasureAt: aPosition in: terrain in: island].
	
	"ix := 1.
	[ix <= pirates size] whileTrue: [ | pirate |
		pirate := pirates at: ix.
		
		(pirate isKindOf: Corsario) ifTrue: [ 
			terrain = #Tree ifTrue: [].
			terrain = #Empty ifTrue: [].
			terrain = #Diggable ifTrue: [ 				pirate drawTreasureMarkAt: aPosition ].
		].
		
		(pirate isKindOf: Filibustero) ifTrue: [
			terrain = #Tree ifTrue: [].
			terrain = #Empty ifTrue: [].
			terrain = #Diggable ifTrue: [].
		].
		
		(pirate isKindOf: Bucanero) ifTrue: [
			terrain = #Tree ifTrue: [ self error: 'Arrgh!! I cannot dig this type of terrain!!' ].
			terrain = #Empty ifTrue: [ self error: 'Arrgh!! I cannot dig this type of terrain!!' ]	.
			terrain = #Diggable ifTrue: [ island receiveTreasureAt: aPosition ].
		].
		
		ix := ix + 1.
	]."
	! !
!Pirate methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:10:50'!
buryTreasureAt: aPosition in: terrain in: island! !
!Bucanero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:10:59' overrides: 50670626!
buryTreasureAt: aPosition in: terrain in: island! !
!Corsario methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:10:59' overrides: 50670626!
buryTreasureAt: aPosition in: terrain in: island! !
!Filibustero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:10:59' overrides: 50670626!
buryTreasureAt: aPosition in: terrain in: island! !
!Pirate methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:10:59' prior: 50670626!
buryTreasureAt: aPosition in: terrain in: island

	self subclassResponsibility! !
!Bucanero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:12:19' prior: 50670631 overrides: 50670646!
buryTreasureAt: aPosition in: terrain in: island
	^terrain bucanero: self BuryAt: aPosition in: island! !
!Corsario methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:12:37' prior: 50670636 overrides: 50670646!
buryTreasureAt: aPosition in: terrain in: island
	^terrain corsario: self BuryAt: aPosition in: island! !
!Filibustero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:12:48' prior: 50670641 overrides: 50670646!
buryTreasureAt: aPosition in: terrain in: island
	^terrain filibustero: self BuryAt: aPosition in: island! !
!Terreno methodsFor: 'no messages' stamp: 'LK 9/25/2023 13:13:28'!
bucanero: aPirate BuryAt: aPosition in: island! !
!Terreno methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:13:32'!
corsario: aPirate BuryAt: aPosition in: island! !
!Terreno methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:13:44'!
filibustero: aPirate BuryAt: aPosition in: island! !
!Tree methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:13:51' overrides: 50670673!
bucanero: aPirate BuryAt: aPosition in: island! !
!Dig methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:13:51' overrides: 50670673!
bucanero: aPirate BuryAt: aPosition in: island! !
!Empty methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:13:51' overrides: 50670673!
bucanero: aPirate BuryAt: aPosition in: island! !
!Terreno methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:13:51' prior: 50670673!
bucanero: aPirate BuryAt: aPosition in: island

	self subclassResponsibility! !
!Tree methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:13:55' overrides: 50670677!
corsario: aPirate BuryAt: aPosition in: island! !
!Dig methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:13:55' overrides: 50670677!
corsario: aPirate BuryAt: aPosition in: island! !
!Empty methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:13:55' overrides: 50670677!
corsario: aPirate BuryAt: aPosition in: island! !
!Terreno methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:13:55' prior: 50670677!
corsario: aPirate BuryAt: aPosition in: island

	self subclassResponsibility! !
!Tree methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:14:00' overrides: 50670681!
filibustero: aPirate BuryAt: aPosition in: island! !
!Dig methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:14:00' overrides: 50670681!
filibustero: aPirate BuryAt: aPosition in: island! !
!Empty methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:14:00' overrides: 50670681!
filibustero: aPirate BuryAt: aPosition in: island! !
!Terreno methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:14:00' prior: 50670681!
filibustero: aPirate BuryAt: aPosition in: island

	self subclassResponsibility! !
!Dig methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:14:50' prior: 50670691 overrides: 50670701!
bucanero: aPirate BuryAt: aPosition in: island
	island receiveTreasureAt: aPosition
! !
!Dig methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:15:43' prior: 50670712 overrides: 50670722!
corsario: aPirate BuryAt: aPosition in: island
	aPirate drawTreasureMarkAt: aPosition! !
!Empty methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:16:49' prior: 50670696 overrides: 50670701!
bucanero: aPirate BuryAt: aPosition in: island
	^self error: 'Arrgh!! I cannot dig this type of terrain!!'.
	! !
!Tree methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:17:03' prior: 50670686 overrides: 50670701!
bucanero: aPirate BuryAt: aPosition in: island
	^self error: 'Arrgh!! I cannot dig this type of terrain!!'.! !
!Crew methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:17:24' prior: 50670594!
buryTreasureAt: aPosition

	| terrain |
	
	terrain := island terrainAt: aPosition.
	
	pirates do: [:pirate | pirate buryTreasureAt: aPosition in: terrain in: island].
	
	! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'LK 9/25/2023 13:19:47'!
FAILURE!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'LK 9/25/2023 13:19:47'!
FAILURE!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'LK 9/25/2023 13:19:47'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'LK 9/25/2023 13:19:47'!
FAILURE!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'LK 9/25/2023 13:19:47'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'LK 9/25/2023 13:19:47'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'LK 9/25/2023 13:19:47'!
ERROR!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'LK 9/25/2023 13:19:47'!
PASSED!
!Crew methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:23:10' prior: 50669659!
moveTo: aPosition

	| acc terrain |
	
	terrain := island terrainAt: aPosition.
	
	acc := pirates inject: true into: [:canMove :pirate | canMove & (pirate canMoveTo: aPosition in: island in: terrain)].
	
	"nos movemos si todos pueden moverse"
	acc ifTrue: [ island crewAt: aPosition ].
	
	"[ix <= pirates size] whileTrue: [ | pirate |
		pirate := pirates at: ix.
		
		(pirate isKindOf: Corsario) ifTrue: [ 
			terrain = #Tree ifTrue: [ acc := acc & false ].
			terrain = #Empty ifTrue: [ 
				pirate drawDirectionTo: aPosition.
				acc := acc & true 
			].
			terrain = #Diggable ifTrue: [ acc := acc & true ].
		].
		
		(pirate isKindOf: Filibustero) ifTrue: [
			terrain = #Tree ifTrue: [ 
				island clearTerrainAt: aPosition.
				acc := acc & false
			].
			terrain = #Empty ifTrue: [ acc := acc & true ].
			terrain = #Diggable ifTrue: [ acc := acc & true ].
		].
		
		(pirate isKindOf: Bucanero) ifTrue: [
			terrain = #Tree ifTrue: [ acc := acc & false ].
			terrain = #Empty ifTrue: [ acc := acc & true ].
			terrain = #Diggable ifTrue: [ acc := acc & true ].
		].
		
		ix := ix + 1.
	].

	
	
	"! !
!Crew methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:23:25' prior: 50670811!
moveTo: aPosition

	| moving terrain |
	
	terrain := island terrainAt: aPosition.
	
	moving := pirates inject: true into: [:canMove :pirate | canMove & (pirate canMoveTo: aPosition in: island in: terrain)].
	
	"nos movemos si todos pueden moverse"
	moving ifTrue: [ island crewAt: aPosition ].
	
	"[ix <= pirates size] whileTrue: [ | pirate |
		pirate := pirates at: ix.
		
		(pirate isKindOf: Corsario) ifTrue: [ 
			terrain = #Tree ifTrue: [ acc := acc & false ].
			terrain = #Empty ifTrue: [ 
				pirate drawDirectionTo: aPosition.
				acc := acc & true 
			].
			terrain = #Diggable ifTrue: [ acc := acc & true ].
		].
		
		(pirate isKindOf: Filibustero) ifTrue: [
			terrain = #Tree ifTrue: [ 
				island clearTerrainAt: aPosition.
				acc := acc & false
			].
			terrain = #Empty ifTrue: [ acc := acc & true ].
			terrain = #Diggable ifTrue: [ acc := acc & true ].
		].
		
		(pirate isKindOf: Bucanero) ifTrue: [
			terrain = #Tree ifTrue: [ acc := acc & false ].
			terrain = #Empty ifTrue: [ acc := acc & true ].
			terrain = #Diggable ifTrue: [ acc := acc & true ].
		].
		
		ix := ix + 1.
	].

	
	
	"! !
!Pirate methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:23:50'!
canMoveTo: aPosition in: island in: terrain! !
!Bucanero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:24:11' overrides: 50670887!
canMoveTo: aPosition in: island in: terrain! !
!Corsario methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:24:11' overrides: 50670887!
canMoveTo: aPosition in: island in: terrain! !
!Filibustero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:24:12' overrides: 50670887!
canMoveTo: aPosition in: island in: terrain! !
!Pirate methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:24:12' prior: 50670887!
canMoveTo: aPosition in: island in: terrain

	self subclassResponsibility! !
!Bucanero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:24:48' prior: 50670892 overrides: 50670907!
canMoveTo: aPosition in: island in: terrain
	^terrain bucanero: self canMoveTo: aPosition in: island.! !
!Corsario methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:25:00' prior: 50670897 overrides: 50670907!
canMoveTo: aPosition in: island in: terrain
	^terrain corsario: self canMoveTo: aPosition in: island.! !
!Filibustero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:25:13' prior: 50670902 overrides: 50670907!
canMoveTo: aPosition in: island in: terrain
	^terrain filibustero: self canMoveTo: aPosition in: island.! !
!Terreno methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:25:48'!
bucanero: aPirate canMoveTo: aPosition in: island! !
!Terreno methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:25:52'!
corsario: aPirate canMoveTo: aPosition in: island! !
!Terreno methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:25:57'!
filibustero: aPirate canMoveTo: aPosition in: island! !
!Tree methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:26:07' overrides: 50670933!
bucanero: aPirate canMoveTo: aPosition in: island! !
!Dig methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:26:07' overrides: 50670933!
bucanero: aPirate canMoveTo: aPosition in: island! !
!Empty methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:26:07' overrides: 50670933!
bucanero: aPirate canMoveTo: aPosition in: island! !
!Terreno methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:26:07' prior: 50670933!
bucanero: aPirate canMoveTo: aPosition in: island

	self subclassResponsibility! !
!Tree methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:26:12' overrides: 50670937!
corsario: aPirate canMoveTo: aPosition in: island! !
!Dig methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:26:13' overrides: 50670937!
corsario: aPirate canMoveTo: aPosition in: island! !
!Empty methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:26:13' overrides: 50670937!
corsario: aPirate canMoveTo: aPosition in: island! !
!Terreno methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:26:13' prior: 50670937!
corsario: aPirate canMoveTo: aPosition in: island

	self subclassResponsibility! !
!Tree methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:26:18' overrides: 50670941!
filibustero: aPirate canMoveTo: aPosition in: island! !
!Dig methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:26:18' overrides: 50670941!
filibustero: aPirate canMoveTo: aPosition in: island! !
!Empty methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:26:18' overrides: 50670941!
filibustero: aPirate canMoveTo: aPosition in: island! !
!Terreno methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:26:18' prior: 50670941!
filibustero: aPirate canMoveTo: aPosition in: island

	self subclassResponsibility! !
!Dig methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:27:54' prior: 50670951 overrides: 50670961!
bucanero: aPirate canMoveTo: aPosition in: island
	^true! !
!Dig methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:28:13' prior: 50670972 overrides: 50670982!
corsario: aPirate canMoveTo: aPosition in: island
	^true
! !
!Dig methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:28:35' prior: 50670993 overrides: 50671003!
filibustero: aPirate canMoveTo: aPosition in: island
	^true
! !
!Empty methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:29:49' prior: 50670977 overrides: 50670982!
corsario: aPirate canMoveTo: aPosition in: island
	aPirate drawDirectionTo: aPosition.
	^true! !
!Empty methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:30:04' prior: 50670998 overrides: 50671003!
filibustero: aPirate canMoveTo: aPosition in: island
	^true! !
!Tree methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:30:21' prior: 50670946 overrides: 50670961!
bucanero: aPirate canMoveTo: aPosition in: island
	^false! !
!Tree methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:30:27' prior: 50670967 overrides: 50670982!
corsario: aPirate canMoveTo: aPosition in: island
	^false! !
!Tree methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:30:42' prior: 50670988 overrides: 50671003!
filibustero: aPirate canMoveTo: aPosition in: island
	island clearTerrainAt: aPosition.
	^false.! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'LK 9/25/2023 13:30:44'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'LK 9/25/2023 13:30:44'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'LK 9/25/2023 13:30:44'!
ERROR!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'LK 9/25/2023 13:30:45'!
ERROR!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'LK 9/25/2023 13:30:45'!
ERROR!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'LK 9/25/2023 13:30:45'!
ERROR!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'LK 9/25/2023 13:30:45'!
ERROR!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'LK 9/25/2023 13:30:45'!
ERROR!

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'LK 9/25/2023 13:35:58'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'LK 9/25/2023 13:35:58'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'LK 9/25/2023 13:35:58'!
ERROR!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'LK 9/25/2023 13:35:58'!
ERROR!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'LK 9/25/2023 13:35:58'!
ERROR!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'LK 9/25/2023 13:35:58'!
ERROR!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'LK 9/25/2023 13:35:58'!
ERROR!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'LK 9/25/2023 13:35:58'!
ERROR!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'LK 9/25/2023 13:36:03'!
ERROR!
!Tree methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:37:49' prior: 50671041 overrides: 50670961!
bucanero: aPirate canMoveTo: aPosition in: island
	^true! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'LK 9/25/2023 13:37:51'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'LK 9/25/2023 13:37:51'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'LK 9/25/2023 13:37:51'!
ERROR!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'LK 9/25/2023 13:37:51'!
ERROR!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'LK 9/25/2023 13:37:51'!
ERROR!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'LK 9/25/2023 13:37:51'!
ERROR!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'LK 9/25/2023 13:37:51'!
ERROR!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'LK 9/25/2023 13:37:51'!
ERROR!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'LK 9/25/2023 13:38:03'!
ERROR!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'LK 9/25/2023 13:46:58'!
ERROR!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'LK 9/25/2023 13:46:58'!
ERROR!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'LK 9/25/2023 13:47:57'!
ERROR!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'LK 9/25/2023 13:47:57'!
ERROR!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'LK 9/25/2023 13:48:01'!
ERROR!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'LK 9/25/2023 13:48:01'!
ERROR!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'LK 9/25/2023 13:48:04'!
ERROR!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'LK 9/25/2023 13:48:04'!
ERROR!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'LK 9/25/2023 13:48:06'!
ERROR!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'LK 9/25/2023 13:48:06'!
ERROR!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'LK 9/25/2023 13:48:08'!
ERROR!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'LK 9/25/2023 13:48:08'!
ERROR!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'LK 9/25/2023 13:48:26'!
ERROR!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'LK 9/25/2023 13:48:26'!
ERROR!
!Crew methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:49:22' prior: 50670849!
moveTo: aPosition

	| moved terrain |
	
	terrain := island terrainAt: aPosition.
	
	moved := pirates inject: true into: [ :canMove :pirate | canMove & (pirate canMoveTo: aPosition in: island in: terrain)	].

	"nos movemos si todos pueden moverse"
	moved ifTrue: [ island crewAt: aPosition ].! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'LK 9/25/2023 13:49:26'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'LK 9/25/2023 13:49:26'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'LK 9/25/2023 13:49:26'!
ERROR!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'LK 9/25/2023 13:49:26'!
ERROR!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'LK 9/25/2023 13:49:26'!
ERROR!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'LK 9/25/2023 13:49:26'!
ERROR!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'LK 9/25/2023 13:49:26'!
ERROR!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'LK 9/25/2023 13:49:26'!
ERROR!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'LK 9/25/2023 13:49:30'!
ERROR!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'LK 9/25/2023 13:49:30'!
ERROR!

----QUIT----(25 September 2023 13:50:27) CuisUniversity-5981.image priorSource: 10804756!

----STARTUP---- (25 September 2023 15:42:58) as C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\CuisUniversity-5981.image!


----End fileIn of C:\Users\lucas\OneDrive\Desktop\ISW1-2022-1C-Parcial-1.st----!

----QUIT----(25 September 2023 15:47:42) CuisUniversity-5981.image priorSource: 10866591!

----STARTUP---- (25 September 2023 17:29:49) as C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\CuisUniversity-5981.image!


----End fileIn of C:\Users\lucas\OneDrive\Desktop\ISW1-2023-2C-Parcial-1.st----!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 17:39:02'!
conDelantero: unDelantero yArquero: unArquero! !

Object subclass: #Arquero
	instanceVariableNames: 'fuerza'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classDefinition: #Arquero category: 'ISW1-2023-2C-Parcial-1' stamp: 'LK 9/25/2023 17:40:27'!
Object subclass: #Arquero
	instanceVariableNames: 'fuerza'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

Object subclass: #Delantero
	instanceVariableNames: 'fuerza'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classDefinition: #Delantero category: 'ISW1-2023-2C-Parcial-1' stamp: 'LK 9/25/2023 17:40:33'!
Object subclass: #Delantero
	instanceVariableNames: 'fuerza'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!
!Delantero methodsFor: 'nil' stamp: 'LK 9/25/2023 17:41:22'!
decideTirarAColocarSuFuerzaBaseEs: fuerzaJugador

	fuerza := fuerzaJugador.! !
!Arquero methodsFor: 'no messages' stamp: 'LK 9/25/2023 17:41:49'!
esperaPorTiroYSeAdelantaSuFuerzaBaseEs: fuerzaArquero
	fuerza := fuerzaArquero.! !
!Delantero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 17:42:14'!
fuerza
	^fuerza.! !
!Arquero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 17:42:25'!
fuerza
	^fuerza! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 17:44:19' prior: 50673348!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	self assert: (direccionTiro between: 0@0 and: 2@2).
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 17:45:51' prior: 50673483!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	(direccionTiro between: 0@0 and: 2@2) ifFalse: (self error: Penales direccionTiroFueraDeRango)
.	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 17:45:53' prior: 50673553!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	(direccionTiro between: 0@0 and: 2@2) ifFalse: (self error: Penales direccionTiroFueraDeRango).	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'LK 9/25/2023 17:45:58'!
ERROR!

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'LK 9/25/2023 17:45:58'!
ERROR!
!Pelota methodsFor: 'nil' stamp: 'LK 9/25/2023 17:46:37'!
jabulaniSudafricanaRapida! !
!Pelota methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 17:46:58' prior: 50673703!
jabulaniSudafricanaRapida! !
!Pelota methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 17:47:02' prior: 50673707!
jabulaniSudafricanaRapida
	^self.! !

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'LK 9/25/2023 17:47:05'!
ERROR!

Delantero decideTirarAColocarSuFuerzaBaseEs!

!classDefinition: #Penales category: 'ISW1-2023-2C-Parcial-1' stamp: 'LK 9/25/2023 17:51:00'!
Object subclass: #Penales
	instanceVariableNames: 'puntajeDelantero'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 17:50:59'!
puntajeDeDelantero
	^puntajeDelantero! !

!classDefinition: #Penales category: 'ISW1-2023-2C-Parcial-1' stamp: 'LK 9/25/2023 17:51:17'!
Object subclass: #Penales
	instanceVariableNames: 'puntajeDelantero puntajeArquero'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 17:51:15'!
puntajeDeArquero
	^puntajeArquero! !

Object subclass: #Pelota
	instanceVariableNames: 'tipo'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classDefinition: #Pelota category: 'ISW1-2023-2C-Parcial-1' stamp: 'LK 9/25/2023 17:51:56'!
Object subclass: #Pelota
	instanceVariableNames: 'tipo'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!
!Pelota methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 17:52:06' prior: 50673711!
jabulaniSudafricanaRapida
	
	tipo := #Jabulani.! !

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'LK 9/25/2023 17:52:11'!
ERROR!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 17:53:17'!
initializeConDelantero: unDelantero yArquero: unArquero! !

!methodRemoval: Penales #conDelantero:yArquero: stamp: 'LK 9/25/2023 17:53:21'!
conDelantero: unDelantero yArquero: unArquero!
!Pelota methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 17:53:32'!
initializeJabulaniSudafricanaRapida
	
	tipo := #Jabulani.! !

!methodRemoval: Pelota #jabulaniSudafricanaRapida stamp: 'LK 9/25/2023 17:53:35'!
jabulaniSudafricanaRapida
	
	tipo := #Jabulani.!
!Arquero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 17:54:00'!
initializeEsperaPorTiroYSeAdelantaSuFuerzaBaseEs: fuerzaArquero
	fuerza := fuerzaArquero.! !

!methodRemoval: Arquero #esperaPorTiroYSeAdelantaSuFuerzaBaseEs: stamp: 'LK 9/25/2023 17:54:03'!
esperaPorTiroYSeAdelantaSuFuerzaBaseEs: fuerzaArquero
	fuerza := fuerzaArquero.!
!Delantero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 17:54:14'!
initializeDecideTirarAColocarSuFuerzaBaseEs: fuerzaJugador

	fuerza := fuerzaJugador.! !

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'LK 9/25/2023 17:54:20'!
ERROR!
!Delantero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 17:55:57' prior: 50673466!
decideTirarAColocarSuFuerzaBaseEs: fuerzaJugador

	|delantero|
	delantero := Delantero new.
	fuerza := fuerzaJugador.
! !
!Delantero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 17:56:09' prior: 50673804!
decideTirarAColocarSuFuerzaBaseEs: fuerzaJugador

	|delantero|
	delantero := Delantero new.
	fuerza := fuerzaJugador.
	^delantero
! !

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'LK 9/25/2023 17:56:12'!
ERROR!

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'LK 9/25/2023 17:56:12'!
ERROR!

3@0 between: 0@0 and: 2@2!

-1@0 between: 0@0 and: 2@2!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 18:01:40' prior: 50673625!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	(direccionTiro between: 0@0 and: 2@2) ifFalse: (self error: Penales direccionTiroFueraDeRango).	
	
	(direccionArquero between: 0@0 and: 2@2) ifFalse: (self error: Penales direccionArqueroFueraDeRango).	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

Delantero class
	instanceVariableNames: 'fuerza'!

!classDefinition: 'Delantero class' category: 'ISW1-2023-2C-Parcial-1' stamp: 'LK 9/25/2023 18:04:28'!
Delantero class
	instanceVariableNames: 'fuerza'!

Delantero class
	instanceVariableNames: ''!

!classDefinition: 'Delantero class' category: 'ISW1-2023-2C-Parcial-1' stamp: 'LK 9/25/2023 18:04:31'!
Delantero class
	instanceVariableNames: ''!
!Delantero class methodsFor: 'nil' stamp: 'LK 9/25/2023 18:04:36'!
decideTirarAColocarSuFuerzaBaseEs: fuerzaJugador
! !

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'LK 9/25/2023 18:04:40'!
ERROR!

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'LK 9/25/2023 18:04:40'!
ERROR!
!Pelota class methodsFor: 'no messages' stamp: 'LK 9/25/2023 18:05:44'!
jabulaniSudafricanaRapida! !
!Arquero class methodsFor: 'nil' stamp: 'LK 9/25/2023 18:06:06'!
esperaPorTiroYSeAdelantaSuFuerzaBaseEs: fuerzaArquero! !
!Arquero class methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 18:06:57' prior: 50673930!
esperaPorTiroYSeAdelantaSuFuerzaBaseEs: fuerzaArquero
	^self new initializeEsperaPorTiroYSeAdelantaSuFuerzaBaseEs: fuerzaArquero.! !
!Delantero class methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 18:07:18' prior: 50673915!
decideTirarAColocarSuFuerzaBaseEs: fuerzaJugador
	^self new initializeDecideTirarAColocarSuFuerzaBaseEs: fuerzaJugador.
! !
!Pelota class methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 18:07:34' prior: 50673927!
jabulaniSudafricanaRapida
	^self new initializeJabulaniSudafricanaRapida! !
!Penales class methodsFor: 'message errors' stamp: 'LK 9/25/2023 18:08:27'!
conDelantero: unDelantero yArquero: unArquero
	^self new initializeConDelantero: unDelantero yArquero: unArquero! !

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'LK 9/25/2023 18:08:35'!
FAILURE!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 18:09:13' prior: 50673828!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	(direccionTiro between: 0@0 and: 2@2) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(direccionArquero between: 0@0 and: 2@2) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'LK 9/25/2023 18:09:14'!
FAILURE!

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'LK 9/25/2023 18:09:14'!
FAILURE!

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'LK 9/25/2023 18:09:26'!
FAILURE!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 18:10:05' prior: 50673765!
initializeConDelantero: unDelantero yArquero: unArquero
	puntajeDelantero := 0! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 18:10:20' prior: 50674053!
initializeConDelantero: unDelantero yArquero: unArquero
	puntajeDelantero := 0.
	puntajeArquero := 0.! !

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'LK 9/25/2023 18:10:24'!
PASSED!

!testRun: #PenalesTest #test02DelanteroNoPuedeApuntarHaciaAfueraDelPaloDerecho stamp: 'LK 9/25/2023 18:10:28'!
PASSED!

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'LK 9/25/2023 18:10:32'!
PASSED!

!testRun: #PenalesTest #test02DelanteroNoPuedeApuntarHaciaAfueraDelPaloDerecho stamp: 'LK 9/25/2023 18:10:32'!
PASSED!

!testRun: #PenalesTest #test03DelanteroNoPuedeApuntarHaciaAbajoDelArco stamp: 'LK 9/25/2023 18:10:32'!
PASSED!

!testRun: #PenalesTest #test04DelanteroNoPuedeApuntarHaciaArribaDelTravesaño stamp: 'LK 9/25/2023 18:10:32'!
PASSED!

!testRun: #PenalesTest #test05ArqueroNoPuedePasarseDelPaloIzquierdo stamp: 'LK 9/25/2023 18:10:32'!
PASSED!

!testRun: #PenalesTest #test06ArqueroNoPuedePasarseDelPaloDerecho stamp: 'LK 9/25/2023 18:10:32'!
PASSED!

!testRun: #PenalesTest #test07ArqueroNoPuedeMeterseAbajoDeLaTierra stamp: 'LK 9/25/2023 18:10:32'!
PASSED!

!testRun: #PenalesTest #test08ArqueroNoPuedeSaltarPorEncimaDelTravesaño stamp: 'LK 9/25/2023 18:10:32'!
PASSED!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'LK 9/25/2023 18:10:32'!
FAILURE!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'LK 9/25/2023 18:10:32'!
FAILURE!

!testRun: #PenalesTest #test11MismasDireccionesSuficienteFuerzaAtajaArquero stamp: 'LK 9/25/2023 18:10:32'!
FAILURE!

!testRun: #PenalesTest #test12DelanteroQueTiraAColocarPierde50PorcFuerza stamp: 'LK 9/25/2023 18:10:32'!
FAILURE!

!testRun: #PenalesTest #test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra stamp: 'LK 9/25/2023 18:10:32'!
ERROR!

!testRun: #PenalesTest #test14FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAColocar stamp: 'LK 9/25/2023 18:10:32'!
ERROR!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'LK 9/25/2023 18:10:32'!
FAILURE!

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'LK 9/25/2023 18:10:32'!
ERROR!

!testRun: #PenalesTest #test17ArqueroQueEligeAntesDeTiroVsPlayeraAColocarSuma100PorcFuerzaExtra stamp: 'LK 9/25/2023 18:10:33'!
ERROR!

!testRun: #PenalesTest #test18FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsPlayeraAColocar stamp: 'LK 9/25/2023 18:10:33'!
ERROR!

!testRun: #PenalesTest #test19ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAColocarEsDescubiertoYPuntoParaDelantero stamp: 'LK 9/25/2023 18:10:33'!
ERROR!

!testRun: #PenalesTest #test20DelanteroTiraAMatarAlAnguloInferiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 18:10:33'!
ERROR!

!testRun: #PenalesTest #test21DelanteroTiraAMatarAlAnguloSuperiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 18:10:33'!
ERROR!

!testRun: #PenalesTest #test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 18:10:33'!
ERROR!

!testRun: #PenalesTest #test23DelanteroTiraAMatarAlAnguloSuperiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 18:10:33'!
ERROR!

!testRun: #PenalesTest #test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro stamp: 'LK 9/25/2023 18:10:33'!
ERROR!

!testRun: #PenalesTest #test25DelanteroTiraAMatarUsa100PorcFuerzaBase stamp: 'LK 9/25/2023 18:10:33'!
ERROR!

!testRun: #PenalesTest #test26DelanteroTiraAMatarConJabulaniGana20PorcFuerzaExtra stamp: 'LK 9/25/2023 18:10:33'!
ERROR!

!testRun: #PenalesTest #test27FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAMatar stamp: 'LK 9/25/2023 18:10:33'!
ERROR!

!testRun: #PenalesTest #test28ArqueroQueEligeAntesDeTiroVsJabulaniAMatarIgnoraAlturaTiro stamp: 'LK 9/25/2023 18:10:33'!
ERROR!

!testRun: #PenalesTest #test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja stamp: 'LK 9/25/2023 18:10:33'!
ERROR!

!testRun: #PenalesTest #test30DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAdentro stamp: 'LK 9/25/2023 18:10:33'!
ERROR!

!testRun: #PenalesTest #test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera stamp: 'LK 9/25/2023 18:10:33'!
ERROR!

!testRun: #PenalesTest #test32ArqueroQueEligeAntesDeTiroVsPlayeraAMatarAlAnguloIgnoraAnchoTiro stamp: 'LK 9/25/2023 18:10:33'!
ERROR!

!testRun: #PenalesTest #test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro stamp: 'LK 9/25/2023 18:10:33'!
ERROR!

!testRun: #PenalesTest #test34ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAMatarSiempreAtaja stamp: 'LK 9/25/2023 18:10:33'!
ERROR!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 18:12:04' prior: 50673966!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	(direccionTiro between: 0@0 and: 2@2) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(direccionArquero between: 0@0 and: 2@2) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	(direccionTiro = direccionArquero) ifTrue: [puntajeArquero := puntajeArquero + 1] 
								ifFalse: [puntajeDelantero := puntajeDelantero +1].
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'LK 9/25/2023 18:12:07'!
ERROR!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 18:12:52'!
varDireccionRemateResultante
	! !

Object subclass: #Penales
	instanceVariableNames: 'puntajeDelantero puntajeArquero direccionDelantero direccionArquero'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

Object subclass: #Penales
	instanceVariableNames: 'puntajeDelantero puntajeArquero direccionDelTiroDelantero direccionDelArquero'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classDefinition: #Penales category: 'ISW1-2023-2C-Parcial-1' stamp: 'LK 9/25/2023 18:13:28'!
Object subclass: #Penales
	instanceVariableNames: 'puntajeDelantero puntajeArquero direccionDelTiroDelantero direccionDelArquero'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 18:14:42' prior: 50674209!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(direccionTiro between: 0@0 and: 2@2) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(direccionArquero between: 0@0 and: 2@2) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	(direccionTiro = direccionArquero) ifTrue: [puntajeArquero := puntajeArquero + 1] 
								ifFalse: [puntajeDelantero := puntajeDelantero +1].
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 18:14:58' prior: 50674291!
varDireccionRemateResultante
	^direccionDelTiroDelantero .! !

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'LK 9/25/2023 18:15:03'!
PASSED!

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'LK 9/25/2023 18:15:03'!
PASSED!

!testRun: #PenalesTest #test02DelanteroNoPuedeApuntarHaciaAfueraDelPaloDerecho stamp: 'LK 9/25/2023 18:15:03'!
PASSED!

!testRun: #PenalesTest #test03DelanteroNoPuedeApuntarHaciaAbajoDelArco stamp: 'LK 9/25/2023 18:15:03'!
PASSED!

!testRun: #PenalesTest #test04DelanteroNoPuedeApuntarHaciaArribaDelTravesaño stamp: 'LK 9/25/2023 18:15:04'!
PASSED!

!testRun: #PenalesTest #test05ArqueroNoPuedePasarseDelPaloIzquierdo stamp: 'LK 9/25/2023 18:15:04'!
PASSED!

!testRun: #PenalesTest #test06ArqueroNoPuedePasarseDelPaloDerecho stamp: 'LK 9/25/2023 18:15:04'!
PASSED!

!testRun: #PenalesTest #test07ArqueroNoPuedeMeterseAbajoDeLaTierra stamp: 'LK 9/25/2023 18:15:04'!
PASSED!

!testRun: #PenalesTest #test08ArqueroNoPuedeSaltarPorEncimaDelTravesaño stamp: 'LK 9/25/2023 18:15:04'!
PASSED!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'LK 9/25/2023 18:15:04'!
PASSED!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'LK 9/25/2023 18:15:04'!
FAILURE!

!testRun: #PenalesTest #test11MismasDireccionesSuficienteFuerzaAtajaArquero stamp: 'LK 9/25/2023 18:15:04'!
PASSED!

!testRun: #PenalesTest #test12DelanteroQueTiraAColocarPierde50PorcFuerza stamp: 'LK 9/25/2023 18:15:04'!
ERROR!

!testRun: #PenalesTest #test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra stamp: 'LK 9/25/2023 18:15:04'!
ERROR!

!testRun: #PenalesTest #test14FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAColocar stamp: 'LK 9/25/2023 18:15:04'!
ERROR!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'LK 9/25/2023 18:15:04'!
FAILURE!

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'LK 9/25/2023 18:15:04'!
ERROR!

!testRun: #PenalesTest #test17ArqueroQueEligeAntesDeTiroVsPlayeraAColocarSuma100PorcFuerzaExtra stamp: 'LK 9/25/2023 18:15:04'!
ERROR!

!testRun: #PenalesTest #test18FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsPlayeraAColocar stamp: 'LK 9/25/2023 18:15:04'!
ERROR!

!testRun: #PenalesTest #test19ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAColocarEsDescubiertoYPuntoParaDelantero stamp: 'LK 9/25/2023 18:15:04'!
ERROR!

!testRun: #PenalesTest #test20DelanteroTiraAMatarAlAnguloInferiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 18:15:04'!
ERROR!

!testRun: #PenalesTest #test21DelanteroTiraAMatarAlAnguloSuperiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 18:15:04'!
ERROR!

!testRun: #PenalesTest #test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 18:15:04'!
ERROR!

!testRun: #PenalesTest #test23DelanteroTiraAMatarAlAnguloSuperiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 18:15:04'!
ERROR!

!testRun: #PenalesTest #test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro stamp: 'LK 9/25/2023 18:15:04'!
ERROR!

!testRun: #PenalesTest #test25DelanteroTiraAMatarUsa100PorcFuerzaBase stamp: 'LK 9/25/2023 18:15:04'!
ERROR!

!testRun: #PenalesTest #test26DelanteroTiraAMatarConJabulaniGana20PorcFuerzaExtra stamp: 'LK 9/25/2023 18:15:04'!
ERROR!

!testRun: #PenalesTest #test27FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAMatar stamp: 'LK 9/25/2023 18:15:04'!
ERROR!

!testRun: #PenalesTest #test28ArqueroQueEligeAntesDeTiroVsJabulaniAMatarIgnoraAlturaTiro stamp: 'LK 9/25/2023 18:15:04'!
ERROR!

!testRun: #PenalesTest #test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja stamp: 'LK 9/25/2023 18:15:04'!
ERROR!

!testRun: #PenalesTest #test30DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAdentro stamp: 'LK 9/25/2023 18:15:04'!
ERROR!

!testRun: #PenalesTest #test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera stamp: 'LK 9/25/2023 18:15:04'!
ERROR!

!testRun: #PenalesTest #test32ArqueroQueEligeAntesDeTiroVsPlayeraAMatarAlAnguloIgnoraAnchoTiro stamp: 'LK 9/25/2023 18:15:04'!
ERROR!

!testRun: #PenalesTest #test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro stamp: 'LK 9/25/2023 18:15:04'!
ERROR!

!testRun: #PenalesTest #test34ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAMatarSiempreAtaja stamp: 'LK 9/25/2023 18:15:04'!
ERROR!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'LK 9/25/2023 18:15:08'!
PASSED!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'LK 9/25/2023 18:15:22'!
FAILURE!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'LK 9/25/2023 18:16:26'!
FAILURE!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 18:17:19' prior: 50674318!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(direccionTiro between: 0@0 and: 2@2) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(direccionArquero between: 0@0 and: 2@2) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	(direccionTiro = direccionArquero) ifTrue: [puntajeArquero := puntajeArquero + 1] 
								ifFalse: [puntajeDelantero := puntajeDelantero +1].
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

Object subclass: #Penales
	instanceVariableNames: 'puntajeDelantero puntajeArquero direccionDelTiroDelantero direccionDelArquero delantero arquero'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classDefinition: #Penales category: 'ISW1-2023-2C-Parcial-1' stamp: 'LK 9/25/2023 18:18:04'!
Object subclass: #Penales
	instanceVariableNames: 'puntajeDelantero puntajeArquero direccionDelTiroDelantero direccionDelArquero delantero arquero'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 18:18:24' prior: 50674059!
initializeConDelantero: unDelantero yArquero: unArquero

delantero := unDelantero .
arquero :=  unArquero.
	puntajeDelantero := 0.
	puntajeArquero := 0.! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 18:19:51' prior: 50674556!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(direccionTiro between: 0@0 and: 2@2) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(direccionArquero between: 0@0 and: 2@2) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	(direccionTiro = direccionArquero & arquero fuerza > delantero fuerza) 
	ifTrue: [self sumarPuntoArquero].
	
	(direccionTiro = direccionArquero & arquero fuerza < delantero fuerza) 
	ifTrue: [self sumarPuntoDelantero].
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 18:20:16'!
sumarPuntoDelantero
	puntajeDelantero := puntajeDelantero + 1.! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 18:20:30'!
sumarPuntoArquero
	puntajeArquero := puntajeArquero + 1.! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 18:21:16' prior: 50674664!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(direccionTiro between: 0@0 and: 2@2) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(direccionArquero between: 0@0 and: 2@2) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	(direccionTiro = direccionArquero & arquero fuerza > delantero fuerza) 
	ifTrue: [self sumarPuntoArquero].
	
	(direccionTiro = direccionArquero & arquero fuerza < delantero fuerza) 
	ifTrue: [self sumarPuntoDelantero].
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'LK 9/25/2023 18:21:18'!
PASSED!

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'LK 9/25/2023 18:21:18'!
PASSED!

!testRun: #PenalesTest #test02DelanteroNoPuedeApuntarHaciaAfueraDelPaloDerecho stamp: 'LK 9/25/2023 18:21:18'!
PASSED!

!testRun: #PenalesTest #test03DelanteroNoPuedeApuntarHaciaAbajoDelArco stamp: 'LK 9/25/2023 18:21:18'!
PASSED!

!testRun: #PenalesTest #test04DelanteroNoPuedeApuntarHaciaArribaDelTravesaño stamp: 'LK 9/25/2023 18:21:18'!
PASSED!

!testRun: #PenalesTest #test05ArqueroNoPuedePasarseDelPaloIzquierdo stamp: 'LK 9/25/2023 18:21:18'!
PASSED!

!testRun: #PenalesTest #test06ArqueroNoPuedePasarseDelPaloDerecho stamp: 'LK 9/25/2023 18:21:18'!
PASSED!

!testRun: #PenalesTest #test07ArqueroNoPuedeMeterseAbajoDeLaTierra stamp: 'LK 9/25/2023 18:21:18'!
PASSED!

!testRun: #PenalesTest #test08ArqueroNoPuedeSaltarPorEncimaDelTravesaño stamp: 'LK 9/25/2023 18:21:18'!
PASSED!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'LK 9/25/2023 18:21:18'!
ERROR!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'LK 9/25/2023 18:21:18'!
PASSED!

!testRun: #PenalesTest #test11MismasDireccionesSuficienteFuerzaAtajaArquero stamp: 'LK 9/25/2023 18:21:19'!
FAILURE!

!testRun: #PenalesTest #test12DelanteroQueTiraAColocarPierde50PorcFuerza stamp: 'LK 9/25/2023 18:21:19'!
FAILURE!

!testRun: #PenalesTest #test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra stamp: 'LK 9/25/2023 18:21:19'!
ERROR!

!testRun: #PenalesTest #test14FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAColocar stamp: 'LK 9/25/2023 18:21:19'!
ERROR!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'LK 9/25/2023 18:21:19'!
ERROR!

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'LK 9/25/2023 18:21:19'!
ERROR!

!testRun: #PenalesTest #test17ArqueroQueEligeAntesDeTiroVsPlayeraAColocarSuma100PorcFuerzaExtra stamp: 'LK 9/25/2023 18:21:19'!
ERROR!

!testRun: #PenalesTest #test18FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsPlayeraAColocar stamp: 'LK 9/25/2023 18:21:19'!
ERROR!

!testRun: #PenalesTest #test19ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAColocarEsDescubiertoYPuntoParaDelantero stamp: 'LK 9/25/2023 18:21:19'!
ERROR!

!testRun: #PenalesTest #test20DelanteroTiraAMatarAlAnguloInferiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 18:21:19'!
ERROR!

!testRun: #PenalesTest #test21DelanteroTiraAMatarAlAnguloSuperiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 18:21:19'!
ERROR!

!testRun: #PenalesTest #test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 18:21:19'!
ERROR!

!testRun: #PenalesTest #test23DelanteroTiraAMatarAlAnguloSuperiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 18:21:19'!
ERROR!

!testRun: #PenalesTest #test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro stamp: 'LK 9/25/2023 18:21:19'!
ERROR!

!testRun: #PenalesTest #test25DelanteroTiraAMatarUsa100PorcFuerzaBase stamp: 'LK 9/25/2023 18:21:19'!
ERROR!

!testRun: #PenalesTest #test26DelanteroTiraAMatarConJabulaniGana20PorcFuerzaExtra stamp: 'LK 9/25/2023 18:21:19'!
ERROR!

!testRun: #PenalesTest #test27FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAMatar stamp: 'LK 9/25/2023 18:21:19'!
ERROR!

!testRun: #PenalesTest #test28ArqueroQueEligeAntesDeTiroVsJabulaniAMatarIgnoraAlturaTiro stamp: 'LK 9/25/2023 18:21:19'!
ERROR!

!testRun: #PenalesTest #test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja stamp: 'LK 9/25/2023 18:21:19'!
ERROR!

!testRun: #PenalesTest #test30DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAdentro stamp: 'LK 9/25/2023 18:21:19'!
ERROR!

!testRun: #PenalesTest #test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera stamp: 'LK 9/25/2023 18:21:19'!
ERROR!

!testRun: #PenalesTest #test32ArqueroQueEligeAntesDeTiroVsPlayeraAMatarAlAnguloIgnoraAnchoTiro stamp: 'LK 9/25/2023 18:21:19'!
ERROR!

!testRun: #PenalesTest #test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro stamp: 'LK 9/25/2023 18:21:19'!
ERROR!

!testRun: #PenalesTest #test34ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAMatarSiempreAtaja stamp: 'LK 9/25/2023 18:21:19'!
ERROR!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'LK 9/25/2023 18:22:17'!
ERROR!

!methodRemoval: Delantero #decideTirarAColocarSuFuerzaBaseEs: stamp: 'LK 9/25/2023 18:22:40'!
decideTirarAColocarSuFuerzaBaseEs: fuerzaJugador

	|delantero|
	delantero := Delantero new.
	fuerza := fuerzaJugador.
	^delantero
!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 18:23:43' prior: 50674758!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(direccionTiro between: 0@0 and: 2@2) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(direccionArquero between: 0@0 and: 2@2) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	(direccionTiro = direccionArquero & (arquero fuerza > delantero fuerza))
	ifTrue: [self sumarPuntoArquero].
	
	(direccionTiro = direccionArquero & (arquero fuerza = delantero fuerza))
	ifTrue: [self sumarPuntoDelantero].
	
	(direccionTiro = direccionArquero & (arquero fuerza < delantero fuerza)) 
	ifTrue: [self sumarPuntoDelantero].
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'LK 9/25/2023 18:23:49'!
PASSED!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'LK 9/25/2023 18:23:51'!
PASSED!

!testRun: #PenalesTest #test11MismasDireccionesSuficienteFuerzaAtajaArquero stamp: 'LK 9/25/2023 18:23:52'!
FAILURE!

!testRun: #PenalesTest #test11MismasDireccionesSuficienteFuerzaAtajaArquero stamp: 'LK 9/25/2023 18:23:52'!
FAILURE!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 18:24:23' prior: 50674995!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(direccionTiro between: 0@0 and: 2@2) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(direccionArquero between: 0@0 and: 2@2) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	(direccionTiro = direccionArquero & (arquero fuerza >= delantero fuerza))
	ifTrue: [self sumarPuntoArquero].
	
	(direccionTiro = direccionArquero & (arquero fuerza = delantero fuerza))
	ifTrue: [self sumarPuntoDelantero].
	
	(direccionTiro = direccionArquero & (arquero fuerza < delantero fuerza)) 
	ifTrue: [self sumarPuntoDelantero].
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test11MismasDireccionesSuficienteFuerzaAtajaArquero stamp: 'LK 9/25/2023 18:24:25'!
FAILURE!

1 < 0!

1 <1 !

1 <= 1!

!testRun: #PenalesTest #test11MismasDireccionesSuficienteFuerzaAtajaArquero stamp: 'LK 9/25/2023 18:25:07'!
FAILURE!

!testRun: #PenalesTest #test11MismasDireccionesSuficienteFuerzaAtajaArquero stamp: 'LK 9/25/2023 18:25:07'!
FAILURE!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 18:25:45' prior: 50675101!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(direccionTiro between: 0@0 and: 2@2) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(direccionArquero between: 0@0 and: 2@2) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	(direccionTiro = direccionArquero & (arquero fuerza >= delantero fuerza))
	ifTrue: [self sumarPuntoArquero].
	
	(direccionTiro = direccionArquero & (arquero fuerza < delantero fuerza)) 
	ifTrue: [self sumarPuntoDelantero].
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test11MismasDireccionesSuficienteFuerzaAtajaArquero stamp: 'LK 9/25/2023 18:25:46'!
PASSED!

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'LK 9/25/2023 18:25:46'!
PASSED!

!testRun: #PenalesTest #test02DelanteroNoPuedeApuntarHaciaAfueraDelPaloDerecho stamp: 'LK 9/25/2023 18:25:46'!
PASSED!

!testRun: #PenalesTest #test03DelanteroNoPuedeApuntarHaciaAbajoDelArco stamp: 'LK 9/25/2023 18:25:46'!
PASSED!

!testRun: #PenalesTest #test04DelanteroNoPuedeApuntarHaciaArribaDelTravesaño stamp: 'LK 9/25/2023 18:25:46'!
PASSED!

!testRun: #PenalesTest #test05ArqueroNoPuedePasarseDelPaloIzquierdo stamp: 'LK 9/25/2023 18:25:46'!
PASSED!

!testRun: #PenalesTest #test06ArqueroNoPuedePasarseDelPaloDerecho stamp: 'LK 9/25/2023 18:25:46'!
PASSED!

!testRun: #PenalesTest #test07ArqueroNoPuedeMeterseAbajoDeLaTierra stamp: 'LK 9/25/2023 18:25:46'!
PASSED!

!testRun: #PenalesTest #test08ArqueroNoPuedeSaltarPorEncimaDelTravesaño stamp: 'LK 9/25/2023 18:25:46'!
PASSED!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'LK 9/25/2023 18:25:46'!
PASSED!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'LK 9/25/2023 18:25:46'!
PASSED!

!testRun: #PenalesTest #test11MismasDireccionesSuficienteFuerzaAtajaArquero stamp: 'LK 9/25/2023 18:25:46'!
PASSED!

!testRun: #PenalesTest #test12DelanteroQueTiraAColocarPierde50PorcFuerza stamp: 'LK 9/25/2023 18:25:47'!
FAILURE!

!testRun: #PenalesTest #test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra stamp: 'LK 9/25/2023 18:25:47'!
ERROR!

!testRun: #PenalesTest #test14FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAColocar stamp: 'LK 9/25/2023 18:25:47'!
ERROR!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'LK 9/25/2023 18:25:47'!
FAILURE!

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'LK 9/25/2023 18:25:47'!
ERROR!

!testRun: #PenalesTest #test17ArqueroQueEligeAntesDeTiroVsPlayeraAColocarSuma100PorcFuerzaExtra stamp: 'LK 9/25/2023 18:25:47'!
ERROR!

!testRun: #PenalesTest #test18FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsPlayeraAColocar stamp: 'LK 9/25/2023 18:25:47'!
ERROR!

!testRun: #PenalesTest #test19ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAColocarEsDescubiertoYPuntoParaDelantero stamp: 'LK 9/25/2023 18:25:47'!
ERROR!

!testRun: #PenalesTest #test20DelanteroTiraAMatarAlAnguloInferiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 18:25:47'!
ERROR!

!testRun: #PenalesTest #test21DelanteroTiraAMatarAlAnguloSuperiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 18:25:47'!
ERROR!

!testRun: #PenalesTest #test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 18:25:47'!
ERROR!

!testRun: #PenalesTest #test23DelanteroTiraAMatarAlAnguloSuperiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 18:25:47'!
ERROR!

!testRun: #PenalesTest #test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro stamp: 'LK 9/25/2023 18:25:47'!
ERROR!

!testRun: #PenalesTest #test25DelanteroTiraAMatarUsa100PorcFuerzaBase stamp: 'LK 9/25/2023 18:25:47'!
ERROR!

!testRun: #PenalesTest #test26DelanteroTiraAMatarConJabulaniGana20PorcFuerzaExtra stamp: 'LK 9/25/2023 18:25:47'!
ERROR!

!testRun: #PenalesTest #test27FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAMatar stamp: 'LK 9/25/2023 18:25:47'!
ERROR!

!testRun: #PenalesTest #test28ArqueroQueEligeAntesDeTiroVsJabulaniAMatarIgnoraAlturaTiro stamp: 'LK 9/25/2023 18:25:47'!
ERROR!

!testRun: #PenalesTest #test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja stamp: 'LK 9/25/2023 18:25:47'!
ERROR!

!testRun: #PenalesTest #test30DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAdentro stamp: 'LK 9/25/2023 18:25:47'!
ERROR!

!testRun: #PenalesTest #test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera stamp: 'LK 9/25/2023 18:25:47'!
ERROR!

!testRun: #PenalesTest #test32ArqueroQueEligeAntesDeTiroVsPlayeraAMatarAlAnguloIgnoraAnchoTiro stamp: 'LK 9/25/2023 18:25:47'!
ERROR!

!testRun: #PenalesTest #test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro stamp: 'LK 9/25/2023 18:25:47'!
ERROR!

!testRun: #PenalesTest #test34ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAMatarSiempreAtaja stamp: 'LK 9/25/2023 18:25:47'!
ERROR!

!testRun: #PenalesTest #test12DelanteroQueTiraAColocarPierde50PorcFuerza stamp: 'LK 9/25/2023 18:25:52'!
FAILURE!

!testRun: #PenalesTest #test12DelanteroQueTiraAColocarPierde50PorcFuerza stamp: 'LK 9/25/2023 18:25:52'!
FAILURE!

!testRun: #PenalesTest #test12DelanteroQueTiraAColocarPierde50PorcFuerza stamp: 'LK 9/25/2023 18:26:41'!
FAILURE!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 18:27:54'!
varFuerzaResultanteDelTiro
	^ (delantero fuerza / 2)! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 18:28:26' prior: 50675204!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(direccionTiro between: 0@0 and: 2@2) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(direccionArquero between: 0@0 and: 2@2) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	(direccionTiro = direccionArquero & (arquero fuerza >= self varFuerzaResultanteDelTiro ))
	ifTrue: [self sumarPuntoArquero].
	
	(direccionTiro = direccionArquero & (arquero fuerza < self varFuerzaResultanteDelTiro )) 
	ifTrue: [self sumarPuntoDelantero].
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test12DelanteroQueTiraAColocarPierde50PorcFuerza stamp: 'LK 9/25/2023 18:28:28'!
ERROR!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 18:29:00'!
varFuerzaResultanteDeTiro
	^ (delantero fuerza / 2)! !
!Penales methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 18:29:00' prior: 50675446!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(direccionTiro between: 0@0 and: 2@2) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(direccionArquero between: 0@0 and: 2@2) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	(direccionTiro = direccionArquero & (arquero fuerza >= self varFuerzaResultanteDeTiro ))
	ifTrue: [self sumarPuntoArquero].
	
	(direccionTiro = direccionArquero & (arquero fuerza < self varFuerzaResultanteDeTiro )) 
	ifTrue: [self sumarPuntoDelantero].
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!methodRemoval: Penales #varFuerzaResultanteDelTiro stamp: 'LK 9/25/2023 18:29:00'!
varFuerzaResultanteDelTiro
	^ (delantero fuerza / 2)!

!testRun: #PenalesTest #test12DelanteroQueTiraAColocarPierde50PorcFuerza stamp: 'LK 9/25/2023 18:29:06'!
PASSED!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 18:29:58'!
varFuerzaResultanteDeAtajada
	^ (arquero fuerza * 1.5)! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 18:30:33' prior: 50675543!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(direccionTiro between: 0@0 and: 2@2) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(direccionArquero between: 0@0 and: 2@2) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	(direccionTiro = direccionArquero & (self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro ))
	ifTrue: [self sumarPuntoArquero].
	
	(direccionTiro = direccionArquero & (self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro )) 
	ifTrue: [self sumarPuntoDelantero].
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !
!Arquero class methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 18:32:28'!
eligeDireccionAntesDeTiroSuFuerzaBaseEs: fuerzaArquero
	^self new initializeEligeDireccionAntesDeTiroSuFuerzaBaseEs: fuerzaArquero.! !
!Arquero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 18:32:52'!
initializeEligeDireccionAntesDeTiroSuFuerzaBaseEs: fuerzaArquero
	fuerza := fuerzaArquero * 1.5! !

!testRun: #PenalesTest #test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra stamp: 'LK 9/25/2023 18:33:00'!
FAILURE!

!testRun: #PenalesTest #test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra stamp: 'LK 9/25/2023 18:33:00'!
FAILURE!

34 * 1.5!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 18:33:40' prior: 50675639!
varFuerzaResultanteDeAtajada
	^ arquero fuerza.! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 18:33:47' prior: 50675538!
varFuerzaResultanteDeTiro
	^ delantero fuerza! !
!Delantero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 18:33:59' prior: 50673794!
initializeDecideTirarAColocarSuFuerzaBaseEs: fuerzaJugador

	fuerza := fuerzaJugador / 2.! !

!testRun: #PenalesTest #test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra stamp: 'LK 9/25/2023 18:34:00'!
PASSED!

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'LK 9/25/2023 18:34:01'!
PASSED!

!testRun: #PenalesTest #test02DelanteroNoPuedeApuntarHaciaAfueraDelPaloDerecho stamp: 'LK 9/25/2023 18:34:01'!
PASSED!

!testRun: #PenalesTest #test03DelanteroNoPuedeApuntarHaciaAbajoDelArco stamp: 'LK 9/25/2023 18:34:01'!
PASSED!

!testRun: #PenalesTest #test04DelanteroNoPuedeApuntarHaciaArribaDelTravesaño stamp: 'LK 9/25/2023 18:34:01'!
PASSED!

!testRun: #PenalesTest #test05ArqueroNoPuedePasarseDelPaloIzquierdo stamp: 'LK 9/25/2023 18:34:01'!
PASSED!

!testRun: #PenalesTest #test06ArqueroNoPuedePasarseDelPaloDerecho stamp: 'LK 9/25/2023 18:34:01'!
PASSED!

!testRun: #PenalesTest #test07ArqueroNoPuedeMeterseAbajoDeLaTierra stamp: 'LK 9/25/2023 18:34:01'!
PASSED!

!testRun: #PenalesTest #test08ArqueroNoPuedeSaltarPorEncimaDelTravesaño stamp: 'LK 9/25/2023 18:34:01'!
PASSED!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'LK 9/25/2023 18:34:01'!
PASSED!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'LK 9/25/2023 18:34:01'!
PASSED!

!testRun: #PenalesTest #test11MismasDireccionesSuficienteFuerzaAtajaArquero stamp: 'LK 9/25/2023 18:34:01'!
PASSED!

!testRun: #PenalesTest #test12DelanteroQueTiraAColocarPierde50PorcFuerza stamp: 'LK 9/25/2023 18:34:01'!
PASSED!

!testRun: #PenalesTest #test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra stamp: 'LK 9/25/2023 18:34:01'!
PASSED!

!testRun: #PenalesTest #test14FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAColocar stamp: 'LK 9/25/2023 18:34:01'!
PASSED!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'LK 9/25/2023 18:34:01'!
FAILURE!

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'LK 9/25/2023 18:34:01'!
ERROR!

!testRun: #PenalesTest #test17ArqueroQueEligeAntesDeTiroVsPlayeraAColocarSuma100PorcFuerzaExtra stamp: 'LK 9/25/2023 18:34:01'!
ERROR!

!testRun: #PenalesTest #test18FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsPlayeraAColocar stamp: 'LK 9/25/2023 18:34:01'!
ERROR!

!testRun: #PenalesTest #test19ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAColocarEsDescubiertoYPuntoParaDelantero stamp: 'LK 9/25/2023 18:34:01'!
ERROR!

!testRun: #PenalesTest #test20DelanteroTiraAMatarAlAnguloInferiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 18:34:01'!
ERROR!

!testRun: #PenalesTest #test21DelanteroTiraAMatarAlAnguloSuperiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 18:34:01'!
ERROR!

!testRun: #PenalesTest #test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 18:34:01'!
ERROR!

!testRun: #PenalesTest #test23DelanteroTiraAMatarAlAnguloSuperiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 18:34:01'!
ERROR!

!testRun: #PenalesTest #test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro stamp: 'LK 9/25/2023 18:34:01'!
ERROR!

!testRun: #PenalesTest #test25DelanteroTiraAMatarUsa100PorcFuerzaBase stamp: 'LK 9/25/2023 18:34:01'!
ERROR!

!testRun: #PenalesTest #test26DelanteroTiraAMatarConJabulaniGana20PorcFuerzaExtra stamp: 'LK 9/25/2023 18:34:01'!
ERROR!

!testRun: #PenalesTest #test27FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAMatar stamp: 'LK 9/25/2023 18:34:01'!
ERROR!

!testRun: #PenalesTest #test28ArqueroQueEligeAntesDeTiroVsJabulaniAMatarIgnoraAlturaTiro stamp: 'LK 9/25/2023 18:34:01'!
ERROR!

!testRun: #PenalesTest #test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja stamp: 'LK 9/25/2023 18:34:01'!
ERROR!

!testRun: #PenalesTest #test30DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAdentro stamp: 'LK 9/25/2023 18:34:01'!
ERROR!

!testRun: #PenalesTest #test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera stamp: 'LK 9/25/2023 18:34:01'!
ERROR!

!testRun: #PenalesTest #test32ArqueroQueEligeAntesDeTiroVsPlayeraAMatarAlAnguloIgnoraAnchoTiro stamp: 'LK 9/25/2023 18:34:01'!
ERROR!

!testRun: #PenalesTest #test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro stamp: 'LK 9/25/2023 18:34:01'!
ERROR!

!testRun: #PenalesTest #test34ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAMatarSiempreAtaja stamp: 'LK 9/25/2023 18:34:01'!
ERROR!
!Pelota class methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 18:36:44'!
playeraLentaCostaAzul
	^self new initializePlayeraLentaCostaAzul! !
!Pelota methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 18:36:55'!
initializePlayeraLentaCostaAzul
	
	tipo := #Playera.! !
!Pelota methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 18:38:27'!
tipo
	^tipo! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 18:41:01' prior: 50675644!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(direccionTiro between: 0@0 and: 2@2) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(direccionArquero between: 0@0 and: 2@2) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	(direccionTiro = direccionArquero & (self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro ))
	ifTrue: [self sumarPuntoArquero].
	
	(direccionTiro = direccionArquero & (self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro )) 
	ifTrue: [self sumarPuntoDelantero].
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	(pelota tipo = #Jabulani) ifTrue: [direccionTiro x = direccionArquero x ifTrue: [self sumarPuntoArquero]].
	
	
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 18:42:21'!
direccionEnRango: direccionTiro

	^ direccionTiro between: 0@0 and: 2@2! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 18:42:21' prior: 50675926!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(self direccionEnRango: direccionTiro) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(direccionArquero between: 0@0 and: 2@2) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	(direccionTiro = direccionArquero & (self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro ))
	ifTrue: [self sumarPuntoArquero].
	
	(direccionTiro = direccionArquero & (self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro )) 
	ifTrue: [self sumarPuntoDelantero].
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	(pelota tipo = #Jabulani) ifTrue: [direccionTiro x = direccionArquero x ifTrue: [self sumarPuntoArquero]].
	
	
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 18:42:39' prior: 50676025!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(self direccionEnRango: direccionTiro) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(self direccionEnRango: direccionArquero) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	(direccionTiro = direccionArquero & (self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro ))
	ifTrue: [self sumarPuntoArquero].
	
	(direccionTiro = direccionArquero & (self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro )) 
	ifTrue: [self sumarPuntoDelantero].
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	(pelota tipo = #Jabulani) ifTrue: [direccionTiro x = direccionArquero x ifTrue: [self sumarPuntoArquero]].
	
	
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!classDefinition: #Delantero category: 'ISW1-2023-2C-Parcial-1' stamp: 'LK 9/25/2023 18:42:59'!
Object subclass: #Delantero
	instanceVariableNames: 'fuerza tipo'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!
!Delantero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 18:42:58' prior: 50675766!
initializeDecideTirarAColocarSuFuerzaBaseEs: fuerzaJugador
	
	tipo := #AColocar.

	fuerza := fuerzaJugador / 2.! !

!classDefinition: #Arquero category: 'ISW1-2023-2C-Parcial-1' stamp: 'LK 9/25/2023 18:43:27'!
Object subclass: #Arquero
	instanceVariableNames: 'fuerza tipo'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!
!Arquero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 18:43:25' prior: 50675740!
initializeEligeDireccionAntesDeTiroSuFuerzaBaseEs: fuerzaArquero

	tipo := #Adelanta.
	fuerza := fuerzaArquero * 1.5! !
!Arquero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 18:43:34' prior: 50673783!
initializeEsperaPorTiroYSeAdelantaSuFuerzaBaseEs: fuerzaArquero
	tipo := #Espera.
	fuerza := fuerzaArquero.! !

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'LK 9/25/2023 18:43:52'!
FAILURE!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'LK 9/25/2023 18:43:52'!
FAILURE!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 18:46:28' prior: 50676118!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(self direccionEnRango: direccionTiro) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(self direccionEnRango: direccionArquero) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	(pelota tipo = #Jabulani) ifTrue: [].
	
	(direccionTiro = direccionArquero & (self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro ))
	ifTrue: [self sumarPuntoArquero].
	
	(direccionTiro = direccionArquero & (self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro )) 
	ifTrue: [self sumarPuntoDelantero].
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	(pelota tipo = #Jabulani) ifTrue: [direccionTiro x = direccionArquero x ifTrue: [self sumarPuntoArquero]].
	
	
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 18:48:28' prior: 50676256!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(self direccionEnRango: direccionTiro) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(self direccionEnRango: direccionArquero) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	(pelota tipo = #Jabulani) ifTrue: [
		
		(arquero tipo = #Adelanta) ifTrue: [
				(direccionTiro x = direccionArquero x) ifTrue: [self sumarPuntoArquero].
			]
		
		
		].
	
	(direccionTiro = direccionArquero & (self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro ))
	ifTrue: [self sumarPuntoArquero].
	
	(direccionTiro = direccionArquero & (self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro )) 
	ifTrue: [self sumarPuntoDelantero].
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	(pelota tipo = #Jabulani) ifTrue: [direccionTiro x = direccionArquero x ifTrue: [self sumarPuntoArquero]].
	
	
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 18:53:25' prior: 50676351!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(self direccionEnRango: direccionTiro) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(self direccionEnRango: direccionArquero) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	(pelota tipo = #Jabulani) ifTrue: [
		
		(arquero tipo = #Adelanta) ifTrue: [
				(direccionTiro x = direccionArquero x & 
				self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro)
				 	ifTrue: [self sumarPuntoArquero].
			].
		(arquero tipo = #Espera) ifTrue: [
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro ))
					ifTrue: [self sumarPuntoArquero].
			
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro )) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
		].
	(pelota = #Playera) ifTrue: [].
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'LK 9/25/2023 18:53:30'!
PASSED!

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'LK 9/25/2023 18:53:33'!
PASSED!

!testRun: #PenalesTest #test02DelanteroNoPuedeApuntarHaciaAfueraDelPaloDerecho stamp: 'LK 9/25/2023 18:53:33'!
PASSED!

!testRun: #PenalesTest #test03DelanteroNoPuedeApuntarHaciaAbajoDelArco stamp: 'LK 9/25/2023 18:53:33'!
PASSED!

!testRun: #PenalesTest #test04DelanteroNoPuedeApuntarHaciaArribaDelTravesaño stamp: 'LK 9/25/2023 18:53:33'!
PASSED!

!testRun: #PenalesTest #test05ArqueroNoPuedePasarseDelPaloIzquierdo stamp: 'LK 9/25/2023 18:53:33'!
PASSED!

!testRun: #PenalesTest #test06ArqueroNoPuedePasarseDelPaloDerecho stamp: 'LK 9/25/2023 18:53:33'!
PASSED!

!testRun: #PenalesTest #test07ArqueroNoPuedeMeterseAbajoDeLaTierra stamp: 'LK 9/25/2023 18:53:33'!
PASSED!

!testRun: #PenalesTest #test08ArqueroNoPuedeSaltarPorEncimaDelTravesaño stamp: 'LK 9/25/2023 18:53:33'!
PASSED!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'LK 9/25/2023 18:53:33'!
ERROR!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'LK 9/25/2023 18:53:33'!
ERROR!

!testRun: #PenalesTest #test11MismasDireccionesSuficienteFuerzaAtajaArquero stamp: 'LK 9/25/2023 18:53:33'!
ERROR!

!testRun: #PenalesTest #test12DelanteroQueTiraAColocarPierde50PorcFuerza stamp: 'LK 9/25/2023 18:53:33'!
ERROR!

!testRun: #PenalesTest #test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra stamp: 'LK 9/25/2023 18:53:33'!
ERROR!

!testRun: #PenalesTest #test14FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAColocar stamp: 'LK 9/25/2023 18:53:33'!
ERROR!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'LK 9/25/2023 18:53:33'!
ERROR!

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'LK 9/25/2023 18:53:33'!
FAILURE!

!testRun: #PenalesTest #test17ArqueroQueEligeAntesDeTiroVsPlayeraAColocarSuma100PorcFuerzaExtra stamp: 'LK 9/25/2023 18:53:33'!
FAILURE!

!testRun: #PenalesTest #test18FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsPlayeraAColocar stamp: 'LK 9/25/2023 18:53:33'!
FAILURE!

!testRun: #PenalesTest #test19ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAColocarEsDescubiertoYPuntoParaDelantero stamp: 'LK 9/25/2023 18:53:33'!
FAILURE!

!testRun: #PenalesTest #test20DelanteroTiraAMatarAlAnguloInferiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 18:53:33'!
ERROR!

!testRun: #PenalesTest #test21DelanteroTiraAMatarAlAnguloSuperiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 18:53:33'!
ERROR!

!testRun: #PenalesTest #test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 18:53:33'!
ERROR!

!testRun: #PenalesTest #test23DelanteroTiraAMatarAlAnguloSuperiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 18:53:33'!
ERROR!

!testRun: #PenalesTest #test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro stamp: 'LK 9/25/2023 18:53:33'!
ERROR!

!testRun: #PenalesTest #test25DelanteroTiraAMatarUsa100PorcFuerzaBase stamp: 'LK 9/25/2023 18:53:33'!
ERROR!

!testRun: #PenalesTest #test26DelanteroTiraAMatarConJabulaniGana20PorcFuerzaExtra stamp: 'LK 9/25/2023 18:53:33'!
ERROR!

!testRun: #PenalesTest #test27FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAMatar stamp: 'LK 9/25/2023 18:53:33'!
ERROR!

!testRun: #PenalesTest #test28ArqueroQueEligeAntesDeTiroVsJabulaniAMatarIgnoraAlturaTiro stamp: 'LK 9/25/2023 18:53:33'!
ERROR!

!testRun: #PenalesTest #test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja stamp: 'LK 9/25/2023 18:53:33'!
ERROR!

!testRun: #PenalesTest #test30DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAdentro stamp: 'LK 9/25/2023 18:53:33'!
ERROR!

!testRun: #PenalesTest #test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera stamp: 'LK 9/25/2023 18:53:33'!
ERROR!

!testRun: #PenalesTest #test32ArqueroQueEligeAntesDeTiroVsPlayeraAMatarAlAnguloIgnoraAnchoTiro stamp: 'LK 9/25/2023 18:53:33'!
ERROR!

!testRun: #PenalesTest #test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro stamp: 'LK 9/25/2023 18:53:33'!
ERROR!

!testRun: #PenalesTest #test34ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAMatarSiempreAtaja stamp: 'LK 9/25/2023 18:53:33'!
ERROR!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'LK 9/25/2023 18:54:04'!
ERROR!
!Arquero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 18:54:23'!
tipo
	^tipo! !

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'LK 9/25/2023 18:54:27'!
PASSED!

!testRun: #PenalesTest #test02DelanteroNoPuedeApuntarHaciaAfueraDelPaloDerecho stamp: 'LK 9/25/2023 18:54:27'!
PASSED!

!testRun: #PenalesTest #test03DelanteroNoPuedeApuntarHaciaAbajoDelArco stamp: 'LK 9/25/2023 18:54:27'!
PASSED!

!testRun: #PenalesTest #test04DelanteroNoPuedeApuntarHaciaArribaDelTravesaño stamp: 'LK 9/25/2023 18:54:27'!
PASSED!

!testRun: #PenalesTest #test05ArqueroNoPuedePasarseDelPaloIzquierdo stamp: 'LK 9/25/2023 18:54:27'!
PASSED!

!testRun: #PenalesTest #test06ArqueroNoPuedePasarseDelPaloDerecho stamp: 'LK 9/25/2023 18:54:27'!
PASSED!

!testRun: #PenalesTest #test07ArqueroNoPuedeMeterseAbajoDeLaTierra stamp: 'LK 9/25/2023 18:54:27'!
PASSED!

!testRun: #PenalesTest #test08ArqueroNoPuedeSaltarPorEncimaDelTravesaño stamp: 'LK 9/25/2023 18:54:27'!
PASSED!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'LK 9/25/2023 18:54:27'!
PASSED!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'LK 9/25/2023 18:54:27'!
PASSED!

!testRun: #PenalesTest #test11MismasDireccionesSuficienteFuerzaAtajaArquero stamp: 'LK 9/25/2023 18:54:27'!
PASSED!

!testRun: #PenalesTest #test12DelanteroQueTiraAColocarPierde50PorcFuerza stamp: 'LK 9/25/2023 18:54:27'!
PASSED!

!testRun: #PenalesTest #test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra stamp: 'LK 9/25/2023 18:54:27'!
PASSED!

!testRun: #PenalesTest #test14FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAColocar stamp: 'LK 9/25/2023 18:54:27'!
FAILURE!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'LK 9/25/2023 18:54:27'!
FAILURE!

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'LK 9/25/2023 18:54:27'!
FAILURE!

!testRun: #PenalesTest #test17ArqueroQueEligeAntesDeTiroVsPlayeraAColocarSuma100PorcFuerzaExtra stamp: 'LK 9/25/2023 18:54:27'!
FAILURE!

!testRun: #PenalesTest #test18FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsPlayeraAColocar stamp: 'LK 9/25/2023 18:54:27'!
FAILURE!

!testRun: #PenalesTest #test19ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAColocarEsDescubiertoYPuntoParaDelantero stamp: 'LK 9/25/2023 18:54:27'!
FAILURE!

!testRun: #PenalesTest #test20DelanteroTiraAMatarAlAnguloInferiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 18:54:27'!
ERROR!

!testRun: #PenalesTest #test21DelanteroTiraAMatarAlAnguloSuperiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 18:54:27'!
ERROR!

!testRun: #PenalesTest #test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 18:54:27'!
ERROR!

!testRun: #PenalesTest #test23DelanteroTiraAMatarAlAnguloSuperiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 18:54:27'!
ERROR!

!testRun: #PenalesTest #test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro stamp: 'LK 9/25/2023 18:54:27'!
ERROR!

!testRun: #PenalesTest #test25DelanteroTiraAMatarUsa100PorcFuerzaBase stamp: 'LK 9/25/2023 18:54:27'!
ERROR!

!testRun: #PenalesTest #test26DelanteroTiraAMatarConJabulaniGana20PorcFuerzaExtra stamp: 'LK 9/25/2023 18:54:27'!
ERROR!

!testRun: #PenalesTest #test27FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAMatar stamp: 'LK 9/25/2023 18:54:27'!
ERROR!

!testRun: #PenalesTest #test28ArqueroQueEligeAntesDeTiroVsJabulaniAMatarIgnoraAlturaTiro stamp: 'LK 9/25/2023 18:54:27'!
ERROR!

!testRun: #PenalesTest #test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja stamp: 'LK 9/25/2023 18:54:27'!
ERROR!

!testRun: #PenalesTest #test30DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAdentro stamp: 'LK 9/25/2023 18:54:27'!
ERROR!

!testRun: #PenalesTest #test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera stamp: 'LK 9/25/2023 18:54:27'!
ERROR!

!testRun: #PenalesTest #test32ArqueroQueEligeAntesDeTiroVsPlayeraAMatarAlAnguloIgnoraAnchoTiro stamp: 'LK 9/25/2023 18:54:27'!
ERROR!

!testRun: #PenalesTest #test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro stamp: 'LK 9/25/2023 18:54:27'!
ERROR!

!testRun: #PenalesTest #test34ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAMatarSiempreAtaja stamp: 'LK 9/25/2023 18:54:27'!
ERROR!

!testRun: #PenalesTest #test14FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAColocar stamp: 'LK 9/25/2023 18:54:40'!
FAILURE!

!testRun: #PenalesTest #test14FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAColocar stamp: 'LK 9/25/2023 18:55:14'!
FAILURE!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 18:56:33' prior: 50676450!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(self direccionEnRango: direccionTiro) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(self direccionEnRango: direccionArquero) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	(pelota tipo = #Jabulani) ifTrue: [
		
		(arquero tipo = #Adelanta) ifTrue: [
				(direccionTiro x = direccionArquero x & 
				self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro)
				 	ifTrue: [self sumarPuntoArquero].
					
				(direccionTiro = direccionArquero & 
				self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro) 
					ifTrue: [self sumarPuntoDelantero].
					
			].
		(arquero tipo = #Espera) ifTrue: [
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro ))
					ifTrue: [self sumarPuntoArquero].
			
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro )) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
		].
	(pelota = #Playera) ifTrue: [].
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test14FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAColocar stamp: 'LK 9/25/2023 18:56:35'!
PASSED!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'LK 9/25/2023 18:56:37'!
FAILURE!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'LK 9/25/2023 18:56:37'!
FAILURE!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'LK 9/25/2023 18:56:46'!
FAILURE!

0@2 x!

(0@2) x!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 18:57:35' prior: 50676842!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(self direccionEnRango: direccionTiro) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(self direccionEnRango: direccionArquero) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	(pelota tipo = #Jabulani) ifTrue: [
		
		(arquero tipo = #Adelanta) ifTrue: [
				((direccionTiro) x = (direccionArquero) x & 
				self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro)
				 	ifTrue: [self sumarPuntoArquero].
					
				(direccionTiro = direccionArquero & 
				self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro) 
					ifTrue: [self sumarPuntoDelantero].
					
			].
		(arquero tipo = #Espera) ifTrue: [
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro ))
					ifTrue: [self sumarPuntoArquero].
			
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro )) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
		].
	(pelota = #Playera) ifTrue: [].
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'LK 9/25/2023 18:57:37'!
FAILURE!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'LK 9/25/2023 18:57:37'!
FAILURE!
!Arquero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 19:00:16' prior: 50676240!
initializeEsperaPorTiroYSeAdelantaSuFuerzaBaseEs: fuerzaArquero

	tipo := #EsperaYAdelanta.
	fuerza := fuerzaArquero.! !
!Arquero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 19:00:21' prior: 50676233!
initializeEligeDireccionAntesDeTiroSuFuerzaBaseEs: fuerzaArquero

	tipo := #Elige.
	fuerza := fuerzaArquero * 1.5! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 19:00:41' prior: 50676966!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(self direccionEnRango: direccionTiro) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(self direccionEnRango: direccionArquero) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	(pelota tipo = #Jabulani) ifTrue: [
		
		(arquero tipo = #EsperaYAdelanta) ifTrue: [
				((direccionTiro) x = (direccionArquero) x & 
				self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro)
				 	ifTrue: [self sumarPuntoArquero].
					
				(direccionTiro = direccionArquero & 
				self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro) 
					ifTrue: [self sumarPuntoDelantero].
					
			].
		(arquero tipo = #Espera) ifTrue: [
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro ))
					ifTrue: [self sumarPuntoArquero].
			
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro )) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
		].
	(pelota = #Playera) ifTrue: [].
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 19:00:52' prior: 50677095!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(self direccionEnRango: direccionTiro) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(self direccionEnRango: direccionArquero) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	(pelota tipo = #Jabulani) ifTrue: [
		
		(arquero tipo = #EsperaYAdelanta) ifTrue: [
				((direccionTiro) x = (direccionArquero) x & 
				self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro)
				 	ifTrue: [self sumarPuntoArquero].
					
				(direccionTiro = direccionArquero & 
				self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro) 
					ifTrue: [self sumarPuntoDelantero].
					
			].
		(arquero tipo = #Elige) ifTrue: [
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro ))
					ifTrue: [self sumarPuntoArquero].
			
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro )) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
		].
	(pelota = #Playera) ifTrue: [].
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'LK 9/25/2023 19:01:00'!
PASSED!

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'LK 9/25/2023 19:01:02'!
PASSED!

!testRun: #PenalesTest #test02DelanteroNoPuedeApuntarHaciaAfueraDelPaloDerecho stamp: 'LK 9/25/2023 19:01:02'!
PASSED!

!testRun: #PenalesTest #test03DelanteroNoPuedeApuntarHaciaAbajoDelArco stamp: 'LK 9/25/2023 19:01:02'!
PASSED!

!testRun: #PenalesTest #test04DelanteroNoPuedeApuntarHaciaArribaDelTravesaño stamp: 'LK 9/25/2023 19:01:02'!
PASSED!

!testRun: #PenalesTest #test05ArqueroNoPuedePasarseDelPaloIzquierdo stamp: 'LK 9/25/2023 19:01:02'!
PASSED!

!testRun: #PenalesTest #test06ArqueroNoPuedePasarseDelPaloDerecho stamp: 'LK 9/25/2023 19:01:02'!
PASSED!

!testRun: #PenalesTest #test07ArqueroNoPuedeMeterseAbajoDeLaTierra stamp: 'LK 9/25/2023 19:01:03'!
PASSED!

!testRun: #PenalesTest #test08ArqueroNoPuedeSaltarPorEncimaDelTravesaño stamp: 'LK 9/25/2023 19:01:03'!
PASSED!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'LK 9/25/2023 19:01:03'!
ERROR!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'LK 9/25/2023 19:01:03'!
PASSED!

!testRun: #PenalesTest #test11MismasDireccionesSuficienteFuerzaAtajaArquero stamp: 'LK 9/25/2023 19:01:03'!
PASSED!

!testRun: #PenalesTest #test12DelanteroQueTiraAColocarPierde50PorcFuerza stamp: 'LK 9/25/2023 19:01:03'!
PASSED!

!testRun: #PenalesTest #test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra stamp: 'LK 9/25/2023 19:01:03'!
PASSED!

!testRun: #PenalesTest #test14FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAColocar stamp: 'LK 9/25/2023 19:01:03'!
PASSED!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'LK 9/25/2023 19:01:03'!
ERROR!

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'LK 9/25/2023 19:01:03'!
FAILURE!

!testRun: #PenalesTest #test17ArqueroQueEligeAntesDeTiroVsPlayeraAColocarSuma100PorcFuerzaExtra stamp: 'LK 9/25/2023 19:01:03'!
FAILURE!

!testRun: #PenalesTest #test18FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsPlayeraAColocar stamp: 'LK 9/25/2023 19:01:03'!
FAILURE!

!testRun: #PenalesTest #test19ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAColocarEsDescubiertoYPuntoParaDelantero stamp: 'LK 9/25/2023 19:01:03'!
FAILURE!

!testRun: #PenalesTest #test20DelanteroTiraAMatarAlAnguloInferiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:01:03'!
ERROR!

!testRun: #PenalesTest #test21DelanteroTiraAMatarAlAnguloSuperiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:01:03'!
ERROR!

!testRun: #PenalesTest #test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:01:03'!
ERROR!

!testRun: #PenalesTest #test23DelanteroTiraAMatarAlAnguloSuperiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:01:03'!
ERROR!

!testRun: #PenalesTest #test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro stamp: 'LK 9/25/2023 19:01:03'!
ERROR!

!testRun: #PenalesTest #test25DelanteroTiraAMatarUsa100PorcFuerzaBase stamp: 'LK 9/25/2023 19:01:03'!
ERROR!

!testRun: #PenalesTest #test26DelanteroTiraAMatarConJabulaniGana20PorcFuerzaExtra stamp: 'LK 9/25/2023 19:01:03'!
ERROR!

!testRun: #PenalesTest #test27FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAMatar stamp: 'LK 9/25/2023 19:01:03'!
ERROR!

!testRun: #PenalesTest #test28ArqueroQueEligeAntesDeTiroVsJabulaniAMatarIgnoraAlturaTiro stamp: 'LK 9/25/2023 19:01:03'!
ERROR!

!testRun: #PenalesTest #test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja stamp: 'LK 9/25/2023 19:01:03'!
ERROR!

!testRun: #PenalesTest #test30DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAdentro stamp: 'LK 9/25/2023 19:01:03'!
ERROR!

!testRun: #PenalesTest #test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera stamp: 'LK 9/25/2023 19:01:03'!
ERROR!

!testRun: #PenalesTest #test32ArqueroQueEligeAntesDeTiroVsPlayeraAMatarAlAnguloIgnoraAnchoTiro stamp: 'LK 9/25/2023 19:01:03'!
ERROR!

!testRun: #PenalesTest #test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro stamp: 'LK 9/25/2023 19:01:03'!
ERROR!

!testRun: #PenalesTest #test34ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAMatarSiempreAtaja stamp: 'LK 9/25/2023 19:01:03'!
ERROR!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'LK 9/25/2023 19:01:35'!
ERROR!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'LK 9/25/2023 19:02:11'!
ERROR!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'LK 9/25/2023 19:02:11'!
ERROR!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 19:02:32' prior: 50677201!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(self direccionEnRango: direccionTiro) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(self direccionEnRango: direccionArquero) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	(pelota tipo = #Jabulani) ifTrue: [
		
		(arquero tipo = #EsperaYAdelanta) ifTrue: [
				((direccionTiro) x = (direccionArquero) x & 
				(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro))
				 	ifTrue: [self sumarPuntoArquero].
					
				(direccionTiro = direccionArquero & 
				self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro) 
					ifTrue: [self sumarPuntoDelantero].
					
			].
		(arquero tipo = #Elige) ifTrue: [
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro ))
					ifTrue: [self sumarPuntoArquero].
			
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro )) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
		].
	(pelota = #Playera) ifTrue: [].
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'LK 9/25/2023 19:02:33'!
ERROR!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'LK 9/25/2023 19:02:33'!
ERROR!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 19:04:19' prior: 50677457!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(self direccionEnRango: direccionTiro) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(self direccionEnRango: direccionArquero) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	(pelota tipo = #Jabulani) ifTrue: [
		
		(arquero tipo = #EsperaYAdelanta) ifTrue: [
				((direccionTiro x = direccionArquero x) & 
				(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro))
				 	ifTrue: [self sumarPuntoArquero].
					
				(direccionTiro = direccionArquero & 
				self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro) 
					ifTrue: [self sumarPuntoDelantero].
					
			].
		(arquero tipo = #Elige) ifTrue: [
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro ))
					ifTrue: [self sumarPuntoArquero].
			
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro )) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
		].
	(pelota = #Playera) ifTrue: [].
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra stamp: 'LK 9/25/2023 19:04:20'!
PASSED!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'LK 9/25/2023 19:04:25'!
ERROR!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'LK 9/25/2023 19:04:25'!
ERROR!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'LK 9/25/2023 19:05:30'!
ERROR!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'LK 9/25/2023 19:05:30'!
ERROR!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 19:05:57' prior: 50677570!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(self direccionEnRango: direccionTiro) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(self direccionEnRango: direccionArquero) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	(pelota tipo = #Jabulani) ifTrue: [
		
		(arquero tipo = #EsperaYAdelanta) ifTrue: [
				((direccionTiro) x = (direccionArquero) x) & 
				(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro)
				 	ifTrue: [self sumarPuntoArquero].
					
				(direccionTiro = direccionArquero) & 
				(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro) 
					ifTrue: [self sumarPuntoDelantero].
					
			].
		(arquero tipo = #Elige) ifTrue: [
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro ))
					ifTrue: [self sumarPuntoArquero].
			
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro )) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
		].
	(pelota = #Playera) ifTrue: [].
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'LK 9/25/2023 19:05:59'!
PASSED!

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'LK 9/25/2023 19:06:02'!
PASSED!

!testRun: #PenalesTest #test02DelanteroNoPuedeApuntarHaciaAfueraDelPaloDerecho stamp: 'LK 9/25/2023 19:06:02'!
PASSED!

!testRun: #PenalesTest #test03DelanteroNoPuedeApuntarHaciaAbajoDelArco stamp: 'LK 9/25/2023 19:06:02'!
PASSED!

!testRun: #PenalesTest #test04DelanteroNoPuedeApuntarHaciaArribaDelTravesaño stamp: 'LK 9/25/2023 19:06:02'!
PASSED!

!testRun: #PenalesTest #test05ArqueroNoPuedePasarseDelPaloIzquierdo stamp: 'LK 9/25/2023 19:06:02'!
PASSED!

!testRun: #PenalesTest #test06ArqueroNoPuedePasarseDelPaloDerecho stamp: 'LK 9/25/2023 19:06:02'!
PASSED!

!testRun: #PenalesTest #test07ArqueroNoPuedeMeterseAbajoDeLaTierra stamp: 'LK 9/25/2023 19:06:02'!
PASSED!

!testRun: #PenalesTest #test08ArqueroNoPuedeSaltarPorEncimaDelTravesaño stamp: 'LK 9/25/2023 19:06:02'!
PASSED!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'LK 9/25/2023 19:06:02'!
PASSED!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'LK 9/25/2023 19:06:02'!
PASSED!

!testRun: #PenalesTest #test11MismasDireccionesSuficienteFuerzaAtajaArquero stamp: 'LK 9/25/2023 19:06:02'!
PASSED!

!testRun: #PenalesTest #test12DelanteroQueTiraAColocarPierde50PorcFuerza stamp: 'LK 9/25/2023 19:06:02'!
PASSED!

!testRun: #PenalesTest #test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra stamp: 'LK 9/25/2023 19:06:02'!
PASSED!

!testRun: #PenalesTest #test14FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAColocar stamp: 'LK 9/25/2023 19:06:02'!
PASSED!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'LK 9/25/2023 19:06:02'!
FAILURE!

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'LK 9/25/2023 19:06:02'!
FAILURE!

!testRun: #PenalesTest #test17ArqueroQueEligeAntesDeTiroVsPlayeraAColocarSuma100PorcFuerzaExtra stamp: 'LK 9/25/2023 19:06:02'!
FAILURE!

!testRun: #PenalesTest #test18FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsPlayeraAColocar stamp: 'LK 9/25/2023 19:06:02'!
FAILURE!

!testRun: #PenalesTest #test19ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAColocarEsDescubiertoYPuntoParaDelantero stamp: 'LK 9/25/2023 19:06:02'!
FAILURE!

!testRun: #PenalesTest #test20DelanteroTiraAMatarAlAnguloInferiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:06:02'!
ERROR!

!testRun: #PenalesTest #test21DelanteroTiraAMatarAlAnguloSuperiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:06:02'!
ERROR!

!testRun: #PenalesTest #test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:06:02'!
ERROR!

!testRun: #PenalesTest #test23DelanteroTiraAMatarAlAnguloSuperiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:06:02'!
ERROR!

!testRun: #PenalesTest #test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro stamp: 'LK 9/25/2023 19:06:02'!
ERROR!

!testRun: #PenalesTest #test25DelanteroTiraAMatarUsa100PorcFuerzaBase stamp: 'LK 9/25/2023 19:06:02'!
ERROR!

!testRun: #PenalesTest #test26DelanteroTiraAMatarConJabulaniGana20PorcFuerzaExtra stamp: 'LK 9/25/2023 19:06:02'!
ERROR!

!testRun: #PenalesTest #test27FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAMatar stamp: 'LK 9/25/2023 19:06:02'!
ERROR!

!testRun: #PenalesTest #test28ArqueroQueEligeAntesDeTiroVsJabulaniAMatarIgnoraAlturaTiro stamp: 'LK 9/25/2023 19:06:02'!
ERROR!

!testRun: #PenalesTest #test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja stamp: 'LK 9/25/2023 19:06:02'!
ERROR!

!testRun: #PenalesTest #test30DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAdentro stamp: 'LK 9/25/2023 19:06:02'!
ERROR!

!testRun: #PenalesTest #test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera stamp: 'LK 9/25/2023 19:06:03'!
ERROR!

!testRun: #PenalesTest #test32ArqueroQueEligeAntesDeTiroVsPlayeraAMatarAlAnguloIgnoraAnchoTiro stamp: 'LK 9/25/2023 19:06:03'!
ERROR!

!testRun: #PenalesTest #test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro stamp: 'LK 9/25/2023 19:06:03'!
ERROR!

!testRun: #PenalesTest #test34ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAMatarSiempreAtaja stamp: 'LK 9/25/2023 19:06:03'!
ERROR!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 19:06:54' prior: 50677694!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(self direccionEnRango: direccionTiro) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(self direccionEnRango: direccionArquero) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	(pelota tipo = #Jabulani) ifTrue: [
		
		(arquero tipo = #EsperaYAdelanta) ifTrue: [
				(((direccionTiro) x = (direccionArquero) x )& 
				(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro))
				 	ifTrue: [self sumarPuntoArquero].
					
				(direccionTiro = direccionArquero) & 
				(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro) 
					ifTrue: [self sumarPuntoDelantero].
					
			].
		(arquero tipo = #Elige) ifTrue: [
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro ))
					ifTrue: [self sumarPuntoArquero].
			
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro )) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
		].
	(pelota = #Playera) ifTrue: [].
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'LK 9/25/2023 19:06:55'!
FAILURE!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'LK 9/25/2023 19:06:55'!
FAILURE!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'LK 9/25/2023 19:07:11'!
FAILURE!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 19:08:20' prior: 50677940!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(self direccionEnRango: direccionTiro) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(self direccionEnRango: direccionArquero) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	(pelota tipo = #Jabulani) ifTrue: [
		
		(arquero tipo = #EsperaYAdelanta) ifTrue: [
				(((direccionTiro) x = (direccionArquero) x )& 
				(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro))
				 	ifTrue: [self sumarPuntoArquero].
					
				(direccionTiro = direccionArquero) & 
				(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro) 
					ifTrue: [self sumarPuntoDelantero].
					
			].
		
		(arquero tipo = #Elige) ifTrue: [
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro ))
					ifTrue: [self sumarPuntoArquero].
			
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro )) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
		].
	(pelota = #Playera) ifTrue: [].
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 19:08:23' prior: 50678060!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(self direccionEnRango: direccionTiro) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(self direccionEnRango: direccionArquero) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	(pelota tipo = #Jabulani) ifTrue: [
		
		(arquero tipo = #EsperaYAdelanta) ifTrue: [
				(((direccionTiro) x = (direccionArquero) x)& 
				(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro))
				 	ifTrue: [self sumarPuntoArquero].
					
				(direccionTiro = direccionArquero) & 
				(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro) 
					ifTrue: [self sumarPuntoDelantero].
					
			].
		
		(arquero tipo = #Elige) ifTrue: [
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro ))
					ifTrue: [self sumarPuntoArquero].
			
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro )) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
		].
	(pelota = #Playera) ifTrue: [].
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'LK 9/25/2023 19:08:25'!
FAILURE!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'LK 9/25/2023 19:08:25'!
FAILURE!

((0@2) x = (0@3) x)!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 19:09:41' prior: 50678167!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(self direccionEnRango: direccionTiro) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(self direccionEnRango: direccionArquero) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	(pelota tipo = #Jabulani) ifTrue: [
		
		(arquero tipo = #EsperaYAdelanta) ifTrue: [
				((direccionTiro) x = (direccionArquero x) & 
				self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro)
				 	ifTrue: [self sumarPuntoArquero].
					
				(direccionTiro = direccionArquero) & 
				(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro) 
					ifTrue: [self sumarPuntoDelantero].
					
			].
		
		(arquero tipo = #Elige) ifTrue: [
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro ))
					ifTrue: [self sumarPuntoArquero].
			
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro )) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
		].
	(pelota = #Playera) ifTrue: [].
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'LK 9/25/2023 19:09:43'!
FAILURE!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'LK 9/25/2023 19:09:43'!
FAILURE!

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'LK 9/25/2023 19:10:21'!
PASSED!

!testRun: #PenalesTest #test02DelanteroNoPuedeApuntarHaciaAfueraDelPaloDerecho stamp: 'LK 9/25/2023 19:10:21'!
PASSED!

!testRun: #PenalesTest #test03DelanteroNoPuedeApuntarHaciaAbajoDelArco stamp: 'LK 9/25/2023 19:10:22'!
PASSED!

!testRun: #PenalesTest #test04DelanteroNoPuedeApuntarHaciaArribaDelTravesaño stamp: 'LK 9/25/2023 19:10:22'!
PASSED!

!testRun: #PenalesTest #test05ArqueroNoPuedePasarseDelPaloIzquierdo stamp: 'LK 9/25/2023 19:10:22'!
PASSED!

!testRun: #PenalesTest #test06ArqueroNoPuedePasarseDelPaloDerecho stamp: 'LK 9/25/2023 19:10:22'!
PASSED!

!testRun: #PenalesTest #test07ArqueroNoPuedeMeterseAbajoDeLaTierra stamp: 'LK 9/25/2023 19:10:22'!
PASSED!

!testRun: #PenalesTest #test08ArqueroNoPuedeSaltarPorEncimaDelTravesaño stamp: 'LK 9/25/2023 19:10:22'!
PASSED!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'LK 9/25/2023 19:10:22'!
ERROR!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'LK 9/25/2023 19:10:22'!
PASSED!

!testRun: #PenalesTest #test11MismasDireccionesSuficienteFuerzaAtajaArquero stamp: 'LK 9/25/2023 19:10:22'!
PASSED!

!testRun: #PenalesTest #test12DelanteroQueTiraAColocarPierde50PorcFuerza stamp: 'LK 9/25/2023 19:10:22'!
PASSED!

!testRun: #PenalesTest #test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra stamp: 'LK 9/25/2023 19:10:22'!
PASSED!

!testRun: #PenalesTest #test14FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAColocar stamp: 'LK 9/25/2023 19:10:22'!
PASSED!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'LK 9/25/2023 19:10:22'!
FAILURE!

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'LK 9/25/2023 19:10:22'!
FAILURE!

!testRun: #PenalesTest #test17ArqueroQueEligeAntesDeTiroVsPlayeraAColocarSuma100PorcFuerzaExtra stamp: 'LK 9/25/2023 19:10:22'!
FAILURE!

!testRun: #PenalesTest #test18FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsPlayeraAColocar stamp: 'LK 9/25/2023 19:10:22'!
FAILURE!

!testRun: #PenalesTest #test19ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAColocarEsDescubiertoYPuntoParaDelantero stamp: 'LK 9/25/2023 19:10:22'!
FAILURE!

!testRun: #PenalesTest #test20DelanteroTiraAMatarAlAnguloInferiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:10:22'!
ERROR!

!testRun: #PenalesTest #test21DelanteroTiraAMatarAlAnguloSuperiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:10:22'!
ERROR!

!testRun: #PenalesTest #test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:10:22'!
ERROR!

!testRun: #PenalesTest #test23DelanteroTiraAMatarAlAnguloSuperiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:10:22'!
ERROR!

!testRun: #PenalesTest #test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro stamp: 'LK 9/25/2023 19:10:22'!
ERROR!

!testRun: #PenalesTest #test25DelanteroTiraAMatarUsa100PorcFuerzaBase stamp: 'LK 9/25/2023 19:10:22'!
ERROR!

!testRun: #PenalesTest #test26DelanteroTiraAMatarConJabulaniGana20PorcFuerzaExtra stamp: 'LK 9/25/2023 19:10:22'!
ERROR!

!testRun: #PenalesTest #test27FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAMatar stamp: 'LK 9/25/2023 19:10:22'!
ERROR!

!testRun: #PenalesTest #test28ArqueroQueEligeAntesDeTiroVsJabulaniAMatarIgnoraAlturaTiro stamp: 'LK 9/25/2023 19:10:22'!
ERROR!

!testRun: #PenalesTest #test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja stamp: 'LK 9/25/2023 19:10:22'!
ERROR!

!testRun: #PenalesTest #test30DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAdentro stamp: 'LK 9/25/2023 19:10:22'!
ERROR!

!testRun: #PenalesTest #test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera stamp: 'LK 9/25/2023 19:10:22'!
ERROR!

!testRun: #PenalesTest #test32ArqueroQueEligeAntesDeTiroVsPlayeraAMatarAlAnguloIgnoraAnchoTiro stamp: 'LK 9/25/2023 19:10:22'!
ERROR!

!testRun: #PenalesTest #test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro stamp: 'LK 9/25/2023 19:10:22'!
ERROR!

!testRun: #PenalesTest #test34ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAMatarSiempreAtaja stamp: 'LK 9/25/2023 19:10:22'!
ERROR!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'LK 9/25/2023 19:10:28'!
ERROR!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'LK 9/25/2023 19:10:28'!
ERROR!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 19:12:28' prior: 50678283!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(self direccionEnRango: direccionTiro) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(self direccionEnRango: direccionArquero) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	(pelota tipo = #Jabulani) ifTrue: [
		
		(arquero tipo = #EsperaYAdelanta) ifTrue: [
				((direccionTiro) x = (direccionArquero x) & 
				self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro)
				 	ifTrue: [self sumarPuntoArquero].
					
				(direccionTiro = direccionArquero) & 
				(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro) 
					ifTrue: [self sumarPuntoDelantero].
					
			].
		
		(arquero tipo = #Elige) ifTrue: [
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro ))
					ifTrue: [self sumarPuntoArquero].
			
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro )) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
		].
	(pelota = #Playera) ifTrue: [].
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!classDefinition: #Penales category: 'ISW1-2023-2C-Parcial-1' stamp: 'LK 9/25/2023 19:15:15'!
Object subclass: #Penales
	instanceVariableNames: 'puntajeDelantero puntajeArquero direccionDelTiroDelantero direccionDelArquero delantero arquero penalPelota'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 19:15:13' prior: 50678541!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(self direccionEnRango: direccionTiro) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(self direccionEnRango: direccionArquero) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	(pelota tipo = #Jabulani) ifTrue: [
			penalPelota := #Jabulani.
		
		(arquero tipo = #EsperaYAdelanta) ifTrue: [
				((direccionTiro) x = (direccionArquero x) & 
				self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro)
				 	ifTrue: [self sumarPuntoArquero].
					
				(direccionTiro = direccionArquero) & 
				(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro) 
					ifTrue: [self sumarPuntoDelantero].
					
			].
		
		(arquero tipo = #Elige) ifTrue: [
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro ))
					ifTrue: [self sumarPuntoArquero].
			
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro )) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
		].
	(pelota = #Playera) ifTrue: [penalPelota := #Playera].
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 19:15:55' prior: 50675761!
varFuerzaResultanteDeTiro
	(penalPelota := #Playera) ifTrue: [^delantero fuerza * 0.8].
	^ delantero fuerza! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 19:17:00' prior: 50678658!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(self direccionEnRango: direccionTiro) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(self direccionEnRango: direccionArquero) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	(pelota tipo = #Jabulani) ifTrue: [
			penalPelota := #Jabulani.
		
		(arquero tipo = #EsperaYAdelanta) ifTrue: [
				((direccionTiro) x = (direccionArquero x) & 
				self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro)
				 	ifTrue: [self sumarPuntoArquero].
					
				(direccionTiro = direccionArquero) & 
				(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro) 
					ifTrue: [self sumarPuntoDelantero].
					
			].
		
		(arquero tipo = #Elige) ifTrue: [
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro ))
					ifTrue: [self sumarPuntoArquero].
			
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro )) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
		].
	(pelota = #Playera) ifTrue: [
			
			penalPelota := #Playera.
		
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro ))
					ifTrue: [self sumarPuntoArquero].
			
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro )) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'LK 9/25/2023 19:17:02'!
FAILURE!

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'LK 9/25/2023 19:20:09'!
FAILURE!

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'LK 9/25/2023 19:20:09'!
FAILURE!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 19:25:17' prior: 50674656!
initializeConDelantero: unDelantero yArquero: unArquero

	delantero := unDelantero.
	arquero :=  unArquero.
	puntajeDelantero := 0.
	puntajeArquero := 0.! !

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'LK 9/25/2023 19:26:43'!
PASSED!

!testRun: #PenalesTest #test02DelanteroNoPuedeApuntarHaciaAfueraDelPaloDerecho stamp: 'LK 9/25/2023 19:26:43'!
PASSED!

!testRun: #PenalesTest #test03DelanteroNoPuedeApuntarHaciaAbajoDelArco stamp: 'LK 9/25/2023 19:26:43'!
PASSED!

!testRun: #PenalesTest #test04DelanteroNoPuedeApuntarHaciaArribaDelTravesaño stamp: 'LK 9/25/2023 19:26:43'!
PASSED!

!testRun: #PenalesTest #test05ArqueroNoPuedePasarseDelPaloIzquierdo stamp: 'LK 9/25/2023 19:26:43'!
PASSED!

!testRun: #PenalesTest #test06ArqueroNoPuedePasarseDelPaloDerecho stamp: 'LK 9/25/2023 19:26:43'!
PASSED!

!testRun: #PenalesTest #test07ArqueroNoPuedeMeterseAbajoDeLaTierra stamp: 'LK 9/25/2023 19:26:43'!
PASSED!

!testRun: #PenalesTest #test08ArqueroNoPuedeSaltarPorEncimaDelTravesaño stamp: 'LK 9/25/2023 19:26:43'!
PASSED!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'LK 9/25/2023 19:26:43'!
ERROR!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'LK 9/25/2023 19:26:43'!
ERROR!

!testRun: #PenalesTest #test11MismasDireccionesSuficienteFuerzaAtajaArquero stamp: 'LK 9/25/2023 19:26:43'!
ERROR!

!testRun: #PenalesTest #test12DelanteroQueTiraAColocarPierde50PorcFuerza stamp: 'LK 9/25/2023 19:26:43'!
ERROR!

!testRun: #PenalesTest #test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra stamp: 'LK 9/25/2023 19:26:43'!
ERROR!

!testRun: #PenalesTest #test14FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAColocar stamp: 'LK 9/25/2023 19:26:43'!
ERROR!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'LK 9/25/2023 19:26:43'!
ERROR!

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'LK 9/25/2023 19:26:43'!
FAILURE!

!testRun: #PenalesTest #test17ArqueroQueEligeAntesDeTiroVsPlayeraAColocarSuma100PorcFuerzaExtra stamp: 'LK 9/25/2023 19:26:43'!
FAILURE!

!testRun: #PenalesTest #test18FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsPlayeraAColocar stamp: 'LK 9/25/2023 19:26:43'!
FAILURE!

!testRun: #PenalesTest #test19ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAColocarEsDescubiertoYPuntoParaDelantero stamp: 'LK 9/25/2023 19:26:43'!
FAILURE!

!testRun: #PenalesTest #test20DelanteroTiraAMatarAlAnguloInferiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:26:43'!
ERROR!

!testRun: #PenalesTest #test21DelanteroTiraAMatarAlAnguloSuperiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:26:43'!
ERROR!

!testRun: #PenalesTest #test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:26:43'!
ERROR!

!testRun: #PenalesTest #test23DelanteroTiraAMatarAlAnguloSuperiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:26:43'!
ERROR!

!testRun: #PenalesTest #test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro stamp: 'LK 9/25/2023 19:26:43'!
ERROR!

!testRun: #PenalesTest #test25DelanteroTiraAMatarUsa100PorcFuerzaBase stamp: 'LK 9/25/2023 19:26:43'!
ERROR!

!testRun: #PenalesTest #test26DelanteroTiraAMatarConJabulaniGana20PorcFuerzaExtra stamp: 'LK 9/25/2023 19:26:43'!
ERROR!

!testRun: #PenalesTest #test27FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAMatar stamp: 'LK 9/25/2023 19:26:43'!
ERROR!

!testRun: #PenalesTest #test28ArqueroQueEligeAntesDeTiroVsJabulaniAMatarIgnoraAlturaTiro stamp: 'LK 9/25/2023 19:26:43'!
ERROR!

!testRun: #PenalesTest #test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja stamp: 'LK 9/25/2023 19:26:43'!
ERROR!

!testRun: #PenalesTest #test30DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAdentro stamp: 'LK 9/25/2023 19:26:43'!
ERROR!

!testRun: #PenalesTest #test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera stamp: 'LK 9/25/2023 19:26:43'!
ERROR!

!testRun: #PenalesTest #test32ArqueroQueEligeAntesDeTiroVsPlayeraAMatarAlAnguloIgnoraAnchoTiro stamp: 'LK 9/25/2023 19:26:43'!
ERROR!

!testRun: #PenalesTest #test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro stamp: 'LK 9/25/2023 19:26:43'!
ERROR!

!testRun: #PenalesTest #test34ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAMatarSiempreAtaja stamp: 'LK 9/25/2023 19:26:43'!
ERROR!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'LK 9/25/2023 19:27:43'!
ERROR!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'LK 9/25/2023 19:27:43'!
ERROR!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 19:27:56' prior: 50678766!
varFuerzaResultanteDeTiro
	(penalPelota = #Playera) ifTrue: [^delantero fuerza * 0.8].
	^ delantero fuerza! !

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'LK 9/25/2023 19:27:59'!
PASSED!

!testRun: #PenalesTest #test02DelanteroNoPuedeApuntarHaciaAfueraDelPaloDerecho stamp: 'LK 9/25/2023 19:27:59'!
PASSED!

!testRun: #PenalesTest #test03DelanteroNoPuedeApuntarHaciaAbajoDelArco stamp: 'LK 9/25/2023 19:27:59'!
PASSED!

!testRun: #PenalesTest #test04DelanteroNoPuedeApuntarHaciaArribaDelTravesaño stamp: 'LK 9/25/2023 19:27:59'!
PASSED!

!testRun: #PenalesTest #test05ArqueroNoPuedePasarseDelPaloIzquierdo stamp: 'LK 9/25/2023 19:27:59'!
PASSED!

!testRun: #PenalesTest #test06ArqueroNoPuedePasarseDelPaloDerecho stamp: 'LK 9/25/2023 19:27:59'!
PASSED!

!testRun: #PenalesTest #test07ArqueroNoPuedeMeterseAbajoDeLaTierra stamp: 'LK 9/25/2023 19:27:59'!
PASSED!

!testRun: #PenalesTest #test08ArqueroNoPuedeSaltarPorEncimaDelTravesaño stamp: 'LK 9/25/2023 19:27:59'!
PASSED!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'LK 9/25/2023 19:27:59'!
ERROR!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'LK 9/25/2023 19:27:59'!
PASSED!

!testRun: #PenalesTest #test11MismasDireccionesSuficienteFuerzaAtajaArquero stamp: 'LK 9/25/2023 19:27:59'!
PASSED!

!testRun: #PenalesTest #test12DelanteroQueTiraAColocarPierde50PorcFuerza stamp: 'LK 9/25/2023 19:27:59'!
PASSED!

!testRun: #PenalesTest #test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra stamp: 'LK 9/25/2023 19:27:59'!
PASSED!

!testRun: #PenalesTest #test14FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAColocar stamp: 'LK 9/25/2023 19:27:59'!
PASSED!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'LK 9/25/2023 19:27:59'!
FAILURE!

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'LK 9/25/2023 19:27:59'!
FAILURE!

!testRun: #PenalesTest #test17ArqueroQueEligeAntesDeTiroVsPlayeraAColocarSuma100PorcFuerzaExtra stamp: 'LK 9/25/2023 19:27:59'!
FAILURE!

!testRun: #PenalesTest #test18FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsPlayeraAColocar stamp: 'LK 9/25/2023 19:27:59'!
FAILURE!

!testRun: #PenalesTest #test19ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAColocarEsDescubiertoYPuntoParaDelantero stamp: 'LK 9/25/2023 19:27:59'!
FAILURE!

!testRun: #PenalesTest #test20DelanteroTiraAMatarAlAnguloInferiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:27:59'!
ERROR!

!testRun: #PenalesTest #test21DelanteroTiraAMatarAlAnguloSuperiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:27:59'!
ERROR!

!testRun: #PenalesTest #test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:27:59'!
ERROR!

!testRun: #PenalesTest #test23DelanteroTiraAMatarAlAnguloSuperiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:27:59'!
ERROR!

!testRun: #PenalesTest #test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro stamp: 'LK 9/25/2023 19:27:59'!
ERROR!

!testRun: #PenalesTest #test25DelanteroTiraAMatarUsa100PorcFuerzaBase stamp: 'LK 9/25/2023 19:27:59'!
ERROR!

!testRun: #PenalesTest #test26DelanteroTiraAMatarConJabulaniGana20PorcFuerzaExtra stamp: 'LK 9/25/2023 19:27:59'!
ERROR!

!testRun: #PenalesTest #test27FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAMatar stamp: 'LK 9/25/2023 19:27:59'!
ERROR!

!testRun: #PenalesTest #test28ArqueroQueEligeAntesDeTiroVsJabulaniAMatarIgnoraAlturaTiro stamp: 'LK 9/25/2023 19:27:59'!
ERROR!

!testRun: #PenalesTest #test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja stamp: 'LK 9/25/2023 19:27:59'!
ERROR!

!testRun: #PenalesTest #test30DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAdentro stamp: 'LK 9/25/2023 19:27:59'!
ERROR!

!testRun: #PenalesTest #test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera stamp: 'LK 9/25/2023 19:27:59'!
ERROR!

!testRun: #PenalesTest #test32ArqueroQueEligeAntesDeTiroVsPlayeraAMatarAlAnguloIgnoraAnchoTiro stamp: 'LK 9/25/2023 19:27:59'!
ERROR!

!testRun: #PenalesTest #test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro stamp: 'LK 9/25/2023 19:27:59'!
ERROR!

!testRun: #PenalesTest #test34ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAMatarSiempreAtaja stamp: 'LK 9/25/2023 19:27:59'!
ERROR!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'LK 9/25/2023 19:28:02'!
ERROR!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 19:28:43' prior: 50678773!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(self direccionEnRango: direccionTiro) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(self direccionEnRango: direccionArquero) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	(pelota tipo = #Jabulani) ifTrue: [
			penalPelota := #Jabulani.
		
		(arquero tipo = #EsperaYAdelanta) ifTrue: [
				((direccionTiro) x = (direccionArquero x) & 
				(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro))
				 	ifTrue: [self sumarPuntoArquero].
					
				(direccionTiro = direccionArquero) & 
				(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro) 
					ifTrue: [self sumarPuntoDelantero].
					
			].
		
		(arquero tipo = #Elige) ifTrue: [
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro ))
					ifTrue: [self sumarPuntoArquero].
			
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro )) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
		].
	(pelota = #Playera) ifTrue: [
			
			penalPelota := #Playera.
		
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro ))
					ifTrue: [self sumarPuntoArquero].
			
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro )) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'LK 9/25/2023 19:28:44'!
PASSED!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'LK 9/25/2023 19:28:47'!
FAILURE!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'LK 9/25/2023 19:28:47'!
FAILURE!

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'LK 9/25/2023 19:28:52'!
PASSED!

!testRun: #PenalesTest #test02DelanteroNoPuedeApuntarHaciaAfueraDelPaloDerecho stamp: 'LK 9/25/2023 19:28:52'!
PASSED!

!testRun: #PenalesTest #test03DelanteroNoPuedeApuntarHaciaAbajoDelArco stamp: 'LK 9/25/2023 19:28:52'!
PASSED!

!testRun: #PenalesTest #test04DelanteroNoPuedeApuntarHaciaArribaDelTravesaño stamp: 'LK 9/25/2023 19:28:52'!
PASSED!

!testRun: #PenalesTest #test05ArqueroNoPuedePasarseDelPaloIzquierdo stamp: 'LK 9/25/2023 19:28:52'!
PASSED!

!testRun: #PenalesTest #test06ArqueroNoPuedePasarseDelPaloDerecho stamp: 'LK 9/25/2023 19:28:52'!
PASSED!

!testRun: #PenalesTest #test07ArqueroNoPuedeMeterseAbajoDeLaTierra stamp: 'LK 9/25/2023 19:28:52'!
PASSED!

!testRun: #PenalesTest #test08ArqueroNoPuedeSaltarPorEncimaDelTravesaño stamp: 'LK 9/25/2023 19:28:52'!
PASSED!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'LK 9/25/2023 19:28:52'!
PASSED!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'LK 9/25/2023 19:28:52'!
PASSED!

!testRun: #PenalesTest #test11MismasDireccionesSuficienteFuerzaAtajaArquero stamp: 'LK 9/25/2023 19:28:52'!
PASSED!

!testRun: #PenalesTest #test12DelanteroQueTiraAColocarPierde50PorcFuerza stamp: 'LK 9/25/2023 19:28:52'!
PASSED!

!testRun: #PenalesTest #test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra stamp: 'LK 9/25/2023 19:28:52'!
PASSED!

!testRun: #PenalesTest #test14FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAColocar stamp: 'LK 9/25/2023 19:28:52'!
PASSED!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'LK 9/25/2023 19:28:52'!
FAILURE!

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'LK 9/25/2023 19:28:52'!
FAILURE!

!testRun: #PenalesTest #test17ArqueroQueEligeAntesDeTiroVsPlayeraAColocarSuma100PorcFuerzaExtra stamp: 'LK 9/25/2023 19:28:52'!
FAILURE!

!testRun: #PenalesTest #test18FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsPlayeraAColocar stamp: 'LK 9/25/2023 19:28:52'!
FAILURE!

!testRun: #PenalesTest #test19ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAColocarEsDescubiertoYPuntoParaDelantero stamp: 'LK 9/25/2023 19:28:52'!
FAILURE!

!testRun: #PenalesTest #test20DelanteroTiraAMatarAlAnguloInferiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:28:52'!
ERROR!

!testRun: #PenalesTest #test21DelanteroTiraAMatarAlAnguloSuperiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:28:52'!
ERROR!

!testRun: #PenalesTest #test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:28:52'!
ERROR!

!testRun: #PenalesTest #test23DelanteroTiraAMatarAlAnguloSuperiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:28:52'!
ERROR!

!testRun: #PenalesTest #test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro stamp: 'LK 9/25/2023 19:28:52'!
ERROR!

!testRun: #PenalesTest #test25DelanteroTiraAMatarUsa100PorcFuerzaBase stamp: 'LK 9/25/2023 19:28:52'!
ERROR!

!testRun: #PenalesTest #test26DelanteroTiraAMatarConJabulaniGana20PorcFuerzaExtra stamp: 'LK 9/25/2023 19:28:52'!
ERROR!

!testRun: #PenalesTest #test27FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAMatar stamp: 'LK 9/25/2023 19:28:52'!
ERROR!

!testRun: #PenalesTest #test28ArqueroQueEligeAntesDeTiroVsJabulaniAMatarIgnoraAlturaTiro stamp: 'LK 9/25/2023 19:28:52'!
ERROR!

!testRun: #PenalesTest #test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja stamp: 'LK 9/25/2023 19:28:52'!
ERROR!

!testRun: #PenalesTest #test30DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAdentro stamp: 'LK 9/25/2023 19:28:52'!
ERROR!

!testRun: #PenalesTest #test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera stamp: 'LK 9/25/2023 19:28:52'!
ERROR!

!testRun: #PenalesTest #test32ArqueroQueEligeAntesDeTiroVsPlayeraAMatarAlAnguloIgnoraAnchoTiro stamp: 'LK 9/25/2023 19:28:52'!
ERROR!

!testRun: #PenalesTest #test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro stamp: 'LK 9/25/2023 19:28:52'!
ERROR!

!testRun: #PenalesTest #test34ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAMatarSiempreAtaja stamp: 'LK 9/25/2023 19:28:52'!
ERROR!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'LK 9/25/2023 19:28:56'!
FAILURE!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'LK 9/25/2023 19:28:56'!
FAILURE!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'LK 9/25/2023 19:30:24'!
FAILURE!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'LK 9/25/2023 19:30:24'!
FAILURE!

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'LK 9/25/2023 19:30:28'!
PASSED!

!testRun: #PenalesTest #test02DelanteroNoPuedeApuntarHaciaAfueraDelPaloDerecho stamp: 'LK 9/25/2023 19:30:28'!
PASSED!

!testRun: #PenalesTest #test03DelanteroNoPuedeApuntarHaciaAbajoDelArco stamp: 'LK 9/25/2023 19:30:28'!
PASSED!

!testRun: #PenalesTest #test04DelanteroNoPuedeApuntarHaciaArribaDelTravesaño stamp: 'LK 9/25/2023 19:30:28'!
PASSED!

!testRun: #PenalesTest #test05ArqueroNoPuedePasarseDelPaloIzquierdo stamp: 'LK 9/25/2023 19:30:28'!
PASSED!

!testRun: #PenalesTest #test06ArqueroNoPuedePasarseDelPaloDerecho stamp: 'LK 9/25/2023 19:30:28'!
PASSED!

!testRun: #PenalesTest #test07ArqueroNoPuedeMeterseAbajoDeLaTierra stamp: 'LK 9/25/2023 19:30:28'!
PASSED!

!testRun: #PenalesTest #test08ArqueroNoPuedeSaltarPorEncimaDelTravesaño stamp: 'LK 9/25/2023 19:30:28'!
PASSED!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'LK 9/25/2023 19:30:28'!
PASSED!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'LK 9/25/2023 19:30:28'!
PASSED!

!testRun: #PenalesTest #test11MismasDireccionesSuficienteFuerzaAtajaArquero stamp: 'LK 9/25/2023 19:30:28'!
PASSED!

!testRun: #PenalesTest #test12DelanteroQueTiraAColocarPierde50PorcFuerza stamp: 'LK 9/25/2023 19:30:28'!
PASSED!

!testRun: #PenalesTest #test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra stamp: 'LK 9/25/2023 19:30:28'!
PASSED!

!testRun: #PenalesTest #test14FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAColocar stamp: 'LK 9/25/2023 19:30:28'!
PASSED!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'LK 9/25/2023 19:30:28'!
FAILURE!

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'LK 9/25/2023 19:30:28'!
FAILURE!

!testRun: #PenalesTest #test17ArqueroQueEligeAntesDeTiroVsPlayeraAColocarSuma100PorcFuerzaExtra stamp: 'LK 9/25/2023 19:30:28'!
FAILURE!

!testRun: #PenalesTest #test18FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsPlayeraAColocar stamp: 'LK 9/25/2023 19:30:28'!
FAILURE!

!testRun: #PenalesTest #test19ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAColocarEsDescubiertoYPuntoParaDelantero stamp: 'LK 9/25/2023 19:30:28'!
FAILURE!

!testRun: #PenalesTest #test20DelanteroTiraAMatarAlAnguloInferiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:30:28'!
ERROR!

!testRun: #PenalesTest #test21DelanteroTiraAMatarAlAnguloSuperiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:30:28'!
ERROR!

!testRun: #PenalesTest #test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:30:28'!
ERROR!

!testRun: #PenalesTest #test23DelanteroTiraAMatarAlAnguloSuperiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:30:28'!
ERROR!

!testRun: #PenalesTest #test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro stamp: 'LK 9/25/2023 19:30:28'!
ERROR!

!testRun: #PenalesTest #test25DelanteroTiraAMatarUsa100PorcFuerzaBase stamp: 'LK 9/25/2023 19:30:28'!
ERROR!

!testRun: #PenalesTest #test26DelanteroTiraAMatarConJabulaniGana20PorcFuerzaExtra stamp: 'LK 9/25/2023 19:30:28'!
ERROR!

!testRun: #PenalesTest #test27FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAMatar stamp: 'LK 9/25/2023 19:30:28'!
ERROR!

!testRun: #PenalesTest #test28ArqueroQueEligeAntesDeTiroVsJabulaniAMatarIgnoraAlturaTiro stamp: 'LK 9/25/2023 19:30:28'!
ERROR!

!testRun: #PenalesTest #test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja stamp: 'LK 9/25/2023 19:30:28'!
ERROR!

!testRun: #PenalesTest #test30DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAdentro stamp: 'LK 9/25/2023 19:30:28'!
ERROR!

!testRun: #PenalesTest #test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera stamp: 'LK 9/25/2023 19:30:28'!
ERROR!

!testRun: #PenalesTest #test32ArqueroQueEligeAntesDeTiroVsPlayeraAMatarAlAnguloIgnoraAnchoTiro stamp: 'LK 9/25/2023 19:30:28'!
ERROR!

!testRun: #PenalesTest #test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro stamp: 'LK 9/25/2023 19:30:28'!
ERROR!

!testRun: #PenalesTest #test34ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAMatarSiempreAtaja stamp: 'LK 9/25/2023 19:30:28'!
ERROR!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 19:31:11' prior: 50679202!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(self direccionEnRango: direccionTiro) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(self direccionEnRango: direccionArquero) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	(pelota tipo = #Jabulani) ifTrue: [
			penalPelota := #Jabulani.
		
		(arquero tipo = #EsperaYAdelanta) ifTrue: [
				((direccionTiro) x = (direccionArquero x) & 
				(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro))
				 	ifTrue: [self sumarPuntoArquero]]
					
				ifFalse: [(direccionTiro = direccionArquero) & 
				(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro) 
					ifTrue: [self sumarPuntoDelantero].
					
			].
		
		(arquero tipo = #Elige) ifTrue: [
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro ))
					ifTrue: [self sumarPuntoArquero].
			
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro )) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
		].
	(pelota = #Playera) ifTrue: [
			
			penalPelota := #Playera.
		
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro ))
					ifTrue: [self sumarPuntoArquero].
			
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro )) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 19:31:48' prior: 50679056!
varFuerzaResultanteDeTiro

	(penalPelota = #Playera) ifTrue: [^delantero fuerza * 4/5].
	^ delantero fuerza! !

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'LK 9/25/2023 19:32:28'!
FAILURE!

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'LK 9/25/2023 19:32:28'!
FAILURE!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 19:33:32' prior: 50679622!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(self direccionEnRango: direccionTiro) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(self direccionEnRango: direccionArquero) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	(pelota tipo = #Jabulani) ifTrue: [
			penalPelota := #Jabulani.
		
		(arquero tipo = #EsperaYAdelanta) ifTrue: [
				((direccionTiro) x = (direccionArquero x) & 
				(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro))
				 	ifTrue: [self sumarPuntoArquero]]
					
				ifFalse: [(direccionTiro = direccionArquero) & 
				(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro) 
					ifTrue: [self sumarPuntoDelantero].
					
			].
		
		(arquero tipo = #Elige) ifTrue: [
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro ))
					ifTrue: [self sumarPuntoArquero].
			
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro )) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
		].
	(pelota = #Playera) ifTrue: [
			
			penalPelota := #Playera.
		
			(direccionTiro = direccionArquero & 
			self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro)
					ifTrue: [self sumarPuntoArquero].
			
			(direccionTiro = direccionArquero & 
			self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'LK 9/25/2023 19:33:35'!
FAILURE!

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'LK 9/25/2023 19:33:35'!
FAILURE!

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'LK 9/25/2023 19:34:42'!
PASSED!

!testRun: #PenalesTest #test02DelanteroNoPuedeApuntarHaciaAfueraDelPaloDerecho stamp: 'LK 9/25/2023 19:34:43'!
PASSED!

!testRun: #PenalesTest #test03DelanteroNoPuedeApuntarHaciaAbajoDelArco stamp: 'LK 9/25/2023 19:34:43'!
PASSED!

!testRun: #PenalesTest #test04DelanteroNoPuedeApuntarHaciaArribaDelTravesaño stamp: 'LK 9/25/2023 19:34:43'!
PASSED!

!testRun: #PenalesTest #test05ArqueroNoPuedePasarseDelPaloIzquierdo stamp: 'LK 9/25/2023 19:34:43'!
PASSED!

!testRun: #PenalesTest #test06ArqueroNoPuedePasarseDelPaloDerecho stamp: 'LK 9/25/2023 19:34:43'!
PASSED!

!testRun: #PenalesTest #test07ArqueroNoPuedeMeterseAbajoDeLaTierra stamp: 'LK 9/25/2023 19:34:43'!
PASSED!

!testRun: #PenalesTest #test08ArqueroNoPuedeSaltarPorEncimaDelTravesaño stamp: 'LK 9/25/2023 19:34:43'!
PASSED!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'LK 9/25/2023 19:34:43'!
PASSED!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'LK 9/25/2023 19:34:43'!
FAILURE!

!testRun: #PenalesTest #test11MismasDireccionesSuficienteFuerzaAtajaArquero stamp: 'LK 9/25/2023 19:34:43'!
PASSED!

!testRun: #PenalesTest #test12DelanteroQueTiraAColocarPierde50PorcFuerza stamp: 'LK 9/25/2023 19:34:43'!
PASSED!

!testRun: #PenalesTest #test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra stamp: 'LK 9/25/2023 19:34:43'!
PASSED!

!testRun: #PenalesTest #test14FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAColocar stamp: 'LK 9/25/2023 19:34:43'!
FAILURE!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'LK 9/25/2023 19:34:43'!
FAILURE!

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'LK 9/25/2023 19:34:43'!
FAILURE!

!testRun: #PenalesTest #test17ArqueroQueEligeAntesDeTiroVsPlayeraAColocarSuma100PorcFuerzaExtra stamp: 'LK 9/25/2023 19:34:43'!
FAILURE!

!testRun: #PenalesTest #test18FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsPlayeraAColocar stamp: 'LK 9/25/2023 19:34:43'!
FAILURE!

!testRun: #PenalesTest #test19ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAColocarEsDescubiertoYPuntoParaDelantero stamp: 'LK 9/25/2023 19:34:43'!
FAILURE!

!testRun: #PenalesTest #test20DelanteroTiraAMatarAlAnguloInferiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:34:43'!
ERROR!

!testRun: #PenalesTest #test21DelanteroTiraAMatarAlAnguloSuperiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:34:43'!
ERROR!

!testRun: #PenalesTest #test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:34:43'!
ERROR!

!testRun: #PenalesTest #test23DelanteroTiraAMatarAlAnguloSuperiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:34:43'!
ERROR!

!testRun: #PenalesTest #test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro stamp: 'LK 9/25/2023 19:34:43'!
ERROR!

!testRun: #PenalesTest #test25DelanteroTiraAMatarUsa100PorcFuerzaBase stamp: 'LK 9/25/2023 19:34:43'!
ERROR!

!testRun: #PenalesTest #test26DelanteroTiraAMatarConJabulaniGana20PorcFuerzaExtra stamp: 'LK 9/25/2023 19:34:43'!
ERROR!

!testRun: #PenalesTest #test27FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAMatar stamp: 'LK 9/25/2023 19:34:43'!
ERROR!

!testRun: #PenalesTest #test28ArqueroQueEligeAntesDeTiroVsJabulaniAMatarIgnoraAlturaTiro stamp: 'LK 9/25/2023 19:34:43'!
ERROR!

!testRun: #PenalesTest #test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja stamp: 'LK 9/25/2023 19:34:43'!
ERROR!

!testRun: #PenalesTest #test30DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAdentro stamp: 'LK 9/25/2023 19:34:43'!
ERROR!

!testRun: #PenalesTest #test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera stamp: 'LK 9/25/2023 19:34:43'!
ERROR!

!testRun: #PenalesTest #test32ArqueroQueEligeAntesDeTiroVsPlayeraAMatarAlAnguloIgnoraAnchoTiro stamp: 'LK 9/25/2023 19:34:43'!
ERROR!

!testRun: #PenalesTest #test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro stamp: 'LK 9/25/2023 19:34:43'!
ERROR!

!testRun: #PenalesTest #test34ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAMatarSiempreAtaja stamp: 'LK 9/25/2023 19:34:43'!
ERROR!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'LK 9/25/2023 19:34:52'!
FAILURE!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'LK 9/25/2023 19:35:03'!
FAILURE!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'LK 9/25/2023 19:35:03'!
FAILURE!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 19:36:37' prior: 50679757!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(self direccionEnRango: direccionTiro) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(self direccionEnRango: direccionArquero) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	(pelota tipo = #Jabulani) ifTrue: [
			penalPelota := #Jabulani.
		
		(arquero tipo = #EsperaYAdelanta) ifTrue: [
				((direccionTiro) x = (direccionArquero x) & 
				(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro))
				 	ifTrue: [self sumarPuntoArquero]]
					
				ifFalse: [(direccionTiro = direccionArquero) & 
				(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro) 
					ifTrue: [self sumarPuntoDelantero].
					
			].
		
		(arquero tipo = #Elige) ifTrue: [
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro ))
					ifTrue: [self sumarPuntoArquero].
			
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro )) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
		].
	(pelota = #Playera) ifTrue: [
			
			penalPelota := #Playera.
			
				
			(direccionTiro = direccionArquero & 
			self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro)
					ifTrue: [self sumarPuntoArquero].
			
			(direccionTiro = direccionArquero & 
			self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 19:37:37' prior: 50675756!
varFuerzaResultanteDeAtajada
	(penalPelota = #Playera & arquero tipo = #Elige) ifTrue: [^arquero fuerza * 2].
	^ arquero fuerza.! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 19:40:55' prior: 50680032!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(self direccionEnRango: direccionTiro) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(self direccionEnRango: direccionArquero) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	(pelota tipo = #Jabulani) ifTrue: [
			penalPelota := #Jabulani.
		
		(arquero tipo = #EsperaYAdelanta) ifTrue: [
				((direccionTiro) x = (direccionArquero x) & 
				(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro))
				 	ifTrue: [self sumarPuntoArquero]]
					
				ifFalse: [(direccionTiro = direccionArquero) & 
				(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro) 
					ifTrue: [self sumarPuntoDelantero].
					
			].
		
		(arquero tipo = #Elige) ifTrue: [
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro ))
					ifTrue: [self sumarPuntoArquero].
			
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro )) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
		].
	(pelota = #Playera) ifTrue: [
			
			penalPelota := #Playera.
			
			(arquero tipo = #Elige) ifTrue: [
				
				(direccionTiro = direccionArquero & 
				self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro)
					ifTrue: [self sumarPuntoArquero].
			
				(direccionTiro = direccionArquero & 
				self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
			(arquero tipo = #EsperaYadelanta) ifTrue: [self sumarPuntoDelantero].
				
		].
			
		
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 19:41:56' prior: 50674401!
varDireccionRemateResultante

	
	^direccionDelTiroDelantero .! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 19:42:27' prior: 50680282!
varDireccionRemateResultante

	(direccionDelTiroDelantero = 0@0) ifTrue: [^0@1.].
	^direccionDelTiroDelantero .! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 19:42:29' prior: 50680288!
varDireccionRemateResultante

	(direccionDelTiroDelantero = 0@0) ifTrue: [^0@1].
	^direccionDelTiroDelantero .! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 19:44:00' prior: 50680295!
varDireccionRemateResultante

	(direccionDelTiroDelantero = 0@0) ifTrue: [^0@1].
	(direccionDelTiroDelantero = 0@2) ifTrue: [^0@1].
	(direccionDelTiroDelantero = 2@0) ifTrue: [^2@1].
	^direccionDelTiroDelantero .! !

!testRun: #PenalesTest #test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:44:01'!
ERROR!

!testRun: #PenalesTest #test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:44:01'!
ERROR!
!Delantero class methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 19:45:07'!
decideTirarAMatarSuFuerzaBaseEs: d
	^self new initializeDecideTirarAMatarSuFuerzaBaseEs: d! !
!Delantero class methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 19:45:23' prior: 50680320!
decideTirarAMatarSuFuerzaBaseEs: fuerzaJugador
	^self new initializeDecideTirarAMatarSuFuerzaBaseEs: fuerzaJugador ! !
!Delantero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 19:45:40'!
initializeDecideTirarAMatarSuFuerzaBaseEs: fuerzaJugador
	
	tipo := #AMatar.

	fuerza := fuerzaJugador.! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 19:46:47' prior: 50680302!
varDireccionRemateResultante
	
	(delantero tipo = #AMatar) ifTrue:[
		
		(direccionDelTiroDelantero = 0@0) ifTrue: [^0@1].
		(direccionDelTiroDelantero = 0@2) ifTrue: [^0@1].
		(direccionDelTiroDelantero = 2@0) ifTrue: [^2@1].
		(direccionDelTiroDelantero = 2@2) ifTrue: [^2@1].
	].

	^direccionDelTiroDelantero .! !

!testRun: #PenalesTest #test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:46:51'!
ERROR!

!testRun: #PenalesTest #test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:46:51'!
ERROR!
!Delantero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 19:47:16'!
tipo
	^tipo.! !

!testRun: #PenalesTest #test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:47:30'!
ERROR!

!testRun: #PenalesTest #test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:47:30'!
ERROR!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 19:48:51' prior: 50680341!
varDireccionRemateResultante
	
	(delantero tipo = #AMatar) ifTrue: [
		
		(direccionDelTiroDelantero = (0@0)) ifTrue: [^0@1].
		(direccionDelTiroDelantero = (0@2)) ifTrue: [^0@1].
		(direccionDelTiroDelantero = (2@0)) ifTrue: [^2@1].
		(direccionDelTiroDelantero = (2@2)) ifTrue: [^2@1].
	].

	^direccionDelTiroDelantero .! !

!testRun: #PenalesTest #test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:48:53'!
PASSED!

!testRun: #PenalesTest #test25DelanteroTiraAMatarUsa100PorcFuerzaBase stamp: 'LK 9/25/2023 19:49:53'!
FAILURE!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 19:51:16' prior: 50679741!
varFuerzaResultanteDeTiro

	(penalPelota = #Playera) ifTrue: [^delantero fuerza * 4/5].
	(penalPelota = #Jabulani & delantero tipo = #AMatar) ifTrue: [^delantero fuerza * 1.2].
	^ delantero fuerza! !

!testRun: #PenalesTest #test26DelanteroTiraAMatarConJabulaniGana20PorcFuerzaExtra stamp: 'LK 9/25/2023 19:51:19'!
FAILURE!

!testRun: #PenalesTest #test26DelanteroTiraAMatarConJabulaniGana20PorcFuerzaExtra stamp: 'LK 9/25/2023 19:51:19'!
FAILURE!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 19:53:25' prior: 50680159!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(self direccionEnRango: direccionTiro) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(self direccionEnRango: direccionArquero) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	(pelota tipo = #Jabulani) ifTrue: [
			penalPelota := #Jabulani.
			
		(delantero tipo = #AMatar) ifTrue: [self sumarPuntoDelantero].
		
		(arquero tipo = #EsperaYAdelanta) ifTrue: [
				((direccionTiro) x = (direccionArquero x) & 
				(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro))
				 	ifTrue: [self sumarPuntoArquero]]
					
				ifFalse: [(direccionTiro = direccionArquero) & 
				(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro) 
					ifTrue: [self sumarPuntoDelantero].
					
			].
		
		(arquero tipo = #Elige) ifTrue: [
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro ))
					ifTrue: [self sumarPuntoArquero].
			
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro )) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
		].
	(pelota = #Playera) ifTrue: [
			
			penalPelota := #Playera.
			
			(arquero tipo = #Elige) ifTrue: [
				
				(direccionTiro = direccionArquero & 
				self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro)
					ifTrue: [self sumarPuntoArquero].
			
				(direccionTiro = direccionArquero & 
				self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
			(arquero tipo = #EsperaYadelanta) ifTrue: [self sumarPuntoDelantero].
				
		].
			
		
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

Pelota subclass: #Jabulani
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classDefinition: #Jabulani category: 'ISW1-2023-2C-Parcial-1' stamp: 'LK 9/25/2023 19:59:38'!
Pelota subclass: #Jabulani
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

Pelota subclass: #Playera
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classDefinition: #Playera category: 'ISW1-2023-2C-Parcial-1' stamp: 'LK 9/25/2023 19:59:43'!
Pelota subclass: #Playera
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

Object subclass: #Pelota
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classDefinition: #Pelota category: 'ISW1-2023-2C-Parcial-1' stamp: 'LK 9/25/2023 19:59:48'!
Object subclass: #Pelota
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!
!Playera methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:00:01' overrides: 50675917!
initializePlayeraLentaCostaAzul
	
	tipo := #Playera.! !

!methodRemoval: Pelota #initializePlayeraLentaCostaAzul stamp: 'LK 9/25/2023 20:00:01'!
initializePlayeraLentaCostaAzul
	
	tipo := #Playera.!
!Jabulani methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:00:09' overrides: 50673774!
initializeJabulaniSudafricanaRapida
	
	tipo := #Jabulani.! !

!methodRemoval: Pelota #initializeJabulaniSudafricanaRapida stamp: 'LK 9/25/2023 20:00:09'!
initializeJabulaniSudafricanaRapida
	
	tipo := #Jabulani.!

!methodRemoval: Pelota #tipo stamp: 'LK 9/25/2023 20:00:15'!
tipo
	^tipo!
!Jabulani class methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:00:36' overrides: 50673950!
jabulaniSudafricanaRapida
	^self new initializeJabulaniSudafricanaRapida! !

!methodRemoval: Pelota class #jabulaniSudafricanaRapida stamp: 'LK 9/25/2023 20:00:36'!
jabulaniSudafricanaRapida
	^self new initializeJabulaniSudafricanaRapida!
!Playera class methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:00:49' overrides: 50675912!
playeraLentaCostaAzul
	^self new initializePlayeraLentaCostaAzul! !

!methodRemoval: Pelota class #playeraLentaCostaAzul stamp: 'LK 9/25/2023 20:00:49'!
playeraLentaCostaAzul
	^self new initializePlayeraLentaCostaAzul!

Delantero subclass: #AMatar
	instanceVariableNames: 'fuerza tipo'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

Delantero subclass: #AMatar
	instanceVariableNames: 'fuerza'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

Delantero subclass: #AMatar
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classDefinition: #AMatar category: 'ISW1-2023-2C-Parcial-1' stamp: 'LK 9/25/2023 20:01:27'!
Delantero subclass: #AMatar
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

Object subclass: #Delantero
	instanceVariableNames: 'fuerza'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classDefinition: #Delantero category: 'ISW1-2023-2C-Parcial-1' stamp: 'LK 9/25/2023 20:01:31'!
Object subclass: #Delantero
	instanceVariableNames: 'fuerza'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!methodRemoval: Delantero #tipo stamp: 'LK 9/25/2023 20:01:36'!
tipo
	^tipo.!
!Delantero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:02:01' prior: 50676219!
initializeDecideTirarAColocarSuFuerzaBaseEs: fuerzaJugador

	fuerza := fuerzaJugador / 2.! !
!Delantero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:02:06' prior: 50680334!
initializeDecideTirarAMatarSuFuerzaBaseEs: fuerzaJugador
	
	fuerza := fuerzaJugador.! !

Delantero subclass: #AColocar
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classDefinition: #AColocar category: 'ISW1-2023-2C-Parcial-1' stamp: 'LK 9/25/2023 20:02:15'!
Delantero subclass: #AColocar
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!
!AColocar methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:02:37' overrides: 50680655!
initializeDecideTirarAColocarSuFuerzaBaseEs: fuerzaJugador

	fuerza := fuerzaJugador / 2.! !

!methodRemoval: Delantero #initializeDecideTirarAColocarSuFuerzaBaseEs: stamp: 'LK 9/25/2023 20:02:37'!
initializeDecideTirarAColocarSuFuerzaBaseEs: fuerzaJugador

	fuerza := fuerzaJugador / 2.!
!AMatar methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:02:49' overrides: 50680661!
initializeDecideTirarAMatarSuFuerzaBaseEs: fuerzaJugador
	
	fuerza := fuerzaJugador.! !

!methodRemoval: Delantero #initializeDecideTirarAMatarSuFuerzaBaseEs: stamp: 'LK 9/25/2023 20:02:49'!
initializeDecideTirarAMatarSuFuerzaBaseEs: fuerzaJugador
	
	fuerza := fuerzaJugador.!
!Delantero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:05:15' prior: 50673476!
fuerza
	self subclassResponsibility ! !
!AMatar methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:08:44' overrides: 50680703!
fuerza
	^fuerza * 1.2! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 20:10:46' prior: 50680415!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(self direccionEnRango: direccionTiro) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(self direccionEnRango: direccionArquero) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	(direccionTiro = direccionArquero) ifTrue: [].
	
	
	
	(pelota tipo = #Jabulani) ifTrue: [
			penalPelota := #Jabulani.
			
		(delantero tipo = #AMatar) ifTrue: [self sumarPuntoDelantero].
		
		(arquero tipo = #EsperaYAdelanta) ifTrue: [
				((direccionTiro) x = (direccionArquero x) & 
				(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro))
				 	ifTrue: [self sumarPuntoArquero]]
					
				ifFalse: [(direccionTiro = direccionArquero) & 
				(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro) 
					ifTrue: [self sumarPuntoDelantero].
					
			].
		
		(arquero tipo = #Elige) ifTrue: [
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro ))
					ifTrue: [self sumarPuntoArquero].
			
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro )) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
		].
	(pelota = #Playera) ifTrue: [
			
			penalPelota := #Playera.
			
			(arquero tipo = #Elige) ifTrue: [
				
				(direccionTiro = direccionArquero & 
				self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro)
					ifTrue: [self sumarPuntoArquero].
			
				(direccionTiro = direccionArquero & 
				self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
			(arquero tipo = #EsperaYadelanta) ifTrue: [self sumarPuntoDelantero].
				
		].
			
		
	
	
	
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 20:10:51' prior: 50680712!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(self direccionEnRango: direccionTiro) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(self direccionEnRango: direccionArquero) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	(direccionTiro = direccionArquero) ifTrue: [].
	
	(pelota tipo = #Jabulani) ifTrue: [
			penalPelota := #Jabulani.
			
		(delantero tipo = #AMatar) ifTrue: [self sumarPuntoDelantero].
		
		(arquero tipo = #EsperaYAdelanta) ifTrue: [
				((direccionTiro) x = (direccionArquero x) & 
				(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro))
				 	ifTrue: [self sumarPuntoArquero]]
					
				ifFalse: [(direccionTiro = direccionArquero) & 
				(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro) 
					ifTrue: [self sumarPuntoDelantero].
					
			].
		
		(arquero tipo = #Elige) ifTrue: [
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro ))
					ifTrue: [self sumarPuntoArquero].
			
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro )) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
		].
	(pelota = #Playera) ifTrue: [
			
			penalPelota := #Playera.
			
			(arquero tipo = #Elige) ifTrue: [
				
				(direccionTiro = direccionArquero & 
				self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro)
					ifTrue: [self sumarPuntoArquero].
			
				(direccionTiro = direccionArquero & 
				self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
			(arquero tipo = #EsperaYadelanta) ifTrue: [self sumarPuntoDelantero].
				
		].
			
		
	
	
	
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 20:14:43' prior: 50680151!
varFuerzaResultanteDeAtajada
	^penalPelota verFuerzaConFuerzaDeArquero: arquero.
	
	
"	(penalPelota = #Playera & arquero tipo = #Elige) ifTrue: [^arquero fuerza * 2].
	^ arquero fuerza."! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 20:14:58' prior: 50680966!
varFuerzaResultanteDeAtajada
	^penalPelota verFuerzaConArquero: arquero.
	
	
"	(penalPelota = #Playera & arquero tipo = #Elige) ifTrue: [^arquero fuerza * 2].
	^ arquero fuerza."! !
!Jabulani methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:15:54'!
verFuerzaConArquero: unArquero
	^unArquero fuerzaResultanteContraJabulani.! !

Arquero subclass: #EsperaYAdelanta
	instanceVariableNames: 'fuerza tipo'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

Arquero subclass: #EsperaYAdelanta
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classDefinition: #EsperaYAdelanta category: 'ISW1-2023-2C-Parcial-1' stamp: 'LK 9/25/2023 20:16:35'!
Arquero subclass: #EsperaYAdelanta
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

Arquero subclass: #Elige
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classDefinition: #Elige category: 'ISW1-2023-2C-Parcial-1' stamp: 'LK 9/25/2023 20:16:40'!
Arquero subclass: #Elige
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

Object subclass: #Arquero
	instanceVariableNames: 'fuerza'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classDefinition: #Arquero category: 'ISW1-2023-2C-Parcial-1' stamp: 'LK 9/25/2023 20:16:45'!
Object subclass: #Arquero
	instanceVariableNames: 'fuerza'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!
!Arquero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:17:12' prior: 50677081!
initializeEsperaPorTiroYSeAdelantaSuFuerzaBaseEs: fuerzaArquero
	fuerza := fuerzaArquero! !
!Arquero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:17:24' prior: 50677088!
initializeEligeDireccionAntesDeTiroSuFuerzaBaseEs: fuerzaArquero

	fuerza := fuerzaArquero * 1.5! !

!methodRemoval: Arquero #tipo stamp: 'LK 9/25/2023 20:17:37'!
tipo
	^tipo!
!Arquero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:18:16'!
fuerzaResultanteContraJabulani
	self subclassResponsibility ! !
!EsperaYAdelanta methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:18:20' overrides: 50681044!
fuerzaResultanteContraJabulani
	self subclassResponsibility ! !
!Elige methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:18:21' overrides: 50681044!
fuerzaResultanteContraJabulani
	self subclassResponsibility ! !
!Arquero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:18:21' prior: 50681044!
fuerzaResultanteContraJabulani

	self subclassResponsibility! !
!Arquero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:18:48'!
fuerzaResultanteContraPlayera

	self subclassResponsibility! !
!EsperaYAdelanta methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:18:54' overrides: 50681065!
fuerzaResultanteContraPlayera

	self subclassResponsibility! !
!Elige methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:18:54' overrides: 50681065!
fuerzaResultanteContraPlayera

	self subclassResponsibility! !
!Arquero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:18:54' prior: 50681065!
fuerzaResultanteContraPlayera

	self subclassResponsibility! !
!Elige methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:19:44' prior: 50681076 overrides: 50681081!
fuerzaResultanteContraPlayera

	^fuerza * 2! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 20:20:09' prior: 50680975!
varFuerzaResultanteDeAtajada
	^penalPelota verFuerzaConArquero: arquero.
	
	! !
!Elige methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:20:24' prior: 50681055 overrides: 50681060!
fuerzaResultanteContraJabulani
	^fuerza! !
!EsperaYAdelanta methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:20:35' prior: 50681071 overrides: 50681081!
fuerzaResultanteContraPlayera

	^fuerza! !
!EsperaYAdelanta methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:20:40' prior: 50681050 overrides: 50681060!
fuerzaResultanteContraJabulani
	
	
	^fuerza! !
!Elige methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:20:47' prior: 50681098 overrides: 50681060!
fuerzaResultanteContraJabulani

	^fuerza! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 20:21:30' prior: 50680397!
varFuerzaResultanteDeTiro
	^penalPelota verFuerzaConTirador: delantero.
	"
	(penalPelota = #Playera) ifTrue: [^delantero fuerza * 4/5].
	(penalPelota = #Jabulani & delantero tipo = #AMatar) ifTrue: [^delantero fuerza * 1.2].
	^ delantero fuerza"! !
!Pelota methodsFor: 'nil' stamp: 'LK 9/25/2023 20:21:48'!
verFuerzaConTirador! !
!Jabulani methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:21:53' overrides: 50681130!
verFuerzaConTirador! !
!Playera methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:21:54' overrides: 50681130!
verFuerzaConTirador! !
!Pelota methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:21:54' prior: 50681130!
verFuerzaConTirador

	self subclassResponsibility! !
!Pelota methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:22:23'!
verFuerzaConTirador: unTirador

	self subclassResponsibility! !

!methodRemoval: Pelota #verFuerzaConTirador stamp: 'LK 9/25/2023 20:22:24'!
verFuerzaConTirador

	self subclassResponsibility!
!Jabulani methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:22:49' overrides: 50681146!
verFuerzaConTirador: unTirador! !

!methodRemoval: Jabulani #verFuerzaConTirador stamp: 'LK 9/25/2023 20:22:51'!
verFuerzaConTirador!
!Playera methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:22:56' overrides: 50681146!
verFuerzaConTirador: unTirador! !

!methodRemoval: Playera #verFuerzaConTirador stamp: 'LK 9/25/2023 20:22:58'!
verFuerzaConTirador!
!Playera methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:23:48' prior: 50681163 overrides: 50681146!
verFuerzaConTirador: unTirador
	^unTirador fuerzaResultanteConPlayera.! !
!Jabulani methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:24:07' prior: 50681155 overrides: 50681146!
verFuerzaConTirador: unTirador
	^unTirador fuerzaResultanteConJabulani.! !
!Delantero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:24:27'!
fuerzaResultanteConJabulani! !
!Delantero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:24:34'!
fuerzaResultanteConPlayera! !
!AMatar methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:24:42' overrides: 50681182!
fuerzaResultanteConJabulani! !
!AColocar methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:24:42' overrides: 50681182!
fuerzaResultanteConJabulani! !
!Delantero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:24:42' prior: 50681182!
fuerzaResultanteConJabulani

	self subclassResponsibility! !
!AMatar methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:24:46' overrides: 50681186!
fuerzaResultanteConPlayera! !
!AColocar methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:24:46' overrides: 50681186!
fuerzaResultanteConPlayera! !
!Delantero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:24:46' prior: 50681186!
fuerzaResultanteConPlayera

	self subclassResponsibility! !
!AMatar methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:25:17' prior: 50681190 overrides: 50681198!
fuerzaResultanteConJabulani
	^fuerza * 1.2! !
!AMatar methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:25:54' prior: 50681203 overrides: 50681211!
fuerzaResultanteConPlayera
	^fuerza * 0.8! !
!AColocar methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:26:15' prior: 50681207 overrides: 50681211!
fuerzaResultanteConPlayera
	^fuerza * 4/5! !
!AMatar methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:26:21' prior: 50681222 overrides: 50681211!
fuerzaResultanteConPlayera
	^fuerza * 4/5! !
!AMatar methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:26:31' prior: 50680708 overrides: 50680703!
fuerza
	^fuerza! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 20:27:26' prior: 50680375!
varDireccionRemateResultante
	
	^delantero direccionFinalDeTiroA: direccionDelTiroDelantero.
	"
	(delantero tipo = #AMatar) ifTrue: [
		
		(direccionDelTiroDelantero = (0@0)) ifTrue: [^0@1].
		(direccionDelTiroDelantero = (0@2)) ifTrue: [^0@1].
		(direccionDelTiroDelantero = (2@0)) ifTrue: [^2@1].
		(direccionDelTiroDelantero = (2@2)) ifTrue: [^2@1].
	].

	^direccionDelTiroDelantero ."! !
!Delantero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:28:08'!
direccionFinalDeTiroA: unaDireccion
	! !
!AMatar methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:28:11' overrides: 50681256!
direccionFinalDeTiroA: unaDireccion
	! !
!AColocar methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:28:12' overrides: 50681256!
direccionFinalDeTiroA: unaDireccion
	! !
!Delantero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:28:12' prior: 50681256!
direccionFinalDeTiroA: unaDireccion

	self subclassResponsibility! !
!AMatar methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:29:37' prior: 50681261 overrides: 50681271!
direccionFinalDeTiroA: unaDireccion

	(unaDireccion = (0@0) | unaDireccion = (0@2)) ifTrue : [^0@1].
	(unaDireccion = (2@0) | unaDireccion = (2@2)) ifTrue: [^2@1].
	^unaDireccion.! !
!AMatar methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:29:44' prior: 50681277 overrides: 50681271!
direccionFinalDeTiroA: unaDireccion

	(unaDireccion = (0@0) | unaDireccion = (0@2)) ifTrue: [^0@1].
	(unaDireccion = (2@0) | unaDireccion = (2@2)) ifTrue: [^2@1].
	^unaDireccion.! !
!AColocar methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:30:00' prior: 50681266 overrides: 50681271!
direccionFinalDeTiroA: unaDireccion
	
	^unaDireccion! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 20:30:08' prior: 50681120!
varFuerzaResultanteDeTiro

	^penalPelota verFuerzaConTirador: delantero.
! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 20:30:11' prior: 50681092!
varFuerzaResultanteDeAtajada

	^penalPelota verFuerzaConArquero: arquero.
	
	! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 20:30:17' prior: 50681241!
varDireccionRemateResultante
	
	^delantero direccionFinalDeTiroA: direccionDelTiroDelantero.
! !
!Playera methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:30:39' prior: 50680575!
initializePlayeraLentaCostaAzul! !
!Jabulani methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:30:44' prior: 50680585!
initializeJabulaniSudafricanaRapida! !
!EsperaYAdelanta methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:31:34' overrides: 50681030!
initializeEsperaPorTiroYSeAdelantaSuFuerzaBaseEs: fuerzaArquero
	fuerza := fuerzaArquero! !

!methodRemoval: Arquero #initializeEsperaPorTiroYSeAdelantaSuFuerzaBaseEs: stamp: 'LK 9/25/2023 20:31:34'!
initializeEsperaPorTiroYSeAdelantaSuFuerzaBaseEs: fuerzaArquero
	fuerza := fuerzaArquero!
!Elige methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:31:47' overrides: 50681036!
initializeEligeDireccionAntesDeTiroSuFuerzaBaseEs: fuerzaArquero

	fuerza := fuerzaArquero * 1.5! !

!methodRemoval: Arquero #initializeEligeDireccionAntesDeTiroSuFuerzaBaseEs: stamp: 'LK 9/25/2023 20:31:47'!
initializeEligeDireccionAntesDeTiroSuFuerzaBaseEs: fuerzaArquero

	fuerza := fuerzaArquero * 1.5!

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'LK 9/25/2023 20:32:46'!
ERROR!

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'LK 9/25/2023 20:32:46'!
ERROR!

Object subclass: #DelanteroConTactica
	instanceVariableNames: 'fuerza'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classDefinition: #DelanteroConTactica category: 'ISW1-2023-2C-Parcial-1' stamp: 'LK 9/25/2023 20:33:47'!
Object subclass: #DelanteroConTactica
	instanceVariableNames: 'fuerza'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

DelanteroConTactica subclass: #AColoccar
	instanceVariableNames: 'fuerza'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

DelanteroConTactica subclass: #AColoccar
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classDefinition: #AColoccar category: 'ISW1-2023-2C-Parcial-1' stamp: 'LK 9/25/2023 20:34:09'!
DelanteroConTactica subclass: #AColoccar
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

DelanteroConTactica subclass: #AMattar
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classDefinition: #AMattar category: 'ISW1-2023-2C-Parcial-1' stamp: 'LK 9/25/2023 20:34:17'!
DelanteroConTactica subclass: #AMattar
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!
!AColocar methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:34:36' prior: 50681194 overrides: 50681198!
fuerzaResultanteConJabulani
	^fuerza! !

!classRemoval: #AColoccar stamp: 'LK 9/25/2023 20:34:54'!
DelanteroConTactica subclass: #AColoccar
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classRemoval: #AMattar stamp: 'LK 9/25/2023 20:34:55'!
DelanteroConTactica subclass: #AMattar
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classRemoval: #DelanteroConTactica stamp: 'LK 9/25/2023 20:34:55'!
Object subclass: #DelanteroConTactica
	instanceVariableNames: 'fuerza'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classRenamed: #Delantero as: #DelanteroConTactica stamp: 'LK 9/25/2023 20:35:06'!
Smalltalk renameClassNamed: #Delantero as: #DelanteroConTactica!
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:35:06' prior: 50672341!
test05ArqueroNoPuedePasarseDelPaloIzquierdo
	
	| arquero delantero juegoPenales pelota |
	
	delantero := DelanteroConTactica decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	self 
		should: [ juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@0 arqueroSeLanzaEnDirección: -1@0.] 
		raise: Error
		withExceptionDo: [ :error |
			self assert: Penales direccionArqueroFueraDeRango equals: error messageText.
			self assert: 0 equals: juegoPenales puntajeDeDelantero.
			self assert: 0 equals: juegoPenales puntajeDeArquero.]
	! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:35:06' prior: 50672416!
test08ArqueroNoPuedeSaltarPorEncimaDelTravesaño
	
	| arquero delantero juegoPenales pelota |
	
	delantero := DelanteroConTactica decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	self 
		should: [ juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@0 arqueroSeLanzaEnDirección: 0@3.] 
		raise: Error
		withExceptionDo: [ :error |
			self assert: Penales direccionArqueroFueraDeRango equals: error messageText.
			self assert: 0 equals: juegoPenales puntajeDeDelantero.
			self assert: 0 equals: juegoPenales puntajeDeArquero.]
	! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:35:06' prior: 50672794!
test20DelanteroTiraAMatarAlAnguloInferiorIzquierdoLaAlturaDelTiroPasaAMedio
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"(tirar a matar no es tan preciso como tirar a colocar, hay desvios de altura. Sin embargo se usa el 100% de fuerza del jugador)"
	
	delantero := DelanteroConTactica decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@0 arqueroSeLanzaEnDirección: 0@0.
	.
	self assert: 0@1 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:35:07' prior: 50672291!
test03DelanteroNoPuedeApuntarHaciaAbajoDelArco
	
	| arquero delantero juegoPenales pelota |
	
	delantero := DelanteroConTactica decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	self 
		should: [ juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@-1 arqueroSeLanzaEnDirección: 0@0.] 
		raise: Error
		withExceptionDo: [ :error |
			self assert: Penales direccionTiroFueraDeRango equals: error messageText.
			self assert: 0 equals: juegoPenales puntajeDeDelantero.
			self assert: 0 equals: juegoPenales puntajeDeArquero.]
	! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:35:07' prior: 50673041!
test28ArqueroQueEligeAntesDeTiroVsJabulaniAMatarIgnoraAlturaTiro
	
	| arquero delantero juegoPenales pelota |
	
	"El Arquero que elige donde tirarse antes de un tiro de jabulani a matar, ignora la 2da coordenada (altura) al atajar..."		
	
	delantero := DelanteroConTactica decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@2 arqueroSeLanzaEnDirección: 0@0.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 0@1 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:35:07' prior: 50672614!
test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro
	
	| arquero delantero juegoPenales pelota |
	
	"La fuerza del Delantero se reduce en 50% siempre que tira a colocar... (no importa pelota, ni arquero)"
	"El Arquero que espera y se adelanta ante un tiro de jabulani a colocar ignora la 2da coordenada (altura) al atajar..."	
	"(al adelanterse encara la pelota antes de que su elevación se transforme en un problema)"
	
	delantero := DelanteroConTactica decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero  esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 50.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@2 arqueroSeLanzaEnDirección: 0@0.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 0@2 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:35:07' prior: 50673005!
test27FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAMatar
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' el Delantero usa el 100% de su fuerza... (no importa pelota, ni arquero)"
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"Si se tira 'a matar' usando la jabulani rápida, el Delantero gana un 20% de fuerza extra... (no importa arquero)"
	
	delantero := DelanteroConTactica decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 119.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@2 arqueroSeLanzaEnDirección: 2@1.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 2@1 equals: juegoPenales varDireccionRemateResultante.
	self assert: 120 equals: juegoPenales varFuerzaResultanteDeTiro.! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:35:07' prior: 50673224!
test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' el Delantero usa el 100% de su fuerza... (no importa pelota, ni arquero)"
	"Si se tira 'a matar' usando una pelota playera a una dirección que no es un ángulo, la 2da coordenada del remate (altura) suma 2, es decir sale volando producto de su liviandez (y que quiere retornar al mar). Si la pelota se va fuera del arco, el puntaje va al arquero... (no importa arquero)"
	"Si el arquero elige donde tirarse antes del tiro a matar de la pelota playera, ignora la 1ra coordenada del remate (ancho) al atajar..."
	"(con agacharse, quedarse parado, o saltar le alcanza...)"
	
	delantero := DelanteroConTactica decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 1@0 arqueroSeLanzaEnDirección: 0@2.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 1@2 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:35:07' prior: 50673187!
test32ArqueroQueEligeAntesDeTiroVsPlayeraAMatarAlAnguloIgnoraAnchoTiro
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' el Delantero usa el 100% de su fuerza... (no importa pelota, ni arquero)"
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"Si el arquero elige donde tirarse antes del tiro a matar de la pelota playera, ignora la 1ra coordenada del remate (ancho) al atajar..."
	"(con agacharse, quedarse parado, o saltar le alcanza...)"
	
	delantero := DelanteroConTactica decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@0 arqueroSeLanzaEnDirección: 2@1.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 0@1 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:35:07' prior: 50672241!
test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo
	
	| arquero delantero juegoPenales pelota |
	
	delantero := DelanteroConTactica decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	self 
		should: [ juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: -1@0 arqueroSeLanzaEnDirección: 0@0.] 
		raise: Error
		withExceptionDo: [ :error |
			self assert: Penales direccionTiroFueraDeRango equals: error messageText.
			self assert: 0 equals: juegoPenales puntajeDeDelantero.
			self assert: 0 equals: juegoPenales puntajeDeArquero.]
	! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:35:07' prior: 50672967!
test26DelanteroTiraAMatarConJabulaniGana20PorcFuerzaExtra
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' el Delantero usa el 100% de su fuerza... (no importa pelota, ni arquero)"
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"Si se tira 'a matar' usando la jabulani rápida, el Delantero gana un 20% de fuerza extra... (no importa arquero)"
	"(Jabulani a matar es la elección de los guerreros Z)"
	
	delantero := DelanteroConTactica decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 120.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@2 arqueroSeLanzaEnDirección: 2@1.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 2@1 equals: juegoPenales varDireccionRemateResultante.
	self assert: 120 equals: juegoPenales varFuerzaResultanteDeTiro.! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:35:07' prior: 50672366!
test06ArqueroNoPuedePasarseDelPaloDerecho
	
	| arquero delantero juegoPenales pelota |
	
	delantero := DelanteroConTactica decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	self 
		should: [ juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@0 arqueroSeLanzaEnDirección: 3@0.] 
		raise: Error
		withExceptionDo: [ :error |
			self assert: Penales direccionArqueroFueraDeRango equals: error messageText.
			self assert: 0 equals: juegoPenales puntajeDeDelantero.
			self assert: 0 equals: juegoPenales puntajeDeArquero.]
	! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:35:07' prior: 50672466!
test10MismasDireccionesInsuficienteFuerzaGolDelantero
	
	| arquero delantero juegoPenales pelota |
	
	"Caso general del juego..."
	
	delantero := DelanteroConTactica decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 10.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@2 arqueroSeLanzaEnDirección: 2@2.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 2@2 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:35:07' prior: 50672544!
test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra
	
	| arquero delantero juegoPenales pelota |
	
	"La fuerza del Delantero se reduce en 50% siempre que tira a colocar... (no importa pelota, ni arquero)"
	"El Arquero que elige donde tirarse antes de un tiro a colocar de jabulani gana 50% de su fuerza extra..."
	"(el arquero llega más cómodo y aprovecha mejor su fuerza)"
	
	delantero := DelanteroConTactica decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 34.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@2 arqueroSeLanzaEnDirección: 0@2.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 0@2 equals: juegoPenales varDireccionRemateResultante.
	self assert: 50 equals: juegoPenales varFuerzaResultanteDeTiro.
	self assert: 51 equals: juegoPenales varFuerzaResultanteDeAtajada.! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:35:07' prior: 50672878!
test23DelanteroTiraAMatarAlAnguloSuperiorDerechoLaAlturaDelTiroPasaAMedio
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"(tirar a matar no es tan preciso como tirar a colocar, hay desvios de altura. Sin embargo se usa el 100% de fuerza del jugador)"
	
	delantero := DelanteroConTactica decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@2 arqueroSeLanzaEnDirección: 2@2.
	
	self assert: 2@1 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:35:07' prior: 50672722!
test18FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsPlayeraAColocar
	
	| arquero delantero juegoPenales pelota |
	
	"La fuerza del Delantero se reduce en 50% siempre que tira a colocar... (no importa pelota, ni arquero)"
	"La humilde pelota playera le hace perder un 20% adicional de fuerza al delantero que la use para colocar... (no importa el arquero)"
	"Arquero que elige donde lanzarse antes de un remate de una pelota playera lenta a colocar, gana un 100% de su fuerza extra..."
	
	delantero := DelanteroConTactica decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 19.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@0 arqueroSeLanzaEnDirección: 0@0.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 0@0 equals: juegoPenales varDireccionRemateResultante.
	self assert: 40 equals: juegoPenales varFuerzaResultanteDeTiro.
	self assert: 38 equals: juegoPenales varFuerzaResultanteDeAtajada! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:35:07' prior: 50672441!
test09DireccionesDiferentesGolDelantero
	
	| arquero delantero juegoPenales pelota |
	
	"Caso general del juego..."
	
	delantero := DelanteroConTactica decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@2 arqueroSeLanzaEnDirección: 0@1.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 2@2 equals: juegoPenales varDireccionRemateResultante
	"varXXXX es por VAR, de 'Video Assistant Referee'"! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:35:07' prior: 50672316!
test04DelanteroNoPuedeApuntarHaciaArribaDelTravesaño
	
	| arquero delantero juegoPenales pelota |
	
	delantero := DelanteroConTactica decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	self 
		should: [ juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@3 arqueroSeLanzaEnDirección: 0@0.] 
		raise: Error
		withExceptionDo: [ :error |
			self assert: Penales direccionTiroFueraDeRango equals: error messageText.
			self assert: 0 equals: juegoPenales puntajeDeDelantero.
			self assert: 0 equals: juegoPenales puntajeDeArquero.]
	! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:35:07' prior: 50673100!
test30DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAdentro
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' el Delantero usa el 100% de su fuerza... (no importa pelota, ni arquero)"
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"Si se tira 'a matar' usando una pelota playera a una dirección que no es un ángulo, la 2da coordenada del remate (altura) suma 2, es decir sale volando producto de su liviandez (y que quiere retornar al mar). Si la pelota se va fuera del arco, el puntaje va al arquero... (no importa arquero)"
	"(y voló.. y me hizo volar... y yo volé de él...  pero acá por la arbolada... y el voló.. y se estrelló por acá por la pared...)"
	
	delantero := DelanteroConTactica decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 1@0 arqueroSeLanzaEnDirección: 1@0.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 1@2 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:35:07' prior: 50673266!
test34ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAMatarSiempreAtaja
	
	| arquero delantero juegoPenales pelota |
	
	"El Arquero que espera y se adelanta ante una pelota playera lenta a matar, siempre la ataja sin importar nada..."	
	"(como la pelota es taaaan lentaaa, el arquero se puede ir a tomar un cafe, verse una serie, volver y aún atajar la pelota habiendose tirado a cualquier lado. Pero igual es más rapida que cuando se la tira a colocar, donde indefectiblemente el arbitro lo detecta...)"
	
	delantero := DelanteroConTactica decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 1.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@2 arqueroSeLanzaEnDirección: 0@0.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 2@1 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:35:07' prior: 50672580!
test14FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAColocar
	
	| arquero delantero juegoPenales pelota |
	
	"La fuerza del Delantero se reduce en 50% siempre que tira a colocar... (no importa pelota, ni arquero)"
	"El Arquero que elige adonde tirarse antes de un tiro a colocar de jabulani gana 50% de su fuerza extra..."
	
	delantero := DelanteroConTactica decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 32.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@2 arqueroSeLanzaEnDirección: 0@2.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 0@2 equals: juegoPenales varDireccionRemateResultante.
	self assert: 50 equals: juegoPenales varFuerzaResultanteDeTiro.
	self assert: 48 equals: juegoPenales varFuerzaResultanteDeAtajada.! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:35:07' prior: 50672490!
test11MismasDireccionesSuficienteFuerzaAtajaArquero
	
	| arquero delantero juegoPenales pelota |
	
	"Caso general del juego..."
	
	delantero := DelanteroConTactica decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@2 arqueroSeLanzaEnDirección: 2@2.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 2@2 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:35:07' prior: 50672906!
test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"(tirar a matar no es tan preciso como tirar a colocar, hay desvios de altura. Sin embargo se usa el 100% de fuerza del jugador)"
	
	delantero := DelanteroConTactica decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 1@2 arqueroSeLanzaEnDirección: 1@1.

	self assert: 1@2 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:35:07' prior: 50672391!
test07ArqueroNoPuedeMeterseAbajoDeLaTierra
	
	| arquero delantero juegoPenales pelota |
	
	delantero := DelanteroConTactica decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	self 
		should: [ juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@0 arqueroSeLanzaEnDirección: 0@-1.] 
		raise: Error
		withExceptionDo: [ :error |
			self assert: Penales direccionArqueroFueraDeRango equals: error messageText.
			self assert: 0 equals: juegoPenales puntajeDeDelantero.
			self assert: 0 equals: juegoPenales puntajeDeArquero.]
	! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:35:07' prior: 50673145!
test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' el Delantero usa el 100% de su fuerza... (no importa pelota, ni arquero)"
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"Si se tira 'a matar' usando una pelota playera a una dirección que no es un ángulo, la 2da coordenada del remate (altura) suma 2, es decir sale volando producto de su liviandez (y que quiere retornar al mar). Si la pelota se va fuera del arco, el puntaje va al arquero... (no importa arquero)"
	"(El caso auspiciado por el Pipita...)"
	
	delantero := DelanteroConTactica decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@1 arqueroSeLanzaEnDirección: 0@0.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 0@3 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:35:08' prior: 50672266!
test02DelanteroNoPuedeApuntarHaciaAfueraDelPaloDerecho
	
	| arquero delantero juegoPenales pelota |
	
	delantero := DelanteroConTactica decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	self 
		should: [ juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 3@0 arqueroSeLanzaEnDirección: 0@0.] 
		raise: Error
		withExceptionDo: [ :error |
			self assert: Penales direccionTiroFueraDeRango equals: error messageText.
			self assert: 0 equals: juegoPenales puntajeDeDelantero.
			self assert: 0 equals: juegoPenales puntajeDeArquero.]
	! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:35:08' prior: 50672682!
test17ArqueroQueEligeAntesDeTiroVsPlayeraAColocarSuma100PorcFuerzaExtra
	
	| arquero delantero juegoPenales pelota |
	
	"La fuerza del Delantero se reduce en 50% siempre que tira a colocar... (no importa pelota, ni arquero)"
	"La humilde pelota playera le hace perder un 20% adicional de fuerza al delantero que la use para colocar... (no importa el arquero)"
	"Arquero que elige donde lanzarse antes de un remate de una pelota playera lenta a colocar, gana un 100% de su fuerza extra..."
	"(a quien madruga...)"
	
	delantero := DelanteroConTactica decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 20.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@0 arqueroSeLanzaEnDirección: 0@0.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 0@0 equals: juegoPenales varDireccionRemateResultante.
	self assert: 40 equals: juegoPenales varFuerzaResultanteDeTiro.
	self assert: 40 equals: juegoPenales varFuerzaResultanteDeAtajada! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:35:08' prior: 50672647!
test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero
	
	| arquero delantero juegoPenales pelota |
	
	"La fuerza del Delantero se reduce en 50% siempre que tira a colocar... (no importa pelota, ni arquero)"
	"La humilde pelota playera le hace perder un 20% de fuerza adicional al delantero que la use para colocar... (no importa el arquero)"
	"(no debería ser reglamentaria... al menos no es de trapo, nos responden)"
	
	delantero := DelanteroConTactica decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 1.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 1@2 arqueroSeLanzaEnDirección: 1@2.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 1@2 equals: juegoPenales varDireccionRemateResultante.
	self assert: 40 equals: juegoPenales varFuerzaResultanteDeTiro! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:35:08' prior: 50673068!
test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja
	
	| arquero delantero juegoPenales pelota |
	
	"El Arquero que espera a ver la dirección del remate de una pelota jabulani rápida a matar antes de lanzarse, nunca la ataja sin importar nada, siquiera que se adelantó..."	
	"(su poder era de más de 9000!! era impresionante, no podía moverme, sólo la ví pasar... f )"
	
	delantero := DelanteroConTactica decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 1@1 arqueroSeLanzaEnDirección: 1@1.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 1@1 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:35:08' prior: 50672514!
test12DelanteroQueTiraAColocarPierde50PorcFuerza
	
	| arquero delantero juegoPenales pelota |
	
	"La fuerza del Delantero se reduce en 50% siempre que tira a colocar... (no importa pelota, ni arquero)"
	"(delantero sacrificia potencia para ganar mayor precisión)"
	
	delantero := DelanteroConTactica decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 50.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@2 arqueroSeLanzaEnDirección: 2@2.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 2@2 equals: juegoPenales varDireccionRemateResultante.
	self assert: 50 equals: juegoPenales varFuerzaResultanteDeTiro.! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:35:08' prior: 50672822!
test21DelanteroTiraAMatarAlAnguloSuperiorIzquierdoLaAlturaDelTiroPasaAMedio
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"(tirar a matar no es tan preciso como tirar a colocar, hay desvios de altura. Sin embargo se usa el 100% de fuerza del jugador)"
	
	delantero := DelanteroConTactica decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@2 arqueroSeLanzaEnDirección: 0@2.
	
	self assert: 0@1 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:35:08' prior: 50672934!
test25DelanteroTiraAMatarUsa100PorcFuerzaBase
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"(tirar a matar no es tan preciso como tirar a colocar, hay desvios de altura. Sin embargo se usa el 100% de fuerza del jugador)"
	
	delantero := DelanteroConTactica decideTirarAMatarSuFuerzaBaseEs:150.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@0 arqueroSeLanzaEnDirección: 2@0.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 2@1 equals: juegoPenales varDireccionRemateResultante.
	self assert: 150 equals: juegoPenales varFuerzaResultanteDeTiro! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:35:08' prior: 50672850!
test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"(tirar a matar no es tan preciso como tirar a colocar, hay desvios de altura. Sin embargo se usa el 100% de fuerza del jugador)"
	
	delantero := DelanteroConTactica decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@0 arqueroSeLanzaEnDirección: 2@0.
	
	self assert: 2@1 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:35:08' prior: 50672761!
test19ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAColocarEsDescubiertoYPuntoParaDelantero
	
	| arquero delantero juegoPenales pelota |
	
	"Arquero que espera y se adelanta ante tiro con la lenta pelota playera, siempre es descubierto por el Árbitro, y el punto se le otorga al Delantero..."
	"(lo que servía de ventaja ante la Jabulani rápida, acá es tan obvio por lo que tarda en llegar la pelota al arco, que marchás preso...)"
	
	delantero := DelanteroConTactica decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero  esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@0 arqueroSeLanzaEnDirección: 0@0.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 0@0 equals: juegoPenales varDireccionRemateResultante! !

!classRenamed: #DelanteroConTactica as: #DelanteroConTacticaa stamp: 'LK 9/25/2023 20:36:01'!
Smalltalk renameClassNamed: #DelanteroConTactica as: #DelanteroConTacticaa!
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:36:01' prior: 50681434!
test05ArqueroNoPuedePasarseDelPaloIzquierdo
	
	| arquero delantero juegoPenales pelota |
	
	delantero := DelanteroConTacticaa decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	self 
		should: [ juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@0 arqueroSeLanzaEnDirección: -1@0.] 
		raise: Error
		withExceptionDo: [ :error |
			self assert: Penales direccionArqueroFueraDeRango equals: error messageText.
			self assert: 0 equals: juegoPenales puntajeDeDelantero.
			self assert: 0 equals: juegoPenales puntajeDeArquero.]
	! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:36:02' prior: 50681460!
test08ArqueroNoPuedeSaltarPorEncimaDelTravesaño
	
	| arquero delantero juegoPenales pelota |
	
	delantero := DelanteroConTacticaa decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	self 
		should: [ juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@0 arqueroSeLanzaEnDirección: 0@3.] 
		raise: Error
		withExceptionDo: [ :error |
			self assert: Penales direccionArqueroFueraDeRango equals: error messageText.
			self assert: 0 equals: juegoPenales puntajeDeDelantero.
			self assert: 0 equals: juegoPenales puntajeDeArquero.]
	! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:36:02' prior: 50681486!
test20DelanteroTiraAMatarAlAnguloInferiorIzquierdoLaAlturaDelTiroPasaAMedio
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"(tirar a matar no es tan preciso como tirar a colocar, hay desvios de altura. Sin embargo se usa el 100% de fuerza del jugador)"
	
	delantero := DelanteroConTacticaa decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@0 arqueroSeLanzaEnDirección: 0@0.
	.
	self assert: 0@1 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:36:02' prior: 50681516!
test03DelanteroNoPuedeApuntarHaciaAbajoDelArco
	
	| arquero delantero juegoPenales pelota |
	
	delantero := DelanteroConTacticaa decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	self 
		should: [ juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@-1 arqueroSeLanzaEnDirección: 0@0.] 
		raise: Error
		withExceptionDo: [ :error |
			self assert: Penales direccionTiroFueraDeRango equals: error messageText.
			self assert: 0 equals: juegoPenales puntajeDeDelantero.
			self assert: 0 equals: juegoPenales puntajeDeArquero.]
	! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:36:02' prior: 50681542!
test28ArqueroQueEligeAntesDeTiroVsJabulaniAMatarIgnoraAlturaTiro
	
	| arquero delantero juegoPenales pelota |
	
	"El Arquero que elige donde tirarse antes de un tiro de jabulani a matar, ignora la 2da coordenada (altura) al atajar..."		
	
	delantero := DelanteroConTacticaa decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@2 arqueroSeLanzaEnDirección: 0@0.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 0@1 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:36:02' prior: 50681570!
test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro
	
	| arquero delantero juegoPenales pelota |
	
	"La fuerza del Delantero se reduce en 50% siempre que tira a colocar... (no importa pelota, ni arquero)"
	"El Arquero que espera y se adelanta ante un tiro de jabulani a colocar ignora la 2da coordenada (altura) al atajar..."	
	"(al adelanterse encara la pelota antes de que su elevación se transforme en un problema)"
	
	delantero := DelanteroConTacticaa decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero  esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 50.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@2 arqueroSeLanzaEnDirección: 0@0.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 0@2 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:36:02' prior: 50681605!
test27FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAMatar
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' el Delantero usa el 100% de su fuerza... (no importa pelota, ni arquero)"
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"Si se tira 'a matar' usando la jabulani rápida, el Delantero gana un 20% de fuerza extra... (no importa arquero)"
	
	delantero := DelanteroConTacticaa decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 119.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@2 arqueroSeLanzaEnDirección: 2@1.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 2@1 equals: juegoPenales varDireccionRemateResultante.
	self assert: 120 equals: juegoPenales varFuerzaResultanteDeTiro.! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:36:02' prior: 50681643!
test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' el Delantero usa el 100% de su fuerza... (no importa pelota, ni arquero)"
	"Si se tira 'a matar' usando una pelota playera a una dirección que no es un ángulo, la 2da coordenada del remate (altura) suma 2, es decir sale volando producto de su liviandez (y que quiere retornar al mar). Si la pelota se va fuera del arco, el puntaje va al arquero... (no importa arquero)"
	"Si el arquero elige donde tirarse antes del tiro a matar de la pelota playera, ignora la 1ra coordenada del remate (ancho) al atajar..."
	"(con agacharse, quedarse parado, o saltar le alcanza...)"
	
	delantero := DelanteroConTacticaa decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 1@0 arqueroSeLanzaEnDirección: 0@2.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 1@2 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:36:02' prior: 50681686!
test32ArqueroQueEligeAntesDeTiroVsPlayeraAMatarAlAnguloIgnoraAnchoTiro
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' el Delantero usa el 100% de su fuerza... (no importa pelota, ni arquero)"
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"Si el arquero elige donde tirarse antes del tiro a matar de la pelota playera, ignora la 1ra coordenada del remate (ancho) al atajar..."
	"(con agacharse, quedarse parado, o saltar le alcanza...)"
	
	delantero := DelanteroConTacticaa decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@0 arqueroSeLanzaEnDirección: 2@1.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 0@1 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:36:02' prior: 50681724!
test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo
	
	| arquero delantero juegoPenales pelota |
	
	delantero := DelanteroConTacticaa decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	self 
		should: [ juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: -1@0 arqueroSeLanzaEnDirección: 0@0.] 
		raise: Error
		withExceptionDo: [ :error |
			self assert: Penales direccionTiroFueraDeRango equals: error messageText.
			self assert: 0 equals: juegoPenales puntajeDeDelantero.
			self assert: 0 equals: juegoPenales puntajeDeArquero.]
	! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:36:02' prior: 50681751!
test26DelanteroTiraAMatarConJabulaniGana20PorcFuerzaExtra
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' el Delantero usa el 100% de su fuerza... (no importa pelota, ni arquero)"
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"Si se tira 'a matar' usando la jabulani rápida, el Delantero gana un 20% de fuerza extra... (no importa arquero)"
	"(Jabulani a matar es la elección de los guerreros Z)"
	
	delantero := DelanteroConTacticaa decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 120.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@2 arqueroSeLanzaEnDirección: 2@1.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 2@1 equals: juegoPenales varDireccionRemateResultante.
	self assert: 120 equals: juegoPenales varFuerzaResultanteDeTiro.! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:36:02' prior: 50681790!
test06ArqueroNoPuedePasarseDelPaloDerecho
	
	| arquero delantero juegoPenales pelota |
	
	delantero := DelanteroConTacticaa decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	self 
		should: [ juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@0 arqueroSeLanzaEnDirección: 3@0.] 
		raise: Error
		withExceptionDo: [ :error |
			self assert: Penales direccionArqueroFueraDeRango equals: error messageText.
			self assert: 0 equals: juegoPenales puntajeDeDelantero.
			self assert: 0 equals: juegoPenales puntajeDeArquero.]
	! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:36:02' prior: 50681816!
test10MismasDireccionesInsuficienteFuerzaGolDelantero
	
	| arquero delantero juegoPenales pelota |
	
	"Caso general del juego..."
	
	delantero := DelanteroConTacticaa decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 10.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@2 arqueroSeLanzaEnDirección: 2@2.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 2@2 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:36:02' prior: 50681841!
test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra
	
	| arquero delantero juegoPenales pelota |
	
	"La fuerza del Delantero se reduce en 50% siempre que tira a colocar... (no importa pelota, ni arquero)"
	"El Arquero que elige donde tirarse antes de un tiro a colocar de jabulani gana 50% de su fuerza extra..."
	"(el arquero llega más cómodo y aprovecha mejor su fuerza)"
	
	delantero := DelanteroConTacticaa decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 34.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@2 arqueroSeLanzaEnDirección: 0@2.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 0@2 equals: juegoPenales varDireccionRemateResultante.
	self assert: 50 equals: juegoPenales varFuerzaResultanteDeTiro.
	self assert: 51 equals: juegoPenales varFuerzaResultanteDeAtajada.! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:36:02' prior: 50681878!
test23DelanteroTiraAMatarAlAnguloSuperiorDerechoLaAlturaDelTiroPasaAMedio
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"(tirar a matar no es tan preciso como tirar a colocar, hay desvios de altura. Sin embargo se usa el 100% de fuerza del jugador)"
	
	delantero := DelanteroConTacticaa decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@2 arqueroSeLanzaEnDirección: 2@2.
	
	self assert: 2@1 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:36:02' prior: 50681908!
test18FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsPlayeraAColocar
	
	| arquero delantero juegoPenales pelota |
	
	"La fuerza del Delantero se reduce en 50% siempre que tira a colocar... (no importa pelota, ni arquero)"
	"La humilde pelota playera le hace perder un 20% adicional de fuerza al delantero que la use para colocar... (no importa el arquero)"
	"Arquero que elige donde lanzarse antes de un remate de una pelota playera lenta a colocar, gana un 100% de su fuerza extra..."
	
	delantero := DelanteroConTacticaa decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 19.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@0 arqueroSeLanzaEnDirección: 0@0.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 0@0 equals: juegoPenales varDireccionRemateResultante.
	self assert: 40 equals: juegoPenales varFuerzaResultanteDeTiro.
	self assert: 38 equals: juegoPenales varFuerzaResultanteDeAtajada! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:36:02' prior: 50681948!
test09DireccionesDiferentesGolDelantero
	
	| arquero delantero juegoPenales pelota |
	
	"Caso general del juego..."
	
	delantero := DelanteroConTacticaa decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@2 arqueroSeLanzaEnDirección: 0@1.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 2@2 equals: juegoPenales varDireccionRemateResultante
	"varXXXX es por VAR, de 'Video Assistant Referee'"! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:36:02' prior: 50681974!
test04DelanteroNoPuedeApuntarHaciaArribaDelTravesaño
	
	| arquero delantero juegoPenales pelota |
	
	delantero := DelanteroConTacticaa decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	self 
		should: [ juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@3 arqueroSeLanzaEnDirección: 0@0.] 
		raise: Error
		withExceptionDo: [ :error |
			self assert: Penales direccionTiroFueraDeRango equals: error messageText.
			self assert: 0 equals: juegoPenales puntajeDeDelantero.
			self assert: 0 equals: juegoPenales puntajeDeArquero.]
	! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:36:02' prior: 50682000!
test30DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAdentro
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' el Delantero usa el 100% de su fuerza... (no importa pelota, ni arquero)"
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"Si se tira 'a matar' usando una pelota playera a una dirección que no es un ángulo, la 2da coordenada del remate (altura) suma 2, es decir sale volando producto de su liviandez (y que quiere retornar al mar). Si la pelota se va fuera del arco, el puntaje va al arquero... (no importa arquero)"
	"(y voló.. y me hizo volar... y yo volé de él...  pero acá por la arbolada... y el voló.. y se estrelló por acá por la pared...)"
	
	delantero := DelanteroConTacticaa decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 1@0 arqueroSeLanzaEnDirección: 1@0.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 1@2 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:36:02' prior: 50682046!
test34ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAMatarSiempreAtaja
	
	| arquero delantero juegoPenales pelota |
	
	"El Arquero que espera y se adelanta ante una pelota playera lenta a matar, siempre la ataja sin importar nada..."	
	"(como la pelota es taaaan lentaaa, el arquero se puede ir a tomar un cafe, verse una serie, volver y aún atajar la pelota habiendose tirado a cualquier lado. Pero igual es más rapida que cuando se la tira a colocar, donde indefectiblemente el arbitro lo detecta...)"
	
	delantero := DelanteroConTacticaa decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 1.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@2 arqueroSeLanzaEnDirección: 0@0.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 2@1 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:36:03' prior: 50682082!
test14FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAColocar
	
	| arquero delantero juegoPenales pelota |
	
	"La fuerza del Delantero se reduce en 50% siempre que tira a colocar... (no importa pelota, ni arquero)"
	"El Arquero que elige adonde tirarse antes de un tiro a colocar de jabulani gana 50% de su fuerza extra..."
	
	delantero := DelanteroConTacticaa decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 32.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@2 arqueroSeLanzaEnDirección: 0@2.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 0@2 equals: juegoPenales varDireccionRemateResultante.
	self assert: 50 equals: juegoPenales varFuerzaResultanteDeTiro.
	self assert: 48 equals: juegoPenales varFuerzaResultanteDeAtajada.! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:36:03' prior: 50682117!
test11MismasDireccionesSuficienteFuerzaAtajaArquero
	
	| arquero delantero juegoPenales pelota |
	
	"Caso general del juego..."
	
	delantero := DelanteroConTacticaa decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@2 arqueroSeLanzaEnDirección: 2@2.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 2@2 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:36:03' prior: 50682142!
test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"(tirar a matar no es tan preciso como tirar a colocar, hay desvios de altura. Sin embargo se usa el 100% de fuerza del jugador)"
	
	delantero := DelanteroConTacticaa decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 1@2 arqueroSeLanzaEnDirección: 1@1.

	self assert: 1@2 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:36:03' prior: 50682171!
test07ArqueroNoPuedeMeterseAbajoDeLaTierra
	
	| arquero delantero juegoPenales pelota |
	
	delantero := DelanteroConTacticaa decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	self 
		should: [ juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@0 arqueroSeLanzaEnDirección: 0@-1.] 
		raise: Error
		withExceptionDo: [ :error |
			self assert: Penales direccionArqueroFueraDeRango equals: error messageText.
			self assert: 0 equals: juegoPenales puntajeDeDelantero.
			self assert: 0 equals: juegoPenales puntajeDeArquero.]
	! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:36:03' prior: 50682197!
test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' el Delantero usa el 100% de su fuerza... (no importa pelota, ni arquero)"
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"Si se tira 'a matar' usando una pelota playera a una dirección que no es un ángulo, la 2da coordenada del remate (altura) suma 2, es decir sale volando producto de su liviandez (y que quiere retornar al mar). Si la pelota se va fuera del arco, el puntaje va al arquero... (no importa arquero)"
	"(El caso auspiciado por el Pipita...)"
	
	delantero := DelanteroConTacticaa decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@1 arqueroSeLanzaEnDirección: 0@0.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 0@3 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:36:03' prior: 50682240!
test02DelanteroNoPuedeApuntarHaciaAfueraDelPaloDerecho
	
	| arquero delantero juegoPenales pelota |
	
	delantero := DelanteroConTacticaa decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	self 
		should: [ juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 3@0 arqueroSeLanzaEnDirección: 0@0.] 
		raise: Error
		withExceptionDo: [ :error |
			self assert: Penales direccionTiroFueraDeRango equals: error messageText.
			self assert: 0 equals: juegoPenales puntajeDeDelantero.
			self assert: 0 equals: juegoPenales puntajeDeArquero.]
	! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:36:03' prior: 50682266!
test17ArqueroQueEligeAntesDeTiroVsPlayeraAColocarSuma100PorcFuerzaExtra
	
	| arquero delantero juegoPenales pelota |
	
	"La fuerza del Delantero se reduce en 50% siempre que tira a colocar... (no importa pelota, ni arquero)"
	"La humilde pelota playera le hace perder un 20% adicional de fuerza al delantero que la use para colocar... (no importa el arquero)"
	"Arquero que elige donde lanzarse antes de un remate de una pelota playera lenta a colocar, gana un 100% de su fuerza extra..."
	"(a quien madruga...)"
	
	delantero := DelanteroConTacticaa decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 20.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@0 arqueroSeLanzaEnDirección: 0@0.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 0@0 equals: juegoPenales varDireccionRemateResultante.
	self assert: 40 equals: juegoPenales varFuerzaResultanteDeTiro.
	self assert: 40 equals: juegoPenales varFuerzaResultanteDeAtajada! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:36:03' prior: 50682307!
test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero
	
	| arquero delantero juegoPenales pelota |
	
	"La fuerza del Delantero se reduce en 50% siempre que tira a colocar... (no importa pelota, ni arquero)"
	"La humilde pelota playera le hace perder un 20% de fuerza adicional al delantero que la use para colocar... (no importa el arquero)"
	"(no debería ser reglamentaria... al menos no es de trapo, nos responden)"
	
	delantero := DelanteroConTacticaa decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 1.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 1@2 arqueroSeLanzaEnDirección: 1@2.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 1@2 equals: juegoPenales varDireccionRemateResultante.
	self assert: 40 equals: juegoPenales varFuerzaResultanteDeTiro! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:36:03' prior: 50682343!
test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja
	
	| arquero delantero juegoPenales pelota |
	
	"El Arquero que espera a ver la dirección del remate de una pelota jabulani rápida a matar antes de lanzarse, nunca la ataja sin importar nada, siquiera que se adelantó..."	
	"(su poder era de más de 9000!! era impresionante, no podía moverme, sólo la ví pasar... f )"
	
	delantero := DelanteroConTacticaa decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 1@1 arqueroSeLanzaEnDirección: 1@1.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 1@1 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:36:03' prior: 50682376!
test12DelanteroQueTiraAColocarPierde50PorcFuerza
	
	| arquero delantero juegoPenales pelota |
	
	"La fuerza del Delantero se reduce en 50% siempre que tira a colocar... (no importa pelota, ni arquero)"
	"(delantero sacrificia potencia para ganar mayor precisión)"
	
	delantero := DelanteroConTacticaa decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 50.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@2 arqueroSeLanzaEnDirección: 2@2.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 2@2 equals: juegoPenales varDireccionRemateResultante.
	self assert: 50 equals: juegoPenales varFuerzaResultanteDeTiro.! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:36:03' prior: 50682407!
test21DelanteroTiraAMatarAlAnguloSuperiorIzquierdoLaAlturaDelTiroPasaAMedio
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"(tirar a matar no es tan preciso como tirar a colocar, hay desvios de altura. Sin embargo se usa el 100% de fuerza del jugador)"
	
	delantero := DelanteroConTacticaa decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@2 arqueroSeLanzaEnDirección: 0@2.
	
	self assert: 0@1 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:36:03' prior: 50682437!
test25DelanteroTiraAMatarUsa100PorcFuerzaBase
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"(tirar a matar no es tan preciso como tirar a colocar, hay desvios de altura. Sin embargo se usa el 100% de fuerza del jugador)"
	
	delantero := DelanteroConTacticaa decideTirarAMatarSuFuerzaBaseEs:150.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@0 arqueroSeLanzaEnDirección: 2@0.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 2@1 equals: juegoPenales varDireccionRemateResultante.
	self assert: 150 equals: juegoPenales varFuerzaResultanteDeTiro! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:36:03' prior: 50682471!
test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"(tirar a matar no es tan preciso como tirar a colocar, hay desvios de altura. Sin embargo se usa el 100% de fuerza del jugador)"
	
	delantero := DelanteroConTacticaa decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@0 arqueroSeLanzaEnDirección: 2@0.
	
	self assert: 2@1 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:36:03' prior: 50682501!
test19ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAColocarEsDescubiertoYPuntoParaDelantero
	
	| arquero delantero juegoPenales pelota |
	
	"Arquero que espera y se adelanta ante tiro con la lenta pelota playera, siempre es descubierto por el Árbitro, y el punto se le otorga al Delantero..."
	"(lo que servía de ventaja ante la Jabulani rápida, acá es tan obvio por lo que tarda en llegar la pelota al arco, que marchás preso...)"
	
	delantero := DelanteroConTacticaa decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero  esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@0 arqueroSeLanzaEnDirección: 0@0.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 0@0 equals: juegoPenales varDireccionRemateResultante! !

Object subclass: #Delantero
	instanceVariableNames: 'fuerza'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classDefinition: #Delantero category: 'ISW1-2023-2C-Parcial-1' stamp: 'LK 9/25/2023 20:36:22'!
Object subclass: #Delantero
	instanceVariableNames: 'fuerza'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!
!PenalesTest methodsFor: 'tests' stamp: 'LK 9/25/2023 20:36:36' prior: 50682831!
test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo
	
	| arquero delantero juegoPenales pelota |
	
	delantero := Delantero decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	self 
		should: [ juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: -1@0 arqueroSeLanzaEnDirección: 0@0.] 
		raise: Error
		withExceptionDo: [ :error |
			self assert: Penales direccionTiroFueraDeRango equals: error messageText.
			self assert: 0 equals: juegoPenales puntajeDeDelantero.
			self assert: 0 equals: juegoPenales puntajeDeArquero.]
	! !
!PenalesTest methodsFor: 'tests' stamp: 'LK 9/25/2023 20:36:41' prior: 50683348!
test02DelanteroNoPuedeApuntarHaciaAfueraDelPaloDerecho
	
	| arquero delantero juegoPenales pelota |
	
	delantero := Delantero decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	self 
		should: [ juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 3@0 arqueroSeLanzaEnDirección: 0@0.] 
		raise: Error
		withExceptionDo: [ :error |
			self assert: Penales direccionTiroFueraDeRango equals: error messageText.
			self assert: 0 equals: juegoPenales puntajeDeDelantero.
			self assert: 0 equals: juegoPenales puntajeDeArquero.]
	! !
!PenalesTest methodsFor: 'tests' stamp: 'LK 9/25/2023 20:36:46' prior: 50682623!
test03DelanteroNoPuedeApuntarHaciaAbajoDelArco
	
	| arquero delantero juegoPenales pelota |
	
	delantero := Delantero decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	self 
		should: [ juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@-1 arqueroSeLanzaEnDirección: 0@0.] 
		raise: Error
		withExceptionDo: [ :error |
			self assert: Penales direccionTiroFueraDeRango equals: error messageText.
			self assert: 0 equals: juegoPenales puntajeDeDelantero.
			self assert: 0 equals: juegoPenales puntajeDeArquero.]
	! !
!PenalesTest methodsFor: 'tests' stamp: 'LK 9/25/2023 20:36:50' prior: 50683081!
test04DelanteroNoPuedeApuntarHaciaArribaDelTravesaño
	
	| arquero delantero juegoPenales pelota |
	
	delantero := Delantero decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	self 
		should: [ juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@3 arqueroSeLanzaEnDirección: 0@0.] 
		raise: Error
		withExceptionDo: [ :error |
			self assert: Penales direccionTiroFueraDeRango equals: error messageText.
			self assert: 0 equals: juegoPenales puntajeDeDelantero.
			self assert: 0 equals: juegoPenales puntajeDeArquero.]
	! !
!PenalesTest methodsFor: 'tests' stamp: 'LK 9/25/2023 20:37:01' prior: 50682541!
test05ArqueroNoPuedePasarseDelPaloIzquierdo
	
	| arquero delantero juegoPenales pelota |
	
	delantero := Delantero decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	self 
		should: [ juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@0 arqueroSeLanzaEnDirección: -1@0.] 
		raise: Error
		withExceptionDo: [ :error |
			self assert: Penales direccionArqueroFueraDeRango equals: error messageText.
			self assert: 0 equals: juegoPenales puntajeDeDelantero.
			self assert: 0 equals: juegoPenales puntajeDeArquero.]
	! !
!PenalesTest methodsFor: 'tests' stamp: 'LK 9/25/2023 20:37:06' prior: 50682897!
test06ArqueroNoPuedePasarseDelPaloDerecho
	
	| arquero delantero juegoPenales pelota |
	
	delantero := Delantero decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	self 
		should: [ juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@0 arqueroSeLanzaEnDirección: 3@0.] 
		raise: Error
		withExceptionDo: [ :error |
			self assert: Penales direccionArqueroFueraDeRango equals: error messageText.
			self assert: 0 equals: juegoPenales puntajeDeDelantero.
			self assert: 0 equals: juegoPenales puntajeDeArquero.]
	! !
!Delantero class methodsFor: 'no messages' stamp: 'LK 9/25/2023 20:38:21'!
decideTirarAColocarSuFuerzaBaseEs: fuerzaJugador
	^DelanteroConTacticaa new initializeDecideTirarAColocarSuFuerzaBaseEs: fuerzaJugador.
! !
!Delantero class methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:39:10'!
decideTirarAMatarSuFuerzaBaseEs: fuerzaJugador
	^self new initializeDecideTirarAMatarSuFuerzaBaseEs: fuerzaJugador ! !

Object subclass: #Delantero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classDefinition: #Delantero category: 'ISW1-2023-2C-Parcial-1' stamp: 'LK 9/25/2023 20:39:54'!
Object subclass: #Delantero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

Object subclass: #ArqueroConTactica
	instanceVariableNames: 'fuerza'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classDefinition: #ArqueroConTactica category: 'ISW1-2023-2C-Parcial-1' stamp: 'LK 9/25/2023 20:40:32'!
Object subclass: #ArqueroConTactica
	instanceVariableNames: 'fuerza'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

ArqueroConTactica subclass: #Elige
	instanceVariableNames: 'fuerza'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

ArqueroConTactica subclass: #Eligee
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classDefinition: #Eligee category: 'ISW1-2023-2C-Parcial-1' stamp: 'LK 9/25/2023 20:41:29'!
ArqueroConTactica subclass: #Eligee
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

ArqueroConTactica subclass: #EesperaYAdelanta
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classDefinition: #EesperaYAdelanta category: 'ISW1-2023-2C-Parcial-1' stamp: 'LK 9/25/2023 20:41:36'!
ArqueroConTactica subclass: #EesperaYAdelanta
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!
!Eligee methodsFor: 'no messages' stamp: 'LK 9/25/2023 20:41:48'!
fuerzaResultanteContraJabulani

	^fuerza! !
!Eligee methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:41:58'!
fuerzaResultanteContraPlayera

	^fuerza * 2! !
!EesperaYAdelanta methodsFor: 'no messages' stamp: 'LK 9/25/2023 20:42:20'!
fuerzaResultanteContraPlayera

	^fuerza * 2! !
!EesperaYAdelanta methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:42:42'!
fuerzaResultanteContraJabulani

	^fuerza! !
!EesperaYAdelanta methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:42:50' prior: 50683887!
fuerzaResultanteContraPlayera

	^fuerza! !
!EesperaYAdelanta methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:43:18'!
initializeEsperaPorTiroYSeAdelantaSuFuerzaBaseEs: fuerzaArquero
	fuerza := fuerzaArquero! !
!Eligee methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:43:29'!
initializeEligeDireccionAntesDeTiroSuFuerzaBaseEs: fuerzaArquero

	fuerza := fuerzaArquero * 1.5! !
!Arquero class methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:43:49' prior: 50675733!
eligeDireccionAntesDeTiroSuFuerzaBaseEs: fuerzaArquero
	^EesperaYAdelanta new initializeEligeDireccionAntesDeTiroSuFuerzaBaseEs: fuerzaArquero.! !
!Arquero class methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:43:59' prior: 50683914!
eligeDireccionAntesDeTiroSuFuerzaBaseEs: fuerzaArquero
	^Eligee new initializeEligeDireccionAntesDeTiroSuFuerzaBaseEs: fuerzaArquero.! !
!Arquero class methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:44:09' prior: 50673935!
esperaPorTiroYSeAdelantaSuFuerzaBaseEs: fuerzaArquero
	^EesperaYAdelanta new initializeEsperaPorTiroYSeAdelantaSuFuerzaBaseEs: fuerzaArquero.! !

!classRemoval: #EsperaYAdelanta stamp: 'LK 9/25/2023 20:44:15'!
Arquero subclass: #EsperaYAdelanta
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classRemoval: #Elige stamp: 'LK 9/25/2023 20:44:23'!
Arquero subclass: #Elige
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classRenamed: #EesperaYAdelanta as: #EsperaYAdelanta stamp: 'LK 9/25/2023 20:44:35'!
Smalltalk renameClassNamed: #EesperaYAdelanta as: #EsperaYAdelanta!
!Penales methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:44:36' prior: 50680839!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(self direccionEnRango: direccionTiro) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(self direccionEnRango: direccionArquero) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	(direccionTiro = direccionArquero) ifTrue: [].
	
	(pelota tipo = #Jabulani) ifTrue: [
			penalPelota := #Jabulani.
			
		(delantero tipo = #AMatar) ifTrue: [self sumarPuntoDelantero].
		
		(arquero tipo = #EsperaYAdelanta) ifTrue: [
				((direccionTiro) x = (direccionArquero x) & 
				(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro))
				 	ifTrue: [self sumarPuntoArquero]]
					
				ifFalse: [(direccionTiro = direccionArquero) & 
				(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro) 
					ifTrue: [self sumarPuntoDelantero].
					
			].
		
		(arquero tipo = #Elige) ifTrue: [
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro ))
					ifTrue: [self sumarPuntoArquero].
			
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro )) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
		].
	(pelota = #Playera) ifTrue: [
			
			penalPelota := #Playera.
			
			(arquero tipo = #Elige) ifTrue: [
				
				(direccionTiro = direccionArquero & 
				self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro)
					ifTrue: [self sumarPuntoArquero].
			
				(direccionTiro = direccionArquero & 
				self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
			(arquero tipo = #EsperaYadelanta) ifTrue: [self sumarPuntoDelantero].
				
		].
			
		
	
	
	
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !
!Arquero class methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:44:36' prior: 50683930!
esperaPorTiroYSeAdelantaSuFuerzaBaseEs: fuerzaArquero
	^EsperaYAdelanta new initializeEsperaPorTiroYSeAdelantaSuFuerzaBaseEs: fuerzaArquero.! !

!classRenamed: #Eligee as: #Elige stamp: 'LK 9/25/2023 20:44:47'!
Smalltalk renameClassNamed: #Eligee as: #Elige!
!Penales methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:44:47' prior: 50683955!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(self direccionEnRango: direccionTiro) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(self direccionEnRango: direccionArquero) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	(direccionTiro = direccionArquero) ifTrue: [].
	
	(pelota tipo = #Jabulani) ifTrue: [
			penalPelota := #Jabulani.
			
		(delantero tipo = #AMatar) ifTrue: [self sumarPuntoDelantero].
		
		(arquero tipo = #EsperaYAdelanta) ifTrue: [
				((direccionTiro) x = (direccionArquero x) & 
				(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro))
				 	ifTrue: [self sumarPuntoArquero]]
					
				ifFalse: [(direccionTiro = direccionArquero) & 
				(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro) 
					ifTrue: [self sumarPuntoDelantero].
					
			].
		
		(arquero tipo = #Elige) ifTrue: [
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro ))
					ifTrue: [self sumarPuntoArquero].
			
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro )) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
		].
	(pelota = #Playera) ifTrue: [
			
			penalPelota := #Playera.
			
			(arquero tipo = #Elige) ifTrue: [
				
				(direccionTiro = direccionArquero & 
				self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro)
					ifTrue: [self sumarPuntoArquero].
			
				(direccionTiro = direccionArquero & 
				self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
			(arquero tipo = #EsperaYadelanta) ifTrue: [self sumarPuntoDelantero].
				
		].
			
		
	
	
	
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !
!Arquero class methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:44:47' prior: 50683922!
eligeDireccionAntesDeTiroSuFuerzaBaseEs: fuerzaArquero
	^Elige new initializeEligeDireccionAntesDeTiroSuFuerzaBaseEs: fuerzaArquero.! !

!classRenamed: #DelanteroConTacticaa as: #DelanteroConTactic stamp: 'LK 9/25/2023 20:45:17'!
Smalltalk renameClassNamed: #DelanteroConTacticaa as: #DelanteroConTactic!
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:45:17' prior: 50683485!
test12DelanteroQueTiraAColocarPierde50PorcFuerza
	
	| arquero delantero juegoPenales pelota |
	
	"La fuerza del Delantero se reduce en 50% siempre que tira a colocar... (no importa pelota, ni arquero)"
	"(delantero sacrificia potencia para ganar mayor precisión)"
	
	delantero := DelanteroConTactic decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 50.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@2 arqueroSeLanzaEnDirección: 2@2.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 2@2 equals: juegoPenales varDireccionRemateResultante.
	self assert: 50 equals: juegoPenales varFuerzaResultanteDeTiro.! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:45:17' prior: 50683416!
test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero
	
	| arquero delantero juegoPenales pelota |
	
	"La fuerza del Delantero se reduce en 50% siempre que tira a colocar... (no importa pelota, ni arquero)"
	"La humilde pelota playera le hace perder un 20% de fuerza adicional al delantero que la use para colocar... (no importa el arquero)"
	"(no debería ser reglamentaria... al menos no es de trapo, nos responden)"
	
	delantero := DelanteroConTactic decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 1.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 1@2 arqueroSeLanzaEnDirección: 1@2.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 1@2 equals: juegoPenales varDireccionRemateResultante.
	self assert: 40 equals: juegoPenales varFuerzaResultanteDeTiro! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:45:17' prior: 50683610!
test19ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAColocarEsDescubiertoYPuntoParaDelantero
	
	| arquero delantero juegoPenales pelota |
	
	"Arquero que espera y se adelanta ante tiro con la lenta pelota playera, siempre es descubierto por el Árbitro, y el punto se le otorga al Delantero..."
	"(lo que servía de ventaja ante la Jabulani rápida, acá es tan obvio por lo que tarda en llegar la pelota al arco, que marchás preso...)"
	
	delantero := DelanteroConTactic decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero  esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@0 arqueroSeLanzaEnDirección: 0@0.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 0@0 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:45:17' prior: 50683516!
test21DelanteroTiraAMatarAlAnguloSuperiorIzquierdoLaAlturaDelTiroPasaAMedio
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"(tirar a matar no es tan preciso como tirar a colocar, hay desvios de altura. Sin embargo se usa el 100% de fuerza del jugador)"
	
	delantero := DelanteroConTactic decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@2 arqueroSeLanzaEnDirección: 0@2.
	
	self assert: 0@1 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:45:17' prior: 50682649!
test28ArqueroQueEligeAntesDeTiroVsJabulaniAMatarIgnoraAlturaTiro
	
	| arquero delantero juegoPenales pelota |
	
	"El Arquero que elige donde tirarse antes de un tiro de jabulani a matar, ignora la 2da coordenada (altura) al atajar..."		
	
	delantero := DelanteroConTactic decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@2 arqueroSeLanzaEnDirección: 0@0.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 0@1 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:45:17' prior: 50683107!
test30DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAdentro
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' el Delantero usa el 100% de su fuerza... (no importa pelota, ni arquero)"
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"Si se tira 'a matar' usando una pelota playera a una dirección que no es un ángulo, la 2da coordenada del remate (altura) suma 2, es decir sale volando producto de su liviandez (y que quiere retornar al mar). Si la pelota se va fuera del arco, el puntaje va al arquero... (no importa arquero)"
	"(y voló.. y me hizo volar... y yo volé de él...  pero acá por la arbolada... y el voló.. y se estrelló por acá por la pared...)"
	
	delantero := DelanteroConTactic decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 1@0 arqueroSeLanzaEnDirección: 1@0.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 1@2 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:45:17' prior: 50683189!
test14FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAColocar
	
	| arquero delantero juegoPenales pelota |
	
	"La fuerza del Delantero se reduce en 50% siempre que tira a colocar... (no importa pelota, ni arquero)"
	"El Arquero que elige adonde tirarse antes de un tiro a colocar de jabulani gana 50% de su fuerza extra..."
	
	delantero := DelanteroConTactic decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 32.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@2 arqueroSeLanzaEnDirección: 0@2.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 0@2 equals: juegoPenales varDireccionRemateResultante.
	self assert: 50 equals: juegoPenales varFuerzaResultanteDeTiro.
	self assert: 48 equals: juegoPenales varFuerzaResultanteDeAtajada.! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:45:17' prior: 50683055!
test09DireccionesDiferentesGolDelantero
	
	| arquero delantero juegoPenales pelota |
	
	"Caso general del juego..."
	
	delantero := DelanteroConTactic decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@2 arqueroSeLanzaEnDirección: 0@1.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 2@2 equals: juegoPenales varDireccionRemateResultante
	"varXXXX es por VAR, de 'Video Assistant Referee'"! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:45:17' prior: 50682712!
test27FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAMatar
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' el Delantero usa el 100% de su fuerza... (no importa pelota, ni arquero)"
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"Si se tira 'a matar' usando la jabulani rápida, el Delantero gana un 20% de fuerza extra... (no importa arquero)"
	
	delantero := DelanteroConTactic decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 119.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@2 arqueroSeLanzaEnDirección: 2@1.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 2@1 equals: juegoPenales varDireccionRemateResultante.
	self assert: 120 equals: juegoPenales varFuerzaResultanteDeTiro.! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:45:17' prior: 50682593!
test20DelanteroTiraAMatarAlAnguloInferiorIzquierdoLaAlturaDelTiroPasaAMedio
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"(tirar a matar no es tan preciso como tirar a colocar, hay desvios de altura. Sin embargo se usa el 100% de fuerza del jugador)"
	
	delantero := DelanteroConTactic decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@0 arqueroSeLanzaEnDirección: 0@0.
	.
	self assert: 0@1 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:45:17' prior: 50682858!
test26DelanteroTiraAMatarConJabulaniGana20PorcFuerzaExtra
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' el Delantero usa el 100% de su fuerza... (no importa pelota, ni arquero)"
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"Si se tira 'a matar' usando la jabulani rápida, el Delantero gana un 20% de fuerza extra... (no importa arquero)"
	"(Jabulani a matar es la elección de los guerreros Z)"
	
	delantero := DelanteroConTactic decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 120.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@2 arqueroSeLanzaEnDirección: 2@1.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 2@1 equals: juegoPenales varDireccionRemateResultante.
	self assert: 120 equals: juegoPenales varFuerzaResultanteDeTiro.! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:45:17' prior: 50683305!
test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' el Delantero usa el 100% de su fuerza... (no importa pelota, ni arquero)"
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"Si se tira 'a matar' usando una pelota playera a una dirección que no es un ángulo, la 2da coordenada del remate (altura) suma 2, es decir sale volando producto de su liviandez (y que quiere retornar al mar). Si la pelota se va fuera del arco, el puntaje va al arquero... (no importa arquero)"
	"(El caso auspiciado por el Pipita...)"
	
	delantero := DelanteroConTactic decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@1 arqueroSeLanzaEnDirección: 0@0.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 0@3 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:45:17' prior: 50682750!
test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' el Delantero usa el 100% de su fuerza... (no importa pelota, ni arquero)"
	"Si se tira 'a matar' usando una pelota playera a una dirección que no es un ángulo, la 2da coordenada del remate (altura) suma 2, es decir sale volando producto de su liviandez (y que quiere retornar al mar). Si la pelota se va fuera del arco, el puntaje va al arquero... (no importa arquero)"
	"Si el arquero elige donde tirarse antes del tiro a matar de la pelota playera, ignora la 1ra coordenada del remate (ancho) al atajar..."
	"(con agacharse, quedarse parado, o saltar le alcanza...)"
	
	delantero := DelanteroConTactic decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 1@0 arqueroSeLanzaEnDirección: 0@2.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 1@2 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:45:17' prior: 50683546!
test25DelanteroTiraAMatarUsa100PorcFuerzaBase
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"(tirar a matar no es tan preciso como tirar a colocar, hay desvios de altura. Sin embargo se usa el 100% de fuerza del jugador)"
	
	delantero := DelanteroConTactic decideTirarAMatarSuFuerzaBaseEs:150.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@0 arqueroSeLanzaEnDirección: 2@0.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 2@1 equals: juegoPenales varDireccionRemateResultante.
	self assert: 150 equals: juegoPenales varFuerzaResultanteDeTiro! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:45:18' prior: 50682948!
test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra
	
	| arquero delantero juegoPenales pelota |
	
	"La fuerza del Delantero se reduce en 50% siempre que tira a colocar... (no importa pelota, ni arquero)"
	"El Arquero que elige donde tirarse antes de un tiro a colocar de jabulani gana 50% de su fuerza extra..."
	"(el arquero llega más cómodo y aprovecha mejor su fuerza)"
	
	delantero := DelanteroConTactic decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 34.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@2 arqueroSeLanzaEnDirección: 0@2.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 0@2 equals: juegoPenales varDireccionRemateResultante.
	self assert: 50 equals: juegoPenales varFuerzaResultanteDeTiro.
	self assert: 51 equals: juegoPenales varFuerzaResultanteDeAtajada.! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:45:18' prior: 50683225!
test11MismasDireccionesSuficienteFuerzaAtajaArquero
	
	| arquero delantero juegoPenales pelota |
	
	"Caso general del juego..."
	
	delantero := DelanteroConTactic decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@2 arqueroSeLanzaEnDirección: 2@2.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 2@2 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:45:18' prior: 50683580!
test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"(tirar a matar no es tan preciso como tirar a colocar, hay desvios de altura. Sin embargo se usa el 100% de fuerza del jugador)"
	
	delantero := DelanteroConTactic decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@0 arqueroSeLanzaEnDirección: 2@0.
	
	self assert: 2@1 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:45:18' prior: 50683250!
test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"(tirar a matar no es tan preciso como tirar a colocar, hay desvios de altura. Sin embargo se usa el 100% de fuerza del jugador)"
	
	delantero := DelanteroConTactic decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 1@2 arqueroSeLanzaEnDirección: 1@1.

	self assert: 1@2 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:45:18' prior: 50683375!
test17ArqueroQueEligeAntesDeTiroVsPlayeraAColocarSuma100PorcFuerzaExtra
	
	| arquero delantero juegoPenales pelota |
	
	"La fuerza del Delantero se reduce en 50% siempre que tira a colocar... (no importa pelota, ni arquero)"
	"La humilde pelota playera le hace perder un 20% adicional de fuerza al delantero que la use para colocar... (no importa el arquero)"
	"Arquero que elige donde lanzarse antes de un remate de una pelota playera lenta a colocar, gana un 100% de su fuerza extra..."
	"(a quien madruga...)"
	
	delantero := DelanteroConTactic decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 20.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@0 arqueroSeLanzaEnDirección: 0@0.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 0@0 equals: juegoPenales varDireccionRemateResultante.
	self assert: 40 equals: juegoPenales varFuerzaResultanteDeTiro.
	self assert: 40 equals: juegoPenales varFuerzaResultanteDeAtajada! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:45:18' prior: 50682923!
test10MismasDireccionesInsuficienteFuerzaGolDelantero
	
	| arquero delantero juegoPenales pelota |
	
	"Caso general del juego..."
	
	delantero := DelanteroConTactic decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 10.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@2 arqueroSeLanzaEnDirección: 2@2.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 2@2 equals: juegoPenales varDireccionRemateResultante! !
!Delantero class methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:45:18' prior: 50683811!
decideTirarAColocarSuFuerzaBaseEs: fuerzaJugador
	^DelanteroConTactic new initializeDecideTirarAColocarSuFuerzaBaseEs: fuerzaJugador.
! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:45:18' prior: 50683015!
test18FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsPlayeraAColocar
	
	| arquero delantero juegoPenales pelota |
	
	"La fuerza del Delantero se reduce en 50% siempre que tira a colocar... (no importa pelota, ni arquero)"
	"La humilde pelota playera le hace perder un 20% adicional de fuerza al delantero que la use para colocar... (no importa el arquero)"
	"Arquero que elige donde lanzarse antes de un remate de una pelota playera lenta a colocar, gana un 100% de su fuerza extra..."
	
	delantero := DelanteroConTactic decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 19.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@0 arqueroSeLanzaEnDirección: 0@0.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 0@0 equals: juegoPenales varDireccionRemateResultante.
	self assert: 40 equals: juegoPenales varFuerzaResultanteDeTiro.
	self assert: 38 equals: juegoPenales varFuerzaResultanteDeAtajada! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:45:18' prior: 50682793!
test32ArqueroQueEligeAntesDeTiroVsPlayeraAMatarAlAnguloIgnoraAnchoTiro
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' el Delantero usa el 100% de su fuerza... (no importa pelota, ni arquero)"
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"Si el arquero elige donde tirarse antes del tiro a matar de la pelota playera, ignora la 1ra coordenada del remate (ancho) al atajar..."
	"(con agacharse, quedarse parado, o saltar le alcanza...)"
	
	delantero := DelanteroConTactic decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@0 arqueroSeLanzaEnDirección: 2@1.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 0@1 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:45:18' prior: 50682985!
test23DelanteroTiraAMatarAlAnguloSuperiorDerechoLaAlturaDelTiroPasaAMedio
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"(tirar a matar no es tan preciso como tirar a colocar, hay desvios de altura. Sin embargo se usa el 100% de fuerza del jugador)"
	
	delantero := DelanteroConTactic decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@2 arqueroSeLanzaEnDirección: 2@2.
	
	self assert: 2@1 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:45:18' prior: 50682677!
test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro
	
	| arquero delantero juegoPenales pelota |
	
	"La fuerza del Delantero se reduce en 50% siempre que tira a colocar... (no importa pelota, ni arquero)"
	"El Arquero que espera y se adelanta ante un tiro de jabulani a colocar ignora la 2da coordenada (altura) al atajar..."	
	"(al adelanterse encara la pelota antes de que su elevación se transforme en un problema)"
	
	delantero := DelanteroConTactic decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero  esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 50.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@2 arqueroSeLanzaEnDirección: 0@0.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 0@2 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:45:18' prior: 50683153!
test34ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAMatarSiempreAtaja
	
	| arquero delantero juegoPenales pelota |
	
	"El Arquero que espera y se adelanta ante una pelota playera lenta a matar, siempre la ataja sin importar nada..."	
	"(como la pelota es taaaan lentaaa, el arquero se puede ir a tomar un cafe, verse una serie, volver y aún atajar la pelota habiendose tirado a cualquier lado. Pero igual es más rapida que cuando se la tira a colocar, donde indefectiblemente el arbitro lo detecta...)"
	
	delantero := DelanteroConTactic decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 1.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@2 arqueroSeLanzaEnDirección: 0@0.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 2@1 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:45:18' prior: 50683279!
test07ArqueroNoPuedeMeterseAbajoDeLaTierra
	
	| arquero delantero juegoPenales pelota |
	
	delantero := DelanteroConTactic decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	self 
		should: [ juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@0 arqueroSeLanzaEnDirección: 0@-1.] 
		raise: Error
		withExceptionDo: [ :error |
			self assert: Penales direccionArqueroFueraDeRango equals: error messageText.
			self assert: 0 equals: juegoPenales puntajeDeDelantero.
			self assert: 0 equals: juegoPenales puntajeDeArquero.]
	! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:45:18' prior: 50683452!
test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja
	
	| arquero delantero juegoPenales pelota |
	
	"El Arquero que espera a ver la dirección del remate de una pelota jabulani rápida a matar antes de lanzarse, nunca la ataja sin importar nada, siquiera que se adelantó..."	
	"(su poder era de más de 9000!! era impresionante, no podía moverme, sólo la ví pasar... f )"
	
	delantero := DelanteroConTactic decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 1@1 arqueroSeLanzaEnDirección: 1@1.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 1@1 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:45:18' prior: 50682567!
test08ArqueroNoPuedeSaltarPorEncimaDelTravesaño
	
	| arquero delantero juegoPenales pelota |
	
	delantero := DelanteroConTactic decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	self 
		should: [ juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@0 arqueroSeLanzaEnDirección: 0@3.] 
		raise: Error
		withExceptionDo: [ :error |
			self assert: Penales direccionArqueroFueraDeRango equals: error messageText.
			self assert: 0 equals: juegoPenales puntajeDeDelantero.
			self assert: 0 equals: juegoPenales puntajeDeArquero.]
	! !

Object subclass: #PelotaDePenalti
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classDefinition: #PelotaDePenalti category: 'ISW1-2023-2C-Parcial-1' stamp: 'LK 9/25/2023 20:45:51'!
Object subclass: #PelotaDePenalti
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

PelotaDePenalti subclass: #PJabulani
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classDefinition: #PJabulani category: 'ISW1-2023-2C-Parcial-1' stamp: 'LK 9/25/2023 20:46:15'!
PelotaDePenalti subclass: #PJabulani
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

PelotaDePenalti subclass: #PPlayera
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classDefinition: #PPlayera category: 'ISW1-2023-2C-Parcial-1' stamp: 'LK 9/25/2023 20:46:20'!
PelotaDePenalti subclass: #PPlayera
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!
!PJabulani methodsFor: 'nil' stamp: 'LK 9/25/2023 20:46:40'!
verFuerzaConArquero: unArquero
	^unArquero fuerzaResultanteContraJabulani.! !
!PJabulani methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:46:49' prior: 50685219!
verFuerzaConArquero: unArquero
	^unArquero fuerzaResultanteContraJabulani.! !
!PJabulani methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:46:56'!
verFuerzaConTirador: unTirador
	^unTirador fuerzaResultanteConJabulani.! !
!PPlayera methodsFor: 'nil' stamp: 'LK 9/25/2023 20:47:05'!
verFuerzaConTirador: unTirador
	^unTirador fuerzaResultanteConPlayera.! !
!PPlayera methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:47:28'!
initializePlayeraLentaCostaAzul! !
!PJabulani methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:47:40'!
initializeJabulaniSudafricanaRapida! !

!classRemoval: #Playera stamp: 'LK 9/25/2023 20:47:44'!
Pelota subclass: #Playera
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classRemoval: #Jabulani stamp: 'LK 9/25/2023 20:47:53'!
Pelota subclass: #Jabulani
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!methodRemoval: Pelota #verFuerzaConTirador: stamp: 'LK 9/25/2023 20:48:33'!
verFuerzaConTirador: unTirador

	self subclassResponsibility!
!Pelota class methodsFor: 'no messages' stamp: 'LK 9/25/2023 20:49:27'!
jabulaniSudafricanaRapida
	^PJabulani new.! !
!Pelota class methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:49:51'!
playeraLentaCostaAzul
	^PPlayera new.! !
!PenalesTest methodsFor: 'tests' stamp: 'LK 9/25/2023 20:51:14' prior: 50685098!
test07ArqueroNoPuedeMeterseAbajoDeLaTierra
	
	| arquero delantero juegoPenales pelota |
	
	delantero := Delantero decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	self 
		should: [ juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@0 arqueroSeLanzaEnDirección: 0@-1.] 
		raise: Error
		withExceptionDo: [ :error |
			self assert: Penales direccionArqueroFueraDeRango equals: error messageText.
			self assert: 0 equals: juegoPenales puntajeDeDelantero.
			self assert: 0 equals: juegoPenales puntajeDeArquero.]
	! !
!PenalesTest methodsFor: 'tests' stamp: 'LK 9/25/2023 20:51:18' prior: 50685157!
test08ArqueroNoPuedeSaltarPorEncimaDelTravesaño
	
	| arquero delantero juegoPenales pelota |
	
	delantero := Delantero decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	self 
		should: [ juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@0 arqueroSeLanzaEnDirección: 0@3.] 
		raise: Error
		withExceptionDo: [ :error |
			self assert: Penales direccionArqueroFueraDeRango equals: error messageText.
			self assert: 0 equals: juegoPenales puntajeDeDelantero.
			self assert: 0 equals: juegoPenales puntajeDeArquero.]
	! !
!PenalesTest methodsFor: 'tests' stamp: 'LK 9/25/2023 20:51:24' prior: 50684473!
test09DireccionesDiferentesGolDelantero
	
	| arquero delantero juegoPenales pelota |
	
	"Caso general del juego..."
	
	delantero := Delantero decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@2 arqueroSeLanzaEnDirección: 0@1.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 2@2 equals: juegoPenales varDireccionRemateResultante
	"varXXXX es por VAR, de 'Video Assistant Referee'"! !
!PenalesTest methodsFor: 'tests' stamp: 'LK 9/25/2023 20:51:29' prior: 50684887!
test10MismasDireccionesInsuficienteFuerzaGolDelantero
	
	| arquero delantero juegoPenales pelota |
	
	"Caso general del juego..."
	
	delantero := Delantero decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 10.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@2 arqueroSeLanzaEnDirección: 2@2.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 2@2 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'tests' stamp: 'LK 9/25/2023 20:51:32' prior: 50684763!
test11MismasDireccionesSuficienteFuerzaAtajaArquero
	
	| arquero delantero juegoPenales pelota |
	
	"Caso general del juego..."
	
	delantero := Delantero decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@2 arqueroSeLanzaEnDirección: 2@2.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 2@2 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'tests' stamp: 'LK 9/25/2023 20:51:39' prior: 50684233!
test12DelanteroQueTiraAColocarPierde50PorcFuerza
	
	| arquero delantero juegoPenales pelota |
	
	"La fuerza del Delantero se reduce en 50% siempre que tira a colocar... (no importa pelota, ni arquero)"
	"(delantero sacrificia potencia para ganar mayor precisión)"
	
	delantero := Delantero decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 50.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@2 arqueroSeLanzaEnDirección: 2@2.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 2@2 equals: juegoPenales varDireccionRemateResultante.
	self assert: 50 equals: juegoPenales varFuerzaResultanteDeTiro.! !
!PenalesTest methodsFor: 'tests' stamp: 'LK 9/25/2023 20:51:48' prior: 50684726!
test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra
	
	| arquero delantero juegoPenales pelota |
	
	"La fuerza del Delantero se reduce en 50% siempre que tira a colocar... (no importa pelota, ni arquero)"
	"El Arquero que elige donde tirarse antes de un tiro a colocar de jabulani gana 50% de su fuerza extra..."
	"(el arquero llega más cómodo y aprovecha mejor su fuerza)"
	
	delantero := Delantero decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 34.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@2 arqueroSeLanzaEnDirección: 0@2.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 0@2 equals: juegoPenales varDireccionRemateResultante.
	self assert: 50 equals: juegoPenales varFuerzaResultanteDeTiro.
	self assert: 51 equals: juegoPenales varFuerzaResultanteDeAtajada.! !
!PenalesTest methodsFor: 'tests' stamp: 'LK 9/25/2023 20:51:51' prior: 50684438!
test14FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAColocar
	
	| arquero delantero juegoPenales pelota |
	
	"La fuerza del Delantero se reduce en 50% siempre que tira a colocar... (no importa pelota, ni arquero)"
	"El Arquero que elige adonde tirarse antes de un tiro a colocar de jabulani gana 50% de su fuerza extra..."
	
	delantero := Delantero decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 32.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@2 arqueroSeLanzaEnDirección: 0@2.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 0@2 equals: juegoPenales varDireccionRemateResultante.
	self assert: 50 equals: juegoPenales varFuerzaResultanteDeTiro.
	self assert: 48 equals: juegoPenales varFuerzaResultanteDeAtajada.! !
!PenalesTest methodsFor: 'tests' stamp: 'LK 9/25/2023 20:51:55' prior: 50685027!
test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro
	
	| arquero delantero juegoPenales pelota |
	
	"La fuerza del Delantero se reduce en 50% siempre que tira a colocar... (no importa pelota, ni arquero)"
	"El Arquero que espera y se adelanta ante un tiro de jabulani a colocar ignora la 2da coordenada (altura) al atajar..."	
	"(al adelanterse encara la pelota antes de que su elevación se transforme en un problema)"
	
	delantero := Delantero decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero  esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 50.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@2 arqueroSeLanzaEnDirección: 0@0.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 0@2 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'tests' stamp: 'LK 9/25/2023 20:51:59' prior: 50684264!
test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero
	
	| arquero delantero juegoPenales pelota |
	
	"La fuerza del Delantero se reduce en 50% siempre que tira a colocar... (no importa pelota, ni arquero)"
	"La humilde pelota playera le hace perder un 20% de fuerza adicional al delantero que la use para colocar... (no importa el arquero)"
	"(no debería ser reglamentaria... al menos no es de trapo, nos responden)"
	
	delantero := Delantero decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 1.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 1@2 arqueroSeLanzaEnDirección: 1@2.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 1@2 equals: juegoPenales varDireccionRemateResultante.
	self assert: 40 equals: juegoPenales varFuerzaResultanteDeTiro! !
!PenalesTest methodsFor: 'tests' stamp: 'LK 9/25/2023 20:52:03' prior: 50684846!
test17ArqueroQueEligeAntesDeTiroVsPlayeraAColocarSuma100PorcFuerzaExtra
	
	| arquero delantero juegoPenales pelota |
	
	"La fuerza del Delantero se reduce en 50% siempre que tira a colocar... (no importa pelota, ni arquero)"
	"La humilde pelota playera le hace perder un 20% adicional de fuerza al delantero que la use para colocar... (no importa el arquero)"
	"Arquero que elige donde lanzarse antes de un remate de una pelota playera lenta a colocar, gana un 100% de su fuerza extra..."
	"(a quien madruga...)"
	
	delantero := Delantero decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 20.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@0 arqueroSeLanzaEnDirección: 0@0.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 0@0 equals: juegoPenales varDireccionRemateResultante.
	self assert: 40 equals: juegoPenales varFuerzaResultanteDeTiro.
	self assert: 40 equals: juegoPenales varFuerzaResultanteDeAtajada! !
!PenalesTest methodsFor: 'tests' stamp: 'LK 9/25/2023 20:52:08' prior: 50684920!
test18FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsPlayeraAColocar
	
	| arquero delantero juegoPenales pelota |
	
	"La fuerza del Delantero se reduce en 50% siempre que tira a colocar... (no importa pelota, ni arquero)"
	"La humilde pelota playera le hace perder un 20% adicional de fuerza al delantero que la use para colocar... (no importa el arquero)"
	"Arquero que elige donde lanzarse antes de un remate de una pelota playera lenta a colocar, gana un 100% de su fuerza extra..."
	
	delantero := Delantero decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 19.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@0 arqueroSeLanzaEnDirección: 0@0.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 0@0 equals: juegoPenales varDireccionRemateResultante.
	self assert: 40 equals: juegoPenales varFuerzaResultanteDeTiro.
	self assert: 38 equals: juegoPenales varFuerzaResultanteDeAtajada! !
!PenalesTest methodsFor: 'tests' stamp: 'LK 9/25/2023 20:52:15' prior: 50684300!
test19ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAColocarEsDescubiertoYPuntoParaDelantero
	
	| arquero delantero juegoPenales pelota |
	
	"Arquero que espera y se adelanta ante tiro con la lenta pelota playera, siempre es descubierto por el Árbitro, y el punto se le otorga al Delantero..."
	"(lo que servía de ventaja ante la Jabulani rápida, acá es tan obvio por lo que tarda en llegar la pelota al arco, que marchás preso...)"
	
	delantero := Delantero decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero  esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@0 arqueroSeLanzaEnDirección: 0@0.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 0@0 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'tests' stamp: 'LK 9/25/2023 20:52:19' prior: 50684537!
test20DelanteroTiraAMatarAlAnguloInferiorIzquierdoLaAlturaDelTiroPasaAMedio
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"(tirar a matar no es tan preciso como tirar a colocar, hay desvios de altura. Sin embargo se usa el 100% de fuerza del jugador)"
	
	delantero := Delantero decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@0 arqueroSeLanzaEnDirección: 0@0.
	.
	self assert: 0@1 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'tests' stamp: 'LK 9/25/2023 20:52:23' prior: 50684334!
test21DelanteroTiraAMatarAlAnguloSuperiorIzquierdoLaAlturaDelTiroPasaAMedio
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"(tirar a matar no es tan preciso como tirar a colocar, hay desvios de altura. Sin embargo se usa el 100% de fuerza del jugador)"
	
	delantero := Delantero decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@2 arqueroSeLanzaEnDirección: 0@2.
	
	self assert: 0@1 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'tests' stamp: 'LK 9/25/2023 20:52:26' prior: 50684788!
test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"(tirar a matar no es tan preciso como tirar a colocar, hay desvios de altura. Sin embargo se usa el 100% de fuerza del jugador)"
	
	delantero := Delantero decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@0 arqueroSeLanzaEnDirección: 2@0.
	
	self assert: 2@1 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'tests' stamp: 'LK 9/25/2023 20:52:30' prior: 50684998!
test23DelanteroTiraAMatarAlAnguloSuperiorDerechoLaAlturaDelTiroPasaAMedio
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"(tirar a matar no es tan preciso como tirar a colocar, hay desvios de altura. Sin embargo se usa el 100% de fuerza del jugador)"
	
	delantero := Delantero decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@2 arqueroSeLanzaEnDirección: 2@2.
	
	self assert: 2@1 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'tests' stamp: 'LK 9/25/2023 20:52:37' prior: 50684817!
test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"(tirar a matar no es tan preciso como tirar a colocar, hay desvios de altura. Sin embargo se usa el 100% de fuerza del jugador)"
	
	delantero := Delantero decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 1@2 arqueroSeLanzaEnDirección: 1@1.

	self assert: 1@2 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'tests' stamp: 'LK 9/25/2023 20:52:41' prior: 50684692!
test25DelanteroTiraAMatarUsa100PorcFuerzaBase
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"(tirar a matar no es tan preciso como tirar a colocar, hay desvios de altura. Sin embargo se usa el 100% de fuerza del jugador)"
	
	delantero := Delantero decideTirarAMatarSuFuerzaBaseEs:150.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@0 arqueroSeLanzaEnDirección: 2@0.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 2@1 equals: juegoPenales varDireccionRemateResultante.
	self assert: 150 equals: juegoPenales varFuerzaResultanteDeTiro! !
!PenalesTest methodsFor: 'tests' stamp: 'LK 9/25/2023 20:52:45' prior: 50684567!
test26DelanteroTiraAMatarConJabulaniGana20PorcFuerzaExtra
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' el Delantero usa el 100% de su fuerza... (no importa pelota, ni arquero)"
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"Si se tira 'a matar' usando la jabulani rápida, el Delantero gana un 20% de fuerza extra... (no importa arquero)"
	"(Jabulani a matar es la elección de los guerreros Z)"
	
	delantero := Delantero decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 120.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@2 arqueroSeLanzaEnDirección: 2@1.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 2@1 equals: juegoPenales varDireccionRemateResultante.
	self assert: 120 equals: juegoPenales varFuerzaResultanteDeTiro.! !
!PenalesTest methodsFor: 'tests' stamp: 'LK 9/25/2023 20:52:48' prior: 50684499!
test27FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAMatar
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' el Delantero usa el 100% de su fuerza... (no importa pelota, ni arquero)"
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"Si se tira 'a matar' usando la jabulani rápida, el Delantero gana un 20% de fuerza extra... (no importa arquero)"
	
	delantero := Delantero decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 119.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@2 arqueroSeLanzaEnDirección: 2@1.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 2@1 equals: juegoPenales varDireccionRemateResultante.
	self assert: 120 equals: juegoPenales varFuerzaResultanteDeTiro.! !
!PenalesTest methodsFor: 'tests' stamp: 'LK 9/25/2023 20:52:51' prior: 50684364!
test28ArqueroQueEligeAntesDeTiroVsJabulaniAMatarIgnoraAlturaTiro
	
	| arquero delantero juegoPenales pelota |
	
	"El Arquero que elige donde tirarse antes de un tiro de jabulani a matar, ignora la 2da coordenada (altura) al atajar..."		
	
	delantero := Delantero decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@2 arqueroSeLanzaEnDirección: 0@0.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 0@1 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'tests' stamp: 'LK 9/25/2023 20:52:55' prior: 50685124!
test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja
	
	| arquero delantero juegoPenales pelota |
	
	"El Arquero que espera a ver la dirección del remate de una pelota jabulani rápida a matar antes de lanzarse, nunca la ataja sin importar nada, siquiera que se adelantó..."	
	"(su poder era de más de 9000!! era impresionante, no podía moverme, sólo la ví pasar... f )"
	
	delantero := Delantero decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 1@1 arqueroSeLanzaEnDirección: 1@1.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 1@1 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'tests' stamp: 'LK 9/25/2023 20:52:58' prior: 50684392!
test30DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAdentro
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' el Delantero usa el 100% de su fuerza... (no importa pelota, ni arquero)"
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"Si se tira 'a matar' usando una pelota playera a una dirección que no es un ángulo, la 2da coordenada del remate (altura) suma 2, es decir sale volando producto de su liviandez (y que quiere retornar al mar). Si la pelota se va fuera del arco, el puntaje va al arquero... (no importa arquero)"
	"(y voló.. y me hizo volar... y yo volé de él...  pero acá por la arbolada... y el voló.. y se estrelló por acá por la pared...)"
	
	delantero := Delantero decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 1@0 arqueroSeLanzaEnDirección: 1@0.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 1@2 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'tests' stamp: 'LK 9/25/2023 20:53:01' prior: 50684606!
test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' el Delantero usa el 100% de su fuerza... (no importa pelota, ni arquero)"
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"Si se tira 'a matar' usando una pelota playera a una dirección que no es un ángulo, la 2da coordenada del remate (altura) suma 2, es decir sale volando producto de su liviandez (y que quiere retornar al mar). Si la pelota se va fuera del arco, el puntaje va al arquero... (no importa arquero)"
	"(El caso auspiciado por el Pipita...)"
	
	delantero := Delantero decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@1 arqueroSeLanzaEnDirección: 0@0.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 0@3 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'tests' stamp: 'LK 9/25/2023 20:53:05' prior: 50684960!
test32ArqueroQueEligeAntesDeTiroVsPlayeraAMatarAlAnguloIgnoraAnchoTiro
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' el Delantero usa el 100% de su fuerza... (no importa pelota, ni arquero)"
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"Si el arquero elige donde tirarse antes del tiro a matar de la pelota playera, ignora la 1ra coordenada del remate (ancho) al atajar..."
	"(con agacharse, quedarse parado, o saltar le alcanza...)"
	
	delantero := Delantero decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@0 arqueroSeLanzaEnDirección: 2@1.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 0@1 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'tests' stamp: 'LK 9/25/2023 20:53:08' prior: 50684649!
test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' el Delantero usa el 100% de su fuerza... (no importa pelota, ni arquero)"
	"Si se tira 'a matar' usando una pelota playera a una dirección que no es un ángulo, la 2da coordenada del remate (altura) suma 2, es decir sale volando producto de su liviandez (y que quiere retornar al mar). Si la pelota se va fuera del arco, el puntaje va al arquero... (no importa arquero)"
	"Si el arquero elige donde tirarse antes del tiro a matar de la pelota playera, ignora la 1ra coordenada del remate (ancho) al atajar..."
	"(con agacharse, quedarse parado, o saltar le alcanza...)"
	
	delantero := Delantero decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 1@0 arqueroSeLanzaEnDirección: 0@2.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 1@2 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'tests' stamp: 'LK 9/25/2023 20:53:14' prior: 50685062!
test34ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAMatarSiempreAtaja
	
	| arquero delantero juegoPenales pelota |
	
	"El Arquero que espera y se adelanta ante una pelota playera lenta a matar, siempre la ataja sin importar nada..."	
	"(como la pelota es taaaan lentaaa, el arquero se puede ir a tomar un cafe, verse una serie, volver y aún atajar la pelota habiendose tirado a cualquier lado. Pero igual es más rapida que cuando se la tira a colocar, donde indefectiblemente el arbitro lo detecta...)"
	
	delantero := Delantero decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 1.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@2 arqueroSeLanzaEnDirección: 0@0.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 2@1 equals: juegoPenales varDireccionRemateResultante! !

Object subclass: #Arquero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classDefinition: #Arquero category: 'ISW1-2023-2C-Parcial-1' stamp: 'LK 9/25/2023 21:00:38'!
Object subclass: #Arquero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!methodRemoval: Arquero #fuerza stamp: 'LK 9/25/2023 21:00:41'!
fuerza
	^fuerza!

!methodRemoval: Arquero #fuerzaResultanteContraJabulani stamp: 'LK 9/25/2023 21:00:47'!
fuerzaResultanteContraJabulani

	self subclassResponsibility!

!methodRemoval: Arquero #fuerzaResultanteContraPlayera stamp: 'LK 9/25/2023 21:00:49'!
fuerzaResultanteContraPlayera

	self subclassResponsibility!

!methodRemoval: DelanteroConTactic class #decideTirarAColocarSuFuerzaBaseEs: stamp: 'LK 9/25/2023 21:01:07'!
decideTirarAColocarSuFuerzaBaseEs: fuerzaJugador
	^self new initializeDecideTirarAColocarSuFuerzaBaseEs: fuerzaJugador.
!

!methodRemoval: DelanteroConTactic class #decideTirarAMatarSuFuerzaBaseEs: stamp: 'LK 9/25/2023 21:01:11'!
decideTirarAMatarSuFuerzaBaseEs: fuerzaJugador
	^self new initializeDecideTirarAMatarSuFuerzaBaseEs: fuerzaJugador !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 21:06:15'!
arqueroSeAdelantaConPlayera
	^self sumarPuntoDelantero! !

!methodRemoval: AMatar #fuerza stamp: 'LK 9/25/2023 21:09:48'!
fuerza
	^fuerza!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 21:11:39' prior: 50684093!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(self direccionEnRango: direccionTiro) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(self direccionEnRango: direccionArquero) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	(pelota tipo = #Jabulani) ifTrue: [
			penalPelota := #Jabulani.
			
		(delantero tipo = #AMatar) ifTrue: [self sumarPuntoDelantero].
		
		(arquero tipo = #EsperaYAdelanta) ifTrue: [
				((direccionTiro) x = (direccionArquero x) & 
				(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro))
				 	ifTrue: [self sumarPuntoArquero]]
					
				ifFalse: [(direccionTiro = direccionArquero) & 
				(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro) 
					ifTrue: [self sumarPuntoDelantero].
					
			].
		
		(arquero tipo = #Elige) ifTrue: [
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro ))
					ifTrue: [self sumarPuntoArquero].
			
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro )) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
		].
	(pelota = #Playera) ifTrue: [
			
			penalPelota := #Playera.
			
			(arquero tipo = #Elige) ifTrue: [
				
				(direccionTiro = direccionArquero & 
				self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro)
					ifTrue: [self sumarPuntoArquero].
			
				(direccionTiro = direccionArquero & 
				self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
			(arquero tipo = #EsperaYadelanta) ifTrue: [self sumarPuntoDelantero].
				
		].
			
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 21:13:21' prior: 50686239!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(self direccionEnRango: direccionTiro) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(self direccionEnRango: direccionArquero) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	(pelota tipo = #Jabulani) ifTrue: [
		penalPelota := #Jabulani.
		
		(arquero tipo = #EsperaYAdelanta) ifTrue: [
				((direccionTiro) x = (direccionArquero x) & 
				(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro))
				 	ifTrue: [self sumarPuntoArquero]]
					
				ifFalse: [(direccionTiro = direccionArquero) & 
				(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro) 
					ifTrue: [self sumarPuntoDelantero].
					
			].
		
		(arquero tipo = #Elige) ifTrue: [
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro ))
					ifTrue: [self sumarPuntoArquero].
			
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro )) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
		].
	(pelota = #Playera) ifTrue: [
			
			penalPelota := #Playera.
			
			(arquero tipo = #Elige) ifTrue: [
				
				(direccionTiro = direccionArquero & 
				self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro)
					ifTrue: [self sumarPuntoArquero].
			
				(direccionTiro = direccionArquero & 
				self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
			(arquero tipo = #EsperaYadelanta) ifTrue: [self sumarPuntoDelantero].
				
		].
			
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

----QUIT----(25 September 2023 21:25:08) CuisUniversity-5981.image priorSource: 10898289!

----STARTUP---- (30 September 2023 00:47:00) as C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\CuisUniversity-5981.image!


!classRemoval: #Penales stamp: 'LK 9/30/2023 00:49:09'!
Object subclass: #Penales
	instanceVariableNames: 'puntajeDelantero puntajeArquero direccionDelTiroDelantero direccionDelArquero delantero arquero penalPelota'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classRemoval: #PPlayera stamp: 'LK 9/30/2023 00:49:10'!
PelotaDePenalti subclass: #PPlayera
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classRemoval: #PJabulani stamp: 'LK 9/30/2023 00:49:10'!
PelotaDePenalti subclass: #PJabulani
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classRemoval: #PelotaDePenalti stamp: 'LK 9/30/2023 00:49:10'!
Object subclass: #PelotaDePenalti
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classRemoval: #Pelota stamp: 'LK 9/30/2023 00:49:10'!
Object subclass: #Pelota
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classRemoval: #AMatar stamp: 'LK 9/30/2023 00:49:10'!
DelanteroConTactic subclass: #AMatar
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classRemoval: #AColocar stamp: 'LK 9/30/2023 00:49:10'!
DelanteroConTactic subclass: #AColocar
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classRemoval: #DelanteroConTactic stamp: 'LK 9/30/2023 00:49:11'!
Object subclass: #DelanteroConTactic
	instanceVariableNames: 'fuerza'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classRemoval: #Delantero stamp: 'LK 9/30/2023 00:49:11'!
Object subclass: #Delantero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classRemoval: #EsperaYAdelanta stamp: 'LK 9/30/2023 00:49:11'!
ArqueroConTactica subclass: #EsperaYAdelanta
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classRemoval: #Elige stamp: 'LK 9/30/2023 00:49:11'!
ArqueroConTactica subclass: #Elige
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classRemoval: #ArqueroConTactica stamp: 'LK 9/30/2023 00:49:11'!
Object subclass: #ArqueroConTactica
	instanceVariableNames: 'fuerza'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classRemoval: #Arquero stamp: 'LK 9/30/2023 00:49:12'!
Object subclass: #Arquero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classRemoval: #PenalesTest stamp: 'LK 9/30/2023 00:49:12'!
TestCase subclass: #PenalesTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

----End fileIn of C:\Users\lucas\OneDrive\Desktop\ISW1-2023-2C-Parcial-1-Ifs.st----!

----QUIT----(30 September 2023 00:54:32) CuisUniversity-5981.image priorSource: 11354725!

----STARTUP---- (30 September 2023 01:04:04) as C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\CuisUniversity-5981.image!


!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'LK 9/30/2023 01:04:13'!
PASSED!

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'LK 9/30/2023 01:04:15'!
PASSED!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'LK 9/30/2023 01:04:15'!
PASSED!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'LK 9/30/2023 01:04:15'!
PASSED!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'LK 9/30/2023 01:04:15'!
PASSED!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'LK 9/30/2023 01:04:15'!
PASSED!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'LK 9/30/2023 01:04:15'!
PASSED!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'LK 9/30/2023 01:04:15'!
PASSED!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'LK 9/30/2023 01:04:16'!
PASSED!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'LK 9/30/2023 01:04:16'!
PASSED!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'LK 9/30/2023 01:04:16'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test01findEncuentraEnElStack stamp: 'LK 9/30/2023 01:04:19'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test02findNoEncuentraEnElStack stamp: 'LK 9/30/2023 01:04:19'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test03findEsCaseSensitive stamp: 'LK 9/30/2023 01:04:19'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test04findNoAceptaPrefijoVacio stamp: 'LK 9/30/2023 01:04:19'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test05findNoModificaElStack stamp: 'LK 9/30/2023 01:04:19'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test06assertErrorNoAceptaEspaciosEnBlanco stamp: 'LK 9/30/2023 01:04:19'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test07inicializarConStackVacio stamp: 'LK 9/30/2023 01:04:19'!
PASSED!

----QUIT----(30 September 2023 01:04:58) CuisUniversity-5981.image priorSource: 11403944!

----STARTUP---- (2 October 2023 13:39:31) as C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\CuisUniversity-5981.image!


!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test34SubstractingAHigherValueToANumberReturnsANegativeNumber stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test35FibonacciZeroIsOne stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test36FibonacciOneIsOne stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test38FibonacciNotDefinedForNegativeNumbers stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test39NegationOfEnteroIsCorrect stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test40NegationOfFraccionIsCorrect stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test41SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

----QUIT----(2 October 2023 15:02:37) CuisUniversity-5981.image priorSource: 11406091!

----STARTUP---- (2 October 2023 20:27:57) as C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\CuisUniversity-5981.image!


Object subclass: #HundredDoors
	VariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: ''!

Object subclass: #HundredDoors
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: ''!

!classDefinition: #HundredDoors category: 'as yet unclassified' stamp: 'LK 10/2/2023 20:28:58'!
Object subclass: #HundredDoors
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'as yet unclassified'!

Object subclass: #HundredDoors
	instanceVariableNames: 'contador puertas'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'as yet unclassified'!

!classDefinition: #HundredDoors category: 'as yet unclassified' stamp: 'LK 10/2/2023 20:30:41'!
Object subclass: #HundredDoors
	instanceVariableNames: 'contador puertas'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'as yet unclassified'!
!HundredDoors methodsFor: 'no messages' stamp: 'LK 10/2/2023 20:31:11' overrides: 16920235!
initialize
	contador := 0.
	puertas := Array new: 100.! !

Object subclass: #HundredDoorsTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'as yet unclassified'!

!classDefinition: #HundredDoorsTest category: 'as yet unclassified' stamp: 'LK 10/2/2023 20:31:33'!
Object subclass: #HundredDoorsTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'as yet unclassified'!
!HundredDoorsTest methodsFor: 'no messages' stamp: 'LK 10/2/2023 20:31:53'!
test01PuertasInicianCerradas
	! !
!HundredDoors methodsFor: 'as yet unclassified' stamp: 'LK 10/2/2023 20:35:57' prior: 50688269 overrides: 16920235!
initialize
	
	|ix|
	
	contador := 0.
	puertas := Array new: 100.
	
	ix := 1.

	[ix < puertas size] whileTrue: [puertas at: ix put: false. ix := ix + 1].
	! !
!HundredDoors methodsFor: 'as yet unclassified' stamp: 'LK 10/2/2023 20:39:24'!
cantidadPuertasCerradas
	
	^(puertas select: [ :a | a = false]) size! !
!HundredDoors methodsFor: 'as yet unclassified' stamp: 'LK 10/2/2023 20:39:40'!
cantidadPuertasAbiertas
	
	^100 - self cantidadPuertasCerradas ! !
!HundredDoorsTest methodsFor: 'as yet unclassified' stamp: 'LK 10/2/2023 20:41:05' prior: 50688286!
test01PuertasInicianCerradas


	| doorsFlipper |
	
	doorsFlipper := HundredDoors new.
	
	self assert: doorsFlipper cantidadPuertasCerradas equals: 100.! !
!HundredDoorsTest methodsFor: 'as yet unclassified' stamp: 'LK 10/2/2023 20:41:16'!
test01puertasInicianCerradas


	| doorsFlipper |
	
	doorsFlipper := HundredDoors new.
	
	self assert: doorsFlipper cantidadPuertasCerradas equals: 100.! !

!methodRemoval: HundredDoorsTest #test01PuertasInicianCerradas stamp: 'LK 10/2/2023 20:41:18'!
test01PuertasInicianCerradas


	| doorsFlipper |
	
	doorsFlipper := HundredDoors new.
	
	self assert: doorsFlipper cantidadPuertasCerradas equals: 100.!
!HundredDoorsTest methodsFor: 'as yet unclassified' stamp: 'LK 10/2/2023 20:42:01' prior: 50688318!
test01puertasInicianCerradas


	| doorsFlipper |
	
	doorsFlipper := HundredDoors new.
	
	self assert: doorsFlipper cantidadPuertasCerradas equals: 100.! !

Object subclass: #HundredDoors
	instanceVariableNames: 'contador puertas'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Hundred Doors'!

!classDefinition: #HundredDoors category: 'Hundred Doors' stamp: 'LK 10/2/2023 20:44:08'!
Object subclass: #HundredDoors
	instanceVariableNames: 'contador puertas'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Hundred Doors'!

Object subclass: #HundredDoorsTests
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Hundred Doors'!

!classDefinition: #HundredDoorsTests category: 'Hundred Doors' stamp: 'LK 10/2/2023 20:44:21'!
Object subclass: #HundredDoorsTests
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Hundred Doors'!

!classRemoval: #HundredDoorsTest stamp: 'LK 10/2/2023 20:44:24'!
Object subclass: #HundredDoorsTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Hundred Doors'!
!HundredDoorsTests methodsFor: 'no messages' stamp: 'LK 10/2/2023 20:45:11'!
test01
	
	| doorFlipper |
	
	doorFlipper := HundredDoors new.
	
	self assert: (doorFlipper isClosed: 1).! !
!HundredDoorsTests methodsFor: 'as yet unclassified' stamp: 'LK 10/2/2023 20:47:30' prior: 50688372!
test01
	
	| doorFlipper |
	
	doorFlipper := HundredDoors new.
	
	self assert: (doorFlipper isClosed: 1)! !
!HundredDoorsTests methodsFor: 'as yet unclassified' stamp: 'LK 10/2/2023 20:47:38'!
test01sadasd 

	| doorFlipper |
	
	doorFlipper := HundredDoors new.
	
	self assert: (doorFlipper isClosed: 1)! !
!HundredDoorsTests methodsFor: 'as yet unclassified' stamp: 'LK 10/2/2023 20:48:43' prior: 50688379!
test01
	
	| hundredDoors |
	
	hundredDoors := HundredDoors new.
	
	self assert: (hundredDoors isClosed: 1)! !

!methodRemoval: HundredDoorsTests #test01sadasd stamp: 'LK 10/2/2023 20:51:25'!
test01sadasd 

	| doorFlipper |
	
	doorFlipper := HundredDoors new.
	
	self assert: (doorFlipper isClosed: 1)!
!HundredDoorsTests methodsFor: 'as yet unclassified' stamp: 'LK 10/2/2023 20:58:41'!
test01AllDoorsStartClosed

	| hundredDoors |
	
	hundredDoors := HundredDoors new.
	
	self assert: (hundredDoors isClosed: 1)! !
!HundredDoorsTests methodsFor: 'as yet unclassified' stamp: 'LK 10/2/2023 20:59:17'!
test01AllClosedDoorsEndOpened

	| hundredDoors |
	
	hundredDoors := HundredDoors new.
	
	hundredDoors flip.
	
	self assert: (hundredDoors isClosed: 1)! !
!HundredDoorsTests methodsFor: 'as yet unclassified' stamp: 'LK 10/2/2023 20:59:36'!
test01AllOpenedDoorsEndClosed

	| hundredDoors |
	
	hundredDoors := HundredDoors new.
	
	hundredDoors flip.
	hundredDoors flip.
	
	self assert: (hundredDoors isClosed: 1)! !
!HundredDoorsTests methodsFor: 'as yet unclassified' stamp: 'LK 10/2/2023 20:59:42'!
test03AllOpenedDoorsEndClosed

	| hundredDoors |
	
	hundredDoors := HundredDoors new.
	
	hundredDoors flip.
	hundredDoors flip.
	
	self assert: (hundredDoors isClosed: 1)! !

!methodRemoval: HundredDoorsTests #test01 stamp: 'LK 10/2/2023 20:59:48'!
test01
	
	| hundredDoors |
	
	hundredDoors := HundredDoors new.
	
	self assert: (hundredDoors isClosed: 1)!
!HundredDoorsTests methodsFor: 'as yet unclassified' stamp: 'LK 10/2/2023 20:59:59'!
test02AllClosedDoorsEndOpened

	| hundredDoors |
	
	hundredDoors := HundredDoors new.
	
	hundredDoors flip.
	
	self deny: (hundredDoors isClosed: 1)! !

!methodRemoval: HundredDoorsTests #test01AllOpenedDoorsEndClosed stamp: 'LK 10/2/2023 21:00:06'!
test01AllOpenedDoorsEndClosed

	| hundredDoors |
	
	hundredDoors := HundredDoors new.
	
	hundredDoors flip.
	hundredDoors flip.
	
	self assert: (hundredDoors isClosed: 1)!

!methodRemoval: HundredDoorsTests #test01AllClosedDoorsEndOpened stamp: 'LK 10/2/2023 21:00:10'!
test01AllClosedDoorsEndOpened

	| hundredDoors |
	
	hundredDoors := HundredDoors new.
	
	hundredDoors flip.
	
	self assert: (hundredDoors isClosed: 1)!
!HundredDoorsTests methodsFor: 'as yet unclassified' stamp: 'LK 10/2/2023 21:02:22' prior: 50688429!
test03AllOpenedDoorsEndClosed

	| hundredDoors |
	
	hundredDoors := HundredDoors with: 2.
	
	hundredDoors flip.
	
	self deny: (hundredDoors isClosed: 1).
	self deny: (hundredDoors isClosed: 2).! !
!HundredDoors methodsFor: 'as yet unclassified' stamp: 'LK 10/2/2023 21:02:49' prior: 50688291 overrides: 16920235!
initialize

"
	
	|ix|
	
	contador := 0.
	puertas := Array new: 100.
	
	ix := 1.

	[ix < puertas size] whileTrue: [puertas at: ix put: false. ix := ix + 1].
"	! !
!HundredDoors class methodsFor: 'nil' stamp: 'LK 10/2/2023 21:04:50'!
with: aNumberDoors

	^self new initializeWith: aNumberDoors.! !

!classDefinition: #HundredDoors category: 'Hundred Doors' stamp: 'LK 10/2/2023 21:05:10'!
Object subclass: #HundredDoors
	instanceVariableNames: 'contador puertas closed'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Hundred Doors'!
!HundredDoors methodsFor: 'as yet unclassified' stamp: 'LK 10/2/2023 21:05:08' prior: 50688478 overrides: 16920235!
initialize

	closed := true.

"
	
	|ix|
	
	contador := 0.
	puertas := Array new: 100.
	
	ix := 1.

	[ix < puertas size] whileTrue: [puertas at: ix put: false. ix := ix + 1].
"	! !
!HundredDoors methodsFor: 'as yet unclassified' stamp: 'LK 10/2/2023 21:05:20'!
initializeWith: aNumberOfDoors

	closed := true.

"
	
	|ix|
	
	contador := 0.
	puertas := Array new: 100.
	
	ix := 1.

	[ix < puertas size] whileTrue: [puertas at: ix put: false. ix := ix + 1].
"	! !
!HundredDoors methodsFor: 'as yet unclassified' stamp: 'LK 10/2/2023 21:05:27'!
flip! !
!HundredDoorsTests methodsFor: 'as yet unclassified' stamp: 'LK 10/2/2023 21:05:53'!
test04AllOpenedDoorsEndClosed

	| hundredDoors |
	
	hundredDoors := HundredDoors with: 2.
	
	hundredDoors flip.
	
	self deny: (hundredDoors isClosed: 1).
	self deny: (hundredDoors isClosed: 2).! !
!HundredDoorsTests methodsFor: 'as yet unclassified' stamp: 'LK 10/2/2023 21:06:26' prior: 50688468!
test03AllOpenedDoorsEndClosed

	| hundredDoors |
	
	hundredDoors := HundredDoors with: 2.
	
	hundredDoors flip.
	hundredDoors flip.
	
	self assert: (hundredDoors isClosed: 1).! !
!HundredDoorsTests methodsFor: 'as yet unclassified' stamp: 'LK 10/2/2023 21:06:35' prior: 50688531!
test03AllOpenedDoorsEndClosed

	| hundredDoors |
	
	hundredDoors := HundredDoors new.
	
	hundredDoors flip.
	hundredDoors flip.
	
	self assert: (hundredDoors isClosed: 1).! !
!HundredDoorsTests methodsFor: 'as yet unclassified' stamp: 'LK 10/2/2023 21:06:50' prior: 50688521!
test04AllOpenedDoorsEndClosed

	| hundredDoors |
	
	hundredDoors := HundredDoors with: 2.
	
	hundredDoors flip.
	hundredDoors flip.
	
	self deny: (hundredDoors isClosed: 1).
	self deny: (hundredDoors isClosed: 2).! !
!HundredDoorsTests methodsFor: 'as yet unclassified' stamp: 'LK 10/2/2023 21:08:54'!
test04TwoOpenedDoorsEndClosed

	| hundredDoors |
	
	hundredDoors := HundredDoors with: 2.
	
	hundredDoors flip.
	hundredDoors flip.
	
	self assert: (hundredDoors isClosed: 1).
	self assert: (hundredDoors isClosed: 2).! !

!methodRemoval: HundredDoorsTests #test04AllOpenedDoorsEndClosed stamp: 'LK 10/2/2023 21:09:03'!
test04AllOpenedDoorsEndClosed

	| hundredDoors |
	
	hundredDoors := HundredDoors with: 2.
	
	hundredDoors flip.
	hundredDoors flip.
	
	self deny: (hundredDoors isClosed: 1).
	self deny: (hundredDoors isClosed: 2).!
!HundredDoorsTests methodsFor: 'as yet unclassified' stamp: 'LK 10/2/2023 21:10:42'!
test05

	|doorsFlipper |
	
	doorsFlipper := HundredDoors with: 4.
	
	doorsFlipper flipBy: 2.
	
	self assert: (doorsFlipper isClosed: 1).
	self deny: (doorsFlipper isClosed: 2).
	self assert: (doorsFlipper isClosed: 3).
	self deny: (doorsFlipper isClosed: 4).

	! !
!HundredDoors methodsFor: 'as yet unclassified' stamp: 'LK 10/2/2023 21:15:05' prior: 50688500 overrides: 16920235!
initialize

	closed := true.

"
	
	|ix|
	
	contador := 0.
	puertas := Array new: 100.
	
	ix := 1.

	[ix < puertas size] whileTrue: [puertas at: ix put: false. ix := ix + 1].
	
	
	1 to puertas size by: aStep do: [ :aDoorNumber | closed at: aDoorNumber put: (closed at: aDoorNumber) not]
"	! !

----QUIT----(2 October 2023 21:34:21) CuisUniversity-5981.image priorSource: 11410667!

----STARTUP---- (5 October 2023 17:40:10) as C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\CuisUniversity-5981.image!


Object subclass: #Calendario
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Calendario-Exercise'!

!classDefinition: #Calendario category: 'Calendario-Exercise' stamp: 'LK 10/5/2023 17:41:28'!
Object subclass: #Calendario
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Calendario-Exercise'!

TestCase subclass: #CalendarioTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Calendario-Exercise'!

!classDefinition: #CalendarioTest category: 'Calendario-Exercise' stamp: 'LK 10/5/2023 17:41:48'!
TestCase subclass: #CalendarioTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Calendario-Exercise'!
!CalendarioTest methodsFor: 'no messages' stamp: 'LK 10/5/2023 17:44:53' overrides: 16961394!
setUp
	
	| calendario |
	
	calendario = Calendario new.! !

TestCase subclass: #CalendarioTest
	instanceVariableNames: 'calendar'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Calendario-Exercise'!

!classDefinition: #CalendarioTest category: 'Calendario-Exercise' stamp: 'LK 10/5/2023 17:46:17'!
TestCase subclass: #CalendarioTest
	instanceVariableNames: 'calendar'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Calendario-Exercise'!
!CalendarioTest methodsFor: 'as yet unclassified' stamp: 'LK 10/5/2023 17:46:26' prior: 50688634 overrides: 16961394!
setUp
	
	calendar = Calendario new.! !
!CalendarioTest methodsFor: 'as yet unclassified' stamp: 'LK 10/5/2023 17:46:33' prior: 50688653 overrides: 16961394!
setUp
	
	calendar := Calendario new.! !
!CalendarioTest methodsFor: 'as yet unclassified' stamp: 'LK 10/5/2023 17:46:37'!
test01! !
!CalendarioTest methodsFor: 'as yet unclassified' stamp: 'LK 10/5/2023 17:47:41' prior: 50688662!
test01
	
	self assert: calendar esFeriado: October/5/2023 equals false.! !

!testRun: #CalendarioTest #test01 stamp: 'LK 10/5/2023 17:47:47'!
ERROR!
!CalendarioTest methodsFor: 'as yet unclassified' stamp: 'LK 10/5/2023 17:48:51' prior: 50688666!
test01
	
	self assert: (calendar esFeriado: October/5/2023 = false).! !

!testRun: #CalendarioTest #test01 stamp: 'LK 10/5/2023 17:48:54'!
ERROR!
!Calendario methodsFor: 'feriados' stamp: 'LK 10/5/2023 17:49:12'!
esFeriado: aRenameMe1 
	self shouldBeImplemented.! !
!Calendario methodsFor: 'feriados' stamp: 'LK 10/5/2023 17:49:25' prior: 50688681!
esFeriado: unaFecha 
	^false! !

!testRun: #CalendarioTest #test01 stamp: 'LK 10/5/2023 17:49:29'!
FAILURE!

!testRun: #CalendarioTest #test01 stamp: 'LK 10/5/2023 17:50:15'!
FAILURE!
!Calendario methodsFor: 'feriados' stamp: 'LK 10/5/2023 17:50:26' prior: 50688686!
esFeriado: unaFecha 

	^false! !
!CalendarioTest methodsFor: 'as yet unclassified' stamp: 'LK 10/5/2023 17:51:18' prior: 50688674!
test01
	
	self deny: (calendar esFeriado: October/5/2023)! !

!testRun: #CalendarioTest #test01 stamp: 'LK 10/5/2023 17:51:19'!
PASSED!

!testRun: #CalendarioTest #test01 stamp: 'LK 10/5/2023 17:51:19'!
PASSED!

GregorianDate!

GregorianDate!

GregorianDate methods!

GregorianDate method!

GregorianDay monday!
!CalendarioTest methodsFor: 'as yet unclassified' stamp: 'LK 10/5/2023 17:56:09'!
test02

	calendar agregarFeriadoPorDiaParticular: October/5/2023.
	
	
	self deny: (calendar esFeriado: October/5/2023)! !
!CalendarioTest methodsFor: 'as yet unclassified' stamp: 'LK 10/5/2023 17:57:43' prior: 50688713!
test02

	calendar agregarFeriadoPorDiaParticular: October/5/2023.
	
	
	self assert: (calendar esFeriado: October/5/2023)! !

!testRun: #CalendarioTest #test02 stamp: 'LK 10/5/2023 17:57:44'!
ERROR!
!Calendario methodsFor: 'feriados' stamp: 'LK 10/5/2023 17:57:49'!
agregarFeriadoPorDiaParticular: aRenameMe1 
	self shouldBeImplemented.! !

!classDefinition: #Calendario category: 'Calendario-Exercise' stamp: 'LK 10/5/2023 17:58:24'!
Object subclass: #Calendario
	instanceVariableNames: 'feriadosExactos'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Calendario-Exercise'!
!Calendario methodsFor: 'feriados' stamp: 'LK 10/5/2023 17:58:22' prior: 50688729!
agregarFeriadoPorDiaParticular: unaFecha

	feriadosExactos add: unaFecha.! !
!Calendario methodsFor: 'feriados' stamp: 'LK 10/5/2023 17:59:06' overrides: 16920235!
initialize
	
	feriadosExactos := Set new.! !
!Calendario methodsFor: 'feriados' stamp: 'LK 10/5/2023 18:01:13' prior: 50688695!
esFeriado: unaFecha 


	(feriadosExactos includes: unaFecha) ifTrue: [^true].
	
	^false! !

!testRun: #CalendarioTest #test02 stamp: 'LK 10/5/2023 18:01:18'!
PASSED!

!testRun: #CalendarioTest #test01 stamp: 'LK 10/5/2023 18:01:18'!
PASSED!

!testRun: #CalendarioTest #test02 stamp: 'LK 10/5/2023 18:01:18'!
PASSED!
!CalendarioTest methodsFor: 'as yet unclassified' stamp: 'LK 10/5/2023 18:29:52'!
test03

	| unDomingo |
	
	calendar.
	unDomingo := October / 8 / 2023.
	
	self assert: (calendar esFeriado: unDomingo)! !
!CalendarioTest methodsFor: 'as yet unclassified' stamp: 'LK 10/5/2023 18:30:11' prior: 50688765!
test03

	| unDomingo |
	
	calendar agregarDiaDeSemanaFeriado: Sunday.
	
	unDomingo := October / 8 / 2023.
	
	self assert: (calendar esFeriado: unDomingo)! !

!testRun: #CalendarioTest #test03 stamp: 'LK 10/5/2023 18:30:17'!
ERROR!

!testRun: #CalendarioTest #test03 stamp: 'LK 10/5/2023 18:30:17'!
ERROR!
!Calendario methodsFor: 'feriados' stamp: 'LK 10/5/2023 18:30:23'!
agregarDiaDeSemanaFeriado: Sunday 
	self shouldBeImplemented.! !
!Calendario methodsFor: 'feriados' stamp: 'LK 10/5/2023 18:31:07' prior: 50688752!
esFeriado: unaFecha 

	(unaFecha day = Sunday) ifTrue: [^true].

	(feriadosExactos includes: unaFecha) ifTrue: [^true].
	
	^false! !

!testRun: #CalendarioTest #test03 stamp: 'LK 10/5/2023 18:31:13'!
ERROR!
!Calendario methodsFor: 'feriados' stamp: 'LK 10/5/2023 18:31:33' prior: 50688784!
agregarDiaDeSemanaFeriado: Sunday 
	! !

!testRun: #CalendarioTest #test03 stamp: 'LK 10/5/2023 18:31:37'!
PASSED!

!testRun: #CalendarioTest #test01 stamp: 'LK 10/5/2023 18:31:37'!
PASSED!

!testRun: #CalendarioTest #test02 stamp: 'LK 10/5/2023 18:31:38'!
PASSED!

!testRun: #CalendarioTest #test03 stamp: 'LK 10/5/2023 18:31:38'!
PASSED!
!Calendario methodsFor: 'feriados' stamp: 'LK 10/5/2023 18:32:05' prior: 50688799!
agregarDiaDeSemanaFeriado: unDiaDeSemana
! !
!CalendarioTest methodsFor: 'as yet unclassified' stamp: 'LK 10/5/2023 18:32:45'!
test04

	| unSabado |
	
	calendar agregarDiaDeSemanaFeriado: Saturday.
	
	unSabado := October / 8 / 2023.
	
	self assert: (calendar esFeriado: unSabado)! !
!Calendario methodsFor: 'feriados' stamp: 'LK 10/5/2023 18:33:11' prior: 50688789!
esFeriado: unaFecha 

	((unaFecha day = Sunday) or: [unaFecha day = Saturday]) ifTrue: [^true].

	(feriadosExactos includes: unaFecha) ifTrue: [^true].
	
	^false! !

!testRun: #CalendarioTest #test04 stamp: 'LK 10/5/2023 18:33:14'!
PASSED!

!testRun: #CalendarioTest #test01 stamp: 'LK 10/5/2023 18:34:00'!
PASSED!

!testRun: #CalendarioTest #test02 stamp: 'LK 10/5/2023 18:34:00'!
PASSED!

!testRun: #CalendarioTest #test03 stamp: 'LK 10/5/2023 18:34:00'!
PASSED!

!testRun: #CalendarioTest #test04 stamp: 'LK 10/5/2023 18:34:00'!
PASSED!

Object subclass: #Calendario
	instanceVariableNames: 'feriadosExactos feriadosDiaDeSemana'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Calendario-Exercise'!

!classDefinition: #Calendario category: 'Calendario-Exercise' stamp: 'LK 10/5/2023 18:34:23'!
Object subclass: #Calendario
	instanceVariableNames: 'feriadosExactos feriadosDiaDeSemana'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Calendario-Exercise'!
!Calendario methodsFor: 'feriados' stamp: 'LK 10/5/2023 18:34:35' prior: 50688748 overrides: 16920235!
initialize
	
	feriadosExactos := Set new.
	
	feriadosDiaDeSemana := Set new.! !
!Calendario methodsFor: 'feriados' stamp: 'LK 10/5/2023 18:34:52' prior: 50688813!
agregarDiaDeSemanaFeriado: unDiaDeSemana

	feriadosDiaDeSemana add: unDiaDeSemana day.! !
!Calendario methodsFor: 'feriados' stamp: 'LK 10/5/2023 18:35:13' prior: 50688825!
esFeriado: unaFecha 

	(feriadosDiaDeSemana includes: unaFecha day) ifTrue: [^true].

	(feriadosExactos includes: unaFecha) ifTrue: [^true].
	
	^false! !

!testRun: #CalendarioTest #test01 stamp: 'LK 10/5/2023 18:35:16'!
PASSED!

!testRun: #CalendarioTest #test02 stamp: 'LK 10/5/2023 18:35:16'!
PASSED!

!testRun: #CalendarioTest #test03 stamp: 'LK 10/5/2023 18:35:16'!
ERROR!

!testRun: #CalendarioTest #test04 stamp: 'LK 10/5/2023 18:35:16'!
ERROR!

!testRun: #CalendarioTest #test03 stamp: 'LK 10/5/2023 18:35:24'!
ERROR!

!testRun: #CalendarioTest #test03 stamp: 'LK 10/5/2023 18:35:24'!
ERROR!

!testRun: #CalendarioTest #test03 stamp: 'LK 10/5/2023 18:35:37'!
ERROR!
!Calendario methodsFor: 'feriados' stamp: 'LK 10/5/2023 18:35:48' prior: 50688865!
agregarDiaDeSemanaFeriado: unDiaDeSemana

	feriadosDiaDeSemana add: unDiaDeSemana.! !

!testRun: #CalendarioTest #test01 stamp: 'LK 10/5/2023 18:35:51'!
PASSED!

!testRun: #CalendarioTest #test02 stamp: 'LK 10/5/2023 18:35:51'!
PASSED!

!testRun: #CalendarioTest #test03 stamp: 'LK 10/5/2023 18:35:51'!
PASSED!

!testRun: #CalendarioTest #test04 stamp: 'LK 10/5/2023 18:35:51'!
FAILURE!

!testRun: #CalendarioTest #test04 stamp: 'LK 10/5/2023 18:35:51'!
FAILURE!

!testRun: #CalendarioTest #test03 stamp: 'LK 10/5/2023 18:36:35'!
PASSED!
!CalendarioTest methodsFor: 'tests' stamp: 'LK 10/5/2023 18:36:44' prior: 50688817!
test04

	| unSabado |
	
	calendar agregarDiaDeSemanaFeriado: Saturday.
	
	unSabado := October / 7 / 2023.
	
	self assert: (calendar esFeriado: unSabado)! !

!testRun: #CalendarioTest #test04 stamp: 'LK 10/5/2023 18:36:46'!
PASSED!

!testRun: #CalendarioTest #test01 stamp: 'LK 10/5/2023 18:36:46'!
PASSED!

!testRun: #CalendarioTest #test02 stamp: 'LK 10/5/2023 18:36:46'!
PASSED!

!testRun: #CalendarioTest #test03 stamp: 'LK 10/5/2023 18:36:46'!
PASSED!

!testRun: #CalendarioTest #test04 stamp: 'LK 10/5/2023 18:36:46'!
PASSED!
!CalendarioTest methodsFor: 'tests' stamp: 'LK 10/5/2023 18:44:30' prior: 50688915!
test04

	| unSabado |
	
	" esta de mas"
	
	calendar agregarDiaDeSemanaFeriado: Saturday.
	
	unSabado := October / 7 / 2023.
	
	self assert: (calendar esFeriado: unSabado)! !
!CalendarioTest methodsFor: 'tests' stamp: 'LK 10/5/2023 18:44:49'!
test01ThereCanBeNoHolidays
	
	self deny: (calendar esFeriado: October/5/2023)! !

!methodRemoval: CalendarioTest #test01 stamp: 'LK 10/5/2023 18:44:54'!
test01
	
	self deny: (calendar esFeriado: October/5/2023)!
!CalendarioTest methodsFor: 'tests' stamp: 'LK 10/5/2023 18:45:54'!
test02OneDateCanBeHoliday

	calendar agregarFeriadoPorDiaParticular: October/5/2023.
	
	
	self assert: (calendar esFeriado: October/5/2023)! !

!methodRemoval: CalendarioTest #test02 stamp: 'LK 10/5/2023 18:45:57'!
test02

	calendar agregarFeriadoPorDiaParticular: October/5/2023.
	
	
	self assert: (calendar esFeriado: October/5/2023)!
!CalendarioTest methodsFor: 'tests' stamp: 'LK 10/5/2023 18:46:09'!
test03OneWeekdayCanBeHoliday

	| unDomingo |
	
	calendar agregarDiaDeSemanaFeriado: Sunday.
	
	unDomingo := October / 8 / 2023.
	
	self assert: (calendar esFeriado: unDomingo)! !

!methodRemoval: CalendarioTest #test03 stamp: 'LK 10/5/2023 18:46:13'!
test03

	| unDomingo |
	
	calendar agregarDiaDeSemanaFeriado: Sunday.
	
	unDomingo := October / 8 / 2023.
	
	self assert: (calendar esFeriado: unDomingo)!
!CalendarioTest methodsFor: 'tests' stamp: 'LK 10/5/2023 18:47:19'!
test04MoreThanOneWeekdayCanBeHoliday

	| unSabado unLunes|
	
	
	calendar agregarDiaDeSemanaFeriado: Saturday.
	calendar agregarDiaDeSemanaFeriado: Monday.
	
	unSabado := October / 7 / 2023.
	
	unLunes := October / 9 / 2023.
	
	self assert: (calendar esFeriado: unSabado).
	
	self assert: (calendar esFeriado: unLunes).! !

!testRun: #CalendarioTest #test04MoreThanOneWeekdayCanBeHoliday stamp: 'LK 10/5/2023 18:47:19'!
PASSED!

!testRun: #CalendarioTest #test01ThereCanBeNoHolidays stamp: 'LK 10/5/2023 18:47:19'!
PASSED!

!testRun: #CalendarioTest #test02OneDateCanBeHoliday stamp: 'LK 10/5/2023 18:47:19'!
PASSED!

!testRun: #CalendarioTest #test03OneWeekdayCanBeHoliday stamp: 'LK 10/5/2023 18:47:19'!
PASSED!

!testRun: #CalendarioTest #test04 stamp: 'LK 10/5/2023 18:47:19'!
PASSED!

!testRun: #CalendarioTest #test04MoreThanOneWeekdayCanBeHoliday stamp: 'LK 10/5/2023 18:47:19'!
PASSED!
!CalendarioTest methodsFor: 'tests' stamp: 'LK 10/5/2023 18:47:59'!
test05! !
!CalendarioTest methodsFor: 'tests' stamp: 'LK 10/5/2023 18:51:26' prior: 50689011!
test05

	| unFeriadoDiaDeMes |
	 
	unFeriadoDiaDeMes := November / 25.
	
	calendar agregarDiaDeMesFeriado: unFeriadoDiaDeMes.
	
	self assert: (calendar esFeriado: unFeriadoDiaDeMes).! !

!testRun: #CalendarioTest #test05 stamp: 'LK 10/5/2023 18:51:29'!
ERROR!
!Calendario methodsFor: 'feriados' stamp: 'LK 10/5/2023 18:51:38'!
agregarDiaDeMesFeriado: unFeriadoDiaDeMes 
	self shouldBeImplemented.! !
!Calendario methodsFor: 'feriados' stamp: 'LK 10/5/2023 18:51:45' prior: 50689025!
agregarDiaDeMesFeriado: unFeriadoDiaDeMes 
	! !

!testRun: #CalendarioTest #test01ThereCanBeNoHolidays stamp: 'LK 10/5/2023 18:51:48'!
PASSED!

!testRun: #CalendarioTest #test02OneDateCanBeHoliday stamp: 'LK 10/5/2023 18:51:48'!
PASSED!

!testRun: #CalendarioTest #test03OneWeekdayCanBeHoliday stamp: 'LK 10/5/2023 18:51:49'!
PASSED!

!testRun: #CalendarioTest #test04 stamp: 'LK 10/5/2023 18:51:49'!
PASSED!

!testRun: #CalendarioTest #test04MoreThanOneWeekdayCanBeHoliday stamp: 'LK 10/5/2023 18:51:49'!
PASSED!

!testRun: #CalendarioTest #test05 stamp: 'LK 10/5/2023 18:51:49'!
ERROR!

!testRun: #CalendarioTest #test05 stamp: 'LK 10/5/2023 18:51:49'!
ERROR!

Object subclass: #Calendario
	instanceVariableNames: 'feriadosExactos feriadosDiaDeSemana feriadosDiaDeMes'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Calendario-Exercise'!

!classDefinition: #Calendario category: 'Calendario-Exercise' stamp: 'LK 10/5/2023 18:52:57'!
Object subclass: #Calendario
	instanceVariableNames: 'feriadosExactos feriadosDiaDeSemana feriadosDiaDeMes'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Calendario-Exercise'!
!Calendario methodsFor: 'feriados' stamp: 'LK 10/5/2023 18:53:05' prior: 50688859 overrides: 16920235!
initialize
	
	feriadosExactos := Set new.
	
	feriadosDiaDeSemana := Set new.
	
	feriadosDiaDeMes := Set new.! !
!Calendario methodsFor: 'feriados' stamp: 'LK 10/5/2023 18:53:19' prior: 50689030!
agregarDiaDeMesFeriado: unFeriadoDiaDeMes 
	
	feriadosDiaDeMes add: unFeriadoDiaDeMes.! !
!Calendario methodsFor: 'feriados' stamp: 'LK 10/5/2023 18:54:04' prior: 50688871!
esFeriado: unaFecha 

	(feriadosDiaDeMes includes: unaFecha) ifTrue: [^true].

	(feriadosExactos includes: unaFecha) ifTrue: [^true].
	
	(feriadosDiaDeSemana includes: unaFecha day) ifTrue: [^true].
	
	^false! !

!testRun: #CalendarioTest #test05 stamp: 'LK 10/5/2023 18:54:11'!
PASSED!

!testRun: #CalendarioTest #test01ThereCanBeNoHolidays stamp: 'LK 10/5/2023 18:54:14'!
PASSED!

!testRun: #CalendarioTest #test02OneDateCanBeHoliday stamp: 'LK 10/5/2023 18:54:14'!
PASSED!

!testRun: #CalendarioTest #test03OneWeekdayCanBeHoliday stamp: 'LK 10/5/2023 18:54:14'!
PASSED!

!testRun: #CalendarioTest #test04 stamp: 'LK 10/5/2023 18:54:14'!
PASSED!

!testRun: #CalendarioTest #test04MoreThanOneWeekdayCanBeHoliday stamp: 'LK 10/5/2023 18:54:14'!
PASSED!

!testRun: #CalendarioTest #test05 stamp: 'LK 10/5/2023 18:54:14'!
PASSED!
!CalendarioTest methodsFor: 'tests' stamp: 'LK 10/5/2023 18:56:34'!
test06

	| unFeriadoDiaDeMes unFeriadoExacto|
	 
	unFeriadoDiaDeMes := November / 25.
	
	calendar agregarDiaDeMesFeriado: unFeriadoDiaDeMes.
	
	self assert: (calendar esFeriado: unFeriadoDiaDeMes).! !
!CalendarioTest methodsFor: 'tests' stamp: 'LK 10/5/2023 18:57:05' prior: 50689110!
test06

	| unFeriadoDiaDeMes unFeriadoExacto|
	 
	unFeriadoDiaDeMes := November / 25.
	unFeriadoExacto := November / 25 / 1999.
	
	calendar agregarDiaDeMesFeriado: unFeriadoDiaDeMes.
	
	self assert: (calendar esFeriado: unFeriadoExacto).! !

!testRun: #CalendarioTest #test06 stamp: 'LK 10/5/2023 18:57:05'!
FAILURE!

November / 25 /1099!

November / 25 /1099 class!

(November / 25 /1999) class!
!Calendario methodsFor: 'feriados' stamp: 'LK 10/5/2023 19:00:07' prior: 50689082!
esFeriado: unaFecha 

	(feriadosDiaDeMes includes: unaFecha dayOfMonth) ifTrue: [^true].

	(feriadosExactos includes: unaFecha) ifTrue: [^true].
	
	(feriadosDiaDeSemana includes: unaFecha day) ifTrue: [^true].
	
	^false! !

!testRun: #CalendarioTest #test06 stamp: 'LK 10/5/2023 19:00:10'!
PASSED!

!testRun: #CalendarioTest #test01ThereCanBeNoHolidays stamp: 'LK 10/5/2023 19:00:15'!
PASSED!

!testRun: #CalendarioTest #test02OneDateCanBeHoliday stamp: 'LK 10/5/2023 19:00:15'!
PASSED!

!testRun: #CalendarioTest #test03OneWeekdayCanBeHoliday stamp: 'LK 10/5/2023 19:00:15'!
PASSED!

!testRun: #CalendarioTest #test04 stamp: 'LK 10/5/2023 19:00:15'!
PASSED!

!testRun: #CalendarioTest #test04MoreThanOneWeekdayCanBeHoliday stamp: 'LK 10/5/2023 19:00:15'!
PASSED!

!testRun: #CalendarioTest #test05 stamp: 'LK 10/5/2023 19:00:15'!
ERROR!

!testRun: #CalendarioTest #test06 stamp: 'LK 10/5/2023 19:00:15'!
PASSED!

!testRun: #CalendarioTest #test05 stamp: 'LK 10/5/2023 19:00:15'!
ERROR!
!Calendario methodsFor: 'feriados' stamp: 'LK 10/5/2023 19:02:16' prior: 50689134!
esFeriado: unaFecha 

	(feriadosExactos includes: unaFecha) ifTrue: [^true].
	
		
	(feriadosDiaDeSemana includes: unaFecha day) ifTrue: [^true].


	(feriadosDiaDeMes includes: unaFecha dayOfMonth) ifTrue: [^true].

	
	^false! !

!testRun: #CalendarioTest #test01ThereCanBeNoHolidays stamp: 'LK 10/5/2023 19:02:20'!
PASSED!

!testRun: #CalendarioTest #test02OneDateCanBeHoliday stamp: 'LK 10/5/2023 19:02:20'!
PASSED!

!testRun: #CalendarioTest #test03OneWeekdayCanBeHoliday stamp: 'LK 10/5/2023 19:02:20'!
PASSED!

!testRun: #CalendarioTest #test04 stamp: 'LK 10/5/2023 19:02:20'!
PASSED!

!testRun: #CalendarioTest #test04MoreThanOneWeekdayCanBeHoliday stamp: 'LK 10/5/2023 19:02:20'!
PASSED!

!testRun: #CalendarioTest #test05 stamp: 'LK 10/5/2023 19:02:20'!
ERROR!

!testRun: #CalendarioTest #test06 stamp: 'LK 10/5/2023 19:02:20'!
PASSED!

!testRun: #CalendarioTest #test05 stamp: 'LK 10/5/2023 19:02:20'!
ERROR!

!methodRemoval: CalendarioTest #test05 stamp: 'LK 10/5/2023 19:02:44'!
test05

	| unFeriadoDiaDeMes |
	 
	unFeriadoDiaDeMes := November / 25.
	
	calendar agregarDiaDeMesFeriado: unFeriadoDiaDeMes.
	
	self assert: (calendar esFeriado: unFeriadoDiaDeMes).!
!CalendarioTest methodsFor: 'tests' stamp: 'LK 10/5/2023 19:02:50'!
test05

	| unFeriadoDiaDeMes unFeriadoExacto|
	 
	unFeriadoDiaDeMes := November / 25.
	unFeriadoExacto := November / 25 / 1999.
	
	calendar agregarDiaDeMesFeriado: unFeriadoDiaDeMes.
	
	self assert: (calendar esFeriado: unFeriadoExacto).! !

!testRun: #CalendarioTest #test05 stamp: 'LK 10/5/2023 19:03:04'!
PASSED!

!testRun: #CalendarioTest #test01ThereCanBeNoHolidays stamp: 'LK 10/5/2023 19:03:09'!
PASSED!

!testRun: #CalendarioTest #test02OneDateCanBeHoliday stamp: 'LK 10/5/2023 19:03:09'!
PASSED!

!testRun: #CalendarioTest #test03OneWeekdayCanBeHoliday stamp: 'LK 10/5/2023 19:03:09'!
PASSED!

!testRun: #CalendarioTest #test04 stamp: 'LK 10/5/2023 19:03:09'!
PASSED!

!testRun: #CalendarioTest #test04MoreThanOneWeekdayCanBeHoliday stamp: 'LK 10/5/2023 19:03:09'!
PASSED!

!testRun: #CalendarioTest #test05 stamp: 'LK 10/5/2023 19:03:09'!
PASSED!

!testRun: #CalendarioTest #test06 stamp: 'LK 10/5/2023 19:03:09'!
PASSED!
!CalendarioTest methodsFor: 'tests' stamp: 'LK 10/5/2023 19:04:01' prior: 50689119!
test06

	| unFeriadoDiaDeMes unFeriadoExacto dos tres|
	 
	unFeriadoDiaDeMes := November / 25.
	
	
	unFeriadoExacto := November / 25 / 1999.
	
	calendar agregarDiaDeMesFeriado: unFeriadoDiaDeMes.
	
	self assert: (calendar esFeriado: unFeriadoExacto).! !

!methodRemoval: CalendarioTest #test06 stamp: 'LK 10/5/2023 19:08:51'!
test06

	| unFeriadoDiaDeMes unFeriadoExacto dos tres|
	 
	unFeriadoDiaDeMes := November / 25.
	
	
	unFeriadoExacto := November / 25 / 1999.
	
	calendar agregarDiaDeMesFeriado: unFeriadoDiaDeMes.
	
	self assert: (calendar esFeriado: unFeriadoExacto).!
!Calendario methodsFor: 'feriados' stamp: 'LK 10/5/2023 19:09:51' prior: 50689168!
esFeriado: unaFecha 

	(feriadosExactos includes: unaFecha) 
		or: [(feriadosDiaDeSemana includes: unaFecha day) 
			or: [(feriadosDiaDeMes includes: unaFecha dayOfMonth)]].
	! !

!testRun: #CalendarioTest #test01ThereCanBeNoHolidays stamp: 'LK 10/5/2023 19:09:56'!
ERROR!

!testRun: #CalendarioTest #test02OneDateCanBeHoliday stamp: 'LK 10/5/2023 19:09:56'!
ERROR!

!testRun: #CalendarioTest #test03OneWeekdayCanBeHoliday stamp: 'LK 10/5/2023 19:09:56'!
ERROR!

!testRun: #CalendarioTest #test04 stamp: 'LK 10/5/2023 19:09:56'!
ERROR!

!testRun: #CalendarioTest #test04MoreThanOneWeekdayCanBeHoliday stamp: 'LK 10/5/2023 19:09:56'!
ERROR!

!testRun: #CalendarioTest #test05 stamp: 'LK 10/5/2023 19:09:56'!
ERROR!

!testRun: #CalendarioTest #test01ThereCanBeNoHolidays stamp: 'LK 10/5/2023 19:10:31'!
ERROR!

!testRun: #CalendarioTest #test01ThereCanBeNoHolidays stamp: 'LK 10/5/2023 19:10:31'!
ERROR!
!Calendario methodsFor: 'feriados' stamp: 'LK 10/5/2023 19:10:52' prior: 50689260!
esFeriado: unaFecha 

	(feriadosExactos includes: unaFecha) 
		or: [(feriadosDiaDeSemana includes: unaFecha day) 
			or: [(feriadosDiaDeMes includes: unaFecha dayOfMonth)]].
		
	^false.
	! !
!Calendario methodsFor: 'feriados' stamp: 'LK 10/5/2023 19:11:31' prior: 50689291!
esFeriado: unaFecha 

	^(feriadosExactos includes: unaFecha) 
		or: [(feriadosDiaDeSemana includes: unaFecha day)
			or: [feriadosDiaDeMes includes: unaFecha dayOfMonth]].! !

!testRun: #CalendarioTest #test05 stamp: 'LK 10/5/2023 19:11:35'!
PASSED!

!testRun: #CalendarioTest #test01ThereCanBeNoHolidays stamp: 'LK 10/5/2023 19:11:39'!
PASSED!

!testRun: #CalendarioTest #test02OneDateCanBeHoliday stamp: 'LK 10/5/2023 19:11:39'!
PASSED!

!testRun: #CalendarioTest #test03OneWeekdayCanBeHoliday stamp: 'LK 10/5/2023 19:11:39'!
PASSED!

!testRun: #CalendarioTest #test04 stamp: 'LK 10/5/2023 19:11:39'!
PASSED!

!testRun: #CalendarioTest #test04MoreThanOneWeekdayCanBeHoliday stamp: 'LK 10/5/2023 19:11:39'!
PASSED!

!testRun: #CalendarioTest #test05 stamp: 'LK 10/5/2023 19:11:39'!
PASSED!
!CalendarioTest methodsFor: 'tests' stamp: 'LK 10/5/2023 19:11:59'!
test05OneDayOfMonthCanBeHoliday

	| unFeriadoDiaDeMes unFeriadoExacto|
	 
	unFeriadoDiaDeMes := November / 25.
	unFeriadoExacto := November / 25 / 1999.
	
	calendar agregarDiaDeMesFeriado: unFeriadoDiaDeMes.
	
	self assert: (calendar esFeriado: unFeriadoExacto).! !

!methodRemoval: CalendarioTest #test05 stamp: 'LK 10/5/2023 19:12:03'!
test05

	| unFeriadoDiaDeMes unFeriadoExacto|
	 
	unFeriadoDiaDeMes := November / 25.
	unFeriadoExacto := November / 25 / 1999.
	
	calendar agregarDiaDeMesFeriado: unFeriadoDiaDeMes.
	
	self assert: (calendar esFeriado: unFeriadoExacto).!
!Calendario methodsFor: 'feriados' stamp: 'LK 10/5/2023 19:15:05'!
esDiaDeSemanaFeriado: unaFecha

	^ feriadosDiaDeSemana includes: unaFecha day! !
!Calendario methodsFor: 'feriados' stamp: 'LK 10/5/2023 19:15:05' prior: 50689300!
esFeriado: unaFecha 

	^(feriadosExactos includes: unaFecha) 
		or: [(self esDiaDeSemanaFeriado: unaFecha)
			or: [feriadosDiaDeMes includes: unaFecha dayOfMonth]].! !
!Calendario methodsFor: 'feriados' stamp: 'LK 10/5/2023 19:15:32'!
esDiaDeMesFeriado: unaFecha

	^ feriadosDiaDeMes includes: unaFecha dayOfMonth! !
!Calendario methodsFor: 'feriados' stamp: 'LK 10/5/2023 19:15:33' prior: 50689354!
esFeriado: unaFecha 

	^(feriadosExactos includes: unaFecha) 
		or: [(self esDiaDeSemanaFeriado: unaFecha)
			or: [self esDiaDeMesFeriado: unaFecha]].! !
!Calendario methodsFor: 'feriados' stamp: 'LK 10/5/2023 19:16:01'!
esFechaFeriado: unaFecha

	^ feriadosExactos includes: unaFecha! !
!Calendario methodsFor: 'feriados' stamp: 'LK 10/5/2023 19:16:01' prior: 50689368!
esFeriado: unaFecha 

	^(self esFechaFeriado: unaFecha) 
		or: [(self esDiaDeSemanaFeriado: unaFecha)
			or: [self esDiaDeMesFeriado: unaFecha]].! !
!Calendario methodsFor: 'feriados' stamp: 'LK 10/5/2023 19:16:29' prior: 50689380!
esFeriado: unPosibleFeriado

	^(self esFechaFeriado: unPosibleFeriado) 
		or: [(self esDiaDeSemanaFeriado: unPosibleFeriado)
			or: [self esDiaDeMesFeriado: unPosibleFeriado]].! !

TestCase subclass: #TextXXX
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!

!classDefinition: #TextXXX category: 'Mars Rover- Exercise' stamp: 'LK 10/5/2023 20:12:42'!
TestCase subclass: #TextXXX
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!

TestCase subclass: #MarsRoverTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!

!classDefinition: #MarsRoverTest category: 'Mars Rover- Exercise' stamp: 'LK 10/5/2023 20:29:24'!
TestCase subclass: #MarsRoverTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!

!classRemoval: #TextXXX stamp: 'LK 10/5/2023 20:29:28'!
TestCase subclass: #TextXXX
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!

----QUIT----(5 October 2023 21:00:10) CuisUniversity-5981.image priorSource: 11422467!

----STARTUP---- (9 October 2023 02:14:22) as C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\CuisUniversity-5981.image!


----QUIT----(9 October 2023 02:21:01) CuisUniversity-5981.image priorSource: 11448802!

----STARTUP---- (9 October 2023 11:38:49) as C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\CuisUniversity-5981.image!

!MarsRoverTest methodsFor: 'no messages' stamp: 'LK 10/9/2023 11:40:15'!
test01! !

!classDefinition: #MarsRover category: 'Mars Rover- Exercise' stamp: 'LK 10/9/2023 11:42:04'!
Object subclass: #MarsRover
	instanceVariableNames: 'position direction'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 11:41:40' prior: 50689439!
test01
	| marsRover coordinate direction|
	
	coordinate := 0@0.
	direction := #North.
	marsRover := MarsRover withCoord: coordinate pointingTo: direction.
	
	self assert: ((marsRover at: coordinate) and: [marsRover cardinal: direction]).
	! !

!testRun: #MarsRoverTest #test01 stamp: 'LK 10/9/2023 11:42:06'!
ERROR!
!MarsRover class methodsFor: 'instance creation' stamp: 'LK 10/9/2023 11:42:13'!
withCoord: coordinate pointingTo: direction 
	"DO NOT FORGET TO RENAME COLLABORATORS AND REMOVE THIS COMMENT!!!!"
	self shouldBeImplemented.
	^self new initializeWithCoord: coordinate pointingTo: direction ! !

!classDefinition: 'MarsRover class' category: 'Mars Rover- Exercise' stamp: 'LK 10/9/2023 11:43:01'!
MarsRover class
	instanceVariableNames: 'position'!
!MarsRover class methodsFor: 'instance creation' stamp: 'LK 10/9/2023 11:43:11' prior: 50689464!
withCoord: aCoordinate pointingTo: aDirection 
! !
!MarsRover class methodsFor: 'instance creation' stamp: 'LK 10/9/2023 11:43:52' prior: 50689479!
withCoord: aCoordinate pointingTo: aDirection 
	^self new withCoord: aCoordinate pointingTo: aDirection.! !

MarsRover class
	instanceVariableNames: ''!

!classDefinition: 'MarsRover class' category: 'Mars Rover- Exercise' stamp: 'LK 10/9/2023 11:44:01'!
MarsRover class
	instanceVariableNames: ''!
!MarsRover methodsFor: 'no messages' stamp: 'LK 10/9/2023 11:44:17'!
withCoord: aCoordinate pointingTo: aDirection
	position := aCoordinate.
	direction := aDirection 
	! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 11:44:21' prior: 50689496!
withCoord: aCoordinate pointingTo: aDirection
	position := aCoordinate.
	direction := aDirection.
	! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 11:44:41' overrides: 16901507!
at: aPosition
	^position = aPosition.! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 11:44:57'!
cardinal: aDirection
	^direction = aDirection.! !

!testRun: #MarsRoverTest #test01 stamp: 'LK 10/9/2023 11:45:04'!
PASSED!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 11:45:23'!
test02
	|marsRover coordinate direction commands|
	coordinate := 0@0.
	direction := #North.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := ''. 
	marsRover execute: commands.
	self assert: ((marsRover at: coordinate) and: [marsRover cardinal: direction]).
	
	
	! !

!testRun: #MarsRoverTest #test02 stamp: 'LK 10/9/2023 11:45:25'!
ERROR!
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 11:45:42'!
execute: commands 
	self shouldBeImplemented.! !
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 11:45:45' prior: 50689535!
execute: commands 
	! !

!testRun: #MarsRoverTest #test02 stamp: 'LK 10/9/2023 11:45:49'!
PASSED!

!testRun: #MarsRoverTest #test01 stamp: 'LK 10/9/2023 11:45:49'!
PASSED!

!testRun: #MarsRoverTest #test02 stamp: 'LK 10/9/2023 11:45:49'!
PASSED!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 11:46:21'!
test03
	|marsRover coordinate direction commands finalCoordinate|
	coordinate := 0@0.
	direction := #North.
	finalCoordinate := coordinate + (0@1).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	self assert: ((marsRover at: finalCoordinate) and: [marsRover cardinal: direction]).
	
	
	! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 11:47:15' prior: 50689551!
test03

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := #North.
	finalCoordinate := coordinate + (0@1).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	self assert: ((marsRover at: finalCoordinate) and: [marsRover cardinal: direction]).
	
	
	! !

!testRun: #MarsRoverTest #test03 stamp: 'LK 10/9/2023 11:47:31'!
FAILURE!
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 11:49:57' prior: 50689540!
execute: commands 
	
	(commands = 'f') ifTrue: [ position = position + (0@1)].! !

!testRun: #MarsRoverTest #test03 stamp: 'LK 10/9/2023 11:50:00'!
ERROR!

!testRun: #MarsRoverTest #test03 stamp: 'LK 10/9/2023 11:50:00'!
ERROR!
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 11:50:21' prior: 50689583!
execute: commands 
	
	(commands = 'f') ifTrue: [ position := position + (0@1)].! !

!testRun: #MarsRoverTest #test01 stamp: 'LK 10/9/2023 11:50:44'!
PASSED!

!testRun: #MarsRoverTest #test02 stamp: 'LK 10/9/2023 11:50:44'!
PASSED!

!testRun: #MarsRoverTest #test03 stamp: 'LK 10/9/2023 11:50:44'!
PASSED!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 11:51:08'!
test04

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := #South.
	finalCoordinate := coordinate - (0@1).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	self assert: ((marsRover at: finalCoordinate) and: [marsRover cardinal: direction]).
	
	
	! !

(0@0) + (0@-1)!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 11:51:51' prior: 50689606!
test04

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := #South.
	finalCoordinate := coordinate + (0@-1).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	self assert: ((marsRover at: finalCoordinate) and: [marsRover cardinal: direction]).
	
	
	! !

!testRun: #MarsRoverTest #test04 stamp: 'LK 10/9/2023 11:51:54'!
FAILURE!
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 11:53:39' prior: 50689593!
execute: commands 
	
	(commands = 'f') ifTrue: [ 
		(direction = #South) ifTrue: [ position := position + (0@-1)].
		(direction = #North) ifTrue: [position := position + (0@1)].
		
		]! !

!testRun: #MarsRoverTest #test01 stamp: 'LK 10/9/2023 11:53:45'!
PASSED!

!testRun: #MarsRoverTest #test04 stamp: 'LK 10/9/2023 11:53:49'!
PASSED!

!testRun: #MarsRoverTest #test01 stamp: 'LK 10/9/2023 11:54:18'!
PASSED!

!testRun: #MarsRoverTest #test02 stamp: 'LK 10/9/2023 11:54:18'!
PASSED!

!testRun: #MarsRoverTest #test03 stamp: 'LK 10/9/2023 11:54:18'!
PASSED!

!testRun: #MarsRoverTest #test04 stamp: 'LK 10/9/2023 11:54:18'!
PASSED!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 11:54:34' prior: 50689621!
test04

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := #East.
	finalCoordinate := coordinate + (1@0).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	self assert: ((marsRover at: finalCoordinate) and: [marsRover cardinal: direction]).
	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 11:54:42' prior: 50689661!
test04

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := #West.
	finalCoordinate := coordinate + (-1@0).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	self assert: ((marsRover at: finalCoordinate) and: [marsRover cardinal: direction]).
	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 11:51:51' prior: 50689676!
test04

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := #South.
	finalCoordinate := coordinate + (0@-1).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	self assert: ((marsRover at: finalCoordinate) and: [marsRover cardinal: direction]).
	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 11:55:09'!
test05

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := #West.
	finalCoordinate := coordinate + (-1@0).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	self assert: ((marsRover at: finalCoordinate) and: [marsRover cardinal: direction]).
	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 11:55:28'!
test06

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := #East.
	finalCoordinate := coordinate + (1@0).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	self assert: ((marsRover at: finalCoordinate) and: [marsRover cardinal: direction]).
	
	
	! !

!testRun: #MarsRoverTest #test06 stamp: 'LK 10/9/2023 11:55:31'!
FAILURE!

!testRun: #MarsRoverTest #test05 stamp: 'LK 10/9/2023 11:55:36'!
FAILURE!
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 11:56:08' prior: 50689638!
execute: commands 
	
	(commands = 'f') ifTrue: [ 
		(direction = #South) ifTrue: [ position := position + (0@-1)].
		(direction = #North) ifTrue: [position := position + (0@1)].
		(direction = #West) ifTrue: [position := position + (-1@0)].
		]! !
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 11:56:52' prior: 50689738!
execute: commands 
	
	(commands = 'f') ifTrue: [ 
		(direction = #South) ifTrue: [ position := position + (0@-1)].
		(direction = #North) ifTrue: [position := position + (0@1)].
		(direction = #West) ifTrue: [position := position + (-1@0)].
		(direction = #East) ifTrue: [position := position + (1@0)]. 
		].! !

!testRun: #MarsRoverTest #test01 stamp: 'LK 10/9/2023 11:56:56'!
PASSED!

!testRun: #MarsRoverTest #test02 stamp: 'LK 10/9/2023 11:56:56'!
PASSED!

!testRun: #MarsRoverTest #test03 stamp: 'LK 10/9/2023 11:56:56'!
PASSED!

!testRun: #MarsRoverTest #test04 stamp: 'LK 10/9/2023 11:56:56'!
PASSED!

!testRun: #MarsRoverTest #test05 stamp: 'LK 10/9/2023 11:56:56'!
PASSED!

!testRun: #MarsRoverTest #test06 stamp: 'LK 10/9/2023 11:56:57'!
PASSED!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:06:28' prior: 50689566!
test03

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := #North.
	finalCoordinate := coordinate + (0@1).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate) and: [marsRover cardinal: direction]).
	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:08:32'!
shouldBeIn: finalCoordinate poitingTo: direction marsRover: marsRover

	^ (marsRover at: finalCoordinate) and: [marsRover cardinal: direction]! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:08:32' prior: 50689719!
test06

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := #East.
	finalCoordinate := coordinate + (1@0).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	self assert: (self shouldBeIn: finalCoordinate poitingTo: direction marsRover: marsRover).
	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:08:32' prior: 50689705!
test05

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := #West.
	finalCoordinate := coordinate + (-1@0).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	self assert: (self shouldBeIn: finalCoordinate poitingTo: direction marsRover: marsRover).
	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:08:32' prior: 50689776!
test03

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := #North.
	finalCoordinate := coordinate + (0@1).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	
	self assert: (self shouldBeIn: finalCoordinate poitingTo: direction marsRover: marsRover).
	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:08:32' prior: 50689691!
test04

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := #South.
	finalCoordinate := coordinate + (0@-1).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	self assert: (self shouldBeIn: finalCoordinate poitingTo: direction marsRover: marsRover).
	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:11:04'!
assertThatMarsRover: aMarsRover shouldBeIn: aCoordinate pointingTo: aDirection

	self assert: (aMarsRover at: aCoordinate and: [aMarsRover cardinal: aDirection]).! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:11:34' prior: 50689857!
assertThatMarsRover: aMarsRover shouldBeIn: aCoordinate pointingTo: aDirection

	self assert: (aMarsRover at: aCoordinate and: [aMarsRover cardinal: aDirection]).! !
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 12:13:06' prior: 50689749!
execute: commands 
	
	(commands = 'f') ifTrue: [ 
		(direction = #South) ifTrue: [ position := position + (0@-1)].
		(direction = #North) ifTrue: [position := position + (0@1)].
		(direction = #West) ifTrue: [position := position + (-1@0)].
		(direction = #East) ifTrue: [position := position + (1@0)]. 
		].
	
	(commands = 'b') ifTrue: [ 
		(direction = #South) ifTrue: [ position := position - (0@-1)].
		(direction = #North) ifTrue: [position := position - (0@1)].
		(direction = #West) ifTrue: [position := position - (-1@0)].
		(direction = #East) ifTrue: [position := position - (1@0)]. 
		].! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:13:18' prior: 50689521!
test02
	|marsRover coordinate direction commands|
	coordinate := 0@0.
	direction := #North.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := ''. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: coordinate) and: [marsRover cardinal: direction]).
	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:13:26' prior: 50689828!
test03

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := #North.
	finalCoordinate := coordinate + (0@1).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: coordinate) and: [marsRover cardinal: direction]).	
	
	! !

!testRun: #MarsRoverTest #test01 stamp: 'LK 10/9/2023 12:13:39'!
PASSED!

!testRun: #MarsRoverTest #test01 stamp: 'LK 10/9/2023 12:13:40'!
PASSED!

!testRun: #MarsRoverTest #test02 stamp: 'LK 10/9/2023 12:13:40'!
PASSED!

!testRun: #MarsRoverTest #test03 stamp: 'LK 10/9/2023 12:13:40'!
FAILURE!

!testRun: #MarsRoverTest #test04 stamp: 'LK 10/9/2023 12:13:40'!
PASSED!

!testRun: #MarsRoverTest #test05 stamp: 'LK 10/9/2023 12:13:40'!
PASSED!

!testRun: #MarsRoverTest #test06 stamp: 'LK 10/9/2023 12:13:40'!
PASSED!

!testRun: #MarsRoverTest #test03 stamp: 'LK 10/9/2023 12:13:40'!
FAILURE!

!testRun: #MarsRoverTest #test01 stamp: 'LK 10/9/2023 12:13:55'!
PASSED!

!testRun: #MarsRoverTest #test01 stamp: 'LK 10/9/2023 12:13:55'!
PASSED!

!testRun: #MarsRoverTest #test02 stamp: 'LK 10/9/2023 12:13:55'!
PASSED!

!testRun: #MarsRoverTest #test03 stamp: 'LK 10/9/2023 12:13:55'!
FAILURE!

!testRun: #MarsRoverTest #test04 stamp: 'LK 10/9/2023 12:13:55'!
PASSED!

!testRun: #MarsRoverTest #test05 stamp: 'LK 10/9/2023 12:13:55'!
PASSED!

!testRun: #MarsRoverTest #test06 stamp: 'LK 10/9/2023 12:13:55'!
PASSED!

!testRun: #MarsRoverTest #test03 stamp: 'LK 10/9/2023 12:13:55'!
FAILURE!
!MarsRover methodsFor: 'init' stamp: 'LK 10/9/2023 12:14:05' prior: 50689503!
withCoord: aCoordinate pointingTo: aDirection

	position := aCoordinate.
	direction := aDirection.
	! !

!testRun: #MarsRoverTest #test01 stamp: 'LK 10/9/2023 12:14:13'!
PASSED!

!testRun: #MarsRoverTest #test01 stamp: 'LK 10/9/2023 12:14:13'!
PASSED!

!testRun: #MarsRoverTest #test02 stamp: 'LK 10/9/2023 12:14:13'!
PASSED!

!testRun: #MarsRoverTest #test03 stamp: 'LK 10/9/2023 12:14:13'!
FAILURE!

!testRun: #MarsRoverTest #test04 stamp: 'LK 10/9/2023 12:14:13'!
PASSED!

!testRun: #MarsRoverTest #test05 stamp: 'LK 10/9/2023 12:14:13'!
PASSED!

!testRun: #MarsRoverTest #test06 stamp: 'LK 10/9/2023 12:14:13'!
PASSED!

!testRun: #MarsRoverTest #test03 stamp: 'LK 10/9/2023 12:14:13'!
FAILURE!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:14:47' prior: 50689843!
test04

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := #South.
	finalCoordinate := coordinate + (0@-1).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	
	self assert: (self shouldBeIn: finalCoordinate poitingTo: direction marsRover: marsRover).
	
	
	! !

!testRun: #MarsRoverTest #test01 stamp: 'LK 10/9/2023 12:14:48'!
PASSED!

!testRun: #MarsRoverTest #test02 stamp: 'LK 10/9/2023 12:14:48'!
PASSED!

!testRun: #MarsRoverTest #test03 stamp: 'LK 10/9/2023 12:14:48'!
FAILURE!

!testRun: #MarsRoverTest #test04 stamp: 'LK 10/9/2023 12:14:48'!
PASSED!

!testRun: #MarsRoverTest #test05 stamp: 'LK 10/9/2023 12:14:48'!
PASSED!

!testRun: #MarsRoverTest #test06 stamp: 'LK 10/9/2023 12:14:48'!
PASSED!

!testRun: #MarsRoverTest #test03 stamp: 'LK 10/9/2023 12:14:48'!
FAILURE!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:14:57' prior: 50689908!
test03

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := #North.
	finalCoordinate := coordinate + (0@1).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	! !

!testRun: #MarsRoverTest #test03 stamp: 'LK 10/9/2023 12:14:58'!
PASSED!

!testRun: #MarsRoverTest #test01 stamp: 'LK 10/9/2023 12:14:58'!
PASSED!

!testRun: #MarsRoverTest #test02 stamp: 'LK 10/9/2023 12:14:58'!
PASSED!

!testRun: #MarsRoverTest #test03 stamp: 'LK 10/9/2023 12:14:58'!
PASSED!

!testRun: #MarsRoverTest #test04 stamp: 'LK 10/9/2023 12:14:58'!
PASSED!

!testRun: #MarsRoverTest #test05 stamp: 'LK 10/9/2023 12:14:58'!
PASSED!

!testRun: #MarsRoverTest #test06 stamp: 'LK 10/9/2023 12:14:58'!
PASSED!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:15:16' prior: 50689984!
test04

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := #South.
	finalCoordinate := coordinate + (0@-1).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:15:24' prior: 50689813!
test05

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := #West.
	finalCoordinate := coordinate + (-1@0).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:15:30' prior: 50689798!
test06

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := #East.
	finalCoordinate := coordinate + (1@0).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	
	! !

!testRun: #MarsRoverTest #test01 stamp: 'LK 10/9/2023 12:15:33'!
PASSED!

!testRun: #MarsRoverTest #test02 stamp: 'LK 10/9/2023 12:15:33'!
PASSED!

!testRun: #MarsRoverTest #test03 stamp: 'LK 10/9/2023 12:15:33'!
PASSED!

!testRun: #MarsRoverTest #test04 stamp: 'LK 10/9/2023 12:15:33'!
PASSED!

!testRun: #MarsRoverTest #test05 stamp: 'LK 10/9/2023 12:15:33'!
PASSED!

!testRun: #MarsRoverTest #test06 stamp: 'LK 10/9/2023 12:15:33'!
PASSED!

!methodRemoval: MarsRoverTest #shouldBeIn:poitingTo:marsRover: stamp: 'LK 10/9/2023 12:15:37'!
shouldBeIn: finalCoordinate poitingTo: direction marsRover: marsRover

	^ (marsRover at: finalCoordinate) and: [marsRover cardinal: direction]!

!methodRemoval: MarsRoverTest #assertThatMarsRover:shouldBeIn:pointingTo: stamp: 'LK 10/9/2023 12:15:39'!
assertThatMarsRover: aMarsRover shouldBeIn: aCoordinate pointingTo: aDirection

	self assert: (aMarsRover at: aCoordinate and: [aMarsRover cardinal: aDirection]).!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:17:15'!
test07

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := #North.
	finalCoordinate := coordinate - (0@1).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'b'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:17:31'!
test08

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := #South.
	finalCoordinate := coordinate - (0@-1).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'b'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:19:01'!
test09

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := #West.
	finalCoordinate := coordinate - (0@0).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'b'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:19:51' prior: 50690148!
test09

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := #West.
	finalCoordinate := coordinate - (-1@0).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'b'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:20:21' prior: 50690163!
test09

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := #East.
	finalCoordinate := coordinate - (1@0).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'b'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	! !

!testRun: #MarsRoverTest #test09 stamp: 'LK 10/9/2023 12:20:22'!
PASSED!

!testRun: #MarsRoverTest #test01 stamp: 'LK 10/9/2023 12:20:24'!
PASSED!

!testRun: #MarsRoverTest #test02 stamp: 'LK 10/9/2023 12:20:24'!
PASSED!

!testRun: #MarsRoverTest #test03 stamp: 'LK 10/9/2023 12:20:24'!
PASSED!

!testRun: #MarsRoverTest #test04 stamp: 'LK 10/9/2023 12:20:24'!
PASSED!

!testRun: #MarsRoverTest #test05 stamp: 'LK 10/9/2023 12:20:24'!
PASSED!

!testRun: #MarsRoverTest #test06 stamp: 'LK 10/9/2023 12:20:24'!
PASSED!

!testRun: #MarsRoverTest #test07 stamp: 'LK 10/9/2023 12:20:24'!
PASSED!

!testRun: #MarsRoverTest #test08 stamp: 'LK 10/9/2023 12:20:24'!
PASSED!

!testRun: #MarsRoverTest #test09 stamp: 'LK 10/9/2023 12:20:24'!
PASSED!

Object subclass: #Direction
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!

!classDefinition: #Direction category: 'Mars Rover- Exercise' stamp: 'LK 10/9/2023 12:20:39'!
Object subclass: #Direction
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!

Direction subclass: #West
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!

!classDefinition: #West category: 'Mars Rover- Exercise' stamp: 'LK 10/9/2023 12:20:48'!
Direction subclass: #West
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!

Direction subclass: #East
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!

!classDefinition: #East category: 'Mars Rover- Exercise' stamp: 'LK 10/9/2023 12:20:51'!
Direction subclass: #East
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!

Direction subclass: #South
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!

!classDefinition: #South category: 'Mars Rover- Exercise' stamp: 'LK 10/9/2023 12:20:54'!
Direction subclass: #South
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!

Direction subclass: #North
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!

!classDefinition: #North category: 'Mars Rover- Exercise' stamp: 'LK 10/9/2023 12:20:59'!
Direction subclass: #North
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!
!Direction methodsFor: 'no messages' stamp: 'LK 10/9/2023 12:22:11'!
goFoward! !
!West methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 12:22:15' overrides: 50690272!
goFoward! !
!East methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 12:22:15' overrides: 50690272!
goFoward! !
!South methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 12:22:15' overrides: 50690272!
goFoward! !
!North methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 12:22:15' overrides: 50690272!
goFoward! !
!Direction methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 12:22:15' prior: 50690272!
goFoward

	self subclassResponsibility! !
!East methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 12:22:37' prior: 50690280 overrides: 50690292!
goFoward
	^(1@0).! !
!West methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 12:22:50' prior: 50690276 overrides: 50690292!
goFoward
	^(-1@0).! !
!North methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 12:22:56' prior: 50690288 overrides: 50690292!
goFoward
	^(0@1)! !
!South methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 12:23:06' prior: 50690284 overrides: 50690292!
goFoward
	^(0@-1).! !
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 12:23:50' prior: 50689873!
execute: commands 
	
	(commands = 'f') ifTrue: [	position := position + direction goFoward].
	
	(commands = 'b') ifTrue: [ 
		(direction = #South) ifTrue: [ position := position - (0@-1)].
		(direction = #North) ifTrue: [position := position - (0@1)].
		(direction = #West) ifTrue: [position := position - (-1@0)].
		(direction = #East) ifTrue: [position := position - (1@0)]. 
		].! !
!Direction methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 12:24:34'!
goForward

	self subclassResponsibility! !

!methodRemoval: Direction #goFoward stamp: 'LK 10/9/2023 12:24:34'!
goFoward

	self subclassResponsibility!
!East methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 12:24:47' overrides: 50690331!
goForward
	^(1@0).! !

!methodRemoval: East #goFoward stamp: 'LK 10/9/2023 12:25:34'!
goFoward
	^(1@0).!
!North methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 12:25:38' overrides: 50690331!
goForward
	^(0@1)! !

!methodRemoval: North #goFoward stamp: 'LK 10/9/2023 12:25:40'!
goFoward
	^(0@1)!
!South methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 12:25:45' overrides: 50690331!
goForward
	^(0@-1).! !

!methodRemoval: South #goFoward stamp: 'LK 10/9/2023 12:25:48'!
goFoward
	^(0@-1).!
!West methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 12:25:52' overrides: 50690331!
goForward
	^(-1@0).! !

!methodRemoval: West #goFoward stamp: 'LK 10/9/2023 12:25:54'!
goFoward
	^(-1@0).!
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 12:26:02' prior: 50690316!
execute: commands 
	
	(commands = 'f') ifTrue: [	position := position + direction goForward].
	
	(commands = 'b') ifTrue: [ 
		(direction = #South) ifTrue: [ position := position - (0@-1)].
		(direction = #North) ifTrue: [position := position - (0@1)].
		(direction = #West) ifTrue: [position := position - (-1@0)].
		(direction = #East) ifTrue: [position := position - (1@0)]. 
		].! !
!Direction methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 12:26:12'!
goBackwards! !
!West methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 12:26:16' overrides: 50690381!
goBackwards! !
!East methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 12:26:16' overrides: 50690381!
goBackwards! !
!South methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 12:26:16' overrides: 50690381!
goBackwards! !
!North methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 12:26:16' overrides: 50690381!
goBackwards! !
!Direction methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 12:26:16' prior: 50690381!
goBackwards

	self subclassResponsibility! !

!methodRemoval: East #goBackwards stamp: 'LK 10/9/2023 12:26:40'!
goBackwards!

!classRemoval: #South stamp: 'LK 10/9/2023 12:26:44'!
Direction subclass: #South
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!

!methodRemoval: West #goBackwards stamp: 'LK 10/9/2023 12:26:51'!
goBackwards!

!methodRemoval: North #goBackwards stamp: 'LK 10/9/2023 12:26:53'!
goBackwards!

Direction subclass: #South
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!

!classDefinition: #South category: 'Mars Rover- Exercise' stamp: 'LK 10/9/2023 12:27:04'!
Direction subclass: #South
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!
!South methodsFor: 'no messages' stamp: 'LK 10/9/2023 12:27:19'!
goForwards
	^(0@-1)! !
!Direction methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 12:27:50' prior: 50690401!
goBackwards

	 
		! !
!West methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 12:27:56' overrides: 50690434!
goBackwards

	 
		! !
!East methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 12:27:57' overrides: 50690434!
goBackwards

	 
		! !
!North methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 12:27:57' overrides: 50690434!
goBackwards

	 
		! !
!South methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 12:27:57' overrides: 50690434!
goBackwards

	 
		! !
!Direction methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 12:27:57' prior: 50690434!
goBackwards

	self subclassResponsibility! !
!East methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 12:28:15' prior: 50690442 overrides: 50690454!
goBackwards
	^(-1@0).
		! !
!North methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 12:28:28' prior: 50690446 overrides: 50690454!
goBackwards
	^(0@-1)! !
!South methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 12:28:39' prior: 50690450 overrides: 50690454!
goBackwards

	 ^(0@1)
		! !
!West methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 12:28:50' prior: 50690438 overrides: 50690454!
goBackwards
	^(1@0)
	 
		! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:29:32' prior: 50689451!
test01
	| marsRover coordinate direction|
	
	coordinate := 0@0.
	direction := North.
	marsRover := MarsRover withCoord: coordinate pointingTo: direction.
	
	self assert: ((marsRover at: coordinate) and: [marsRover cardinal: direction]).
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:29:57' prior: 50689895!
test02
	|marsRover coordinate direction commands|
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := ''. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: coordinate) and: [marsRover cardinal: direction]).
	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:30:03' prior: 50690478!
test01
	| marsRover coordinate direction|
	
	coordinate := 0@0.
	direction := North new.
	marsRover := MarsRover withCoord: coordinate pointingTo: direction.
	
	self assert: ((marsRover at: coordinate) and: [marsRover cardinal: direction]).
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:30:10' prior: 50690015!
test03

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := North new.
	finalCoordinate := coordinate + (0@1).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:30:16' prior: 50690046!
test04

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := South new.
	finalCoordinate := coordinate + (0@-1).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:30:22' prior: 50690061!
test05

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := West new.
	finalCoordinate := coordinate + (-1@0).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:30:39' prior: 50690120!
test07

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := North new.
	finalCoordinate := coordinate - (0@1).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'b'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:30:53' prior: 50690178!
test09

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := East new.
	finalCoordinate := coordinate - (1@0).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'b'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	! !

!testRun: #MarsRoverTest #test01 stamp: 'LK 10/9/2023 12:31:14'!
PASSED!

!testRun: #MarsRoverTest #test02 stamp: 'LK 10/9/2023 12:31:16'!
PASSED!

!testRun: #MarsRoverTest #test03 stamp: 'LK 10/9/2023 12:31:18'!
PASSED!

!testRun: #MarsRoverTest #test04 stamp: 'LK 10/9/2023 12:31:19'!
ERROR!

!testRun: #MarsRoverTest #test04 stamp: 'LK 10/9/2023 12:31:19'!
ERROR!

!testRun: #MarsRoverTest #test03 stamp: 'LK 10/9/2023 12:31:34'!
PASSED!

!testRun: #MarsRoverTest #test01 stamp: 'LK 10/9/2023 12:31:34'!
PASSED!

!testRun: #MarsRoverTest #test02 stamp: 'LK 10/9/2023 12:31:34'!
PASSED!

!testRun: #MarsRoverTest #test03 stamp: 'LK 10/9/2023 12:31:34'!
PASSED!

!testRun: #MarsRoverTest #test04 stamp: 'LK 10/9/2023 12:31:34'!
ERROR!

!testRun: #MarsRoverTest #test05 stamp: 'LK 10/9/2023 12:31:34'!
PASSED!

!testRun: #MarsRoverTest #test06 stamp: 'LK 10/9/2023 12:31:34'!
ERROR!

!testRun: #MarsRoverTest #test07 stamp: 'LK 10/9/2023 12:31:34'!
FAILURE!

!testRun: #MarsRoverTest #test08 stamp: 'LK 10/9/2023 12:31:34'!
PASSED!

!testRun: #MarsRoverTest #test09 stamp: 'LK 10/9/2023 12:31:34'!
FAILURE!

!testRun: #MarsRoverTest #test03 stamp: 'LK 10/9/2023 12:31:37'!
PASSED!

!testRun: #MarsRoverTest #test04 stamp: 'LK 10/9/2023 12:31:41'!
ERROR!
!South methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 12:32:12' overrides: 50690331!
goForward
	^(0@-1)! !

!methodRemoval: South #goForwards stamp: 'LK 10/9/2023 12:32:12'!
goForwards
	^(0@-1)!

!testRun: #MarsRoverTest #test01 stamp: 'LK 10/9/2023 12:32:16'!
PASSED!

!testRun: #MarsRoverTest #test02 stamp: 'LK 10/9/2023 12:32:16'!
PASSED!

!testRun: #MarsRoverTest #test03 stamp: 'LK 10/9/2023 12:32:16'!
PASSED!

!testRun: #MarsRoverTest #test04 stamp: 'LK 10/9/2023 12:32:16'!
PASSED!

!testRun: #MarsRoverTest #test05 stamp: 'LK 10/9/2023 12:32:16'!
PASSED!

!testRun: #MarsRoverTest #test06 stamp: 'LK 10/9/2023 12:32:16'!
ERROR!

!testRun: #MarsRoverTest #test07 stamp: 'LK 10/9/2023 12:32:16'!
FAILURE!

!testRun: #MarsRoverTest #test08 stamp: 'LK 10/9/2023 12:32:16'!
PASSED!

!testRun: #MarsRoverTest #test09 stamp: 'LK 10/9/2023 12:32:16'!
FAILURE!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:32:59' prior: 50690134!
test08

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := South new.
	finalCoordinate := coordinate - (0@-1).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'b'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:33:09' prior: 50690076!
test06

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := East new.
	finalCoordinate := coordinate + (1@0).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:33:22' prior: 50690513!
test03

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := #North.
	finalCoordinate := coordinate + (0@1).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	! !

!testRun: #MarsRoverTest #test03 stamp: 'LK 10/9/2023 12:33:24'!
ERROR!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:33:30' prior: 50690684!
test03

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := North new.
	finalCoordinate := coordinate + (0@1).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:33:42'!
test10

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := West new.
	finalCoordinate := coordinate - (1@0).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'b'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:33:51' prior: 50690715!
test10

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := West new.
	finalCoordinate := coordinate - (-1@0).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'b'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	! !
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 12:34:15' prior: 50690366!
execute: commands 
	
	(commands = 'f') ifTrue: [	position := position + direction goForward].
	
	(commands = 'b') ifTrue: [ position := position + direction goBackwards].! !

!testRun: #MarsRoverTest #test01 stamp: 'LK 10/9/2023 12:34:18'!
PASSED!

!testRun: #MarsRoverTest #test02 stamp: 'LK 10/9/2023 12:34:18'!
PASSED!

!testRun: #MarsRoverTest #test03 stamp: 'LK 10/9/2023 12:34:18'!
PASSED!

!testRun: #MarsRoverTest #test04 stamp: 'LK 10/9/2023 12:34:18'!
PASSED!

!testRun: #MarsRoverTest #test05 stamp: 'LK 10/9/2023 12:34:18'!
PASSED!

!testRun: #MarsRoverTest #test06 stamp: 'LK 10/9/2023 12:34:18'!
PASSED!

!testRun: #MarsRoverTest #test07 stamp: 'LK 10/9/2023 12:34:18'!
PASSED!

!testRun: #MarsRoverTest #test08 stamp: 'LK 10/9/2023 12:34:18'!
PASSED!

!testRun: #MarsRoverTest #test09 stamp: 'LK 10/9/2023 12:34:18'!
PASSED!

!testRun: #MarsRoverTest #test10 stamp: 'LK 10/9/2023 12:34:18'!
PASSED!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:34:45'!
test01shouldInitializeInGivenCoordinateAndDirection
	| marsRover coordinate direction|
	
	coordinate := 0@0.
	direction := North new.
	marsRover := MarsRover withCoord: coordinate pointingTo: direction.
	
	self assert: ((marsRover at: coordinate) and: [marsRover cardinal: direction]).
	! !

!methodRemoval: MarsRoverTest #test01 stamp: 'LK 10/9/2023 12:34:48'!
test01
	| marsRover coordinate direction|
	
	coordinate := 0@0.
	direction := North new.
	marsRover := MarsRover withCoord: coordinate pointingTo: direction.
	
	self assert: ((marsRover at: coordinate) and: [marsRover cardinal: direction]).
	!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:35:08'!
test02shouldDoNothingOnEmptyString

	|marsRover coordinate direction commands|
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := ''. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: coordinate) and: [marsRover cardinal: direction]).
	
	
	! !

!methodRemoval: MarsRoverTest #test02 stamp: 'LK 10/9/2023 12:35:10'!
test02
	|marsRover coordinate direction commands|
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := ''. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: coordinate) and: [marsRover cardinal: direction]).
	
	
	!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:36:10'!
test03shouldMoveForwardsPointingNorth

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := North new.
	finalCoordinate := coordinate + (0@1).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:36:34'!
test03shouldMoveForwardsPointingNorthCorrectly

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := North new.
	finalCoordinate := coordinate + (0@1).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	! !

!methodRemoval: MarsRoverTest #test03 stamp: 'LK 10/9/2023 12:36:36'!
test03

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := North new.
	finalCoordinate := coordinate + (0@1).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	!

!methodRemoval: MarsRoverTest #test03shouldMoveForwardsPointingNorth stamp: 'LK 10/9/2023 12:36:37'!
test03shouldMoveForwardsPointingNorth

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := North new.
	finalCoordinate := coordinate + (0@1).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:36:54'!
test04shouldMoveForwardsPointingSouthCorrectly

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := South new.
	finalCoordinate := coordinate + (0@-1).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	
	! !

!methodRemoval: MarsRoverTest #test04 stamp: 'LK 10/9/2023 12:36:55'!
test04

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := South new.
	finalCoordinate := coordinate + (0@-1).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	
	!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:37:16'!
test05shouldMoveForwardsPointingWestCorrectly

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := West new.
	finalCoordinate := coordinate + (-1@0).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	
	! !

!methodRemoval: MarsRoverTest #test05 stamp: 'LK 10/9/2023 12:37:16'!
test05

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := West new.
	finalCoordinate := coordinate + (-1@0).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	
	!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:37:26'!
test06shouldMoveForwardsPointingEastCorrectly

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := East new.
	finalCoordinate := coordinate + (1@0).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	
	! !

!methodRemoval: MarsRoverTest #test06 stamp: 'LK 10/9/2023 12:37:27'!
test06

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := East new.
	finalCoordinate := coordinate + (1@0).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	
	!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:37:45'!
test07shouldMoveBackwardsPointingNorthCorrectly

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := North new.
	finalCoordinate := coordinate - (0@1).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'b'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	! !

!methodRemoval: MarsRoverTest #test07 stamp: 'LK 10/9/2023 12:37:47'!
test07

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := North new.
	finalCoordinate := coordinate - (0@1).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'b'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:37:53'!
test08shouldMoveBackwardsPointingSouthCorrectly

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := South new.
	finalCoordinate := coordinate - (0@-1).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'b'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	! !

!methodRemoval: MarsRoverTest #test08 stamp: 'LK 10/9/2023 12:37:54'!
test08

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := South new.
	finalCoordinate := coordinate - (0@-1).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'b'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:38:01'!
test09shouldMoveBackwardsPointingEastCorrectly

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := East new.
	finalCoordinate := coordinate - (1@0).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'b'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	! !

!methodRemoval: MarsRoverTest #test09 stamp: 'LK 10/9/2023 12:38:02'!
test09

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := East new.
	finalCoordinate := coordinate - (1@0).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'b'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:38:09'!
test10shouldMoveBackwardsPointingWestCorrectly

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := West new.
	finalCoordinate := coordinate - (-1@0).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'b'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	! !

!methodRemoval: MarsRoverTest #test10 stamp: 'LK 10/9/2023 12:38:10'!
test10

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := West new.
	finalCoordinate := coordinate - (-1@0).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'b'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	!

!testRun: #MarsRoverTest #test01shouldInitializeInGivenCoordinateAndDirection stamp: 'LK 10/9/2023 12:38:14'!
PASSED!

!testRun: #MarsRoverTest #test02shouldDoNothingOnEmptyString stamp: 'LK 10/9/2023 12:38:14'!
PASSED!

!testRun: #MarsRoverTest #test03shouldMoveForwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 12:38:14'!
PASSED!

!testRun: #MarsRoverTest #test04shouldMoveForwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 12:38:14'!
PASSED!

!testRun: #MarsRoverTest #test05shouldMoveForwardsPointingWestCorrectly stamp: 'LK 10/9/2023 12:38:14'!
PASSED!

!testRun: #MarsRoverTest #test06shouldMoveForwardsPointingEastCorrectly stamp: 'LK 10/9/2023 12:38:14'!
PASSED!

!testRun: #MarsRoverTest #test07shouldMoveBackwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 12:38:14'!
PASSED!

!testRun: #MarsRoverTest #test08shouldMoveBackwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 12:38:14'!
PASSED!

!testRun: #MarsRoverTest #test09shouldMoveBackwardsPointingEastCorrectly stamp: 'LK 10/9/2023 12:38:14'!
PASSED!

!testRun: #MarsRoverTest #test10shouldMoveBackwardsPointingWestCorrectly stamp: 'LK 10/9/2023 12:38:14'!
PASSED!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:39:23'!
test11

	|marsRover coordinate direction commands finalDirection |
	
	coordinate := 0@0.
	direction := North new.
	finalDirection := East new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'r'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: coordinate ) and: [marsRover cardinal: finalDirection]).	
	
	! !

!testRun: #MarsRoverTest #test11 stamp: 'LK 10/9/2023 12:39:47'!
FAILURE!
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 12:40:11' prior: 50690745!
execute: commands 
	
	(commands = 'f') ifTrue: [	position := position + direction goForward].
	
	(commands = 'b') ifTrue: [ position := position + direction goBackwards].
	
	direction := East new.! !

!testRun: #MarsRoverTest #test11 stamp: 'LK 10/9/2023 12:40:14'!
FAILURE!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:40:59' prior: 50691122!
test11

	|marsRover coordinate direction commands finalDirection |
	
	coordinate := 0@0.
	direction := North new.
	finalDirection := East new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'r'. 
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: coordinate ) and: [marsRover cardinal: finalDirection]).	
	
	! !

!testRun: #MarsRoverTest #test11 stamp: 'LK 10/9/2023 12:41:02'!
FAILURE!

East new!

East new = East new!
!MarsRover methodsFor: 'private' stamp: 'LK 10/9/2023 13:08:41' prior: 50689514!
cardinal: aDirection

	^direction = aDirection.! !
!MarsRover methodsFor: 'private' stamp: 'LK 10/9/2023 13:13:13' prior: 50691169!
cardinal: aDirection

	^direction class= aDirection class.! !

!testRun: #MarsRoverTest #test01shouldInitializeInGivenCoordinateAndDirection stamp: 'LK 10/9/2023 13:13:17'!
PASSED!

!testRun: #MarsRoverTest #test02shouldDoNothingOnEmptyString stamp: 'LK 10/9/2023 13:13:17'!
FAILURE!

!testRun: #MarsRoverTest #test03shouldMoveForwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:13:17'!
FAILURE!

!testRun: #MarsRoverTest #test04shouldMoveForwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:13:17'!
FAILURE!

!testRun: #MarsRoverTest #test05shouldMoveForwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:13:17'!
FAILURE!

!testRun: #MarsRoverTest #test06shouldMoveForwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:13:17'!
PASSED!

!testRun: #MarsRoverTest #test07shouldMoveBackwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:13:17'!
FAILURE!

!testRun: #MarsRoverTest #test08shouldMoveBackwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:13:17'!
FAILURE!

!testRun: #MarsRoverTest #test09shouldMoveBackwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:13:17'!
PASSED!

!testRun: #MarsRoverTest #test10shouldMoveBackwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:13:17'!
FAILURE!

!testRun: #MarsRoverTest #test11 stamp: 'LK 10/9/2023 13:13:17'!
PASSED!
!MarsRover methodsFor: 'private' stamp: 'LK 10/9/2023 13:14:00' prior: 50691174!
cardinal: aDirection

	^direction class = aDirection class.! !

!testRun: #MarsRoverTest #test11 stamp: 'LK 10/9/2023 13:14:03'!
PASSED!

!testRun: #MarsRoverTest #test01shouldInitializeInGivenCoordinateAndDirection stamp: 'LK 10/9/2023 13:14:03'!
PASSED!

!testRun: #MarsRoverTest #test02shouldDoNothingOnEmptyString stamp: 'LK 10/9/2023 13:14:03'!
FAILURE!

!testRun: #MarsRoverTest #test03shouldMoveForwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:14:03'!
FAILURE!

!testRun: #MarsRoverTest #test04shouldMoveForwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:14:03'!
FAILURE!

!testRun: #MarsRoverTest #test05shouldMoveForwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:14:03'!
FAILURE!

!testRun: #MarsRoverTest #test06shouldMoveForwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:14:03'!
PASSED!

!testRun: #MarsRoverTest #test07shouldMoveBackwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:14:03'!
FAILURE!

!testRun: #MarsRoverTest #test08shouldMoveBackwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:14:03'!
FAILURE!

!testRun: #MarsRoverTest #test09shouldMoveBackwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:14:03'!
PASSED!

!testRun: #MarsRoverTest #test10shouldMoveBackwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:14:04'!
FAILURE!

!testRun: #MarsRoverTest #test11 stamp: 'LK 10/9/2023 13:14:04'!
PASSED!

!testRun: #MarsRoverTest #test01shouldInitializeInGivenCoordinateAndDirection stamp: 'LK 10/9/2023 13:14:09'!
PASSED!

!testRun: #MarsRoverTest #test01shouldInitializeInGivenCoordinateAndDirection stamp: 'LK 10/9/2023 13:14:09'!
PASSED!

!testRun: #MarsRoverTest #test02shouldDoNothingOnEmptyString stamp: 'LK 10/9/2023 13:14:09'!
FAILURE!

!testRun: #MarsRoverTest #test03shouldMoveForwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:14:09'!
FAILURE!

!testRun: #MarsRoverTest #test04shouldMoveForwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:14:10'!
FAILURE!

!testRun: #MarsRoverTest #test05shouldMoveForwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:14:10'!
FAILURE!

!testRun: #MarsRoverTest #test06shouldMoveForwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:14:10'!
PASSED!

!testRun: #MarsRoverTest #test07shouldMoveBackwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:14:10'!
FAILURE!

!testRun: #MarsRoverTest #test08shouldMoveBackwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:14:10'!
FAILURE!

!testRun: #MarsRoverTest #test09shouldMoveBackwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:14:10'!
PASSED!

!testRun: #MarsRoverTest #test10shouldMoveBackwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:14:10'!
FAILURE!

!testRun: #MarsRoverTest #test11 stamp: 'LK 10/9/2023 13:14:10'!
PASSED!

!testRun: #MarsRoverTest #test01shouldInitializeInGivenCoordinateAndDirection stamp: 'LK 10/9/2023 13:14:14'!
PASSED!

!testRun: #MarsRoverTest #test02shouldDoNothingOnEmptyString stamp: 'LK 10/9/2023 13:14:16'!
FAILURE!

!testRun: #MarsRoverTest #test02shouldDoNothingOnEmptyString stamp: 'LK 10/9/2023 13:14:16'!
FAILURE!

!testRun: #MarsRoverTest #test02shouldDoNothingOnEmptyString stamp: 'LK 10/9/2023 13:14:42'!
FAILURE!

!testRun: #MarsRoverTest #test02shouldDoNothingOnEmptyString stamp: 'LK 10/9/2023 13:14:42'!
FAILURE!

!testRun: #MarsRoverTest #test03shouldMoveForwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:14:44'!
FAILURE!

!testRun: #MarsRoverTest #test03shouldMoveForwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:14:44'!
FAILURE!

!testRun: #MarsRoverTest #test04shouldMoveForwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:14:47'!
FAILURE!

!testRun: #MarsRoverTest #test04shouldMoveForwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:14:47'!
FAILURE!

!testRun: #MarsRoverTest #test05shouldMoveForwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:14:50'!
FAILURE!

!testRun: #MarsRoverTest #test05shouldMoveForwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:14:50'!
FAILURE!

!testRun: #MarsRoverTest #test06shouldMoveForwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:14:53'!
PASSED!

!testRun: #MarsRoverTest #test07shouldMoveBackwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:15:06'!
FAILURE!

!testRun: #MarsRoverTest #test07shouldMoveBackwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:15:06'!
FAILURE!

!testRun: #MarsRoverTest #test06shouldMoveForwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:15:09'!
PASSED!

!testRun: #MarsRoverTest #test09shouldMoveBackwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:15:12'!
PASSED!
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 13:15:25' prior: 50691139!
execute: commands 
	
	(commands = 'f') ifTrue: [	position := position + direction goForward].
	
	(commands = 'b') ifTrue: [ position := position + direction goBackwards].
	
! !

!testRun: #MarsRoverTest #test01shouldInitializeInGivenCoordinateAndDirection stamp: 'LK 10/9/2023 13:15:29'!
PASSED!

!testRun: #MarsRoverTest #test02shouldDoNothingOnEmptyString stamp: 'LK 10/9/2023 13:15:29'!
PASSED!

!testRun: #MarsRoverTest #test03shouldMoveForwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:15:29'!
PASSED!

!testRun: #MarsRoverTest #test04shouldMoveForwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:15:29'!
PASSED!

!testRun: #MarsRoverTest #test05shouldMoveForwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:15:29'!
PASSED!

!testRun: #MarsRoverTest #test06shouldMoveForwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:15:29'!
PASSED!

!testRun: #MarsRoverTest #test07shouldMoveBackwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:15:29'!
PASSED!

!testRun: #MarsRoverTest #test08shouldMoveBackwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:15:29'!
PASSED!

!testRun: #MarsRoverTest #test09shouldMoveBackwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:15:29'!
PASSED!

!testRun: #MarsRoverTest #test10shouldMoveBackwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:15:29'!
PASSED!

!testRun: #MarsRoverTest #test11 stamp: 'LK 10/9/2023 13:15:29'!
FAILURE!

!testRun: #MarsRoverTest #test11 stamp: 'LK 10/9/2023 13:15:29'!
FAILURE!

!testRun: #MarsRoverTest #test01shouldInitializeInGivenCoordinateAndDirection stamp: 'LK 10/9/2023 13:15:32'!
PASSED!

!testRun: #MarsRoverTest #test02shouldDoNothingOnEmptyString stamp: 'LK 10/9/2023 13:15:33'!
PASSED!

!testRun: #MarsRoverTest #test01shouldInitializeInGivenCoordinateAndDirection stamp: 'LK 10/9/2023 13:15:36'!
PASSED!

!testRun: #MarsRoverTest #test02shouldDoNothingOnEmptyString stamp: 'LK 10/9/2023 13:15:36'!
PASSED!

!testRun: #MarsRoverTest #test03shouldMoveForwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:15:36'!
PASSED!

!testRun: #MarsRoverTest #test04shouldMoveForwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:15:36'!
PASSED!

!testRun: #MarsRoverTest #test05shouldMoveForwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:15:36'!
PASSED!

!testRun: #MarsRoverTest #test06shouldMoveForwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:15:36'!
PASSED!

!testRun: #MarsRoverTest #test07shouldMoveBackwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:15:36'!
PASSED!

!testRun: #MarsRoverTest #test08shouldMoveBackwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:15:36'!
PASSED!

!testRun: #MarsRoverTest #test09shouldMoveBackwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:15:36'!
PASSED!

!testRun: #MarsRoverTest #test10shouldMoveBackwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:15:36'!
PASSED!

!testRun: #MarsRoverTest #test11 stamp: 'LK 10/9/2023 13:15:36'!
FAILURE!

!testRun: #MarsRoverTest #test11 stamp: 'LK 10/9/2023 13:15:36'!
FAILURE!

!testRun: #MarsRoverTest #test03shouldMoveForwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:15:39'!
PASSED!

!testRun: #MarsRoverTest #test04shouldMoveForwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:15:40'!
PASSED!

!testRun: #MarsRoverTest #test05shouldMoveForwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:15:42'!
PASSED!

!testRun: #MarsRoverTest #test06shouldMoveForwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:15:44'!
PASSED!

!testRun: #MarsRoverTest #test07shouldMoveBackwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:15:45'!
PASSED!

!testRun: #MarsRoverTest #test08shouldMoveBackwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:15:47'!
PASSED!

!testRun: #MarsRoverTest #test09shouldMoveBackwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:15:48'!
PASSED!

!testRun: #MarsRoverTest #test10shouldMoveBackwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:15:49'!
PASSED!
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 13:16:23' prior: 50691360!
execute: commands 
	
	(commands = 'f') ifTrue: [	position := position + direction goForward].
	
	(commands = 'b') ifTrue: [ position := position + direction goBackwards].
	
	(commands = 'r') ifTrue: [ 	direction := East new].
	
! !

!testRun: #MarsRoverTest #test01shouldInitializeInGivenCoordinateAndDirection stamp: 'LK 10/9/2023 13:16:28'!
PASSED!

!testRun: #MarsRoverTest #test02shouldDoNothingOnEmptyString stamp: 'LK 10/9/2023 13:16:28'!
PASSED!

!testRun: #MarsRoverTest #test03shouldMoveForwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:16:28'!
PASSED!

!testRun: #MarsRoverTest #test04shouldMoveForwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:16:28'!
PASSED!

!testRun: #MarsRoverTest #test05shouldMoveForwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:16:28'!
PASSED!

!testRun: #MarsRoverTest #test06shouldMoveForwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:16:28'!
PASSED!

!testRun: #MarsRoverTest #test07shouldMoveBackwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:16:28'!
PASSED!

!testRun: #MarsRoverTest #test08shouldMoveBackwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:16:28'!
PASSED!

!testRun: #MarsRoverTest #test09shouldMoveBackwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:16:28'!
PASSED!

!testRun: #MarsRoverTest #test10shouldMoveBackwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:16:28'!
PASSED!

!testRun: #MarsRoverTest #test11 stamp: 'LK 10/9/2023 13:16:28'!
PASSED!
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 13:17:10' prior: 50691484!
execute: commands 
	
	(commands = 'f') ifTrue: [	position := position + direction goForward].
	
	(commands = 'b') ifTrue: [ position := position + direction goBackwards].
	
	(commands = 'r') ifTrue: [ 	direction := direction rotateRight].
	
! !
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 13:17:56' prior: 50691532!
execute: commands 
	
	(commands = 'f') ifTrue: [	position := position + direction goForward].
	
	(commands = 'b') ifTrue: [ position := position + direction goBackwards].
	
	(commands = 'r') ifTrue: [	direction := direction rotateRight].
	
! !
!Direction methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 13:18:16'!
rotateRight! !
!West methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 13:18:19' overrides: 50691554!
rotateRight! !
!East methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 13:18:19' overrides: 50691554!
rotateRight! !
!North methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 13:18:19' overrides: 50691554!
rotateRight! !
!South methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 13:18:19' overrides: 50691554!
rotateRight! !
!Direction methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 13:18:19' prior: 50691554!
rotateRight

	self subclassResponsibility! !
!North methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 13:18:32' prior: 50691566 overrides: 50691574!
rotateRight
	^East new.! !

!testRun: #MarsRoverTest #test11 stamp: 'LK 10/9/2023 13:18:43'!
PASSED!
!East methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 13:18:56' prior: 50691562 overrides: 50691574!
rotateRight
	^South new.! !
!South methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 13:19:05' prior: 50691570 overrides: 50691574!
rotateRight
	^West new.! !
!West methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 13:19:15' prior: 50691558 overrides: 50691574!
rotateRight
	^North new.! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:19:44'!
test12

	|marsRover coordinate direction commands finalDirection |
	
	coordinate := 0@0.
	direction := East new.
	finalDirection := South new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'r'. 
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: coordinate ) and: [marsRover cardinal: finalDirection]).	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:19:53'!
test13

	|marsRover coordinate direction commands finalDirection |
	
	coordinate := 0@0.
	direction := South new.
	finalDirection := West new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'r'. 
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: coordinate ) and: [marsRover cardinal: finalDirection]).	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:20:00'!
test14

	|marsRover coordinate direction commands finalDirection |
	
	coordinate := 0@0.
	direction := West new.
	finalDirection := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'r'. 
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: coordinate ) and: [marsRover cardinal: finalDirection]).	
	
	! !

!testRun: #MarsRoverTest #test01shouldInitializeInGivenCoordinateAndDirection stamp: 'LK 10/9/2023 13:20:03'!
PASSED!

!testRun: #MarsRoverTest #test02shouldDoNothingOnEmptyString stamp: 'LK 10/9/2023 13:20:03'!
PASSED!

!testRun: #MarsRoverTest #test03shouldMoveForwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:20:03'!
PASSED!

!testRun: #MarsRoverTest #test04shouldMoveForwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:20:03'!
PASSED!

!testRun: #MarsRoverTest #test05shouldMoveForwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:20:03'!
PASSED!

!testRun: #MarsRoverTest #test06shouldMoveForwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:20:03'!
PASSED!

!testRun: #MarsRoverTest #test07shouldMoveBackwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:20:03'!
PASSED!

!testRun: #MarsRoverTest #test08shouldMoveBackwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:20:03'!
PASSED!

!testRun: #MarsRoverTest #test09shouldMoveBackwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:20:03'!
PASSED!

!testRun: #MarsRoverTest #test10shouldMoveBackwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:20:03'!
PASSED!

!testRun: #MarsRoverTest #test11 stamp: 'LK 10/9/2023 13:20:03'!
PASSED!

!testRun: #MarsRoverTest #test12 stamp: 'LK 10/9/2023 13:20:03'!
PASSED!

!testRun: #MarsRoverTest #test13 stamp: 'LK 10/9/2023 13:20:03'!
PASSED!

!testRun: #MarsRoverTest #test14 stamp: 'LK 10/9/2023 13:20:03'!
PASSED!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:20:19'!
test11shouldRotateRightPointingNorthCorrectly

	|marsRover coordinate direction commands finalDirection |
	
	coordinate := 0@0.
	direction := North new.
	finalDirection := East new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'r'. 
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: coordinate ) and: [marsRover cardinal: finalDirection]).	
	
	! !

!methodRemoval: MarsRoverTest #test11 stamp: 'LK 10/9/2023 13:20:20'!
test11

	|marsRover coordinate direction commands finalDirection |
	
	coordinate := 0@0.
	direction := North new.
	finalDirection := East new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'r'. 
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: coordinate ) and: [marsRover cardinal: finalDirection]).	
	
	!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:20:29'!
test12shouldRotateRightPointingEastCorrectly

	|marsRover coordinate direction commands finalDirection |
	
	coordinate := 0@0.
	direction := East new.
	finalDirection := South new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'r'. 
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: coordinate ) and: [marsRover cardinal: finalDirection]).	
	
	! !

!methodRemoval: MarsRoverTest #test12 stamp: 'LK 10/9/2023 13:20:31'!
test12

	|marsRover coordinate direction commands finalDirection |
	
	coordinate := 0@0.
	direction := East new.
	finalDirection := South new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'r'. 
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: coordinate ) and: [marsRover cardinal: finalDirection]).	
	
	!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:20:42'!
test13shouldRotateRightPointingSouthNew

	|marsRover coordinate direction commands finalDirection |
	
	coordinate := 0@0.
	direction := South new.
	finalDirection := West new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'r'. 
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: coordinate ) and: [marsRover cardinal: finalDirection]).	
	
	! !

!methodRemoval: MarsRoverTest #test13 stamp: 'LK 10/9/2023 13:20:43'!
test13

	|marsRover coordinate direction commands finalDirection |
	
	coordinate := 0@0.
	direction := South new.
	finalDirection := West new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'r'. 
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: coordinate ) and: [marsRover cardinal: finalDirection]).	
	
	!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:20:56'!
test14shouldRotateRightPointingWestCorrectly

	|marsRover coordinate direction commands finalDirection |
	
	coordinate := 0@0.
	direction := West new.
	finalDirection := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'r'. 
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: coordinate ) and: [marsRover cardinal: finalDirection]).	
	
	! !

!methodRemoval: MarsRoverTest #test14 stamp: 'LK 10/9/2023 13:20:57'!
test14

	|marsRover coordinate direction commands finalDirection |
	
	coordinate := 0@0.
	direction := West new.
	finalDirection := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'r'. 
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: coordinate ) and: [marsRover cardinal: finalDirection]).	
	
	!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:21:03'!
test13shouldRotateRightPointingSouthCorrectly
	|marsRover coordinate direction commands finalDirection |
	
	coordinate := 0@0.
	direction := South new.
	finalDirection := West new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'r'. 
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: coordinate ) and: [marsRover cardinal: finalDirection]).	
	
	! !

!methodRemoval: MarsRoverTest #test13shouldRotateRightPointingSouthNew stamp: 'LK 10/9/2023 13:21:04'!
test13shouldRotateRightPointingSouthNew

	|marsRover coordinate direction commands finalDirection |
	
	coordinate := 0@0.
	direction := South new.
	finalDirection := West new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'r'. 
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: coordinate ) and: [marsRover cardinal: finalDirection]).	
	
	!

!testRun: #MarsRoverTest #test01shouldInitializeInGivenCoordinateAndDirection stamp: 'LK 10/9/2023 13:21:07'!
PASSED!

!testRun: #MarsRoverTest #test02shouldDoNothingOnEmptyString stamp: 'LK 10/9/2023 13:21:07'!
PASSED!

!testRun: #MarsRoverTest #test03shouldMoveForwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:21:07'!
PASSED!

!testRun: #MarsRoverTest #test04shouldMoveForwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:21:07'!
PASSED!

!testRun: #MarsRoverTest #test05shouldMoveForwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:21:07'!
PASSED!

!testRun: #MarsRoverTest #test06shouldMoveForwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:21:07'!
PASSED!

!testRun: #MarsRoverTest #test07shouldMoveBackwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:21:07'!
PASSED!

!testRun: #MarsRoverTest #test08shouldMoveBackwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:21:07'!
PASSED!

!testRun: #MarsRoverTest #test09shouldMoveBackwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:21:07'!
PASSED!

!testRun: #MarsRoverTest #test10shouldMoveBackwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:21:07'!
PASSED!

!testRun: #MarsRoverTest #test11shouldRotateRightPointingNorthCorrectly stamp: 'LK 10/9/2023 13:21:07'!
PASSED!

!testRun: #MarsRoverTest #test12shouldRotateRightPointingEastCorrectly stamp: 'LK 10/9/2023 13:21:07'!
PASSED!

!testRun: #MarsRoverTest #test13shouldRotateRightPointingSouthCorrectly stamp: 'LK 10/9/2023 13:21:07'!
PASSED!

!testRun: #MarsRoverTest #test14shouldRotateRightPointingWestCorrectly stamp: 'LK 10/9/2023 13:21:07'!
PASSED!
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 13:22:19' prior: 50691543!
execute: commands 
	
	(commands = 'f') ifTrue: [	position := position + direction goForward].
	
	(commands = 'b') ifTrue: [ position := position + direction goBackwards].
	
	(commands = 'r') ifTrue: [	direction := direction rotateRight].
	
	(commands = 'l') ifTrue: [direction := direction rotateLeft].
	
! !
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 13:23:05' prior: 50691882!
execute: commands 
	
	(commands = 'f') ifTrue: [	position := position + direction goForward].
	
	(commands = 'b') ifTrue: [ position := position + direction goBackwards].
	
	(commands = 'r') ifTrue: [	direction := direction rotateRight].
	
	(commands = 'l') ifTrue: [direction := direction rotateLeft].
	
! !
!Direction methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 13:23:12'!
rotateLeft! !
!West methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 13:23:15' overrides: 50691908!
rotateLeft! !
!East methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 13:23:15' overrides: 50691908!
rotateLeft! !
!North methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 13:23:15' overrides: 50691908!
rotateLeft! !
!South methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 13:23:15' overrides: 50691908!
rotateLeft! !
!Direction methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 13:23:16' prior: 50691908!
rotateLeft

	self subclassResponsibility! !
!East methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 13:23:25' prior: 50691916 overrides: 50691928!
rotateLeft
	^North new.! !
!North methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 13:23:35' prior: 50691920 overrides: 50691928!
rotateLeft
	^West new.! !
!South methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 13:23:46' prior: 50691924 overrides: 50691928!
rotateLeft
	^East new.! !
!West methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 13:24:00' prior: 50691912 overrides: 50691928!
rotateLeft
	^South new.! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:24:23'!
test15shouldRotateLeftPointingNorthCorrectly

	|marsRover coordinate direction commands finalDirection |
	
	coordinate := 0@0.
	direction := North new.
	finalDirection := West new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'r'. 
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: coordinate ) and: [marsRover cardinal: finalDirection]).	
	
	! !

!testRun: #MarsRoverTest #test15shouldRotateLeftPointingNorthCorrectly stamp: 'LK 10/9/2023 13:24:25'!
FAILURE!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:24:40' prior: 50691951!
test15shouldRotateLeftPointingNorthCorrectly

	|marsRover coordinate direction commands finalDirection |
	
	coordinate := 0@0.
	direction := North new.
	finalDirection := West new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'l'. 
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: coordinate ) and: [marsRover cardinal: finalDirection]).	
	
	! !

!testRun: #MarsRoverTest #test15shouldRotateLeftPointingNorthCorrectly stamp: 'LK 10/9/2023 13:24:41'!
PASSED!

!testRun: #MarsRoverTest #test01shouldInitializeInGivenCoordinateAndDirection stamp: 'LK 10/9/2023 13:24:41'!
PASSED!

!testRun: #MarsRoverTest #test02shouldDoNothingOnEmptyString stamp: 'LK 10/9/2023 13:24:41'!
PASSED!

!testRun: #MarsRoverTest #test03shouldMoveForwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:24:41'!
PASSED!

!testRun: #MarsRoverTest #test04shouldMoveForwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:24:41'!
PASSED!

!testRun: #MarsRoverTest #test05shouldMoveForwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:24:41'!
PASSED!

!testRun: #MarsRoverTest #test06shouldMoveForwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:24:41'!
PASSED!

!testRun: #MarsRoverTest #test07shouldMoveBackwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:24:41'!
PASSED!

!testRun: #MarsRoverTest #test08shouldMoveBackwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:24:41'!
PASSED!

!testRun: #MarsRoverTest #test09shouldMoveBackwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:24:41'!
PASSED!

!testRun: #MarsRoverTest #test10shouldMoveBackwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:24:41'!
PASSED!

!testRun: #MarsRoverTest #test11shouldRotateRightPointingNorthCorrectly stamp: 'LK 10/9/2023 13:24:41'!
PASSED!

!testRun: #MarsRoverTest #test12shouldRotateRightPointingEastCorrectly stamp: 'LK 10/9/2023 13:24:41'!
PASSED!

!testRun: #MarsRoverTest #test13shouldRotateRightPointingSouthCorrectly stamp: 'LK 10/9/2023 13:24:41'!
PASSED!

!testRun: #MarsRoverTest #test14shouldRotateRightPointingWestCorrectly stamp: 'LK 10/9/2023 13:24:41'!
PASSED!

!testRun: #MarsRoverTest #test15shouldRotateLeftPointingNorthCorrectly stamp: 'LK 10/9/2023 13:24:41'!
PASSED!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:25:08'!
test16shouldRotateLeftPointingSouthCorrectly

	|marsRover coordinate direction commands finalDirection |
	
	coordinate := 0@0.
	direction := South new.
	finalDirection := East new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'l'. 
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: coordinate ) and: [marsRover cardinal: finalDirection]).	
	
	! !

!testRun: #MarsRoverTest #test16shouldRotateLeftPointingSouthCorrectly stamp: 'LK 10/9/2023 13:25:09'!
PASSED!

!testRun: #MarsRoverTest #test01shouldInitializeInGivenCoordinateAndDirection stamp: 'LK 10/9/2023 13:25:09'!
PASSED!

!testRun: #MarsRoverTest #test02shouldDoNothingOnEmptyString stamp: 'LK 10/9/2023 13:25:09'!
PASSED!

!testRun: #MarsRoverTest #test03shouldMoveForwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:25:09'!
PASSED!

!testRun: #MarsRoverTest #test04shouldMoveForwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:25:09'!
PASSED!

!testRun: #MarsRoverTest #test05shouldMoveForwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:25:09'!
PASSED!

!testRun: #MarsRoverTest #test06shouldMoveForwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:25:09'!
PASSED!

!testRun: #MarsRoverTest #test07shouldMoveBackwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:25:09'!
PASSED!

!testRun: #MarsRoverTest #test08shouldMoveBackwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:25:09'!
PASSED!

!testRun: #MarsRoverTest #test09shouldMoveBackwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:25:09'!
PASSED!

!testRun: #MarsRoverTest #test10shouldMoveBackwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:25:09'!
PASSED!

!testRun: #MarsRoverTest #test11shouldRotateRightPointingNorthCorrectly stamp: 'LK 10/9/2023 13:25:09'!
PASSED!

!testRun: #MarsRoverTest #test12shouldRotateRightPointingEastCorrectly stamp: 'LK 10/9/2023 13:25:09'!
PASSED!

!testRun: #MarsRoverTest #test13shouldRotateRightPointingSouthCorrectly stamp: 'LK 10/9/2023 13:25:09'!
PASSED!

!testRun: #MarsRoverTest #test14shouldRotateRightPointingWestCorrectly stamp: 'LK 10/9/2023 13:25:09'!
PASSED!

!testRun: #MarsRoverTest #test15shouldRotateLeftPointingNorthCorrectly stamp: 'LK 10/9/2023 13:25:10'!
PASSED!

!testRun: #MarsRoverTest #test16shouldRotateLeftPointingSouthCorrectly stamp: 'LK 10/9/2023 13:25:10'!
PASSED!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:25:20'!
test17shouldRotateLeftPointingEastCorrectly

	|marsRover coordinate direction commands finalDirection |
	
	coordinate := 0@0.
	direction := East new.
	finalDirection := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'l'. 
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: coordinate ) and: [marsRover cardinal: finalDirection]).	
	
	! !

!testRun: #MarsRoverTest #test17shouldRotateLeftPointingEastCorrectly stamp: 'LK 10/9/2023 13:25:21'!
PASSED!

!testRun: #MarsRoverTest #test01shouldInitializeInGivenCoordinateAndDirection stamp: 'LK 10/9/2023 13:25:21'!
PASSED!

!testRun: #MarsRoverTest #test02shouldDoNothingOnEmptyString stamp: 'LK 10/9/2023 13:25:21'!
PASSED!

!testRun: #MarsRoverTest #test03shouldMoveForwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:25:21'!
PASSED!

!testRun: #MarsRoverTest #test04shouldMoveForwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:25:21'!
PASSED!

!testRun: #MarsRoverTest #test05shouldMoveForwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:25:21'!
PASSED!

!testRun: #MarsRoverTest #test06shouldMoveForwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:25:21'!
PASSED!

!testRun: #MarsRoverTest #test07shouldMoveBackwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:25:21'!
PASSED!

!testRun: #MarsRoverTest #test08shouldMoveBackwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:25:21'!
PASSED!

!testRun: #MarsRoverTest #test09shouldMoveBackwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:25:21'!
PASSED!

!testRun: #MarsRoverTest #test10shouldMoveBackwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:25:21'!
PASSED!

!testRun: #MarsRoverTest #test11shouldRotateRightPointingNorthCorrectly stamp: 'LK 10/9/2023 13:25:21'!
PASSED!

!testRun: #MarsRoverTest #test12shouldRotateRightPointingEastCorrectly stamp: 'LK 10/9/2023 13:25:21'!
PASSED!

!testRun: #MarsRoverTest #test13shouldRotateRightPointingSouthCorrectly stamp: 'LK 10/9/2023 13:25:22'!
PASSED!

!testRun: #MarsRoverTest #test14shouldRotateRightPointingWestCorrectly stamp: 'LK 10/9/2023 13:25:22'!
PASSED!

!testRun: #MarsRoverTest #test15shouldRotateLeftPointingNorthCorrectly stamp: 'LK 10/9/2023 13:25:22'!
PASSED!

!testRun: #MarsRoverTest #test16shouldRotateLeftPointingSouthCorrectly stamp: 'LK 10/9/2023 13:25:22'!
PASSED!

!testRun: #MarsRoverTest #test17shouldRotateLeftPointingEastCorrectly stamp: 'LK 10/9/2023 13:25:22'!
PASSED!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:25:31'!
test17shouldRotateLeftPointingWestCorrectly

	|marsRover coordinate direction commands finalDirection |
	
	coordinate := 0@0.
	direction := West new.
	finalDirection := South new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'l'. 
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: coordinate ) and: [marsRover cardinal: finalDirection]).	
	
	! !

!testRun: #MarsRoverTest #test17shouldRotateLeftPointingWestCorrectly stamp: 'LK 10/9/2023 13:25:32'!
PASSED!

!testRun: #MarsRoverTest #test01shouldInitializeInGivenCoordinateAndDirection stamp: 'LK 10/9/2023 13:25:32'!
PASSED!

!testRun: #MarsRoverTest #test02shouldDoNothingOnEmptyString stamp: 'LK 10/9/2023 13:25:32'!
PASSED!

!testRun: #MarsRoverTest #test03shouldMoveForwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:25:32'!
PASSED!

!testRun: #MarsRoverTest #test04shouldMoveForwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:25:32'!
PASSED!

!testRun: #MarsRoverTest #test05shouldMoveForwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:25:32'!
PASSED!

!testRun: #MarsRoverTest #test06shouldMoveForwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:25:32'!
PASSED!

!testRun: #MarsRoverTest #test07shouldMoveBackwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:25:32'!
PASSED!

!testRun: #MarsRoverTest #test08shouldMoveBackwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:25:32'!
PASSED!

!testRun: #MarsRoverTest #test09shouldMoveBackwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:25:32'!
PASSED!

!testRun: #MarsRoverTest #test10shouldMoveBackwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:25:32'!
PASSED!

!testRun: #MarsRoverTest #test11shouldRotateRightPointingNorthCorrectly stamp: 'LK 10/9/2023 13:25:32'!
PASSED!

!testRun: #MarsRoverTest #test12shouldRotateRightPointingEastCorrectly stamp: 'LK 10/9/2023 13:25:32'!
PASSED!

!testRun: #MarsRoverTest #test13shouldRotateRightPointingSouthCorrectly stamp: 'LK 10/9/2023 13:25:32'!
PASSED!

!testRun: #MarsRoverTest #test14shouldRotateRightPointingWestCorrectly stamp: 'LK 10/9/2023 13:25:32'!
PASSED!

!testRun: #MarsRoverTest #test15shouldRotateLeftPointingNorthCorrectly stamp: 'LK 10/9/2023 13:25:32'!
PASSED!

!testRun: #MarsRoverTest #test16shouldRotateLeftPointingSouthCorrectly stamp: 'LK 10/9/2023 13:25:32'!
PASSED!

!testRun: #MarsRoverTest #test17shouldRotateLeftPointingEastCorrectly stamp: 'LK 10/9/2023 13:25:32'!
PASSED!

!testRun: #MarsRoverTest #test17shouldRotateLeftPointingWestCorrectly stamp: 'LK 10/9/2023 13:25:32'!
PASSED!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:25:51'!
test18shouldRotateLeftPointingWestCorrectly

	|marsRover coordinate direction commands finalDirection |
	
	coordinate := 0@0.
	direction := West new.
	finalDirection := South new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'l'. 
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: coordinate ) and: [marsRover cardinal: finalDirection]).	
	
	! !

!methodRemoval: MarsRoverTest #test17shouldRotateLeftPointingWestCorrectly stamp: 'LK 10/9/2023 13:25:59'!
test17shouldRotateLeftPointingWestCorrectly

	|marsRover coordinate direction commands finalDirection |
	
	coordinate := 0@0.
	direction := West new.
	finalDirection := South new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'l'. 
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: coordinate ) and: [marsRover cardinal: finalDirection]).	
	
	!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:26:03'!
test19! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:26:47' prior: 50692308!
test19! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:27:50' prior: 50692311!
test19

	|marsRover coordinate direction commands |
	
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'fb'. 
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: coordinate ) and: [marsRover cardinal: direction]).	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:27:58'!
test19canHandleMultipleCommands

	|marsRover coordinate direction commands |
	
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'fb'. 
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: coordinate ) and: [marsRover cardinal: direction]).	
	! !

!methodRemoval: MarsRoverTest #test19 stamp: 'LK 10/9/2023 13:28:04'!
test19

	|marsRover coordinate direction commands |
	
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'fb'. 
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: coordinate ) and: [marsRover cardinal: direction]).	
	!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:28:41' prior: 50692326!
test19canHandleMultipleCommands

	|marsRover coordinate direction commands |
	
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'fb'. 
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: coordinate ) and: [marsRover cardinal: direction]).	
	! !

!testRun: #MarsRoverTest #test19canHandleMultipleCommands stamp: 'LK 10/9/2023 13:29:39'!
PASSED!

!testRun: #MarsRoverTest #test01shouldInitializeInGivenCoordinateAndDirection stamp: 'LK 10/9/2023 13:29:39'!
PASSED!

!testRun: #MarsRoverTest #test02shouldDoNothingOnEmptyString stamp: 'LK 10/9/2023 13:29:39'!
PASSED!

!testRun: #MarsRoverTest #test03shouldMoveForwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:29:39'!
PASSED!

!testRun: #MarsRoverTest #test04shouldMoveForwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:29:39'!
PASSED!

!testRun: #MarsRoverTest #test05shouldMoveForwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:29:39'!
PASSED!

!testRun: #MarsRoverTest #test06shouldMoveForwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:29:39'!
PASSED!

!testRun: #MarsRoverTest #test07shouldMoveBackwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:29:39'!
PASSED!

!testRun: #MarsRoverTest #test08shouldMoveBackwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:29:39'!
PASSED!

!testRun: #MarsRoverTest #test09shouldMoveBackwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:29:39'!
PASSED!

!testRun: #MarsRoverTest #test10shouldMoveBackwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:29:39'!
PASSED!

!testRun: #MarsRoverTest #test11shouldRotateRightPointingNorthCorrectly stamp: 'LK 10/9/2023 13:29:39'!
PASSED!

!testRun: #MarsRoverTest #test12shouldRotateRightPointingEastCorrectly stamp: 'LK 10/9/2023 13:29:39'!
PASSED!

!testRun: #MarsRoverTest #test13shouldRotateRightPointingSouthCorrectly stamp: 'LK 10/9/2023 13:29:39'!
PASSED!

!testRun: #MarsRoverTest #test14shouldRotateRightPointingWestCorrectly stamp: 'LK 10/9/2023 13:29:39'!
PASSED!

!testRun: #MarsRoverTest #test15shouldRotateLeftPointingNorthCorrectly stamp: 'LK 10/9/2023 13:29:39'!
PASSED!

!testRun: #MarsRoverTest #test16shouldRotateLeftPointingSouthCorrectly stamp: 'LK 10/9/2023 13:29:39'!
PASSED!

!testRun: #MarsRoverTest #test17shouldRotateLeftPointingEastCorrectly stamp: 'LK 10/9/2023 13:29:40'!
PASSED!

!testRun: #MarsRoverTest #test18shouldRotateLeftPointingWestCorrectly stamp: 'LK 10/9/2023 13:29:40'!
PASSED!

!testRun: #MarsRoverTest #test19canHandleMultipleCommands stamp: 'LK 10/9/2023 13:29:40'!
PASSED!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:29:59' prior: 50692352!
test19canHandleMultipleCommands

	|marsRover coordinate direction commands |
	
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'fbf'. 
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: coordinate ) and: [marsRover cardinal: direction]).	
	! !

!testRun: #MarsRoverTest #test19canHandleMultipleCommands stamp: 'LK 10/9/2023 13:30:00'!
PASSED!

!testRun: #MarsRoverTest #test01shouldInitializeInGivenCoordinateAndDirection stamp: 'LK 10/9/2023 13:30:00'!
PASSED!

!testRun: #MarsRoverTest #test02shouldDoNothingOnEmptyString stamp: 'LK 10/9/2023 13:30:00'!
PASSED!

!testRun: #MarsRoverTest #test03shouldMoveForwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:30:00'!
PASSED!

!testRun: #MarsRoverTest #test04shouldMoveForwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:30:00'!
PASSED!

!testRun: #MarsRoverTest #test05shouldMoveForwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:30:00'!
PASSED!

!testRun: #MarsRoverTest #test06shouldMoveForwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:30:00'!
PASSED!

!testRun: #MarsRoverTest #test07shouldMoveBackwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:30:00'!
PASSED!

!testRun: #MarsRoverTest #test08shouldMoveBackwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:30:00'!
PASSED!

!testRun: #MarsRoverTest #test09shouldMoveBackwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:30:00'!
PASSED!

!testRun: #MarsRoverTest #test10shouldMoveBackwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:30:00'!
PASSED!

!testRun: #MarsRoverTest #test11shouldRotateRightPointingNorthCorrectly stamp: 'LK 10/9/2023 13:30:00'!
PASSED!

!testRun: #MarsRoverTest #test12shouldRotateRightPointingEastCorrectly stamp: 'LK 10/9/2023 13:30:01'!
PASSED!

!testRun: #MarsRoverTest #test13shouldRotateRightPointingSouthCorrectly stamp: 'LK 10/9/2023 13:30:01'!
PASSED!

!testRun: #MarsRoverTest #test14shouldRotateRightPointingWestCorrectly stamp: 'LK 10/9/2023 13:30:01'!
PASSED!

!testRun: #MarsRoverTest #test15shouldRotateLeftPointingNorthCorrectly stamp: 'LK 10/9/2023 13:30:01'!
PASSED!

!testRun: #MarsRoverTest #test16shouldRotateLeftPointingSouthCorrectly stamp: 'LK 10/9/2023 13:30:01'!
PASSED!

!testRun: #MarsRoverTest #test17shouldRotateLeftPointingEastCorrectly stamp: 'LK 10/9/2023 13:30:01'!
PASSED!

!testRun: #MarsRoverTest #test18shouldRotateLeftPointingWestCorrectly stamp: 'LK 10/9/2023 13:30:01'!
PASSED!

!testRun: #MarsRoverTest #test19canHandleMultipleCommands stamp: 'LK 10/9/2023 13:30:01'!
PASSED!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:30:23' prior: 50692435!
test19canHandleMultipleCommands

	|marsRover coordinate direction commands finalCoordinate |
	
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'fbf'. 
	finalCoordinate := 0@1.
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: coordinate ) and: [marsRover cardinal: direction]).	
	! !

!testRun: #MarsRoverTest #test19canHandleMultipleCommands stamp: 'LK 10/9/2023 13:30:33'!
PASSED!

!testRun: #MarsRoverTest #test01shouldInitializeInGivenCoordinateAndDirection stamp: 'LK 10/9/2023 13:30:33'!
PASSED!

!testRun: #MarsRoverTest #test02shouldDoNothingOnEmptyString stamp: 'LK 10/9/2023 13:30:33'!
PASSED!

!testRun: #MarsRoverTest #test03shouldMoveForwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:30:33'!
PASSED!

!testRun: #MarsRoverTest #test04shouldMoveForwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:30:33'!
PASSED!

!testRun: #MarsRoverTest #test05shouldMoveForwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:30:33'!
PASSED!

!testRun: #MarsRoverTest #test06shouldMoveForwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:30:33'!
PASSED!

!testRun: #MarsRoverTest #test07shouldMoveBackwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:30:33'!
PASSED!

!testRun: #MarsRoverTest #test08shouldMoveBackwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:30:33'!
PASSED!

!testRun: #MarsRoverTest #test09shouldMoveBackwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:30:33'!
PASSED!

!testRun: #MarsRoverTest #test10shouldMoveBackwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:30:33'!
PASSED!

!testRun: #MarsRoverTest #test11shouldRotateRightPointingNorthCorrectly stamp: 'LK 10/9/2023 13:30:33'!
PASSED!

!testRun: #MarsRoverTest #test12shouldRotateRightPointingEastCorrectly stamp: 'LK 10/9/2023 13:30:33'!
PASSED!

!testRun: #MarsRoverTest #test13shouldRotateRightPointingSouthCorrectly stamp: 'LK 10/9/2023 13:30:33'!
PASSED!

!testRun: #MarsRoverTest #test14shouldRotateRightPointingWestCorrectly stamp: 'LK 10/9/2023 13:30:33'!
PASSED!

!testRun: #MarsRoverTest #test15shouldRotateLeftPointingNorthCorrectly stamp: 'LK 10/9/2023 13:30:33'!
PASSED!

!testRun: #MarsRoverTest #test16shouldRotateLeftPointingSouthCorrectly stamp: 'LK 10/9/2023 13:30:33'!
PASSED!

!testRun: #MarsRoverTest #test17shouldRotateLeftPointingEastCorrectly stamp: 'LK 10/9/2023 13:30:33'!
PASSED!

!testRun: #MarsRoverTest #test18shouldRotateLeftPointingWestCorrectly stamp: 'LK 10/9/2023 13:30:33'!
PASSED!

!testRun: #MarsRoverTest #test19canHandleMultipleCommands stamp: 'LK 10/9/2023 13:30:33'!
PASSED!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:30:36' prior: 50692518!
test19canHandleMultipleCommands

	|marsRover coordinate direction commands finalCoordinate |
	
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'fbf'. 
	finalCoordinate := 0@1.
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	! !

!testRun: #MarsRoverTest #test19canHandleMultipleCommands stamp: 'LK 10/9/2023 13:30:36'!
FAILURE!

East class = East class!

West class = East class true .!

West class = East class!
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 13:36:14' prior: 50691895!
execute: commands 

	commands do: [:char | self executeChar].
	
	(commands = 'f') ifTrue: [	position := position + direction goForward].
	
	(commands = 'b') ifTrue: [ position := position + direction goBackwards].
	
	(commands = 'r') ifTrue: [	direction := direction rotateRight].
	
	(commands = 'l') ifTrue: [direction := direction rotateLeft].
	
! !
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 13:36:27' prior: 50692624!
execute: commands 

	commands do: [:char | self executeChar: char].
	
	(commands = 'f') ifTrue: [	position := position + direction goForward].
	
	(commands = 'b') ifTrue: [ position := position + direction goBackwards].
	
	(commands = 'r') ifTrue: [	direction := direction rotateRight].
	
	(commands = 'l') ifTrue: [direction := direction rotateLeft].
	
! !
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 13:36:58'!
executeChar: aSingleCommand
	
	(aSingleCommand = 'f') ifTrue: [	position := position + direction goForward].
	
	(aSingleCommand = 'b') ifTrue: [ position := position + direction goBackwards].
	
	(aSingleCommand = 'r') ifTrue: [	direction := direction rotateRight].
	
	(aSingleCommand = 'l') ifTrue: [direction := direction rotateLeft].
	
! !

!testRun: #MarsRoverTest #test19canHandleMultipleCommands stamp: 'LK 10/9/2023 13:37:05'!
FAILURE!
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 13:37:15' prior: 50692638!
execute: commands 

	commands do: [:char | self executeChar: char].

	
! !

!testRun: #MarsRoverTest #test19canHandleMultipleCommands stamp: 'LK 10/9/2023 13:37:18'!
FAILURE!

!testRun: #MarsRoverTest #test19canHandleMultipleCommands stamp: 'LK 10/9/2023 13:37:18'!
FAILURE!
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 13:38:12' prior: 50692652!
executeChar: aSingleCommand
	
	(aSingleCommand = $f) ifTrue: [	position := position + direction goForward].
	
	(aSingleCommand = $b) ifTrue: [ position := position + direction goBackwards].
	
	(aSingleCommand = $r) ifTrue: [	direction := direction rotateRight].
	
	(aSingleCommand = $l) ifTrue: [direction := direction rotateLeft].
	
! !

!testRun: #MarsRoverTest #test19canHandleMultipleCommands stamp: 'LK 10/9/2023 13:38:15'!
PASSED!

!testRun: #MarsRoverTest #test01shouldInitializeInGivenCoordinateAndDirection stamp: 'LK 10/9/2023 13:38:17'!
PASSED!

!testRun: #MarsRoverTest #test02shouldDoNothingOnEmptyString stamp: 'LK 10/9/2023 13:38:17'!
PASSED!

!testRun: #MarsRoverTest #test03shouldMoveForwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:38:17'!
PASSED!

!testRun: #MarsRoverTest #test04shouldMoveForwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:38:17'!
PASSED!

!testRun: #MarsRoverTest #test05shouldMoveForwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:38:17'!
PASSED!

!testRun: #MarsRoverTest #test06shouldMoveForwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:38:17'!
PASSED!

!testRun: #MarsRoverTest #test07shouldMoveBackwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:38:17'!
PASSED!

!testRun: #MarsRoverTest #test08shouldMoveBackwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:38:17'!
PASSED!

!testRun: #MarsRoverTest #test09shouldMoveBackwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:38:17'!
PASSED!

!testRun: #MarsRoverTest #test10shouldMoveBackwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:38:17'!
PASSED!

!testRun: #MarsRoverTest #test11shouldRotateRightPointingNorthCorrectly stamp: 'LK 10/9/2023 13:38:17'!
PASSED!

!testRun: #MarsRoverTest #test12shouldRotateRightPointingEastCorrectly stamp: 'LK 10/9/2023 13:38:17'!
PASSED!

!testRun: #MarsRoverTest #test13shouldRotateRightPointingSouthCorrectly stamp: 'LK 10/9/2023 13:38:17'!
PASSED!

!testRun: #MarsRoverTest #test14shouldRotateRightPointingWestCorrectly stamp: 'LK 10/9/2023 13:38:17'!
PASSED!

!testRun: #MarsRoverTest #test15shouldRotateLeftPointingNorthCorrectly stamp: 'LK 10/9/2023 13:38:17'!
PASSED!

!testRun: #MarsRoverTest #test16shouldRotateLeftPointingSouthCorrectly stamp: 'LK 10/9/2023 13:38:17'!
PASSED!

!testRun: #MarsRoverTest #test17shouldRotateLeftPointingEastCorrectly stamp: 'LK 10/9/2023 13:38:17'!
PASSED!

!testRun: #MarsRoverTest #test18shouldRotateLeftPointingWestCorrectly stamp: 'LK 10/9/2023 13:38:17'!
PASSED!

!testRun: #MarsRoverTest #test19canHandleMultipleCommands stamp: 'LK 10/9/2023 13:38:17'!
PASSED!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:39:32'!
test19shouldHandleMultipleCommands

	|marsRover coordinate direction commands finalCoordinate |
	
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'fbf'. 
	finalCoordinate := 0@1.
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	! !

!methodRemoval: MarsRoverTest #test19canHandleMultipleCommands stamp: 'LK 10/9/2023 13:39:33'!
test19canHandleMultipleCommands

	|marsRover coordinate direction commands finalCoordinate |
	
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'fbf'. 
	finalCoordinate := 0@1.
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:39:45'!
test20shouldHandleInvalidCommand

	|marsRover coordinate direction commands finalCoordinate |
	
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'ds'. 
	finalCoordinate := 0@1.
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:39:57' prior: 50692794!
test20shouldHandleInvalidCommand

	|marsRover coordinate direction commands finalCoordinate |
	
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'ds'. 
	finalCoordinate := 0@0.
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	! !

!testRun: #MarsRoverTest #test20shouldHandleInvalidCommand stamp: 'LK 10/9/2023 13:39:59'!
PASSED!

!testRun: #MarsRoverTest #test01shouldInitializeInGivenCoordinateAndDirection stamp: 'LK 10/9/2023 13:39:59'!
PASSED!

!testRun: #MarsRoverTest #test02shouldDoNothingOnEmptyString stamp: 'LK 10/9/2023 13:39:59'!
PASSED!

!testRun: #MarsRoverTest #test03shouldMoveForwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:39:59'!
PASSED!

!testRun: #MarsRoverTest #test04shouldMoveForwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:39:59'!
PASSED!

!testRun: #MarsRoverTest #test05shouldMoveForwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:39:59'!
PASSED!

!testRun: #MarsRoverTest #test06shouldMoveForwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:39:59'!
PASSED!

!testRun: #MarsRoverTest #test07shouldMoveBackwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:39:59'!
PASSED!

!testRun: #MarsRoverTest #test08shouldMoveBackwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:39:59'!
PASSED!

!testRun: #MarsRoverTest #test09shouldMoveBackwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:39:59'!
PASSED!

!testRun: #MarsRoverTest #test10shouldMoveBackwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:39:59'!
PASSED!

!testRun: #MarsRoverTest #test11shouldRotateRightPointingNorthCorrectly stamp: 'LK 10/9/2023 13:39:59'!
PASSED!

!testRun: #MarsRoverTest #test12shouldRotateRightPointingEastCorrectly stamp: 'LK 10/9/2023 13:39:59'!
PASSED!

!testRun: #MarsRoverTest #test13shouldRotateRightPointingSouthCorrectly stamp: 'LK 10/9/2023 13:39:59'!
PASSED!

!testRun: #MarsRoverTest #test14shouldRotateRightPointingWestCorrectly stamp: 'LK 10/9/2023 13:39:59'!
PASSED!

!testRun: #MarsRoverTest #test15shouldRotateLeftPointingNorthCorrectly stamp: 'LK 10/9/2023 13:39:59'!
PASSED!

!testRun: #MarsRoverTest #test16shouldRotateLeftPointingSouthCorrectly stamp: 'LK 10/9/2023 13:39:59'!
PASSED!

!testRun: #MarsRoverTest #test17shouldRotateLeftPointingEastCorrectly stamp: 'LK 10/9/2023 13:40:00'!
PASSED!

!testRun: #MarsRoverTest #test18shouldRotateLeftPointingWestCorrectly stamp: 'LK 10/9/2023 13:40:00'!
PASSED!

!testRun: #MarsRoverTest #test19shouldHandleMultipleCommands stamp: 'LK 10/9/2023 13:40:00'!
PASSED!

!testRun: #MarsRoverTest #test20shouldHandleInvalidCommand stamp: 'LK 10/9/2023 13:40:00'!
PASSED!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:40:54'!
test20shouldHandleCommandsUntilInvalidCommand

	|marsRover coordinate direction commands finalCoordinate |
	
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'ds'. 
	finalCoordinate := 0@0.
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:41:00' prior: 50692896!
test20shouldHandleCommandsUntilInvalidCommand

	|marsRover coordinate direction commands finalCoordinate |
	
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'fffppp'. 
	finalCoordinate := 0@0.
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:41:04' prior: 50692912!
test20shouldHandleCommandsUntilInvalidCommand

	|marsRover coordinate direction commands finalCoordinate |
	
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'fffppp'. 
	finalCoordinate := 0@3.
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:41:11'!
test21shouldHandleCommandsUntilInvalidCommand

	|marsRover coordinate direction commands finalCoordinate |
	
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'fffppp'. 
	finalCoordinate := 0@3.
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	! !

!methodRemoval: MarsRoverTest #test20shouldHandleCommandsUntilInvalidCommand stamp: 'LK 10/9/2023 13:41:13'!
test20shouldHandleCommandsUntilInvalidCommand

	|marsRover coordinate direction commands finalCoordinate |
	
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'fffppp'. 
	finalCoordinate := 0@3.
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	!

!testRun: #MarsRoverTest #test20shouldHandleInvalidCommand stamp: 'LK 10/9/2023 13:41:25'!
PASSED!

!testRun: #MarsRoverTest #test21shouldHandleCommandsUntilInvalidCommand stamp: 'LK 10/9/2023 13:41:26'!
PASSED!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:41:47' prior: 50692943!
test21shouldHandleCommandsUntilInvalidCommand

	|marsRover coordinate direction commands finalCoordinate |
	
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'fffpppf'. 
	finalCoordinate := 0@3.
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	! !

!testRun: #MarsRoverTest #test21shouldHandleCommandsUntilInvalidCommand stamp: 'LK 10/9/2023 13:41:48'!
FAILURE!
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 13:43:25'!
commandForward

	^ position := position + direction goForward! !
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 13:43:25' prior: 50692681!
executeChar: aSingleCommand
	
	(aSingleCommand = $f) ifTrue: [	self commandForward].
	
	(aSingleCommand = $b) ifTrue: [ position := position + direction goBackwards].
	
	(aSingleCommand = $r) ifTrue: [	direction := direction rotateRight].
	
	(aSingleCommand = $l) ifTrue: [direction := direction rotateLeft].
	
! !
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 13:43:37' prior: 50693005!
executeChar: aSingleCommand
	
	(aSingleCommand = $f) ifTrue: [	self commandForward].
	
	(aSingleCommand = $b) ifTrue: [position := position + direction goBackwards].
	
	(aSingleCommand = $r) ifTrue: [	direction := direction rotateRight].
	
	(aSingleCommand = $l) ifTrue: [direction := direction rotateLeft].
	
! !
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 13:43:49'!
commandBackward

	^ position := position + direction goBackwards! !
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 13:43:49' prior: 50693018!
executeChar: aSingleCommand
	
	(aSingleCommand = $f) ifTrue: [	self commandForward].
	
	(aSingleCommand = $b) ifTrue: [self commandBackward].
	
	(aSingleCommand = $r) ifTrue: [	direction := direction rotateRight].
	
	(aSingleCommand = $l) ifTrue: [direction := direction rotateLeft].
	
! !
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 13:44:10'!
commandRotateRight

	^ direction := direction rotateRight! !
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 13:44:10' prior: 50693035!
executeChar: aSingleCommand
	
	(aSingleCommand = $f) ifTrue: [	self commandForward].
	
	(aSingleCommand = $b) ifTrue: [self commandBackward].
	
	(aSingleCommand = $r) ifTrue: [	self commandRotateRight].
	
	(aSingleCommand = $l) ifTrue: [direction := direction rotateLeft].
	
! !
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 13:44:21'!
commandRotateLeft

	^ direction := direction rotateLeft! !
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 13:44:21' prior: 50693052!
executeChar: aSingleCommand
	
	(aSingleCommand = $f) ifTrue: [	self commandForward].
	
	(aSingleCommand = $b) ifTrue: [self commandBackward].
	
	(aSingleCommand = $r) ifTrue: [	self commandRotateRight].
	
	(aSingleCommand = $l) ifTrue: [self commandRotateLeft].
	
! !
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 13:44:55' prior: 50693068!
executeChar: aSingleCommand
	
	(aSingleCommand = $f) ifTrue: [	self commandForward].
	
	(aSingleCommand = $b) ifTrue: [self commandBackward].
	
	(aSingleCommand = $r) ifTrue: [	self commandRotateRight].
	
	(aSingleCommand = $l) ifTrue: [self commandRotateLeft].
	
	^self
	
! !

!testRun: #MarsRoverTest #test19shouldHandleMultipleCommands stamp: 'LK 10/9/2023 13:44:58'!
PASSED!

!testRun: #MarsRoverTest #test20shouldHandleInvalidCommand stamp: 'LK 10/9/2023 13:44:59'!
PASSED!

!testRun: #MarsRoverTest #test21shouldHandleCommandsUntilInvalidCommand stamp: 'LK 10/9/2023 13:45:00'!
FAILURE!

!testRun: #MarsRoverTest #test21shouldHandleCommandsUntilInvalidCommand stamp: 'LK 10/9/2023 13:45:00'!
FAILURE!
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 13:46:36' prior: 50693079!
executeChar: aSingleCommand
	
	(aSingleCommand = $f) ifTrue: [	self commandForward].
	
	(aSingleCommand = $b) ifTrue: [self commandBackward].
	
	(aSingleCommand = $r) ifTrue: [	self commandRotateRight].
	
	(aSingleCommand = $l) ifTrue: [self commandRotateLeft].
	
	
! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:52:37'!
assertMarsRover: marsRover shouldBeIn: finalCoordinate pointingTo: direction

	^ self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction])! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:52:37' prior: 50690941!
test06shouldMoveForwardsPointingEastCorrectly

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := East new.
	finalCoordinate := coordinate + (1@0).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	
	self assertMarsRover: marsRover shouldBeIn: finalCoordinate pointingTo: direction.	
	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:52:37' prior: 50691057!
test10shouldMoveBackwardsPointingWestCorrectly

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := West new.
	finalCoordinate := coordinate - (-1@0).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'b'. 
	marsRover execute: commands.
	
	self assertMarsRover: marsRover shouldBeIn: finalCoordinate pointingTo: direction.	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:52:37' prior: 50691028!
test09shouldMoveBackwardsPointingEastCorrectly

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := East new.
	finalCoordinate := coordinate - (1@0).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'b'. 
	marsRover execute: commands.
	
	self assertMarsRover: marsRover shouldBeIn: finalCoordinate pointingTo: direction.	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:52:37' prior: 50692764!
test19shouldHandleMultipleCommands

	|marsRover coordinate direction commands finalCoordinate |
	
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'fbf'. 
	finalCoordinate := 0@1.
	
	marsRover execute: commands.
	
	self assertMarsRover: marsRover shouldBeIn: finalCoordinate pointingTo: direction.	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:52:37' prior: 50690999!
test08shouldMoveBackwardsPointingSouthCorrectly

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := South new.
	finalCoordinate := coordinate - (0@-1).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'b'. 
	marsRover execute: commands.
	
	self assertMarsRover: marsRover shouldBeIn: finalCoordinate pointingTo: direction.	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:52:37' prior: 50690838!
test03shouldMoveForwardsPointingNorthCorrectly

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := North new.
	finalCoordinate := coordinate + (0@1).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	
	self assertMarsRover: marsRover shouldBeIn: finalCoordinate pointingTo: direction.	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:52:37' prior: 50692981!
test21shouldHandleCommandsUntilInvalidCommand

	|marsRover coordinate direction commands finalCoordinate |
	
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'fffpppf'. 
	finalCoordinate := 0@3.
	
	marsRover execute: commands.
	
	self assertMarsRover: marsRover shouldBeIn: finalCoordinate pointingTo: direction.	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:52:37' prior: 50690912!
test05shouldMoveForwardsPointingWestCorrectly

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := West new.
	finalCoordinate := coordinate + (-1@0).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	
	self assertMarsRover: marsRover shouldBeIn: finalCoordinate pointingTo: direction.	
	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:52:37' prior: 50690970!
test07shouldMoveBackwardsPointingNorthCorrectly

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := North new.
	finalCoordinate := coordinate - (0@1).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'b'. 
	marsRover execute: commands.
	
	self assertMarsRover: marsRover shouldBeIn: finalCoordinate pointingTo: direction.	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:52:37' prior: 50692809!
test20shouldHandleInvalidCommand

	|marsRover coordinate direction commands finalCoordinate |
	
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'ds'. 
	finalCoordinate := 0@0.
	
	marsRover execute: commands.
	
	self assertMarsRover: marsRover shouldBeIn: finalCoordinate pointingTo: direction.	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:52:37' prior: 50690883!
test04shouldMoveForwardsPointingSouthCorrectly

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := South new.
	finalCoordinate := coordinate + (0@-1).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	
	self assertMarsRover: marsRover shouldBeIn: finalCoordinate pointingTo: direction.	
	
	
	! !

!testRun: #MarsRoverTest #test01shouldInitializeInGivenCoordinateAndDirection stamp: 'LK 10/9/2023 13:52:46'!
PASSED!

!testRun: #MarsRoverTest #test02shouldDoNothingOnEmptyString stamp: 'LK 10/9/2023 13:52:46'!
PASSED!

!testRun: #MarsRoverTest #test03shouldMoveForwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:52:46'!
PASSED!

!testRun: #MarsRoverTest #test04shouldMoveForwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:52:46'!
PASSED!

!testRun: #MarsRoverTest #test05shouldMoveForwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:52:46'!
PASSED!

!testRun: #MarsRoverTest #test06shouldMoveForwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:52:46'!
PASSED!

!testRun: #MarsRoverTest #test07shouldMoveBackwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:52:46'!
PASSED!

!testRun: #MarsRoverTest #test08shouldMoveBackwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:52:46'!
PASSED!

!testRun: #MarsRoverTest #test09shouldMoveBackwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:52:46'!
PASSED!

!testRun: #MarsRoverTest #test10shouldMoveBackwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:52:46'!
PASSED!

!testRun: #MarsRoverTest #test11shouldRotateRightPointingNorthCorrectly stamp: 'LK 10/9/2023 13:52:46'!
PASSED!

!testRun: #MarsRoverTest #test12shouldRotateRightPointingEastCorrectly stamp: 'LK 10/9/2023 13:52:46'!
PASSED!

!testRun: #MarsRoverTest #test13shouldRotateRightPointingSouthCorrectly stamp: 'LK 10/9/2023 13:52:46'!
PASSED!

!testRun: #MarsRoverTest #test14shouldRotateRightPointingWestCorrectly stamp: 'LK 10/9/2023 13:52:46'!
PASSED!

!testRun: #MarsRoverTest #test15shouldRotateLeftPointingNorthCorrectly stamp: 'LK 10/9/2023 13:52:46'!
PASSED!

!testRun: #MarsRoverTest #test16shouldRotateLeftPointingSouthCorrectly stamp: 'LK 10/9/2023 13:52:46'!
PASSED!

!testRun: #MarsRoverTest #test17shouldRotateLeftPointingEastCorrectly stamp: 'LK 10/9/2023 13:52:46'!
PASSED!

!testRun: #MarsRoverTest #test18shouldRotateLeftPointingWestCorrectly stamp: 'LK 10/9/2023 13:52:46'!
PASSED!

!testRun: #MarsRoverTest #test19shouldHandleMultipleCommands stamp: 'LK 10/9/2023 13:52:46'!
PASSED!

!testRun: #MarsRoverTest #test20shouldHandleInvalidCommand stamp: 'LK 10/9/2023 13:52:46'!
PASSED!

!testRun: #MarsRoverTest #test21shouldHandleCommandsUntilInvalidCommand stamp: 'LK 10/9/2023 13:52:46'!
FAILURE!

!testRun: #MarsRoverTest #test21shouldHandleCommandsUntilInvalidCommand stamp: 'LK 10/9/2023 13:52:46'!
FAILURE!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:52:56' prior: 50693218!
test21shouldHandleCommandsUntilInvalidCommand

	|marsRover coordinate direction commands finalCoordinate |
	
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'fffpppf'. 
	finalCoordinate := 0@3.
	
	marsRover execute: commands.
	
	"self assertMarsRover: marsRover shouldBeIn: finalCoordinate pointingTo: direction.	"
	! !

!testRun: #MarsRoverTest #test21shouldHandleCommandsUntilInvalidCommand stamp: 'LK 10/9/2023 13:52:59'!
PASSED!

!testRun: #MarsRoverTest #test01shouldInitializeInGivenCoordinateAndDirection stamp: 'LK 10/9/2023 13:52:59'!
PASSED!

!testRun: #MarsRoverTest #test02shouldDoNothingOnEmptyString stamp: 'LK 10/9/2023 13:52:59'!
PASSED!

!testRun: #MarsRoverTest #test03shouldMoveForwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:52:59'!
PASSED!

!testRun: #MarsRoverTest #test04shouldMoveForwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:52:59'!
PASSED!

!testRun: #MarsRoverTest #test05shouldMoveForwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:52:59'!
PASSED!

!testRun: #MarsRoverTest #test06shouldMoveForwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:52:59'!
PASSED!

!testRun: #MarsRoverTest #test07shouldMoveBackwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:52:59'!
PASSED!

!testRun: #MarsRoverTest #test08shouldMoveBackwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:52:59'!
PASSED!

!testRun: #MarsRoverTest #test09shouldMoveBackwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:52:59'!
PASSED!

!testRun: #MarsRoverTest #test10shouldMoveBackwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:52:59'!
PASSED!

!testRun: #MarsRoverTest #test11shouldRotateRightPointingNorthCorrectly stamp: 'LK 10/9/2023 13:52:59'!
PASSED!

!testRun: #MarsRoverTest #test12shouldRotateRightPointingEastCorrectly stamp: 'LK 10/9/2023 13:53:00'!
PASSED!

!testRun: #MarsRoverTest #test13shouldRotateRightPointingSouthCorrectly stamp: 'LK 10/9/2023 13:53:00'!
PASSED!

!testRun: #MarsRoverTest #test14shouldRotateRightPointingWestCorrectly stamp: 'LK 10/9/2023 13:53:00'!
PASSED!

!testRun: #MarsRoverTest #test15shouldRotateLeftPointingNorthCorrectly stamp: 'LK 10/9/2023 13:53:00'!
PASSED!

!testRun: #MarsRoverTest #test16shouldRotateLeftPointingSouthCorrectly stamp: 'LK 10/9/2023 13:53:00'!
PASSED!

!testRun: #MarsRoverTest #test17shouldRotateLeftPointingEastCorrectly stamp: 'LK 10/9/2023 13:53:00'!
PASSED!

!testRun: #MarsRoverTest #test18shouldRotateLeftPointingWestCorrectly stamp: 'LK 10/9/2023 13:53:00'!
PASSED!

!testRun: #MarsRoverTest #test19shouldHandleMultipleCommands stamp: 'LK 10/9/2023 13:53:00'!
PASSED!

!testRun: #MarsRoverTest #test20shouldHandleInvalidCommand stamp: 'LK 10/9/2023 13:53:00'!
PASSED!

!testRun: #MarsRoverTest #test21shouldHandleCommandsUntilInvalidCommand stamp: 'LK 10/9/2023 13:53:00'!
PASSED!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:53:29' prior: 50690776!
test01shouldInitializeInGivenCoordinateAndDirection
	| marsRover coordinate direction|
	
	coordinate := 0@0.
	direction := North new.
	marsRover := MarsRover withCoord: coordinate pointingTo: direction.
	
	self assertMarsRover: marsRover shouldBeIn: direction pointingTo: coordinate.
	! !

!testRun: #MarsRoverTest #test01shouldInitializeInGivenCoordinateAndDirection stamp: 'LK 10/9/2023 13:53:29'!
FAILURE!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:53:45' prior: 50693466!
test01shouldInitializeInGivenCoordinateAndDirection
	| marsRover coordinate direction|
	
	coordinate := 0@0.
	direction := North new.
	marsRover := MarsRover withCoord: coordinate pointingTo: direction.
	
	self assertMarsRover: marsRover shouldBeIn: coordinate pointingTo: direction.
	! !

!testRun: #MarsRoverTest #test01shouldInitializeInGivenCoordinateAndDirection stamp: 'LK 10/9/2023 13:53:46'!
PASSED!

!testRun: #MarsRoverTest #test01shouldInitializeInGivenCoordinateAndDirection stamp: 'LK 10/9/2023 13:53:46'!
PASSED!

!testRun: #MarsRoverTest #test02shouldDoNothingOnEmptyString stamp: 'LK 10/9/2023 13:53:46'!
PASSED!

!testRun: #MarsRoverTest #test03shouldMoveForwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:53:46'!
PASSED!

!testRun: #MarsRoverTest #test04shouldMoveForwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:53:46'!
PASSED!

!testRun: #MarsRoverTest #test05shouldMoveForwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:53:46'!
PASSED!

!testRun: #MarsRoverTest #test06shouldMoveForwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:53:46'!
PASSED!

!testRun: #MarsRoverTest #test07shouldMoveBackwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:53:46'!
PASSED!

!testRun: #MarsRoverTest #test08shouldMoveBackwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:53:46'!
PASSED!

!testRun: #MarsRoverTest #test09shouldMoveBackwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:53:46'!
PASSED!

!testRun: #MarsRoverTest #test10shouldMoveBackwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:53:46'!
PASSED!

!testRun: #MarsRoverTest #test11shouldRotateRightPointingNorthCorrectly stamp: 'LK 10/9/2023 13:53:46'!
PASSED!

!testRun: #MarsRoverTest #test12shouldRotateRightPointingEastCorrectly stamp: 'LK 10/9/2023 13:53:46'!
PASSED!

!testRun: #MarsRoverTest #test13shouldRotateRightPointingSouthCorrectly stamp: 'LK 10/9/2023 13:53:46'!
PASSED!

!testRun: #MarsRoverTest #test14shouldRotateRightPointingWestCorrectly stamp: 'LK 10/9/2023 13:53:46'!
PASSED!

!testRun: #MarsRoverTest #test15shouldRotateLeftPointingNorthCorrectly stamp: 'LK 10/9/2023 13:53:46'!
PASSED!

!testRun: #MarsRoverTest #test16shouldRotateLeftPointingSouthCorrectly stamp: 'LK 10/9/2023 13:53:46'!
PASSED!

!testRun: #MarsRoverTest #test17shouldRotateLeftPointingEastCorrectly stamp: 'LK 10/9/2023 13:53:46'!
PASSED!

!testRun: #MarsRoverTest #test18shouldRotateLeftPointingWestCorrectly stamp: 'LK 10/9/2023 13:53:46'!
PASSED!

!testRun: #MarsRoverTest #test19shouldHandleMultipleCommands stamp: 'LK 10/9/2023 13:53:46'!
PASSED!

!testRun: #MarsRoverTest #test20shouldHandleInvalidCommand stamp: 'LK 10/9/2023 13:53:46'!
PASSED!

!testRun: #MarsRoverTest #test21shouldHandleCommandsUntilInvalidCommand stamp: 'LK 10/9/2023 13:53:46'!
PASSED!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:54:06' prior: 50690798!
test02shouldDoNothingOnEmptyString

	|marsRover coordinate direction commands|
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := ''. 
	marsRover execute: commands.
	
	self assertMarsRover: marsRover shouldBeIn: coordinate pointingTo: direction.
	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:54:24' prior: 50693202!
test03shouldMoveForwardsPointingNorthCorrectly

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := North new.
	finalCoordinate := coordinate + (0@1).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	
	marsRover execute: commands.
	
	self assertMarsRover: marsRover shouldBeIn: finalCoordinate pointingTo: direction.	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:54:33' prior: 50693482!
test01shouldInitializeInGivenCoordinateAndDirection

	| marsRover coordinate direction|
	
	coordinate := 0@0.
	direction := North new.
	marsRover := MarsRover withCoord: coordinate pointingTo: direction.
	
	self assertMarsRover: marsRover shouldBeIn: coordinate pointingTo: direction.
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:54:36' prior: 50693571!
test02shouldDoNothingOnEmptyString

	|marsRover coordinate direction commands|
	
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := ''. 
	marsRover execute: commands.
	
	self assertMarsRover: marsRover shouldBeIn: coordinate pointingTo: direction.
	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:54:42' prior: 50693613!
test02shouldDoNothingOnEmptyString

	|marsRover coordinate direction commands|
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := ''. 
	
	marsRover execute: commands.
	
	self assertMarsRover: marsRover shouldBeIn: coordinate pointingTo: direction.
	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:54:49' prior: 50693627!
test02shouldDoNothingOnEmptyString

	|marsRover coordinate direction commands|
	
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := ''. 
	
	marsRover execute: commands.
	
	self assertMarsRover: marsRover shouldBeIn: coordinate pointingTo: direction.
	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:55:01' prior: 50693281!
test04shouldMoveForwardsPointingSouthCorrectly

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := South new.
	finalCoordinate := coordinate + (0@-1).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	
	marsRover execute: commands.
	
	self assertMarsRover: marsRover shouldBeIn: finalCoordinate pointingTo: direction.	
	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:55:05' prior: 50693234!
test05shouldMoveForwardsPointingWestCorrectly

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := West new.
	finalCoordinate := coordinate + (-1@0).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	
	marsRover execute: commands.
	
	self assertMarsRover: marsRover shouldBeIn: finalCoordinate pointingTo: direction.	
	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:55:42' prior: 50691687!
test11shouldRotateRightPointingNorthCorrectly

	|marsRover coordinate direction commands finalDirection |
	
	coordinate := 0@0.
	direction := North new.
	finalDirection := East new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'r'. 
	
	marsRover execute: commands.
	
	self assertMarsRover: marsRover shouldBeIn: coordinate pointingTo: finalDirection.
	
	! !

!testRun: #MarsRoverTest #test11shouldRotateRightPointingNorthCorrectly stamp: 'LK 10/9/2023 13:55:43'!
PASSED!

!testRun: #MarsRoverTest #test01shouldInitializeInGivenCoordinateAndDirection stamp: 'LK 10/9/2023 13:55:43'!
PASSED!

!testRun: #MarsRoverTest #test02shouldDoNothingOnEmptyString stamp: 'LK 10/9/2023 13:55:43'!
PASSED!

!testRun: #MarsRoverTest #test03shouldMoveForwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:55:43'!
PASSED!

!testRun: #MarsRoverTest #test04shouldMoveForwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:55:43'!
PASSED!

!testRun: #MarsRoverTest #test05shouldMoveForwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:55:43'!
PASSED!

!testRun: #MarsRoverTest #test06shouldMoveForwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:55:43'!
PASSED!

!testRun: #MarsRoverTest #test07shouldMoveBackwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:55:43'!
PASSED!

!testRun: #MarsRoverTest #test08shouldMoveBackwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:55:43'!
PASSED!

!testRun: #MarsRoverTest #test09shouldMoveBackwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:55:43'!
PASSED!

!testRun: #MarsRoverTest #test10shouldMoveBackwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:55:43'!
PASSED!

!testRun: #MarsRoverTest #test11shouldRotateRightPointingNorthCorrectly stamp: 'LK 10/9/2023 13:55:43'!
PASSED!

!testRun: #MarsRoverTest #test12shouldRotateRightPointingEastCorrectly stamp: 'LK 10/9/2023 13:55:43'!
PASSED!

!testRun: #MarsRoverTest #test13shouldRotateRightPointingSouthCorrectly stamp: 'LK 10/9/2023 13:55:43'!
PASSED!

!testRun: #MarsRoverTest #test14shouldRotateRightPointingWestCorrectly stamp: 'LK 10/9/2023 13:55:43'!
PASSED!

!testRun: #MarsRoverTest #test15shouldRotateLeftPointingNorthCorrectly stamp: 'LK 10/9/2023 13:55:43'!
PASSED!

!testRun: #MarsRoverTest #test16shouldRotateLeftPointingSouthCorrectly stamp: 'LK 10/9/2023 13:55:43'!
PASSED!

!testRun: #MarsRoverTest #test17shouldRotateLeftPointingEastCorrectly stamp: 'LK 10/9/2023 13:55:43'!
PASSED!

!testRun: #MarsRoverTest #test18shouldRotateLeftPointingWestCorrectly stamp: 'LK 10/9/2023 13:55:43'!
PASSED!

!testRun: #MarsRoverTest #test19shouldHandleMultipleCommands stamp: 'LK 10/9/2023 13:55:43'!
PASSED!

!testRun: #MarsRoverTest #test20shouldHandleInvalidCommand stamp: 'LK 10/9/2023 13:55:43'!
PASSED!

!testRun: #MarsRoverTest #test21shouldHandleCommandsUntilInvalidCommand stamp: 'LK 10/9/2023 13:55:43'!
PASSED!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:55:54' prior: 50691716!
test12shouldRotateRightPointingEastCorrectly

	|marsRover coordinate direction commands finalDirection |
	
	coordinate := 0@0.
	direction := East new.
	finalDirection := South new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'r'. 
	
	marsRover execute: commands.
	
	self assertMarsRover: marsRover shouldBeIn: coordinate pointingTo: finalDirection.
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:55:59' prior: 50691802!
test13shouldRotateRightPointingSouthCorrectly
	|marsRover coordinate direction commands finalDirection |
	
	coordinate := 0@0.
	direction := South new.
	finalDirection := West new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'r'. 
	
	marsRover execute: commands.
	
	self assertMarsRover: marsRover shouldBeIn: coordinate pointingTo: finalDirection.
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:56:04' prior: 50691773!
test14shouldRotateRightPointingWestCorrectly

	|marsRover coordinate direction commands finalDirection |
	
	coordinate := 0@0.
	direction := West new.
	finalDirection := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'r'. 
	
	marsRover execute: commands.
	
	self assertMarsRover: marsRover shouldBeIn: coordinate pointingTo: finalDirection.
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:56:11' prior: 50691970!
test15shouldRotateLeftPointingNorthCorrectly

	|marsRover coordinate direction commands finalDirection |
	
	coordinate := 0@0.
	direction := North new.
	finalDirection := West new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'l'. 
	
	marsRover execute: commands.
	
	self assertMarsRover: marsRover shouldBeIn: coordinate pointingTo: finalDirection.
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:56:15' prior: 50692042!
test16shouldRotateLeftPointingSouthCorrectly

	|marsRover coordinate direction commands finalDirection |
	
	coordinate := 0@0.
	direction := South new.
	finalDirection := East new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'l'. 
	
	marsRover execute: commands.
	
	self assertMarsRover: marsRover shouldBeIn: coordinate pointingTo: finalDirection.
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:56:20' prior: 50692117!
test17shouldRotateLeftPointingEastCorrectly

	|marsRover coordinate direction commands finalDirection |
	
	coordinate := 0@0.
	direction := East new.
	finalDirection := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'l'. 
	
	marsRover execute: commands.
	
	self assertMarsRover: marsRover shouldBeIn: coordinate pointingTo: finalDirection.
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:56:24' prior: 50692277!
test18shouldRotateLeftPointingWestCorrectly

	|marsRover coordinate direction commands finalDirection |
	
	coordinate := 0@0.
	direction := West new.
	finalDirection := South new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'l'. 
	
	marsRover execute: commands.
	
	self assertMarsRover: marsRover shouldBeIn: coordinate pointingTo: finalDirection.
	
	! !
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 13:58:22' prior: 50693030!
commandBackward

	position := position + direction goBackwards! !
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 13:58:26' prior: 50693000!
commandForward

	position := position + direction goForward! !
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 13:58:28' prior: 50693063!
commandRotateLeft

	direction := direction rotateLeft! !
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 13:58:31' prior: 50693047!
commandRotateRight

	direction := direction rotateRight! !

!testRun: #MarsRoverTest #test01shouldInitializeInGivenCoordinateAndDirection stamp: 'LK 10/9/2023 13:58:36'!
PASSED!

!testRun: #MarsRoverTest #test02shouldDoNothingOnEmptyString stamp: 'LK 10/9/2023 13:58:36'!
PASSED!

!testRun: #MarsRoverTest #test03shouldMoveForwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:58:36'!
PASSED!

!testRun: #MarsRoverTest #test04shouldMoveForwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:58:36'!
PASSED!

!testRun: #MarsRoverTest #test05shouldMoveForwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:58:36'!
PASSED!

!testRun: #MarsRoverTest #test06shouldMoveForwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:58:36'!
PASSED!

!testRun: #MarsRoverTest #test07shouldMoveBackwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:58:36'!
PASSED!

!testRun: #MarsRoverTest #test08shouldMoveBackwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:58:36'!
PASSED!

!testRun: #MarsRoverTest #test09shouldMoveBackwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:58:36'!
PASSED!

!testRun: #MarsRoverTest #test10shouldMoveBackwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:58:36'!
PASSED!

!testRun: #MarsRoverTest #test11shouldRotateRightPointingNorthCorrectly stamp: 'LK 10/9/2023 13:58:36'!
PASSED!

!testRun: #MarsRoverTest #test12shouldRotateRightPointingEastCorrectly stamp: 'LK 10/9/2023 13:58:36'!
PASSED!

!testRun: #MarsRoverTest #test13shouldRotateRightPointingSouthCorrectly stamp: 'LK 10/9/2023 13:58:36'!
PASSED!

!testRun: #MarsRoverTest #test14shouldRotateRightPointingWestCorrectly stamp: 'LK 10/9/2023 13:58:36'!
PASSED!

!testRun: #MarsRoverTest #test15shouldRotateLeftPointingNorthCorrectly stamp: 'LK 10/9/2023 13:58:36'!
PASSED!

!testRun: #MarsRoverTest #test16shouldRotateLeftPointingSouthCorrectly stamp: 'LK 10/9/2023 13:58:36'!
PASSED!

!testRun: #MarsRoverTest #test17shouldRotateLeftPointingEastCorrectly stamp: 'LK 10/9/2023 13:58:36'!
PASSED!

!testRun: #MarsRoverTest #test18shouldRotateLeftPointingWestCorrectly stamp: 'LK 10/9/2023 13:58:36'!
PASSED!

!testRun: #MarsRoverTest #test19shouldHandleMultipleCommands stamp: 'LK 10/9/2023 13:58:36'!
PASSED!

!testRun: #MarsRoverTest #test20shouldHandleInvalidCommand stamp: 'LK 10/9/2023 13:58:36'!
PASSED!

!testRun: #MarsRoverTest #test21shouldHandleCommandsUntilInvalidCommand stamp: 'LK 10/9/2023 13:58:36'!
PASSED!

Object subclass: #Command
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!

!classDefinition: #Command category: 'Mars Rover- Exercise' stamp: 'LK 10/9/2023 13:58:59'!
Object subclass: #Command
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!

Command subclass: #Forward
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!

!classDefinition: #Forward category: 'Mars Rover- Exercise' stamp: 'LK 10/9/2023 13:59:07'!
Command subclass: #Forward
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!

Command subclass: #Backward
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!

!classDefinition: #Backward category: 'Mars Rover- Exercise' stamp: 'LK 10/9/2023 13:59:11'!
Command subclass: #Backward
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!

Command subclass: #RotateLeft
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!

!classDefinition: #RotateLeft category: 'Mars Rover- Exercise' stamp: 'LK 10/9/2023 13:59:26'!
Command subclass: #RotateLeft
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!

Command subclass: #RotateRight
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!

!classDefinition: #RotateRight category: 'Mars Rover- Exercise' stamp: 'LK 10/9/2023 13:59:30'!
Command subclass: #RotateRight
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 14:00:10' prior: 50692669!
execute: commands 

	commands do: [:command | self executeChar: command].

	
! !
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 14:02:24' prior: 50693104!
executeChar: aSingleCommand
	
	(aSingleCommand = $f) ifTrue: [	^self commandForward].
	
	(aSingleCommand = $b) ifTrue: [^self commandBackward].
	
	(aSingleCommand = $r) ifTrue: [^	self commandRotateRight].
	
	(aSingleCommand = $l) ifTrue: [^self commandRotateLeft].
	
	self error: 'comando invalido'.
	
! !

!testRun: #MarsRoverTest #test20shouldHandleInvalidCommand stamp: 'LK 10/9/2023 14:02:28'!
ERROR!

!testRun: #MarsRoverTest #test20shouldHandleInvalidCommand stamp: 'LK 10/9/2023 14:02:28'!
ERROR!

!testRun: #MarsRoverTest #test21shouldHandleCommandsUntilInvalidCommand stamp: 'LK 10/9/2023 14:02:33'!
ERROR!

!testRun: #MarsRoverTest #test21shouldHandleCommandsUntilInvalidCommand stamp: 'LK 10/9/2023 14:02:33'!
ERROR!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 14:03:12' prior: 50693374!
test21shouldHandleCommandsUntilInvalidCommand

	|marsRover coordinate direction commands finalCoordinate |
	
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'fffpppf'. 
	finalCoordinate := 0@3.
	
	marsRover execute: commands.
	

	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 14:05:39' prior: 50693266!
test20shouldHandleInvalidCommand

	|marsRover coordinate direction commands finalCoordinate |
	
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'ds'. 
	finalCoordinate := 0@0.
	
	
	self 
		should: [marsRover execute: commands]
		raise: Error
		withExceptionDo: [ :anError |].
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 14:06:26' prior: 50694080!
test20shouldHandleInvalidCommand

	|marsRover coordinate direction commands finalCoordinate |
	
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'ds'. 
	finalCoordinate := 0@0.
	
	
	self 
		should: [marsRover execute: commands]
		raise: Error
		withExceptionDo: [ :anError | 
			self assert: anError messageText = ''].
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 14:06:38' prior: 50694094!
test20shouldHandleInvalidCommand

	|marsRover coordinate direction commands|
	
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'ds'. 
	
	
	self 
		should: [marsRover execute: commands]
		raise: Error
		withExceptionDo: [ :anError | 
			self assert: anError messageText = ''].
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 14:06:52' prior: 50694110!
test20shouldHandleInvalidCommand

	|marsRover coordinate direction commands|
	
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'ds'. 
	
	
	self 
		should: [marsRover execute: commands]
		raise: Error
		withExceptionDo: [ :anError | 
			self assert: anError messageText = 'comando invalido'].
	! !

!testRun: #MarsRoverTest #test20shouldHandleInvalidCommand stamp: 'LK 10/9/2023 14:06:53'!
PASSED!

!testRun: #MarsRoverTest #test01shouldInitializeInGivenCoordinateAndDirection stamp: 'LK 10/9/2023 14:06:53'!
PASSED!

!testRun: #MarsRoverTest #test02shouldDoNothingOnEmptyString stamp: 'LK 10/9/2023 14:06:53'!
PASSED!

!testRun: #MarsRoverTest #test03shouldMoveForwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 14:06:53'!
PASSED!

!testRun: #MarsRoverTest #test04shouldMoveForwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 14:06:53'!
PASSED!

!testRun: #MarsRoverTest #test05shouldMoveForwardsPointingWestCorrectly stamp: 'LK 10/9/2023 14:06:53'!
PASSED!

!testRun: #MarsRoverTest #test06shouldMoveForwardsPointingEastCorrectly stamp: 'LK 10/9/2023 14:06:53'!
PASSED!

!testRun: #MarsRoverTest #test07shouldMoveBackwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 14:06:53'!
PASSED!

!testRun: #MarsRoverTest #test08shouldMoveBackwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 14:06:53'!
PASSED!

!testRun: #MarsRoverTest #test09shouldMoveBackwardsPointingEastCorrectly stamp: 'LK 10/9/2023 14:06:53'!
PASSED!

!testRun: #MarsRoverTest #test10shouldMoveBackwardsPointingWestCorrectly stamp: 'LK 10/9/2023 14:06:53'!
PASSED!

!testRun: #MarsRoverTest #test11shouldRotateRightPointingNorthCorrectly stamp: 'LK 10/9/2023 14:06:53'!
PASSED!

!testRun: #MarsRoverTest #test12shouldRotateRightPointingEastCorrectly stamp: 'LK 10/9/2023 14:06:53'!
PASSED!

!testRun: #MarsRoverTest #test13shouldRotateRightPointingSouthCorrectly stamp: 'LK 10/9/2023 14:06:53'!
PASSED!

!testRun: #MarsRoverTest #test14shouldRotateRightPointingWestCorrectly stamp: 'LK 10/9/2023 14:06:53'!
PASSED!

!testRun: #MarsRoverTest #test15shouldRotateLeftPointingNorthCorrectly stamp: 'LK 10/9/2023 14:06:54'!
PASSED!

!testRun: #MarsRoverTest #test16shouldRotateLeftPointingSouthCorrectly stamp: 'LK 10/9/2023 14:06:54'!
PASSED!

!testRun: #MarsRoverTest #test17shouldRotateLeftPointingEastCorrectly stamp: 'LK 10/9/2023 14:06:54'!
PASSED!

!testRun: #MarsRoverTest #test18shouldRotateLeftPointingWestCorrectly stamp: 'LK 10/9/2023 14:06:54'!
PASSED!

!testRun: #MarsRoverTest #test19shouldHandleMultipleCommands stamp: 'LK 10/9/2023 14:06:54'!
PASSED!

!testRun: #MarsRoverTest #test20shouldHandleInvalidCommand stamp: 'LK 10/9/2023 14:06:54'!
PASSED!

!testRun: #MarsRoverTest #test21shouldHandleCommandsUntilInvalidCommand stamp: 'LK 10/9/2023 14:06:54'!
ERROR!

!testRun: #MarsRoverTest #test21shouldHandleCommandsUntilInvalidCommand stamp: 'LK 10/9/2023 14:06:54'!
ERROR!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'LK 10/9/2023 14:07:08'!
PASSED!

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'LK 10/9/2023 14:07:08'!
PASSED!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'LK 10/9/2023 14:07:08'!
PASSED!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'LK 10/9/2023 14:07:08'!
PASSED!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'LK 10/9/2023 14:07:08'!
PASSED!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'LK 10/9/2023 14:07:08'!
PASSED!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'LK 10/9/2023 14:07:08'!
PASSED!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'LK 10/9/2023 14:07:08'!
PASSED!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'LK 10/9/2023 14:07:08'!
PASSED!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'LK 10/9/2023 14:07:08'!
PASSED!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'LK 10/9/2023 14:07:08'!
PASSED!

!testRun: #MarsRoverTest #test20shouldHandleInvalidCommand stamp: 'LK 10/9/2023 14:08:02'!
PASSED!

!testRun: #MarsRoverTest #test01shouldInitializeInGivenCoordinateAndDirection stamp: 'LK 10/9/2023 14:08:02'!
PASSED!

!testRun: #MarsRoverTest #test02shouldDoNothingOnEmptyString stamp: 'LK 10/9/2023 14:08:02'!
PASSED!

!testRun: #MarsRoverTest #test03shouldMoveForwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 14:08:02'!
PASSED!

!testRun: #MarsRoverTest #test04shouldMoveForwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 14:08:02'!
PASSED!

!testRun: #MarsRoverTest #test05shouldMoveForwardsPointingWestCorrectly stamp: 'LK 10/9/2023 14:08:02'!
PASSED!

!testRun: #MarsRoverTest #test06shouldMoveForwardsPointingEastCorrectly stamp: 'LK 10/9/2023 14:08:02'!
PASSED!

!testRun: #MarsRoverTest #test07shouldMoveBackwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 14:08:02'!
PASSED!

!testRun: #MarsRoverTest #test08shouldMoveBackwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 14:08:02'!
PASSED!

!testRun: #MarsRoverTest #test09shouldMoveBackwardsPointingEastCorrectly stamp: 'LK 10/9/2023 14:08:02'!
PASSED!

!testRun: #MarsRoverTest #test10shouldMoveBackwardsPointingWestCorrectly stamp: 'LK 10/9/2023 14:08:02'!
PASSED!

!testRun: #MarsRoverTest #test11shouldRotateRightPointingNorthCorrectly stamp: 'LK 10/9/2023 14:08:02'!
PASSED!

!testRun: #MarsRoverTest #test12shouldRotateRightPointingEastCorrectly stamp: 'LK 10/9/2023 14:08:02'!
PASSED!

!testRun: #MarsRoverTest #test13shouldRotateRightPointingSouthCorrectly stamp: 'LK 10/9/2023 14:08:02'!
PASSED!

!testRun: #MarsRoverTest #test14shouldRotateRightPointingWestCorrectly stamp: 'LK 10/9/2023 14:08:02'!
PASSED!

!testRun: #MarsRoverTest #test15shouldRotateLeftPointingNorthCorrectly stamp: 'LK 10/9/2023 14:08:02'!
PASSED!

!testRun: #MarsRoverTest #test16shouldRotateLeftPointingSouthCorrectly stamp: 'LK 10/9/2023 14:08:02'!
PASSED!

!testRun: #MarsRoverTest #test17shouldRotateLeftPointingEastCorrectly stamp: 'LK 10/9/2023 14:08:02'!
PASSED!

!testRun: #MarsRoverTest #test18shouldRotateLeftPointingWestCorrectly stamp: 'LK 10/9/2023 14:08:02'!
PASSED!

!testRun: #MarsRoverTest #test19shouldHandleMultipleCommands stamp: 'LK 10/9/2023 14:08:02'!
PASSED!

!testRun: #MarsRoverTest #test20shouldHandleInvalidCommand stamp: 'LK 10/9/2023 14:08:02'!
PASSED!

!testRun: #MarsRoverTest #test21shouldHandleCommandsUntilInvalidCommand stamp: 'LK 10/9/2023 14:08:02'!
ERROR!

!testRun: #MarsRoverTest #test21shouldHandleCommandsUntilInvalidCommand stamp: 'LK 10/9/2023 14:08:02'!
ERROR!

!testRun: #MarsRoverTest #test20shouldHandleInvalidCommand stamp: 'LK 10/9/2023 14:08:11'!
PASSED!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 14:08:17' prior: 50694124!
test20shouldHandleInvalidCommand

	|marsRover coordinate direction commands|
	
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'ds'. 
	
	self 
		should: [marsRover execute: commands]
		raise: Error
		withExceptionDo: [ :anError | 
			self assert: anError messageText = 'comando invalido'].
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 14:08:54' prior: 50694067!
test21shouldHandleCommandsUntilInvalidCommand

	|marsRover coordinate direction commands finalCoordinate |
	
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'fffpppf'. 
	finalCoordinate := 0@3.
	
	self 
		should: [marsRover execute: commands]
		raise: Error
		withExceptionDo: [ :anError | 
			self assert: anError messageText = 'comando invalido'].
	
	self assertMarsRover: marsRover shouldBeIn: finalCoordinate pointingTo: direction.
	

	! !

!testRun: #MarsRoverTest #test21shouldHandleCommandsUntilInvalidCommand stamp: 'LK 10/9/2023 14:08:55'!
PASSED!

!testRun: #MarsRoverTest #test01shouldInitializeInGivenCoordinateAndDirection stamp: 'LK 10/9/2023 14:08:55'!
PASSED!

!testRun: #MarsRoverTest #test02shouldDoNothingOnEmptyString stamp: 'LK 10/9/2023 14:08:55'!
PASSED!

!testRun: #MarsRoverTest #test03shouldMoveForwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 14:08:55'!
PASSED!

!testRun: #MarsRoverTest #test04shouldMoveForwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 14:08:55'!
PASSED!

!testRun: #MarsRoverTest #test05shouldMoveForwardsPointingWestCorrectly stamp: 'LK 10/9/2023 14:08:55'!
PASSED!

!testRun: #MarsRoverTest #test06shouldMoveForwardsPointingEastCorrectly stamp: 'LK 10/9/2023 14:08:55'!
PASSED!

!testRun: #MarsRoverTest #test07shouldMoveBackwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 14:08:55'!
PASSED!

!testRun: #MarsRoverTest #test08shouldMoveBackwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 14:08:55'!
PASSED!

!testRun: #MarsRoverTest #test09shouldMoveBackwardsPointingEastCorrectly stamp: 'LK 10/9/2023 14:08:55'!
PASSED!

!testRun: #MarsRoverTest #test10shouldMoveBackwardsPointingWestCorrectly stamp: 'LK 10/9/2023 14:08:55'!
PASSED!

!testRun: #MarsRoverTest #test11shouldRotateRightPointingNorthCorrectly stamp: 'LK 10/9/2023 14:08:55'!
PASSED!

!testRun: #MarsRoverTest #test12shouldRotateRightPointingEastCorrectly stamp: 'LK 10/9/2023 14:08:55'!
PASSED!

!testRun: #MarsRoverTest #test13shouldRotateRightPointingSouthCorrectly stamp: 'LK 10/9/2023 14:08:55'!
PASSED!

!testRun: #MarsRoverTest #test14shouldRotateRightPointingWestCorrectly stamp: 'LK 10/9/2023 14:08:55'!
PASSED!

!testRun: #MarsRoverTest #test15shouldRotateLeftPointingNorthCorrectly stamp: 'LK 10/9/2023 14:08:55'!
PASSED!

!testRun: #MarsRoverTest #test16shouldRotateLeftPointingSouthCorrectly stamp: 'LK 10/9/2023 14:08:55'!
PASSED!

!testRun: #MarsRoverTest #test17shouldRotateLeftPointingEastCorrectly stamp: 'LK 10/9/2023 14:08:55'!
PASSED!

!testRun: #MarsRoverTest #test18shouldRotateLeftPointingWestCorrectly stamp: 'LK 10/9/2023 14:08:55'!
PASSED!

!testRun: #MarsRoverTest #test19shouldHandleMultipleCommands stamp: 'LK 10/9/2023 14:08:55'!
PASSED!

!testRun: #MarsRoverTest #test20shouldHandleInvalidCommand stamp: 'LK 10/9/2023 14:08:55'!
PASSED!

!testRun: #MarsRoverTest #test21shouldHandleCommandsUntilInvalidCommand stamp: 'LK 10/9/2023 14:08:55'!
PASSED!
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 14:10:02' prior: 50694041!
executeChar: aSingleCommand
	
	(aSingleCommand = $f) ifTrue: [	^self commandForward].
	
	(aSingleCommand = $b) ifTrue: [^self commandBackward].
	
	(aSingleCommand = $r) ifTrue: [^	self commandRotateRight].
	
	(aSingleCommand = $l) ifTrue: [^self commandRotateLeft].
	
	self error: MarsRover errorInvalidCommand.
	
! !
!MarsRover class methodsFor: 'instance creation' stamp: 'LK 10/9/2023 14:10:17'!
errorInvalidCommand
	^'Command is invalid'.! !

!testRun: #MarsRoverTest #test20shouldHandleInvalidCommand stamp: 'LK 10/9/2023 14:10:21'!
FAILURE!

!testRun: #MarsRoverTest #test20shouldHandleInvalidCommand stamp: 'LK 10/9/2023 14:10:21'!
FAILURE!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 14:10:42' prior: 50694338!
test20shouldHandleInvalidCommand

	|marsRover coordinate direction commands|
	
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'ds'. 
	
	self 
		should: [marsRover execute: commands]
		raise: Error
		withExceptionDo: [ :anError | 
			self assert: anError messageText = MarsRover errorInvalidCommand].
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 14:10:55' prior: 50694353!
test21shouldHandleCommandsUntilInvalidCommand

	|marsRover coordinate direction commands finalCoordinate |
	
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'fffpppf'. 
	finalCoordinate := 0@3.
	
	self 
		should: [marsRover execute: commands]
		raise: Error
		withExceptionDo: [ :anError | 
			self assert: anError messageText = MarsRover errorInvalidCommand].
	
	self assertMarsRover: marsRover shouldBeIn: finalCoordinate pointingTo: direction.
	

	! !

!testRun: #MarsRoverTest #test21shouldHandleCommandsUntilInvalidCommand stamp: 'LK 10/9/2023 14:10:56'!
PASSED!

!testRun: #MarsRoverTest #test20shouldHandleInvalidCommand stamp: 'LK 10/9/2023 14:10:58'!
PASSED!

!testRun: #MarsRoverTest #test01shouldInitializeInGivenCoordinateAndDirection stamp: 'LK 10/9/2023 14:11:02'!
PASSED!

!testRun: #MarsRoverTest #test02shouldDoNothingOnEmptyString stamp: 'LK 10/9/2023 14:11:02'!
PASSED!

!testRun: #MarsRoverTest #test03shouldMoveForwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 14:11:02'!
PASSED!

!testRun: #MarsRoverTest #test04shouldMoveForwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 14:11:02'!
PASSED!

!testRun: #MarsRoverTest #test05shouldMoveForwardsPointingWestCorrectly stamp: 'LK 10/9/2023 14:11:02'!
PASSED!

!testRun: #MarsRoverTest #test06shouldMoveForwardsPointingEastCorrectly stamp: 'LK 10/9/2023 14:11:02'!
PASSED!

!testRun: #MarsRoverTest #test07shouldMoveBackwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 14:11:02'!
PASSED!

!testRun: #MarsRoverTest #test08shouldMoveBackwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 14:11:02'!
PASSED!

!testRun: #MarsRoverTest #test09shouldMoveBackwardsPointingEastCorrectly stamp: 'LK 10/9/2023 14:11:02'!
PASSED!

!testRun: #MarsRoverTest #test10shouldMoveBackwardsPointingWestCorrectly stamp: 'LK 10/9/2023 14:11:02'!
PASSED!

!testRun: #MarsRoverTest #test11shouldRotateRightPointingNorthCorrectly stamp: 'LK 10/9/2023 14:11:02'!
PASSED!

!testRun: #MarsRoverTest #test12shouldRotateRightPointingEastCorrectly stamp: 'LK 10/9/2023 14:11:02'!
PASSED!

!testRun: #MarsRoverTest #test13shouldRotateRightPointingSouthCorrectly stamp: 'LK 10/9/2023 14:11:02'!
PASSED!

!testRun: #MarsRoverTest #test14shouldRotateRightPointingWestCorrectly stamp: 'LK 10/9/2023 14:11:02'!
PASSED!

!testRun: #MarsRoverTest #test15shouldRotateLeftPointingNorthCorrectly stamp: 'LK 10/9/2023 14:11:02'!
PASSED!

!testRun: #MarsRoverTest #test16shouldRotateLeftPointingSouthCorrectly stamp: 'LK 10/9/2023 14:11:02'!
PASSED!

!testRun: #MarsRoverTest #test17shouldRotateLeftPointingEastCorrectly stamp: 'LK 10/9/2023 14:11:02'!
PASSED!

!testRun: #MarsRoverTest #test18shouldRotateLeftPointingWestCorrectly stamp: 'LK 10/9/2023 14:11:02'!
PASSED!

!testRun: #MarsRoverTest #test19shouldHandleMultipleCommands stamp: 'LK 10/9/2023 14:11:02'!
PASSED!

!testRun: #MarsRoverTest #test20shouldHandleInvalidCommand stamp: 'LK 10/9/2023 14:11:02'!
PASSED!

!testRun: #MarsRoverTest #test21shouldHandleCommandsUntilInvalidCommand stamp: 'LK 10/9/2023 14:11:02'!
PASSED!

!classRemoval: #Forward stamp: 'LK 10/9/2023 14:11:42'!
Command subclass: #Forward
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!

!classRemoval: #Backward stamp: 'LK 10/9/2023 14:11:43'!
Command subclass: #Backward
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!

!classRemoval: #RotateLeft stamp: 'LK 10/9/2023 14:11:43'!
Command subclass: #RotateLeft
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!

!classRemoval: #RotateRight stamp: 'LK 10/9/2023 14:11:43'!
Command subclass: #RotateRight
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!

!classRemoval: #Command stamp: 'LK 10/9/2023 14:11:43'!
Object subclass: #Command
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!

!testRun: #MarsRoverTest #test01shouldInitializeInGivenCoordinateAndDirection stamp: 'LK 10/9/2023 14:11:47'!
PASSED!

!testRun: #MarsRoverTest #test02shouldDoNothingOnEmptyString stamp: 'LK 10/9/2023 14:11:47'!
PASSED!

!testRun: #MarsRoverTest #test03shouldMoveForwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 14:11:47'!
PASSED!

!testRun: #MarsRoverTest #test04shouldMoveForwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 14:11:47'!
PASSED!

!testRun: #MarsRoverTest #test05shouldMoveForwardsPointingWestCorrectly stamp: 'LK 10/9/2023 14:11:47'!
PASSED!

!testRun: #MarsRoverTest #test06shouldMoveForwardsPointingEastCorrectly stamp: 'LK 10/9/2023 14:11:47'!
PASSED!

!testRun: #MarsRoverTest #test07shouldMoveBackwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 14:11:47'!
PASSED!

!testRun: #MarsRoverTest #test08shouldMoveBackwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 14:11:47'!
PASSED!

!testRun: #MarsRoverTest #test09shouldMoveBackwardsPointingEastCorrectly stamp: 'LK 10/9/2023 14:11:47'!
PASSED!

!testRun: #MarsRoverTest #test10shouldMoveBackwardsPointingWestCorrectly stamp: 'LK 10/9/2023 14:11:47'!
PASSED!

!testRun: #MarsRoverTest #test11shouldRotateRightPointingNorthCorrectly stamp: 'LK 10/9/2023 14:11:47'!
PASSED!

!testRun: #MarsRoverTest #test12shouldRotateRightPointingEastCorrectly stamp: 'LK 10/9/2023 14:11:47'!
PASSED!

!testRun: #MarsRoverTest #test13shouldRotateRightPointingSouthCorrectly stamp: 'LK 10/9/2023 14:11:47'!
PASSED!

!testRun: #MarsRoverTest #test14shouldRotateRightPointingWestCorrectly stamp: 'LK 10/9/2023 14:11:47'!
PASSED!

!testRun: #MarsRoverTest #test15shouldRotateLeftPointingNorthCorrectly stamp: 'LK 10/9/2023 14:11:47'!
PASSED!

!testRun: #MarsRoverTest #test16shouldRotateLeftPointingSouthCorrectly stamp: 'LK 10/9/2023 14:11:47'!
PASSED!

!testRun: #MarsRoverTest #test17shouldRotateLeftPointingEastCorrectly stamp: 'LK 10/9/2023 14:11:47'!
PASSED!

!testRun: #MarsRoverTest #test18shouldRotateLeftPointingWestCorrectly stamp: 'LK 10/9/2023 14:11:47'!
PASSED!

!testRun: #MarsRoverTest #test19shouldHandleMultipleCommands stamp: 'LK 10/9/2023 14:11:47'!
PASSED!

!testRun: #MarsRoverTest #test20shouldHandleInvalidCommand stamp: 'LK 10/9/2023 14:11:47'!
PASSED!

!testRun: #MarsRoverTest #test21shouldHandleCommandsUntilInvalidCommand stamp: 'LK 10/9/2023 14:11:47'!
PASSED!

Object subclass: #CommandHandler
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!

!classDefinition: #CommandHandler category: 'Mars Rover- Exercise' stamp: 'LK 10/9/2023 15:13:16'!
Object subclass: #CommandHandler
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!

CommandHandler subclass: #Forward
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!

!classDefinition: #Forward category: 'Mars Rover- Exercise' stamp: 'LK 10/9/2023 15:13:51'!
CommandHandler subclass: #Forward
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!

CommandHandler subclass: #Backward
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!

!classDefinition: #Backward category: 'Mars Rover- Exercise' stamp: 'LK 10/9/2023 15:13:55'!
CommandHandler subclass: #Backward
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!

CommandHandler subclass: #RotateLeft
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!

!classDefinition: #RotateLeft category: 'Mars Rover- Exercise' stamp: 'LK 10/9/2023 15:14:00'!
CommandHandler subclass: #RotateLeft
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!

CommandHandler subclass: #RotateRight
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!

!classDefinition: #RotateRight category: 'Mars Rover- Exercise' stamp: 'LK 10/9/2023 15:14:05'!
CommandHandler subclass: #RotateRight
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!
!CommandHandler class methodsFor: 'nil' stamp: 'LK 10/9/2023 15:14:33'!
canHandle: aChar
! !
!Forward class methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 15:14:37' overrides: 50694751!
canHandle: aChar
! !
!Backward class methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 15:14:37' overrides: 50694751!
canHandle: aChar
! !
!RotateLeft class methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 15:14:37' overrides: 50694751!
canHandle: aChar
! !
!RotateRight class methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 15:14:37' overrides: 50694751!
canHandle: aChar
! !
!CommandHandler class methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 15:14:37' prior: 50694751!
canHandle: aChar

	self subclassResponsibility! !
!Backward class methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 15:14:49' prior: 50694759 overrides: 50694771!
canHandle: aChar
	^aChar = $b.! !
!Forward class methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 15:15:05' prior: 50694755 overrides: 50694771!
canHandle: aChar
	^aChar = $f.
! !
!RotateLeft class methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 15:15:18' prior: 50694763 overrides: 50694771!
canHandle: aChar
	^aChar = $l.! !
!RotateRight class methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 15:15:27' prior: 50694767 overrides: 50694771!
canHandle: aChar
	^aChar = $r! !
!CommandHandler class methodsFor: 'nil' stamp: 'LK 10/9/2023 15:19:23'!
with: aChar

	^(CommandHandler allSubclasses detect: [:aClass | aClass canHandle: aChar])! !
!CommandHandler class methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 15:19:48' prior: 50694796!
with: aChar

	^(CommandHandler allSubclasses detect: [:aClass | aClass canHandle: aChar]) new! !
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 15:25:27' prior: 50694449!
executeChar: aSingleCommand
	
	
	(aSingleCommand = $f) ifTrue: [	^self commandForward].
	
	(aSingleCommand = $b) ifTrue: [^self commandBackward].
	
	(aSingleCommand = $r) ifTrue: [^	self commandRotateRight].
	
	(aSingleCommand = $l) ifTrue: [^self commandRotateLeft].
	
	self error: MarsRover errorInvalidCommand.
	
! !
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 15:26:40' prior: 50694809!
executeChar: aSingleCommand
	
	|handler|
	
	handler := (CommandHandler with: aSingleCommand).
	
	(handler execute: self).
	
	
	(aSingleCommand = $f) ifTrue: [	^self commandForward].
	
	(aSingleCommand = $b) ifTrue: [^self commandBackward].
	
	(aSingleCommand = $r) ifTrue: [^	self commandRotateRight].
	
	(aSingleCommand = $l) ifTrue: [^self commandRotateLeft].
	
	self error: MarsRover errorInvalidCommand.
	
! !
!CommandHandler methodsFor: 'nil' stamp: 'LK 10/9/2023 15:27:24'!
excute: aMarsRover
	! !
!CommandHandler methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 15:27:34'!
execute: aMarsRover
	! !

!methodRemoval: CommandHandler #excute: stamp: 'LK 10/9/2023 15:27:35'!
excute: aMarsRover
	!
!Forward methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 15:27:40' overrides: 50694841!
execute: aMarsRover
	! !
!Backward methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 15:27:40' overrides: 50694841!
execute: aMarsRover
	! !
!RotateLeft methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 15:27:40' overrides: 50694841!
execute: aMarsRover
	! !
!RotateRight methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 15:27:41' overrides: 50694841!
execute: aMarsRover
	! !
!CommandHandler methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 15:27:41' prior: 50694841!
execute: aMarsRover

	self subclassResponsibility! !
!Backward methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 15:28:08' prior: 50694852 overrides: 50694864!
execute: aMarsRover
	aMarsRover commandBackward! !
!Forward methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 15:28:18' prior: 50694848 overrides: 50694864!
execute: aMarsRover
	aMarsRover commandForward
	! !
!RotateLeft methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 15:28:35' prior: 50694856 overrides: 50694864!
execute: aMarsRover
	aMarsRover commandRotateLeft! !
!RotateRight methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 15:28:51' prior: 50694860 overrides: 50694864!
execute: aMarsRover
	aMarsRover commandRotateRight ! !
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 15:29:49' prior: 50694822!
executeChar: aSingleCommand
	
	|handler|
	
	handler := (CommandHandler with: aSingleCommand).
	
	(handler execute: self).
	"
	(aSingleCommand = $f) ifTrue: [	^self commandForward].
	
	(aSingleCommand = $b) ifTrue: [^self commandBackward].
	
	(aSingleCommand = $r) ifTrue: [^	self commandRotateRight].
	
	(aSingleCommand = $l) ifTrue: [^self commandRotateLeft].
	
	self error: MarsRover errorInvalidCommand.
	
"! !

!testRun: #MarsRoverTest #test01shouldInitializeInGivenCoordinateAndDirection stamp: 'LK 10/9/2023 15:29:52'!
PASSED!

!testRun: #MarsRoverTest #test02shouldDoNothingOnEmptyString stamp: 'LK 10/9/2023 15:29:54'!
PASSED!

!testRun: #MarsRoverTest #test03shouldMoveForwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 15:29:55'!
PASSED!

!testRun: #MarsRoverTest #test04shouldMoveForwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 15:29:57'!
PASSED!

!testRun: #MarsRoverTest #test05shouldMoveForwardsPointingWestCorrectly stamp: 'LK 10/9/2023 15:29:59'!
PASSED!

!testRun: #MarsRoverTest #test06shouldMoveForwardsPointingEastCorrectly stamp: 'LK 10/9/2023 15:30:00'!
PASSED!

!testRun: #MarsRoverTest #test07shouldMoveBackwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 15:30:02'!
PASSED!

!testRun: #MarsRoverTest #test19shouldHandleMultipleCommands stamp: 'LK 10/9/2023 15:30:06'!
PASSED!

!testRun: #MarsRoverTest #test20shouldHandleInvalidCommand stamp: 'LK 10/9/2023 15:30:07'!
FAILURE!

!testRun: #MarsRoverTest #test20shouldHandleInvalidCommand stamp: 'LK 10/9/2023 15:30:07'!
FAILURE!

!testRun: #MarsRoverTest #test20shouldHandleInvalidCommand stamp: 'LK 10/9/2023 15:30:14'!
FAILURE!

!testRun: #MarsRoverTest #test20shouldHandleInvalidCommand stamp: 'LK 10/9/2023 15:30:14'!
FAILURE!
!CommandHandler class methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 15:31:19' prior: 50694803!
with: aChar

	^(CommandHandler allSubclasses detect: [:aClass | aClass canHandle: aChar] ifNone:[^MarsRover errorInvalidCommand]) new! !

!testRun: #MarsRoverTest #test20shouldHandleInvalidCommand stamp: 'LK 10/9/2023 15:31:23'!
FAILURE!

!testRun: #MarsRoverTest #test20shouldHandleInvalidCommand stamp: 'LK 10/9/2023 15:31:23'!
FAILURE!
!CommandHandler class methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 15:32:03' prior: 50694950!
with: aChar

	^(CommandHandler allSubclasses detect: [:aClass | aClass canHandle: aChar] ifNone:[^(MarsRover new) errorInvalidCommand]) new! !

!testRun: #MarsRoverTest #test20shouldHandleInvalidCommand stamp: 'LK 10/9/2023 15:32:08'!
FAILURE!

!testRun: #MarsRoverTest #test20shouldHandleInvalidCommand stamp: 'LK 10/9/2023 15:32:08'!
FAILURE!

!testRun: #MarsRoverTest #test21shouldHandleCommandsUntilInvalidCommand stamp: 'LK 10/9/2023 15:32:28'!
FAILURE!
!CommandHandler class methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 15:33:12' prior: 50694964!
with: aChar

	^(CommandHandler allSubclasses detect: [:aClass | aClass canHandle: aChar] ifNone:[self error: 'comando invalido']) new! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 15:33:26' prior: 50694473!
test20shouldHandleInvalidCommand

	|marsRover coordinate direction commands|
	
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'ds'. 
	
	self 
		should: [marsRover execute: commands]
		raise: Error
		withExceptionDo: [ :anError | 
			self assert: anError messageText = 'comando invalido'].
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 15:33:39' prior: 50694488!
test21shouldHandleCommandsUntilInvalidCommand

	|marsRover coordinate direction commands finalCoordinate |
	
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'fffpppf'. 
	finalCoordinate := 0@3.
	
	self 
		should: [marsRover execute: commands]
		raise: Error
		withExceptionDo: [ :anError | 
			self assert: anError messageText = 'comando invalido'].
	
	self assertMarsRover: marsRover shouldBeIn: finalCoordinate pointingTo: direction.
	

	! !

!testRun: #MarsRoverTest #test01shouldInitializeInGivenCoordinateAndDirection stamp: 'LK 10/9/2023 15:33:40'!
PASSED!

!testRun: #MarsRoverTest #test02shouldDoNothingOnEmptyString stamp: 'LK 10/9/2023 15:33:40'!
PASSED!

!testRun: #MarsRoverTest #test03shouldMoveForwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 15:33:40'!
PASSED!

!testRun: #MarsRoverTest #test04shouldMoveForwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 15:33:40'!
PASSED!

!testRun: #MarsRoverTest #test05shouldMoveForwardsPointingWestCorrectly stamp: 'LK 10/9/2023 15:33:40'!
PASSED!

!testRun: #MarsRoverTest #test06shouldMoveForwardsPointingEastCorrectly stamp: 'LK 10/9/2023 15:33:40'!
PASSED!

!testRun: #MarsRoverTest #test07shouldMoveBackwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 15:33:40'!
PASSED!

!testRun: #MarsRoverTest #test08shouldMoveBackwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 15:33:40'!
PASSED!

!testRun: #MarsRoverTest #test09shouldMoveBackwardsPointingEastCorrectly stamp: 'LK 10/9/2023 15:33:40'!
PASSED!

!testRun: #MarsRoverTest #test10shouldMoveBackwardsPointingWestCorrectly stamp: 'LK 10/9/2023 15:33:40'!
PASSED!

!testRun: #MarsRoverTest #test11shouldRotateRightPointingNorthCorrectly stamp: 'LK 10/9/2023 15:33:40'!
PASSED!

!testRun: #MarsRoverTest #test12shouldRotateRightPointingEastCorrectly stamp: 'LK 10/9/2023 15:33:40'!
PASSED!

!testRun: #MarsRoverTest #test13shouldRotateRightPointingSouthCorrectly stamp: 'LK 10/9/2023 15:33:40'!
PASSED!

!testRun: #MarsRoverTest #test14shouldRotateRightPointingWestCorrectly stamp: 'LK 10/9/2023 15:33:40'!
PASSED!

!testRun: #MarsRoverTest #test15shouldRotateLeftPointingNorthCorrectly stamp: 'LK 10/9/2023 15:33:40'!
PASSED!

!testRun: #MarsRoverTest #test16shouldRotateLeftPointingSouthCorrectly stamp: 'LK 10/9/2023 15:33:40'!
PASSED!

!testRun: #MarsRoverTest #test17shouldRotateLeftPointingEastCorrectly stamp: 'LK 10/9/2023 15:33:40'!
PASSED!

!testRun: #MarsRoverTest #test18shouldRotateLeftPointingWestCorrectly stamp: 'LK 10/9/2023 15:33:40'!
PASSED!

!testRun: #MarsRoverTest #test19shouldHandleMultipleCommands stamp: 'LK 10/9/2023 15:33:40'!
PASSED!

!testRun: #MarsRoverTest #test20shouldHandleInvalidCommand stamp: 'LK 10/9/2023 15:33:40'!
PASSED!

!testRun: #MarsRoverTest #test21shouldHandleCommandsUntilInvalidCommand stamp: 'LK 10/9/2023 15:33:40'!
PASSED!
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 15:33:55' prior: 50694893!
executeChar: aSingleCommand
	
	|handler|
	
	handler := (CommandHandler with: aSingleCommand).
	
	(handler execute: self).
	
	"
	(aSingleCommand = $f) ifTrue: [	^self commandForward].
	
	(aSingleCommand = $b) ifTrue: [^self commandBackward].
	
	(aSingleCommand = $r) ifTrue: [^	self commandRotateRight].
	
	(aSingleCommand = $l) ifTrue: [^self commandRotateLeft].
	
	self error: MarsRover errorInvalidCommand.
	
"! !

!testRun: #MarsRoverTest #test01shouldInitializeInGivenCoordinateAndDirection stamp: 'LK 10/9/2023 15:34:36'!
PASSED!

!testRun: #MarsRoverTest #test02shouldDoNothingOnEmptyString stamp: 'LK 10/9/2023 15:34:36'!
PASSED!

!testRun: #MarsRoverTest #test03shouldMoveForwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 15:34:36'!
PASSED!

!testRun: #MarsRoverTest #test04shouldMoveForwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 15:34:36'!
PASSED!

!testRun: #MarsRoverTest #test05shouldMoveForwardsPointingWestCorrectly stamp: 'LK 10/9/2023 15:34:36'!
PASSED!

!testRun: #MarsRoverTest #test06shouldMoveForwardsPointingEastCorrectly stamp: 'LK 10/9/2023 15:34:36'!
PASSED!

!testRun: #MarsRoverTest #test07shouldMoveBackwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 15:34:36'!
PASSED!

!testRun: #MarsRoverTest #test08shouldMoveBackwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 15:34:36'!
PASSED!

!testRun: #MarsRoverTest #test09shouldMoveBackwardsPointingEastCorrectly stamp: 'LK 10/9/2023 15:34:36'!
PASSED!

!testRun: #MarsRoverTest #test10shouldMoveBackwardsPointingWestCorrectly stamp: 'LK 10/9/2023 15:34:36'!
PASSED!

!testRun: #MarsRoverTest #test11shouldRotateRightPointingNorthCorrectly stamp: 'LK 10/9/2023 15:34:36'!
PASSED!

!testRun: #MarsRoverTest #test12shouldRotateRightPointingEastCorrectly stamp: 'LK 10/9/2023 15:34:36'!
PASSED!

!testRun: #MarsRoverTest #test13shouldRotateRightPointingSouthCorrectly stamp: 'LK 10/9/2023 15:34:36'!
PASSED!

!testRun: #MarsRoverTest #test14shouldRotateRightPointingWestCorrectly stamp: 'LK 10/9/2023 15:34:36'!
PASSED!

!testRun: #MarsRoverTest #test15shouldRotateLeftPointingNorthCorrectly stamp: 'LK 10/9/2023 15:34:36'!
PASSED!

!testRun: #MarsRoverTest #test16shouldRotateLeftPointingSouthCorrectly stamp: 'LK 10/9/2023 15:34:36'!
PASSED!

!testRun: #MarsRoverTest #test17shouldRotateLeftPointingEastCorrectly stamp: 'LK 10/9/2023 15:34:36'!
PASSED!

!testRun: #MarsRoverTest #test18shouldRotateLeftPointingWestCorrectly stamp: 'LK 10/9/2023 15:34:36'!
PASSED!

!testRun: #MarsRoverTest #test19shouldHandleMultipleCommands stamp: 'LK 10/9/2023 15:34:36'!
PASSED!

!testRun: #MarsRoverTest #test20shouldHandleInvalidCommand stamp: 'LK 10/9/2023 15:34:36'!
PASSED!

!testRun: #MarsRoverTest #test21shouldHandleCommandsUntilInvalidCommand stamp: 'LK 10/9/2023 15:34:36'!
PASSED!
!MarsRover methodsFor: 'private' stamp: 'LK 10/9/2023 15:39:56' prior: 50689510 overrides: 16901507!
at: aPosition

	^position = aPosition.! !
!CommandHandler class methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 15:41:40' prior: 50694982!
with: aChar

	^(CommandHandler allSubclasses detect: [:aClass | aClass canHandle: aChar] ifNone:[^MarsRover errorInvalidCommand]) new! !

!testRun: #MarsRoverTest #test20shouldHandleInvalidCommand stamp: 'LK 10/9/2023 15:42:02'!
FAILURE!

!testRun: #MarsRoverTest #test20shouldHandleInvalidCommand stamp: 'LK 10/9/2023 15:42:02'!
FAILURE!
!CommandHandler class methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 15:42:25' prior: 50695192!
with: aChar

	^(CommandHandler allSubclasses detect: [:aClass | aClass canHandle: aChar] ifNone:[^'comando invalido']) new! !

!testRun: #MarsRoverTest #test01shouldInitializeInGivenCoordinateAndDirection stamp: 'LK 10/9/2023 15:42:29'!
PASSED!

!testRun: #MarsRoverTest #test02shouldDoNothingOnEmptyString stamp: 'LK 10/9/2023 15:42:29'!
PASSED!

!testRun: #MarsRoverTest #test03shouldMoveForwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 15:42:29'!
PASSED!

!testRun: #MarsRoverTest #test04shouldMoveForwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 15:42:29'!
PASSED!

!testRun: #MarsRoverTest #test05shouldMoveForwardsPointingWestCorrectly stamp: 'LK 10/9/2023 15:42:29'!
PASSED!

!testRun: #MarsRoverTest #test06shouldMoveForwardsPointingEastCorrectly stamp: 'LK 10/9/2023 15:42:29'!
PASSED!

!testRun: #MarsRoverTest #test07shouldMoveBackwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 15:42:29'!
PASSED!

!testRun: #MarsRoverTest #test08shouldMoveBackwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 15:42:29'!
PASSED!

!testRun: #MarsRoverTest #test09shouldMoveBackwardsPointingEastCorrectly stamp: 'LK 10/9/2023 15:42:29'!
PASSED!

!testRun: #MarsRoverTest #test10shouldMoveBackwardsPointingWestCorrectly stamp: 'LK 10/9/2023 15:42:29'!
PASSED!

!testRun: #MarsRoverTest #test11shouldRotateRightPointingNorthCorrectly stamp: 'LK 10/9/2023 15:42:29'!
PASSED!

!testRun: #MarsRoverTest #test12shouldRotateRightPointingEastCorrectly stamp: 'LK 10/9/2023 15:42:29'!
PASSED!

!testRun: #MarsRoverTest #test13shouldRotateRightPointingSouthCorrectly stamp: 'LK 10/9/2023 15:42:29'!
PASSED!

!testRun: #MarsRoverTest #test14shouldRotateRightPointingWestCorrectly stamp: 'LK 10/9/2023 15:42:29'!
PASSED!

!testRun: #MarsRoverTest #test15shouldRotateLeftPointingNorthCorrectly stamp: 'LK 10/9/2023 15:42:29'!
PASSED!

!testRun: #MarsRoverTest #test16shouldRotateLeftPointingSouthCorrectly stamp: 'LK 10/9/2023 15:42:29'!
PASSED!

!testRun: #MarsRoverTest #test17shouldRotateLeftPointingEastCorrectly stamp: 'LK 10/9/2023 15:42:29'!
PASSED!

!testRun: #MarsRoverTest #test18shouldRotateLeftPointingWestCorrectly stamp: 'LK 10/9/2023 15:42:29'!
PASSED!

!testRun: #MarsRoverTest #test19shouldHandleMultipleCommands stamp: 'LK 10/9/2023 15:42:29'!
PASSED!

!testRun: #MarsRoverTest #test20shouldHandleInvalidCommand stamp: 'LK 10/9/2023 15:42:29'!
FAILURE!

!testRun: #MarsRoverTest #test21shouldHandleCommandsUntilInvalidCommand stamp: 'LK 10/9/2023 15:42:29'!
FAILURE!
!CommandHandler class methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 15:33:12' prior: 50695206!
with: aChar

	^(CommandHandler allSubclasses detect: [:aClass | aClass canHandle: aChar] ifNone:[self error: 'comando invalido']) new! !

!testRun: #MarsRoverTest #test01shouldInitializeInGivenCoordinateAndDirection stamp: 'LK 10/9/2023 15:42:57'!
PASSED!

!testRun: #MarsRoverTest #test02shouldDoNothingOnEmptyString stamp: 'LK 10/9/2023 15:42:57'!
PASSED!

!testRun: #MarsRoverTest #test03shouldMoveForwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 15:42:57'!
PASSED!

!testRun: #MarsRoverTest #test04shouldMoveForwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 15:42:57'!
PASSED!

!testRun: #MarsRoverTest #test05shouldMoveForwardsPointingWestCorrectly stamp: 'LK 10/9/2023 15:42:57'!
PASSED!

!testRun: #MarsRoverTest #test06shouldMoveForwardsPointingEastCorrectly stamp: 'LK 10/9/2023 15:42:57'!
PASSED!

!testRun: #MarsRoverTest #test07shouldMoveBackwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 15:42:57'!
PASSED!

!testRun: #MarsRoverTest #test08shouldMoveBackwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 15:42:57'!
PASSED!

!testRun: #MarsRoverTest #test09shouldMoveBackwardsPointingEastCorrectly stamp: 'LK 10/9/2023 15:42:57'!
PASSED!

!testRun: #MarsRoverTest #test10shouldMoveBackwardsPointingWestCorrectly stamp: 'LK 10/9/2023 15:42:57'!
PASSED!

!testRun: #MarsRoverTest #test11shouldRotateRightPointingNorthCorrectly stamp: 'LK 10/9/2023 15:42:57'!
PASSED!

!testRun: #MarsRoverTest #test12shouldRotateRightPointingEastCorrectly stamp: 'LK 10/9/2023 15:42:57'!
PASSED!

!testRun: #MarsRoverTest #test13shouldRotateRightPointingSouthCorrectly stamp: 'LK 10/9/2023 15:42:57'!
PASSED!

!testRun: #MarsRoverTest #test14shouldRotateRightPointingWestCorrectly stamp: 'LK 10/9/2023 15:42:57'!
PASSED!

!testRun: #MarsRoverTest #test15shouldRotateLeftPointingNorthCorrectly stamp: 'LK 10/9/2023 15:42:57'!
PASSED!

!testRun: #MarsRoverTest #test16shouldRotateLeftPointingSouthCorrectly stamp: 'LK 10/9/2023 15:42:57'!
PASSED!

!testRun: #MarsRoverTest #test17shouldRotateLeftPointingEastCorrectly stamp: 'LK 10/9/2023 15:42:57'!
PASSED!

!testRun: #MarsRoverTest #test18shouldRotateLeftPointingWestCorrectly stamp: 'LK 10/9/2023 15:42:57'!
PASSED!

!testRun: #MarsRoverTest #test19shouldHandleMultipleCommands stamp: 'LK 10/9/2023 15:42:57'!
PASSED!

!testRun: #MarsRoverTest #test20shouldHandleInvalidCommand stamp: 'LK 10/9/2023 15:42:57'!
PASSED!

!testRun: #MarsRoverTest #test21shouldHandleCommandsUntilInvalidCommand stamp: 'LK 10/9/2023 15:42:57'!
PASSED!

----QUIT----(9 October 2023 15:43:38) CuisUniversity-5981.image priorSource: 11449020!

----STARTUP---- (9 October 2023 19:43:28) as C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\CuisUniversity-5981.image!

!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 19:44:56' prior: 50695097!
executeChar: aSingleCommand
	
	|handler|
	
	handler := (CommandHandler with: aSingleCommand).
	
	handler execute: self.! !
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 19:44:57' prior: 50695374!
executeChar: aSingleCommand
	
	|handler|
	
	handler := (CommandHandler with: aSingleCommand).
	
	handler execute: self! !

----End fileIn of C:\Users\lucas\OneDrive\Desktop\Portfolio-Ejercicio.st----!

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'LK 10/9/2023 20:38:34'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'LK 10/9/2023 20:39:22'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'LK 10/9/2023 20:39:24'!
FAILURE!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'LK 10/9/2023 20:39:24'!
FAILURE!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'LK 10/9/2023 20:39:29'!
FAILURE!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'LK 10/9/2023 20:39:33'!
PASSED!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'LK 10/9/2023 20:39:35'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'LK 10/9/2023 20:39:37'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'LK 10/9/2023 20:39:40'!
PASSED!
!Withdraw methodsFor: 'value' stamp: 'LK 10/9/2023 20:41:43' prior: 50695556 overrides: 50695485!
value

	^  value negative ! !

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'LK 10/9/2023 20:41:47'!
ERROR!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'LK 10/9/2023 20:41:47'!
ERROR!
!ReceptiveAccount methodsFor: 'balance' stamp: 'LK 10/9/2023 21:17:08' prior: 50695600!
balance

	| sum|
	
	sum := 0.
	transactions do: [ :aTransaction | (aTransaction isKindOf: Deposit) ifTrue: [sum := sum + aTransaction value] 
					ifFalse: [sum := sum - aTransaction value]].
					
	^sum! !

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'LK 10/9/2023 21:17:12'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'LK 10/9/2023 21:17:12'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'LK 10/9/2023 21:17:13'!
ERROR!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'LK 10/9/2023 21:17:13'!
FAILURE!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'LK 10/9/2023 21:17:13'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'LK 10/9/2023 21:17:13'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'LK 10/9/2023 21:17:13'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'LK 10/9/2023 21:17:39'!
ERROR!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'LK 10/9/2023 21:17:39'!
ERROR!

East new = East new!

East new class = East new class!

----QUIT----(9 October 2023 21:42:29) CuisUniversity-5981.image priorSource: 11638928!

----STARTUP---- (14 October 2023 18:57:56) as C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\CuisUniversity-5981.image!


----End fileIn of C:\Users\lucas\OneDrive\Desktop\Portfolio-Ejercicio (1).st----!

!testRun: #PortfolioTest #test03OneAccountWithOneTransaction stamp: 'LK 10/14/2023 19:04:18'!
PASSED!

!testRun: #PortfolioTest #test01EmptyPortfolioZeroTransactions stamp: 'LK 10/14/2023 19:04:18'!
PASSED!

!testRun: #PortfolioTest #test02OneAccountWithoutTransactions stamp: 'LK 10/14/2023 19:04:18'!
PASSED!

!testRun: #PortfolioTest #test03OneAccountWithOneTransaction stamp: 'LK 10/14/2023 19:04:18'!
PASSED!

!testRun: #PortfolioTest #test04PortfolioHasARegisteredTransaction stamp: 'LK 10/14/2023 19:04:18'!
PASSED!

----STARTUP---- (19 October 2023 14:10:51) as C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\CuisUniversity-5981.image!


----End fileIn of C:\Users\lucas\OneDrive\Desktop\Portfolio-Ejercicio.st----!

!testRun: #PortfolioTest #test10 stamp: 'LK 10/19/2023 14:25:57'!
PASSED!

!testRun: #PortfolioTest #test01newPortfolioHasZeroBalance stamp: 'LK 10/19/2023 14:25:57'!
PASSED!

!testRun: #PortfolioTest #test02portfolioBalanceIsTheSumOfEachAccountBalance stamp: 'LK 10/19/2023 14:25:58'!
PASSED!

!testRun: #PortfolioTest #test03portfolioBalanceIsTheSumOfAccountsAndPortfoliosBalances stamp: 'LK 10/19/2023 14:25:58'!
PASSED!

!testRun: #PortfolioTest #test04newPortfolioWithoutRegisteredTransactions stamp: 'LK 10/19/2023 14:25:58'!
PASSED!

!testRun: #PortfolioTest #test05portfolioWithAccountsCheckTransaction stamp: 'LK 10/19/2023 14:25:58'!
PASSED!

!testRun: #PortfolioTest #test06portfolioWithAccountsAndPortfoliosCheckTransaction stamp: 'LK 10/19/2023 14:25:58'!
PASSED!

!testRun: #PortfolioTest #test07newPortfolioHasNoTransactions stamp: 'LK 10/19/2023 14:25:58'!
PASSED!

!testRun: #PortfolioTest #test08portfolioWithAccountsTransactions stamp: 'LK 10/19/2023 14:25:58'!
PASSED!

!testRun: #PortfolioTest #test09portfolioWithAccountsAndPortfoliosTransactions stamp: 'LK 10/19/2023 14:25:58'!
PASSED!

!testRun: #PortfolioTest #test10 stamp: 'LK 10/19/2023 14:25:58'!
PASSED!

!testRun: #PortfolioTest #test11 stamp: 'LK 10/19/2023 14:25:58'!
PASSED!

!testRun: #PortfolioTest #test12 stamp: 'LK 10/19/2023 14:25:58'!
PASSED!

!testRun: #PortfolioTest #test13 stamp: 'LK 10/19/2023 14:25:58'!
FAILURE!

!testRun: #PortfolioTest #test13 stamp: 'LK 10/19/2023 14:25:58'!
FAILURE!

!testRun: #PortfolioTest #test10 stamp: 'LK 10/19/2023 14:26:05'!
PASSED!

PortfolioTree subclass: #TransactionContainer
	instanceVariableNames: 'accounts portfolios'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classDefinition: #TransactionContainer category: 'Portfolio-Ejercicio' stamp: 'LK 10/19/2023 14:41:13'!
PortfolioTree subclass: #TransactionContainer
	instanceVariableNames: 'accounts portfolios'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

----QUIT----(19 October 2023 15:26:13) CuisUniversity-5981.image priorSource: 11649699!

----STARTUP---- (19 October 2023 19:48:24) as C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\CuisUniversity-5981.image!


----End fileIn of C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\repo\isw1\06-Portfolio1\Portfolio-Ejercicio.st----!

!classRemoval: #TransactionContainer stamp: 'LK 10/19/2023 19:48:59'!
PortfolioTree subclass: #TransactionContainer
	instanceVariableNames: 'accounts portfolios'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classRemoval: #ReceptiveAccount stamp: 'LK 10/19/2023 19:49:00'!
PortfolioTree subclass: #ReceptiveAccount
	instanceVariableNames: 'transactions'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classRemoval: #Portfolio stamp: 'LK 10/19/2023 19:49:00'!
PortfolioTree subclass: #Portfolio
	instanceVariableNames: 'childrenNodes'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classRemoval: #PortfolioTree stamp: 'LK 10/19/2023 19:49:01'!
Object subclass: #PortfolioTree
	instanceVariableNames: 'parentNode'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classRemoval: #Withdraw stamp: 'LK 10/19/2023 19:49:01'!
AccountTransaction subclass: #Withdraw
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classRemoval: #Deposit stamp: 'LK 10/19/2023 19:49:02'!
AccountTransaction subclass: #Deposit
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classRemoval: #AccountTransaction stamp: 'LK 10/19/2023 19:49:02'!
Object subclass: #AccountTransaction
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classRemoval: #ReceptiveAccountTest stamp: 'LK 10/19/2023 19:49:02'!
TestCase subclass: #ReceptiveAccountTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classRemoval: #PortfolioTest stamp: 'LK 10/19/2023 19:49:03'!
TestCase subclass: #PortfolioTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

----End fileIn of C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\repo\isw1\06-Portfolio1\Portfolio-Ejercicio.st----!

!classRemoval: #ReceptiveAccount stamp: 'LK 10/19/2023 21:14:32'!
PortfolioTree subclass: #ReceptiveAccount
	instanceVariableNames: 'transactions'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classRemoval: #Portfolio stamp: 'LK 10/19/2023 21:14:33'!
PortfolioTree subclass: #Portfolio
	instanceVariableNames: 'childrenNodes'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classRemoval: #PortfolioTree stamp: 'LK 10/19/2023 21:14:33'!
Object subclass: #PortfolioTree
	instanceVariableNames: 'parentNode'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classRemoval: #Withdraw stamp: 'LK 10/19/2023 21:14:34'!
AccountTransaction subclass: #Withdraw
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classRemoval: #Deposit stamp: 'LK 10/19/2023 21:14:34'!
AccountTransaction subclass: #Deposit
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classRemoval: #AccountTransaction stamp: 'LK 10/19/2023 21:14:34'!
Object subclass: #AccountTransaction
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classRemoval: #ReceptiveAccountTest stamp: 'LK 10/19/2023 21:14:35'!
TestCase subclass: #ReceptiveAccountTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

!classRemoval: #PortfolioTest stamp: 'LK 10/19/2023 21:14:35'!
TestCase subclass: #PortfolioTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Ejercicio'!

----End fileIn of C:\Users\lucas\OneDrive\Desktop\Portfolio-Solucion.st----!

TestCase subclass: #XXXTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #XXXTest category: 'Portfolio-Solucion' stamp: 'LK 10/19/2023 21:19:20'!
TestCase subclass: #XXXTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!
!XXXTest methodsFor: 'no messages' stamp: 'LK 10/19/2023 21:23:42'!
test01
	| receivingAccount transferingAccount |
	
	receivingAccount := ReceptiveAccount new. transferingAccount := ReceptiveAccount new.
	
	transferingAccount transfer: 50 to: receivingAccount .
! !
!XXXTest methodsFor: 'as yet unclassified' stamp: 'LK 10/19/2023 21:23:45' prior: 50698822!
test01
	| receivingAccount transferingAccount |
	
	receivingAccount := ReceptiveAccount new. 
	transferingAccount := ReceptiveAccount new.
	
	transferingAccount transfer: 50 to: receivingAccount .
! !
!ReceptiveAccount methodsFor: 'transactions' stamp: 'LK 10/19/2023 21:27:59'!
transfer: anAmount to: receivingAccount
	
	|  a b |
	
	a := Deposit new.
	b := Withdraw new.! !
!ReceptiveAccount methodsFor: 'transactions' stamp: 'LK 10/19/2023 21:28:52' prior: 50698841!
transfer: anAmount to: receivingAccount
	
	|  a b |
	
	a := Deposit new.
	b := Withdraw new.
	
	a initializeFor: anAmount.
	b initializeFor: anAmount.
	
	! !
!ReceptiveAccount methodsFor: 'transactions' stamp: 'LK 10/19/2023 21:29:38' prior: 50698847!
transfer: anAmount to: receivingAccount
	
	|  a b |
	
	a := Deposit new.
	b := Withdraw new.
	
	a initializeFor: anAmount.
	b initializeFor: anAmount.
	
	receivingAccount register: a.
	self register: a.
	
	! !
!XXXTest methodsFor: 'as yet unclassified' stamp: 'LK 10/19/2023 21:30:21' prior: 50698832!
test01
	| receivingAccount transferingAccount |
	
	receivingAccount := ReceptiveAccount new. 
	transferingAccount := ReceptiveAccount new.
	
	transferingAccount transfer: 50 to: receivingAccount .
	
	self assert: receivingAccount balance = 50.
	self assert: transferingAccount balance = -50.
! !

!testRun: #XXXTest #test01 stamp: 'LK 10/19/2023 21:30:22'!
FAILURE!
!ReceptiveAccount methodsFor: 'transactions' stamp: 'LK 10/19/2023 21:30:39' prior: 50698855!
transfer: anAmount to: receivingAccount
	
	|  a b |
	
	a := Deposit new.
	b := Withdraw new.
	
	a initializeFor: anAmount.
	b initializeFor: anAmount.
	
	receivingAccount register: a.
	self register: b.
	
	! !

!testRun: #XXXTest #test01 stamp: 'LK 10/19/2023 21:30:46'!
PASSED!
!ReceptiveAccount methodsFor: 'transactions' stamp: 'LK 10/19/2023 21:31:52' prior: 50698880!
transfer: anAmount to: receivingAccount
	
	Deposit register: anAmount on: receivingAccount.
	Withdraw register: anAmount on: self.
	! !

!testRun: #XXXTest #test01 stamp: 'LK 10/19/2023 21:31:56'!
PASSED!

AccountTransaction subclass: #Transfer
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #Transfer category: 'Portfolio-Solucion' stamp: 'LK 10/19/2023 21:39:20'!
AccountTransaction subclass: #Transfer
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!
!XXXTest methodsFor: 'as yet unclassified' stamp: 'LK 10/19/2023 21:51:20'!
test02
	| receivingAccount transferingAccount |
	
	receivingAccount := ReceptiveAccount new. 
	transferingAccount := ReceptiveAccount new.
	
	transferingAccount transfer: 50 to: receivingAccount .

! !
!XXXTest methodsFor: 'as yet unclassified' stamp: 'LK 10/19/2023 21:51:28' prior: 50698914!
test02
	| receivingAccount transferingAccount |
	
	receivingAccount := ReceptiveAccount new. 
	transferingAccount := ReceptiveAccount new.
	
	transferingAccount transfer: 50 to: receivingAccount.
	


! !
!XXXTest methodsFor: 'as yet unclassified' stamp: 'LK 10/19/2023 21:53:25' prior: 50698924!
test02
	| receivingAccount transferingAccount transfer|
	
	receivingAccount := ReceptiveAccount new. 
	transferingAccount := ReceptiveAccount new.
	
	transferingAccount transfer: 50 to: receivingAccount.
	
	transfer := Transfer amount: 50 from: transferingAccount to: receivingAccount.
	
	self assert: (receivingAccount hasRegistered: transfer).
	self assert: (transferingAccount hasRegistered: transfer).


! !

!testRun: #XXXTest #test02 stamp: 'LK 10/19/2023 21:53:27'!
ERROR!
!Transfer methodsFor: 'no messages' stamp: 'LK 10/19/2023 21:54:15' overrides: 50698708!
value
	^value! !

----QUIT----(19 October 2023 22:04:59) CuisUniversity-5981.image priorSource: 11682485!

----STARTUP---- (23 October 2023 14:09:01) as C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\CuisUniversity-5981.image!


!classDefinition: #Deposit category: 'Portfolio-Solucion' stamp: 'LK 10/23/2023 14:09:15'!
AccountTransaction subclass: #Deposit
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #Withdraw category: 'Portfolio-Solucion' stamp: 'LK 10/23/2023 14:09:15'!
AccountTransaction subclass: #Withdraw
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #Transfer category: 'Portfolio-Solucion' stamp: 'LK 10/23/2023 14:09:15'!
AccountTransaction subclass: #Transfer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #AccountTransaction category: 'Portfolio-Solucion' stamp: 'LK 10/23/2023 14:09:15'!
Object subclass: #AccountTransaction
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'LK 10/23/2023 14:09:37'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'LK 10/23/2023 14:09:37'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'LK 10/23/2023 14:09:37'!
PASSED!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'LK 10/23/2023 14:09:37'!
PASSED!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'LK 10/23/2023 14:09:37'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'LK 10/23/2023 14:09:37'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'LK 10/23/2023 14:09:37'!
PASSED!

!testRun: #PortfolioTest #test01BalanceOfPortfolioWithoutAccountsIsZero stamp: 'LK 10/23/2023 14:09:39'!
PASSED!

!testRun: #PortfolioTest #test02BalanceOfPortfolioWithAccountsIsSumOfAccountsBalance stamp: 'LK 10/23/2023 14:09:39'!
PASSED!

!testRun: #PortfolioTest #test03BalanceOfPortfolioIsCalculatedRecursivelyOnPortfolios stamp: 'LK 10/23/2023 14:09:39'!
PASSED!

!testRun: #PortfolioTest #test04PortfolioWithoutAccountsHasNoRegisteredTransaction stamp: 'LK 10/23/2023 14:09:39'!
PASSED!

!testRun: #PortfolioTest #test05PortfolioHasRegisteredItsAccountsTransactions stamp: 'LK 10/23/2023 14:09:39'!
PASSED!

!testRun: #PortfolioTest #test06PortfolioLooksForRegisteredTransactionsRecursively stamp: 'LK 10/23/2023 14:09:39'!
PASSED!

!testRun: #PortfolioTest #test07PortfolioHasNoTransactionWhenHasNoAccounts stamp: 'LK 10/23/2023 14:09:39'!
PASSED!

!testRun: #PortfolioTest #test08PortfolioTransactionsIncludesAllItsAccountsTransactions stamp: 'LK 10/23/2023 14:09:39'!
PASSED!

!testRun: #PortfolioTest #test09PortfolioTransactionsAreCalculatedRecursively stamp: 'LK 10/23/2023 14:09:39'!
PASSED!

!testRun: #PortfolioTest #test10PortfolioCanNotIncludeTheSameAccountMoreThanOnce stamp: 'LK 10/23/2023 14:09:39'!
PASSED!

!testRun: #PortfolioTest #test11PortfolioCanNotIncludeAccountOfItsPortfolios stamp: 'LK 10/23/2023 14:09:39'!
PASSED!

!testRun: #PortfolioTest #test12PortfolioCanNotIncludeItself stamp: 'LK 10/23/2023 14:09:39'!
PASSED!

!testRun: #PortfolioTest #test13ComposedPortfolioCanNotHaveParentPortfolioAccount stamp: 'LK 10/23/2023 14:09:39'!
PASSED!

!testRun: #PortfolioTest #test14ComposedPortfolioCanNotHaveAccountOfAnyRootParentRecursively stamp: 'LK 10/23/2023 14:09:39'!
PASSED!

!testRun: #PortfolioTest #test15PortfolioCanNotIncludeAnyOfTheComposedAccountOfPortfolioToAdd stamp: 'LK 10/23/2023 14:09:39'!
PASSED!

Object subclass: #Transfer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #Transfer category: 'Portfolio-Solucion' stamp: 'LK 10/23/2023 14:10:14'!
Object subclass: #Transfer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

TestCase subclass: #AccountSummary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #AccountSummary category: 'Portfolio-Solucion' stamp: 'LK 10/23/2023 14:29:49'!
TestCase subclass: #AccountSummary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!
!Account methodsFor: 'transactions' stamp: 'LK 10/23/2023 14:34:17'!
reportAccountSummary! !
!Portfolio methodsFor: 'reporting' stamp: 'LK 10/23/2023 14:35:00' overrides: 50699100!
reportAccountSummary! !
!ReceptiveAccount methodsFor: 'reporting' stamp: 'LK 10/23/2023 14:35:01' overrides: 50699100!
reportAccountSummary! !
!Account methodsFor: 'reporting' stamp: 'LK 10/23/2023 14:35:01' prior: 50699100!
reportAccountSummary

	self subclassResponsibility! !

!classRemoval: #AccountSummary stamp: 'LK 10/23/2023 14:36:33'!
TestCase subclass: #AccountSummary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!methodRemoval: XXXTest #test02 stamp: 'LK 10/23/2023 14:36:57'!
test02
	| receivingAccount transferingAccount transfer|
	
	receivingAccount := ReceptiveAccount new. 
	transferingAccount := ReceptiveAccount new.
	
	transferingAccount transfer: 50 to: receivingAccount.
	
	transfer := Transfer amount: 50 from: transferingAccount to: receivingAccount.
	
	self assert: (receivingAccount hasRegistered: transfer).
	self assert: (transferingAccount hasRegistered: transfer).


!

!methodRemoval: XXXTest #test01 stamp: 'LK 10/23/2023 14:37:00'!
test01
	| receivingAccount transferingAccount |
	
	receivingAccount := ReceptiveAccount new. 
	transferingAccount := ReceptiveAccount new.
	
	transferingAccount transfer: 50 to: receivingAccount .
	
	self assert: receivingAccount balance = 50.
	self assert: transferingAccount balance = -50.
!

!classRemoval: #Transfer stamp: 'LK 10/23/2023 14:37:03'!
Object subclass: #Transfer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

----QUIT----(23 October 2023 14:38:11) CuisUniversity-5981.image priorSource: 11753744!

----STARTUP---- (23 October 2023 15:37:00) as C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\CuisUniversity-5981.image!


----QUIT----(23 October 2023 15:45:37) CuisUniversity-5981.image priorSource: 11760135!

----STARTUP---- (23 October 2023 18:53:31) as C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\CuisUniversity-5981.image!


----QUIT----(23 October 2023 18:55:46) CuisUniversity-5981.image priorSource: 11760355!

----STARTUP---- (23 October 2023 19:23:10) as C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\CuisUniversity-5981.image!


Object subclass: #NameOfSubclass
	instanceVariableNames: 'reports'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #NameOfSubclass category: 'Portfolio-Solucion' stamp: 'LK 10/23/2023 19:30:18'!
Object subclass: #NameOfSubclass
	instanceVariableNames: 'reports'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classRemoval: #NameOfSubclass stamp: 'LK 10/23/2023 19:30:34'!
Object subclass: #NameOfSubclass
	instanceVariableNames: 'reports'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

Object subclass: #Account
	instanceVariableNames: 'reportes'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #Account category: 'Portfolio-Solucion' stamp: 'LK 10/23/2023 19:31:09'!
Object subclass: #Account
	instanceVariableNames: 'reportes'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!
!ReceptiveAccount methodsFor: 'initialization' stamp: 'LK 10/23/2023 19:31:31' prior: 50698650 overrides: 16920235!
initialize

	super initialize.
	transactions := OrderedCollection new.
	reportes := OrderedCollection new.! !
!ReceptiveAccount methodsFor: 'transactions' stamp: 'LK 10/23/2023 19:38:50' prior: 50698662!
register: aTransaction

	|string|

	transactions add: aTransaction. 

	(aTransaction isKindOf: Deposit) ifTrue: [ string := 'Depósito por ', aTransaction value asString, '.'].
								
	(aTransaction isKindOf: Withdraw)							ifTrue: [string := 'Extracción por', aTransaction value asString, '.'].
										
	reportes add: string.
								
								
			
	! !
!ReceptiveAccount methodsFor: 'reporting' stamp: 'LK 10/23/2023 19:41:08' prior: 50699108 overrides: 50699112!
reportAccountSummary
	
	reportes add: 'Balance = ', self balance asString.
	
	^reportes.! !
!XXXTest methodsFor: 'no messages' stamp: 'LK 10/23/2023 19:41:45'!
test01

	| acc |
	
	acc := ReceptiveAccount.! !
!XXXTest methodsFor: 'as yet unclassified' stamp: 'LK 10/23/2023 19:44:01' prior: 50699234!
test01

	|account deposit stringEsperado| 
	
	account := ReceptiveAccount new.
	deposit := Deposit register: 100 on: account.
	
	stringEsperado := OrderedCollection new.
	stringEsperado add: 'Deposito por 100.'.
	
	self assert: stringEsperado = account reportAccountSummary.
	
	! !

!testRun: #XXXTest #test01 stamp: 'LK 10/23/2023 19:44:06'!
FAILURE!
!XXXTest methodsFor: 'as yet unclassified' stamp: 'LK 10/23/2023 19:44:37' prior: 50699239!
test01

	|account deposit stringEsperado| 
	
	account := ReceptiveAccount new.
	deposit := Deposit register: 100 on: account.
	
	stringEsperado := OrderedCollection new.
	stringEsperado add: 'Deposito por 100.'.
	
	self assert: stringEsperado = account reportAccountSummary.
	
	! !
!XXXTest methodsFor: 'as yet unclassified' stamp: 'LK 10/23/2023 19:45:21' prior: 50699253!
test01

	|account deposit stringEsperado| 
	
	account := ReceptiveAccount new.
	deposit := Deposit register: 100 on: account.
	
	stringEsperado := OrderedCollection new.
	stringEsperado add: 'Deposito por 100.'.
	stringEsperado add: 'Balance = 100'.
	
	self assert: stringEsperado = account reportAccountSummary.
	
	! !

!testRun: #XXXTest #test01 stamp: 'LK 10/23/2023 19:45:25'!
FAILURE!

account := ReceptiveAccount new.!

deposit := Deposit register: 100 on: account.!

string := account reportAccountSummary !
!XXXTest methodsFor: 'as yet unclassified' stamp: 'LK 10/23/2023 19:47:26' prior: 50699265!
test01

	|account deposit stringEsperado| 
	
	account := ReceptiveAccount new.
	deposit := Deposit register: 100 on: account.
	
	stringEsperado := OrderedCollection new.
	stringEsperado add: 'Depósito por 100.'.
	stringEsperado add: 'Balance = 100'.
	
	self assert: stringEsperado = account reportAccountSummary.
	
	! !

!testRun: #XXXTest #test01 stamp: 'LK 10/23/2023 19:47:32'!
PASSED!

!testRun: #XXXTest #test01 stamp: 'LK 10/23/2023 19:47:32'!
PASSED!
!XXXTest methodsFor: 'as yet unclassified' stamp: 'LK 10/23/2023 20:01:21'!
test02

	|account deposit stringEsperado| 
	
	account := ReceptiveAccount new.
	deposit := Deposit register: 100 on: account.
	
	stringEsperado := OrderedCollection new.
	stringEsperado add: 'Depósito por 100.'.
	stringEsperado add: 'Balance = 100'.
	
	self assert: stringEsperado = account reportAccountSummary.
	
	! !

!methodRemoval: XXXTest #test01 stamp: 'LK 10/23/2023 20:01:21'!
test01

	|account deposit stringEsperado| 
	
	account := ReceptiveAccount new.
	deposit := Deposit register: 100 on: account.
	
	stringEsperado := OrderedCollection new.
	stringEsperado add: 'Depósito por 100.'.
	stringEsperado add: 'Balance = 100'.
	
	self assert: stringEsperado = account reportAccountSummary.
	
	!
!XXXTest methodsFor: 'as yet unclassified' stamp: 'LK 10/23/2023 20:01:42'!
test01

	|account stringEsperado| 
	
	account := ReceptiveAccount new.
	
	stringEsperado := OrderedCollection new.
	stringEsperado add: 'Balance = 0'.
	
	self assert: stringEsperado = account reportAccountSummary.
	
	! !

!testRun: #XXXTest #test01 stamp: 'LK 10/23/2023 20:01:47'!
PASSED!

!testRun: #XXXTest #test01 stamp: 'LK 10/23/2023 20:01:47'!
PASSED!

!testRun: #XXXTest #test02 stamp: 'LK 10/23/2023 20:01:47'!
PASSED!
!XXXTest methodsFor: 'as yet unclassified' stamp: 'LK 10/23/2023 20:01:57'!
test03

	|account deposit stringEsperado| 
	
	account := ReceptiveAccount new.
	deposit := Deposit register: 100 on: account.
	
	stringEsperado := OrderedCollection new.
	stringEsperado add: 'Depósito por 100.'.
	stringEsperado add: 'Balance = 100'.
	
	self assert: stringEsperado = account reportAccountSummary.
	
	! !
!XXXTest methodsFor: 'as yet unclassified' stamp: 'LK 10/23/2023 20:05:07' prior: 50699342!
test03

	|account deposit stringEsperado| 
	
	account := ReceptiveAccount new.
	deposit := Withdraw register: 50 on: account.
	
	stringEsperado := OrderedCollection new.
	stringEsperado add: 'Extracción por 50.'.
	stringEsperado add: 'Balance = -50'.
	
	self assert: stringEsperado = account reportAccountSummary.
	
	! !
!ReceptiveAccount methodsFor: 'reporting' stamp: 'LK 10/23/2023 20:05:59' prior: 50699229 overrides: 50699112!
reportAccountSummary
	
	
	
	
	reportes add: 'Balance = ', self balance asString.
	
	^reportes.! !
!ReceptiveAccount methodsFor: 'reporting' stamp: 'LK 10/23/2023 20:07:26' prior: 50699369 overrides: 50699112!
reportAccountSummary
	
	|string|
	transactions do: [:aTransaction | 
		(aTransaction isKindOf: Deposit) ifTrue: [ string := 'Depósito por ', aTransaction value asString, '.'].
		(aTransaction isKindOf: Withdraw)							ifTrue: [string := 'Extracción por', aTransaction value asString, '.'].
	].
	
	
	reportes add: 'Balance = ', self balance asString.
	
	^reportes.! !
!ReceptiveAccount methodsFor: 'reporting' stamp: 'LK 10/23/2023 20:07:32' prior: 50699376 overrides: 50699112!
reportAccountSummary
	
	|string|
	transactions do: [:aTransaction | 
		(aTransaction isKindOf: Deposit) ifTrue: [ string := 'Depósito por ', aTransaction value asString, '.'].
		(aTransaction isKindOf: Withdraw)							ifTrue: [string := 'Extracción por', aTransaction value asString, '.'].
	
	].
	
	
	reportes add: 'Balance = ', self balance asString.
	
	^reportes.! !
!ReceptiveAccount methodsFor: 'reporting' stamp: 'LK 10/23/2023 20:08:23' prior: 50699391 overrides: 50699112!
reportAccountSummary
	
	|string|
	
	string := OrderedCollection new.
	
	transactions do: [:aTransaction | 
		(aTransaction isKindOf: Deposit) ifTrue: [ string := 'Depósito por ', aTransaction value asString, '.'].
		(aTransaction isKindOf: Withdraw)							ifTrue: [string := 'Extracción por', aTransaction value asString, '.'].
	
	].
	
	string add: 'Balance = ', self balance asString.
	
	^string.! !

!testRun: #XXXTest #test01 stamp: 'LK 10/23/2023 20:08:30'!
PASSED!

!testRun: #XXXTest #test02 stamp: 'LK 10/23/2023 20:08:32'!
ERROR!

!testRun: #XXXTest #test02 stamp: 'LK 10/23/2023 20:08:32'!
ERROR!
!ReceptiveAccount methodsFor: 'reporting' stamp: 'LK 10/23/2023 20:09:23' prior: 50699407 overrides: 50699112!
reportAccountSummary
	
	|string|
	
	string := OrderedCollection new.
	
	transactions do: [:aTransaction | 
		(aTransaction isKindOf: Deposit) ifTrue: [ string := 'Depósito por ', aTransaction value asString, '.'].
		(aTransaction isKindOf: Withdraw)							ifTrue: [string := 'Extracción por', aTransaction value asString, '.'].
	
	].
	
	string add: ('Balance = ', self balance asString).
	
	^string.! !

!testRun: #XXXTest #test02 stamp: 'LK 10/23/2023 20:09:27'!
ERROR!

!testRun: #XXXTest #test02 stamp: 'LK 10/23/2023 20:09:27'!
ERROR!
!ReceptiveAccount methodsFor: 'reporting' stamp: 'LK 10/23/2023 20:10:53' prior: 50699430 overrides: 50699112!
reportAccountSummary
	
	|reports|
	
	reports := OrderedCollection new.
	
	transactions do: [:aTransaction | 
		(aTransaction isKindOf: Deposit) ifTrue: [ reports addLast:
										 'Depósito por ', aTransaction value asString, '.'].
		(aTransaction isKindOf: Withdraw)							ifTrue: [reports addLast: 
										 'Extracción por', aTransaction value asString, '.'].
	
	].
	
	reports addLast: ('Balance = ', self balance asString).
	
	^reports.! !

!testRun: #XXXTest #test01 stamp: 'LK 10/23/2023 20:10:57'!
PASSED!

!testRun: #XXXTest #test02 stamp: 'LK 10/23/2023 20:10:59'!
PASSED!

!testRun: #XXXTest #test03 stamp: 'LK 10/23/2023 20:11:02'!
FAILURE!
!XXXTest methodsFor: 'as yet unclassified' stamp: 'LK 10/23/2023 20:11:09' prior: 50699355!
test03

	|account deposit stringEsperado| 
	
	account := ReceptiveAccount new.
	deposit := Withdraw register: 50 on: account.
	
	stringEsperado := OrderedCollection new.
	stringEsperado add: 'Extracción por -50.'.
	stringEsperado add: 'Balance = -50'.
	
	self assert: stringEsperado = account reportAccountSummary.
	
	! !

!testRun: #XXXTest #test03 stamp: 'LK 10/23/2023 20:11:12'!
FAILURE!
!XXXTest methodsFor: 'as yet unclassified' stamp: 'LK 10/23/2023 20:11:36' prior: 50699475!
test03

	|account deposit stringEsperado| 
	
	account := ReceptiveAccount new.
	deposit := Withdraw register: 50 on: account.
	
	stringEsperado := OrderedCollection new.
	stringEsperado add: 'Extracción por 50.'.
	stringEsperado add: 'Balance = -50'.
	
	self assert: stringEsperado = account reportAccountSummary.
	
	! !

!testRun: #XXXTest #test03 stamp: 'LK 10/23/2023 20:11:39'!
FAILURE!

!testRun: #XXXTest #test03 stamp: 'LK 10/23/2023 20:11:55'!
FAILURE!
!XXXTest methodsFor: 'as yet unclassified' stamp: 'LK 10/23/2023 20:12:15' prior: 50699491!
test03

	|account deposit stringEsperado| 
	
	account := ReceptiveAccount new.
	deposit := Withdraw register: 50 on: account.
	
	stringEsperado := OrderedCollection new.
	stringEsperado add: 'Extracción por 50.'.
	stringEsperado add: 'Balance = -50'.
	
	self assert: stringEsperado = account reportAccountSummary.
	
	! !

!testRun: #XXXTest #test03 stamp: 'LK 10/23/2023 20:12:17'!
FAILURE!

!testRun: #XXXTest #test03 stamp: 'LK 10/23/2023 20:12:33'!
FAILURE!

!testRun: #XXXTest #test03 stamp: 'LK 10/23/2023 20:12:33'!
FAILURE!

account := ReceptiveAccount new.!

deposit := Withdraw register: 50 on: account.!

stringEsperado := OrderedCollection new.!

stringEsperado = account reportAccountSummary.!

account reportAccountSummary.!
!ReceptiveAccount methodsFor: 'reporting' stamp: 'LK 10/23/2023 20:15:56' prior: 50699451 overrides: 50699112!
reportAccountSummary
	
	|reports|
	
	reports := OrderedCollection new.
	
	transactions do: [:aTransaction | 
		(aTransaction isKindOf: Deposit) ifTrue: [ reports addLast:
										 'Depósito por ', aTransaction value asString, '.'].
		(aTransaction isKindOf: Withdraw)							ifTrue: [reports addLast: 
										 'Extracción por ', aTransaction value asString, '.'].
	
	].
	
	reports addLast: ('Balance = ', self balance asString).
	
	^reports.! !

!testRun: #XXXTest #test03 stamp: 'LK 10/23/2023 20:16:00'!
PASSED!
!AccountTransaction methodsFor: 'value' stamp: 'LK 10/23/2023 20:16:18'!
valueForTransferNet! !
!Deposit methodsFor: 'value' stamp: 'LK 10/23/2023 20:16:25' overrides: 50699555!
valueForTransferNet! !
!Withdraw methodsFor: 'value' stamp: 'LK 10/23/2023 20:16:25' overrides: 50699555!
valueForTransferNet! !
!AccountTransaction methodsFor: 'value' stamp: 'LK 10/23/2023 20:16:26' prior: 50699555!
valueForTransferNet

	self subclassResponsibility! !
!Withdraw methodsFor: 'value' stamp: 'LK 10/23/2023 20:16:33' prior: 50699563 overrides: 50699567!
valueForTransferNet
	^0.! !
!Deposit methodsFor: 'value' stamp: 'LK 10/23/2023 20:16:39' prior: 50699559 overrides: 50699567!
valueForTransferNet
	^0.! !

Object subclass: #Transfer
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #Transfer category: 'Portfolio-Solucion' stamp: 'LK 10/23/2023 21:28:31'!
Object subclass: #Transfer
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!
!XXXTest methodsFor: 'as yet unclassified' stamp: 'LK 10/23/2023 21:28:57'!
test01t

	|account stringEsperado| 
	
	account := ReceptiveAccount new.
	
	stringEsperado := OrderedCollection new.
	stringEsperado add: 'Balance = 0'.
	
	self assert: stringEsperado = account reportAccountSummary.
	
	! !
!XXXTest methodsFor: 'as yet unclassified' stamp: 'LK 10/23/2023 21:29:46' prior: 50699591!
test01t

	|account deposit withdraw| 
	
	account := ReceptiveAccount new.
	
	! !
!XXXTest methodsFor: 'as yet unclassified' stamp: 'LK 10/23/2023 21:30:01' prior: 50699601!
test01t

	|account deposit withdraw| 
	
	account := ReceptiveAccount new.

	! !
!XXXTest methodsFor: 'as yet unclassified' stamp: 'LK 10/23/2023 21:32:23' prior: 50699607!
test01t

	|recieveingAcc withdrawingAcc| 
	
	withdrawingAcc := ReceptiveAccount new.
	recieveingAcc := ReceptiveAccount new.
	
	withdrawingAcc transfer: 50 to: recieveingAcc.
	
	self assert: recieveingAcc balance = -50.
	self assert: withdrawingAcc balance = 50.
! !

!testRun: #XXXTest #test01t stamp: 'LK 10/23/2023 21:32:24'!
FAILURE!
!XXXTest methodsFor: 'as yet unclassified' stamp: 'LK 10/23/2023 21:32:34' prior: 50699613!
test01t

	|recieveingAcc withdrawingAcc| 
	
	withdrawingAcc := ReceptiveAccount new.
	recieveingAcc := ReceptiveAccount new.
	
	withdrawingAcc transfer: 50 to: recieveingAcc.
	
	self assert: recieveingAcc balance = 50.
	self assert: withdrawingAcc balance = -50.
! !

!testRun: #XXXTest #test01t stamp: 'LK 10/23/2023 21:32:35'!
PASSED!

!testRun: #XXXTest #test01 stamp: 'LK 10/23/2023 21:32:35'!
PASSED!

!testRun: #XXXTest #test01t stamp: 'LK 10/23/2023 21:32:35'!
PASSED!

!testRun: #XXXTest #test02 stamp: 'LK 10/23/2023 21:32:35'!
PASSED!

!testRun: #XXXTest #test03 stamp: 'LK 10/23/2023 21:32:36'!
PASSED!
!XXXTest methodsFor: 'as yet unclassified' stamp: 'LK 10/23/2023 21:32:43'!
test02t

	|recieveingAcc withdrawingAcc| 
	
	withdrawingAcc := ReceptiveAccount new.
	recieveingAcc := ReceptiveAccount new.
	
	withdrawingAcc transfer: 50 to: recieveingAcc.
	
	self assert: recieveingAcc balance = 50.
	self assert: withdrawingAcc balance = -50.
! !

AccountTransaction subclass: #Transfer
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

AccountTransaction subclass: #Transfer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #Transfer category: 'Portfolio-Solucion' stamp: 'LK 10/23/2023 21:34:30'!
AccountTransaction subclass: #Transfer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!
!XXXTest methodsFor: 'as yet unclassified' stamp: 'LK 10/23/2023 21:38:24' prior: 50699627!
test01t

	|recieveingAcc withdrawingAcc| 
	
	withdrawingAcc := ReceptiveAccount new.
	recieveingAcc := ReceptiveAccount new.
	
	recieveingAcc register: Transfer with: 50 from: withdrawingAcc to: recieveingAcc.
	
	self assert: recieveingAcc balance = 50.
	self assert: withdrawingAcc balance = -50.
! !

!testRun: #XXXTest #test01t stamp: 'LK 10/23/2023 21:38:58'!
ERROR!
!XXXTest methodsFor: 'as yet unclassified' stamp: 'LK 10/23/2023 21:39:42' prior: 50699677!
test01t

	|recieveingAcc withdrawingAcc transfer| 
	
	withdrawingAcc := ReceptiveAccount new.
	recieveingAcc := ReceptiveAccount new.
	transfer := Transfer with: 50 from: withdrawingAcc to: recieveingAcc.
	recieveingAcc register: transfer.
	
	self assert: recieveingAcc balance = 50.
	self assert: withdrawingAcc balance = -50.
! !

!testRun: #XXXTest #test01t stamp: 'LK 10/23/2023 21:39:44'!
ERROR!
!Transfer class methodsFor: 'instance creation' stamp: 'LK 10/23/2023 21:39:51'!
with: aRenameMe1 from: withdrawingAcc to: recieveingAcc 
	"DO NOT FORGET TO RENAME COLLABORATORS AND REMOVE THIS COMMENT!!!!"
	self shouldBeImplemented.
	^self new initializeWith: aRenameMe1 from: withdrawingAcc to: recieveingAcc ! !
!ReceptiveAccount methodsFor: 'transactions' stamp: 'LK 10/23/2023 21:41:31' prior: 50699214!
register: aTransaction

	transactions add: aTransaction. 

			
	! !

!methodRemoval: ReceptiveAccount #transfer:to: stamp: 'LK 10/23/2023 21:41:43'!
transfer: anAmount to: receivingAccount
	
	Deposit register: anAmount on: receivingAccount.
	Withdraw register: anAmount on: self.
	!
!Transfer class methodsFor: 'instance creation' stamp: 'LK 10/23/2023 21:42:10' prior: 50699708!
with: aValue from: withdrawingAcc to: recieveingAcc 
	
	
	"^self new initializeWith: aRenameMe1 from: withdrawingAcc to: recieveingAcc "! !
!Transfer class methodsFor: 'instance creation' stamp: 'LK 10/23/2023 21:42:15' prior: 50699731!
with: aValue from: withdrawingAcc to: recieveingAcc 
	
	
	"^self new initializeWith: aRenameMe1 from: withdrawingAcc to: recieveingAcc"! !
!Transfer methodsFor: 'no messages' stamp: 'LK 10/23/2023 21:43:08'!
initializeWith: aValue from: withdrawingAccount to: receivingAccount! !
!Transfer methodsFor: 'as yet unclassified' stamp: 'LK 10/23/2023 21:43:18' prior: 50699746!
initializeWith: aValue from: withdrawingAccount to: receivingAccount
	
	! !

AccountTransaction subclass: #Transfer
	instanceVariableNames: 'withdrawAccount receiveAccount'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #Transfer category: 'Portfolio-Solucion' stamp: 'LK 10/23/2023 21:43:35'!
AccountTransaction subclass: #Transfer
	instanceVariableNames: 'withdrawAccount receiveAccount'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!
!Transfer methodsFor: 'as yet unclassified' stamp: 'LK 10/23/2023 21:44:28' prior: 50699752!
initializeWith: aValue from: aWithdrawingAccount to: aReceivingAccount
	
	value := aValue.
	withdrawAccount := aWithdrawingAccount.
	receiveAccount := aReceivingAccount.
	! !
!Transfer methodsFor: 'as yet unclassified' stamp: 'LK 10/23/2023 21:45:05' overrides: 50698712!
affectBalance: asd! !
!Transfer methodsFor: 'as yet unclassified' stamp: 'LK 10/23/2023 21:46:39'!
affectBalance: aBalance from: anAccount
	
	^aBalance ! !

!methodRemoval: Transfer #affectBalance: stamp: 'LK 10/23/2023 21:46:43'!
affectBalance: asd!
!Transfer methodsFor: 'as yet unclassified' stamp: 'LK 10/23/2023 21:47:31' prior: 50699785!
affectBalance: aBalance from: anAccount
	
	(anAccount = receiveAccount) ifTrue: [^aBalance + self value].
	
	(anAccount = withdrawAccount ) ifTrue: [^aBalance - self value]! !

!testRun: #XXXTest #test01t stamp: 'LK 10/23/2023 21:47:38'!
ERROR!

!testRun: #XXXTest #test01t stamp: 'LK 10/23/2023 21:47:38'!
ERROR!
!Transfer methodsFor: 'as yet unclassified' stamp: 'LK 10/23/2023 21:49:43' overrides: 50698708!
value
	^value! !

----QUIT----(23 October 2023 21:57:21) CuisUniversity-5981.image priorSource: 11760575!

----STARTUP---- (24 October 2023 14:47:39) as C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\CuisUniversity-5981.image!

!XXXTest methodsFor: 'as yet unclassified' stamp: 'LK 10/24/2023 14:49:14' prior: 50699649!
test02t

	|receiveingAcc withdrawingAcc| 
	
	withdrawingAcc := ReceptiveAccount new.
	receiveingAcc := ReceptiveAccount new.
	
	withdrawingAcc transfer: 50 to: receiveingAcc.
	
	self assert: receiveingAcc balance = 50.
	self assert: withdrawingAcc balance = -50.
! !
!XXXTest methodsFor: 'as yet unclassified' stamp: 'LK 10/24/2023 14:49:22' prior: 50699692!
test01t

	|receiveingAcc withdrawingAcc transfer| 
	
	withdrawingAcc := ReceptiveAccount new.
	receiveingAcc := ReceptiveAccount new.
	transfer := Transfer with: 50 from: withdrawingAcc to: receiveingAcc.
	receiveingAcc register: transfer.
	
	self assert: receiveingAcc balance = 50.
	self assert: withdrawingAcc balance = -50.
! !

Object subclass: #Transfer
	instanceVariableNames: 'withdrawAccount receiveAccount'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #Transfer category: 'Portfolio-Solucion' stamp: 'LK 10/24/2023 17:20:25'!
Object subclass: #Transfer
	instanceVariableNames: 'withdrawAccount receiveAccount'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

Object subclass: #Transfer
	instanceVariableNames: 'value withdrawAccount receiveAccount'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #Transfer category: 'Portfolio-Solucion' stamp: 'LK 10/24/2023 17:20:36'!
Object subclass: #Transfer
	instanceVariableNames: 'value withdrawAccount receiveAccount'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!
!Transfer methodsFor: 'as yet unclassified' stamp: 'LK 10/24/2023 17:23:33'!
withdrawingLeg
	^withdrawAccount ! !
!Transfer methodsFor: 'as yet unclassified' stamp: 'LK 10/24/2023 17:23:53'!
depositingLeg
	! !
!Transfer methodsFor: 'as yet unclassified' stamp: 'LK 10/24/2023 17:24:13'!
receivingAccount
	^receiveAccount 
	! !

AccountTransaction subclass: #TransferLegs
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #TransferLegs category: 'Portfolio-Solucion' stamp: 'LK 10/24/2023 17:24:31'!
AccountTransaction subclass: #TransferLegs
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!
!Transfer methodsFor: 'as yet unclassified' stamp: 'LK 10/24/2023 17:26:49' prior: 50699873!
depositingLeg
	^receiveAccount ! !
!Transfer methodsFor: 'as yet unclassified' stamp: 'LK 10/24/2023 17:27:12'!
receivingLeg
	^receiveAccount ! !

!methodRemoval: Transfer #receivingAccount stamp: 'LK 10/24/2023 17:27:24'!
receivingAccount
	^receiveAccount 
	!

TransferLegs subclass: #DepositLeg
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #DepositLeg category: 'Portfolio-Solucion' stamp: 'LK 10/24/2023 17:29:08'!
TransferLegs subclass: #DepositLeg
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

TransferLegs subclass: #WithdrawLeg
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #WithdrawLeg category: 'Portfolio-Solucion' stamp: 'LK 10/24/2023 17:29:20'!
TransferLegs subclass: #WithdrawLeg
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

AccountTransaction subclass: #TransferLegs
	instanceVariableNames: 'transfer'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #TransferLegs category: 'Portfolio-Solucion' stamp: 'LK 10/24/2023 17:29:40'!
AccountTransaction subclass: #TransferLegs
	instanceVariableNames: 'transfer'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!
!TransferLegs methodsFor: 'nil' stamp: 'LK 10/24/2023 17:30:01' overrides: 50698712!
affectBalance: aBalance! !
!DepositLeg methodsFor: 'as yet unclassified' stamp: 'LK 10/24/2023 17:30:05' overrides: 50699941!
affectBalance: aBalance! !
!WithdrawLeg methodsFor: 'as yet unclassified' stamp: 'LK 10/24/2023 17:30:05' overrides: 50699941!
affectBalance: aBalance! !
!TransferLegs methodsFor: 'as yet unclassified' stamp: 'LK 10/24/2023 17:30:06' prior: 50699941 overrides: 50698712!
affectBalance: aBalance

	self subclassResponsibility! !
!DepositLeg methodsFor: 'as yet unclassified' stamp: 'LK 10/24/2023 17:30:25' prior: 50699945 overrides: 50699954!
affectBalance: aBalance
	
	^aBalance! !
!DepositLeg methodsFor: 'as yet unclassified' stamp: 'LK 10/24/2023 17:30:46' prior: 50699960 overrides: 50699954!
affectBalance: aBalance
	
	^aBalance + transfer value.! !
!WithdrawLeg methodsFor: 'as yet unclassified' stamp: 'LK 10/24/2023 17:30:57' prior: 50699949 overrides: 50699954!
affectBalance: aBalance
	^aBalance - transfer value.! !
!TransferLegs methodsFor: 'as yet unclassified' stamp: 'LK 10/24/2023 17:31:30' overrides: 50699567!
valueForTransferNet! !
!DepositLeg methodsFor: 'as yet unclassified' stamp: 'LK 10/24/2023 17:31:38' overrides: 50699976!
valueForTransferNet! !
!WithdrawLeg methodsFor: 'as yet unclassified' stamp: 'LK 10/24/2023 17:31:38' overrides: 50699976!
valueForTransferNet! !
!TransferLegs methodsFor: 'as yet unclassified' stamp: 'LK 10/24/2023 17:31:38' prior: 50699976 overrides: 50699567!
valueForTransferNet

	self subclassResponsibility! !
!WithdrawLeg methodsFor: 'as yet unclassified' stamp: 'LK 10/24/2023 17:32:09' prior: 50699984 overrides: 50699989!
valueForTransferNet
	^transfer value! !
!DepositLeg methodsFor: 'as yet unclassified' stamp: 'LK 10/24/2023 17:32:17' prior: 50699980 overrides: 50699989!
valueForTransferNet
	^transfer value! !
!WithdrawLeg methodsFor: 'as yet unclassified' stamp: 'LK 10/24/2023 17:32:29' prior: 50699995 overrides: 50699989!
valueForTransferNet
	^(transfer value) negative! !
!WithdrawLeg methodsFor: 'as yet unclassified' stamp: 'LK 10/24/2023 17:32:46' prior: 50700005 overrides: 50699989!
valueForTransferNet
	^(transfer value) negated! !
!WithdrawLeg methodsFor: 'as yet unclassified' stamp: 'LK 10/24/2023 17:32:53' prior: 50700011 overrides: 50699989!
valueForTransferNet
	^(transfer value negated)! !
!Transfer class methodsFor: 'instance creation' stamp: 'LK 10/24/2023 17:35:25' prior: 50699739!
with: aValue from: withdrawingAcc to: recieveingAcc 
	
	
	^self new initializeWith: aValue from: withdrawingAcc to: recieveingAcc! !

!methodRemoval: Transfer #affectBalance:from: stamp: 'LK 10/24/2023 17:47:43'!
affectBalance: aBalance from: anAccount
	
	(anAccount = receiveAccount) ifTrue: [^aBalance + self value].
	
	(anAccount = withdrawAccount ) ifTrue: [^aBalance - self value]!
!TransferLegs class methodsFor: 'no messages' stamp: 'LK 10/24/2023 17:48:07'!
for: aTransfer
! !
!TransferLegs class methodsFor: 'as yet unclassified' stamp: 'LK 10/24/2023 17:49:09' prior: 50700037!
for: aTransfer
	^self new init! !
!TransferLegs methodsFor: 'as yet unclassified' stamp: 'LK 10/24/2023 17:49:37'!
initializeFor: aTransfer
	transfer := aTransfer.! !
!DepositLeg methodsFor: 'as yet unclassified' stamp: 'LK 10/24/2023 17:49:42' overrides: 50700045!
initializeFor: aTransfer
	transfer := aTransfer.! !
!WithdrawLeg methodsFor: 'as yet unclassified' stamp: 'LK 10/24/2023 17:49:42' overrides: 50700045!
initializeFor: aTransfer
	transfer := aTransfer.! !
!TransferLegs methodsFor: 'as yet unclassified' stamp: 'LK 10/24/2023 17:49:42' prior: 50700045!
initializeFor: aTransfer

	self subclassResponsibility! !
!TransferLegs class methodsFor: 'as yet unclassified' stamp: 'LK 10/24/2023 17:49:58' prior: 50700041!
for: aTransfer
	^self new initializeFor: aTransfer.! !
!Transfer class methodsFor: 'instance creation' stamp: 'LK 10/24/2023 17:50:26' prior: 50700022!
with: aValue from: withdrawingAcc to: recieveingAcc 
	
	|transfer|
	
	transfer := self new.
	
	^self new initializeWith: aValue from: withdrawingAcc to: recieveingAcc! !
!Transfer class methodsFor: 'instance creation' stamp: 'LK 10/24/2023 17:52:06' prior: 50700071!
with: aValue from: aWithdrawingAcc to: aRecieveingAcc 
	
	|transfer withdrawingAcc receivingAcc|
	
	transfer := self new.
	
	withdrawingAcc := WithdrawLeg for: transfer.
	
	receivingAcc := DepositLeg for: transfer.
	
	^self new initializeWith: aValue from: withdrawingAcc to: receivingAcc.! !

Object subclass: #Transfer
	instanceVariableNames: 'value withdrawLeg receiveLeg'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #Transfer category: 'Portfolio-Solucion' stamp: 'LK 10/24/2023 17:52:22'!
Object subclass: #Transfer
	instanceVariableNames: 'value withdrawLeg receiveLeg'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!
!Transfer methodsFor: 'as yet unclassified' stamp: 'LK 10/24/2023 17:52:30' prior: 50699897!
receivingLeg
	^receiveLeg! !
!Transfer methodsFor: 'as yet unclassified' stamp: 'LK 10/24/2023 17:52:33' prior: 50699869!
withdrawingLeg
	^withdrawLeg! !
!Transfer methodsFor: 'as yet unclassified' stamp: 'LK 10/24/2023 17:52:43' prior: 50699772!
initializeWith: aValue from: aWithdrawingAccount to: aReceivingAccount
	
	value := aValue.
	withdrawLeg := aWithdrawingAccount.
	receiveLeg := aReceivingAccount.
	! !

!methodRemoval: Transfer #depositingLeg stamp: 'LK 10/24/2023 17:52:59'!
depositingLeg
	^receiveAccount !

----QUIT----(24 October 2023 17:56:54) CuisUniversity-5981.image priorSource: 11781072!

----STARTUP---- (24 October 2023 23:35:27) as C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\CuisUniversity-5981.image!


!testRun: #XXXTest #test01t stamp: 'LK 10/24/2023 23:35:36'!
ERROR!
!TransferLegs methodsFor: 'as yet unclassified' stamp: 'LK 10/24/2023 23:37:30' overrides: 50698708!
value
	^transfer value.! !
!XXXTest methodsFor: 'as yet unclassified' stamp: 'LK 10/24/2023 23:38:02'!
testr

	|account stringEsperado| 
	
	account := ReceptiveAccount new.
	
	stringEsperado := OrderedCollection new.
	stringEsperado add: 'Balance = 0'.
	
	self assert: stringEsperado = account reportAccountSummary.
	
	! !

!methodRemoval: XXXTest #test01 stamp: 'LK 10/24/2023 23:38:02'!
test01

	|account stringEsperado| 
	
	account := ReceptiveAccount new.
	
	stringEsperado := OrderedCollection new.
	stringEsperado add: 'Balance = 0'.
	
	self assert: stringEsperado = account reportAccountSummary.
	
	!
!XXXTest methodsFor: 'as yet unclassified' stamp: 'LK 10/24/2023 23:38:19'!
testrr

	|account deposit stringEsperado| 
	
	account := ReceptiveAccount new.
	deposit := Withdraw register: 50 on: account.
	
	stringEsperado := OrderedCollection new.
	stringEsperado add: 'Extracción por 50.'.
	stringEsperado add: 'Balance = -50'.
	
	self assert: stringEsperado = account reportAccountSummary.
	
	! !

!methodRemoval: XXXTest #test03 stamp: 'LK 10/24/2023 23:38:19'!
test03

	|account deposit stringEsperado| 
	
	account := ReceptiveAccount new.
	deposit := Withdraw register: 50 on: account.
	
	stringEsperado := OrderedCollection new.
	stringEsperado add: 'Extracción por 50.'.
	stringEsperado add: 'Balance = -50'.
	
	self assert: stringEsperado = account reportAccountSummary.
	
	!
!XXXTest methodsFor: 'as yet unclassified' stamp: 'LK 10/24/2023 23:38:28'!
testrrrr

	|account deposit stringEsperado| 
	
	account := ReceptiveAccount new.
	deposit := Deposit register: 100 on: account.
	
	stringEsperado := OrderedCollection new.
	stringEsperado add: 'Depósito por 100.'.
	stringEsperado add: 'Balance = 100'.
	
	self assert: stringEsperado = account reportAccountSummary.
	
	! !

!methodRemoval: XXXTest #test02 stamp: 'LK 10/24/2023 23:38:29'!
test02

	|account deposit stringEsperado| 
	
	account := ReceptiveAccount new.
	deposit := Deposit register: 100 on: account.
	
	stringEsperado := OrderedCollection new.
	stringEsperado add: 'Depósito por 100.'.
	stringEsperado add: 'Balance = 100'.
	
	self assert: stringEsperado = account reportAccountSummary.
	
	!
!XXXTest methodsFor: 'as yet unclassified' stamp: 'LK 10/24/2023 23:38:37'!
test01

	|receiveingAcc withdrawingAcc transfer| 
	
	withdrawingAcc := ReceptiveAccount new.
	receiveingAcc := ReceptiveAccount new.
	transfer := Transfer with: 50 from: withdrawingAcc to: receiveingAcc.
	receiveingAcc register: transfer.
	
	self assert: receiveingAcc balance = 50.
	self assert: withdrawingAcc balance = -50.
! !

!methodRemoval: XXXTest #test01t stamp: 'LK 10/24/2023 23:38:37'!
test01t

	|receiveingAcc withdrawingAcc transfer| 
	
	withdrawingAcc := ReceptiveAccount new.
	receiveingAcc := ReceptiveAccount new.
	transfer := Transfer with: 50 from: withdrawingAcc to: receiveingAcc.
	receiveingAcc register: transfer.
	
	self assert: receiveingAcc balance = 50.
	self assert: withdrawingAcc balance = -50.
!
!XXXTest methodsFor: 'as yet unclassified' stamp: 'LK 10/24/2023 23:38:40'!
test02

	|receiveingAcc withdrawingAcc| 
	
	withdrawingAcc := ReceptiveAccount new.
	receiveingAcc := ReceptiveAccount new.
	
	withdrawingAcc transfer: 50 to: receiveingAcc.
	
	self assert: receiveingAcc balance = 50.
	self assert: withdrawingAcc balance = -50.
! !

!methodRemoval: XXXTest #test02t stamp: 'LK 10/24/2023 23:38:40'!
test02t

	|receiveingAcc withdrawingAcc| 
	
	withdrawingAcc := ReceptiveAccount new.
	receiveingAcc := ReceptiveAccount new.
	
	withdrawingAcc transfer: 50 to: receiveingAcc.
	
	self assert: receiveingAcc balance = 50.
	self assert: withdrawingAcc balance = -50.
!
!XXXTest methodsFor: 'as yet unclassified' stamp: 'LK 10/24/2023 23:39:59' prior: 50700208!
test01

	|receiveingAcc withdrawingAcc transfer| 
	
	withdrawingAcc := ReceptiveAccount new.
	receiveingAcc := ReceptiveAccount new.
	transfer := Transfer with: 50 from: withdrawingAcc to: receiveingAcc.
	receiveingAcc register: transfer.
	
	self assert: receiveingAcc balance = 50.
	self assert: withdrawingAcc balance = -50.
! !
!XXXTest methodsFor: 'as yet unclassified' stamp: 'LK 10/24/2023 23:40:22' prior: 50700256!
test01

	|receiveingAcc withdrawingAcc transfer| 
	
	withdrawingAcc := ReceptiveAccount new.
	receiveingAcc := ReceptiveAccount new.
	transfer := Transfer with: 50 from: withdrawingAcc to: receiveingAcc.
	receiveingAcc register: transfer receivingLeg.
	withdrawingAcc register: transfer withdrawingLeg.
	
	self assert: receiveingAcc balance = 50.
	self assert: withdrawingAcc balance = -50.
! !

!testRun: #XXXTest #test01 stamp: 'LK 10/24/2023 23:40:23'!
ERROR!
!DepositLeg methodsFor: 'as yet unclassified' stamp: 'LK 10/24/2023 23:40:45' prior: 50699965 overrides: 50699954!
affectBalance: aBalance
	
	^aBalance + (self value).! !
!WithdrawLeg methodsFor: 'as yet unclassified' stamp: 'LK 10/24/2023 23:40:57' prior: 50699971 overrides: 50699954!
affectBalance: aBalance
	^aBalance - (self value).! !

!testRun: #XXXTest #test01 stamp: 'LK 10/24/2023 23:41:00'!
ERROR!

!testRun: #XXXTest #test01 stamp: 'LK 10/24/2023 23:41:00'!
ERROR!
!XXXTest methodsFor: 'as yet unclassified' stamp: 'LK 10/24/2023 23:43:49' prior: 50700270!
test01

	|receiveingAcc withdrawingAcc transfer| 
	
	withdrawingAcc := ReceptiveAccount new.
	receiveingAcc := ReceptiveAccount new.
	transfer := Transfer with: 50 from: withdrawingAcc to: receiveingAcc.
	
	self assert: receiveingAcc balance = 50.
	self assert: withdrawingAcc balance = -50.
! !
!Transfer class methodsFor: 'instance creation' stamp: 'LK 10/24/2023 23:47:25' prior: 50700080!
with: aValue from: aWithdrawingAcc to: aReceivingAcc 
	
	|transfer withdrawingAccLeg receivingAccLeg|
	
	transfer := self new.
	
	withdrawingAccLeg := (WithdrawLeg for: transfer).
	receivingAccLeg := (DepositLeg for: transfer).
	
	aWithdrawingAcc register: withdrawingAccLeg.
	aReceivingAcc register: receivingAccLeg.
	
	^self new initializeWith: aValue from: aWithdrawingAcc to: aReceivingAcc.! !
!Transfer class methodsFor: 'instance creation' stamp: 'LK 10/24/2023 23:47:39' prior: 50700317!
with: aValue from: aWithdrawingAcc to: aReceivingAcc 
	
	|transfer withdrawingAccLeg receivingAccLeg|
	
	transfer := self new.
	
	withdrawingAccLeg := (WithdrawLeg for: transfer).
	receivingAccLeg := (DepositLeg for: transfer).
	
	aWithdrawingAcc register: withdrawingAccLeg.
	aReceivingAcc register: receivingAccLeg.
	
	^self new initializeWith: aValue from: withdrawingAccLeg to: receivingAccLeg.! !

!testRun: #XXXTest #test01 stamp: 'LK 10/24/2023 23:47:43'!
ERROR!

!testRun: #XXXTest #test01 stamp: 'LK 10/24/2023 23:47:43'!
ERROR!
!Transfer class methodsFor: 'instance creation' stamp: 'LK 10/24/2023 23:56:36' prior: 50700333!
with: aValue from: aWithdrawingAcc to: aReceivingAcc 
	
	|transfer withdrawingAccLeg receivingAccLeg|
	
	transfer := self new.
	
	withdrawingAccLeg := (WithdrawLeg for: transfer).
	receivingAccLeg := (DepositLeg for: transfer).
	
	aWithdrawingAcc register: withdrawingAccLeg.
	aReceivingAcc register: receivingAccLeg.
	
	transfer initializeWith: aValue from: withdrawingAccLeg to: receivingAccLeg.
	
	^transfer.! !

!testRun: #XXXTest #test01 stamp: 'LK 10/24/2023 23:56:39'!
PASSED!

!testRun: #XXXTest #test02 stamp: 'LK 10/24/2023 23:56:40'!
ERROR!

!testRun: #XXXTest #test02 stamp: 'LK 10/24/2023 23:56:40'!
ERROR!

!methodRemoval: XXXTest #test02 stamp: 'LK 10/24/2023 23:56:50'!
test02

	|receiveingAcc withdrawingAcc| 
	
	withdrawingAcc := ReceptiveAccount new.
	receiveingAcc := ReceptiveAccount new.
	
	withdrawingAcc transfer: 50 to: receiveingAcc.
	
	self assert: receiveingAcc balance = 50.
	self assert: withdrawingAcc balance = -50.
!

!classRemoval: #Transfer stamp: 'LK 10/25/2023 00:09:18'!
Object subclass: #Transfer
	instanceVariableNames: 'value withdrawLeg receiveLeg'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classRemoval: #Withdraw stamp: 'LK 10/25/2023 00:09:18'!
AccountTransaction subclass: #Withdraw
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classRemoval: #WithdrawLeg stamp: 'LK 10/25/2023 00:09:18'!
TransferLegs subclass: #WithdrawLeg
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classRemoval: #DepositLeg stamp: 'LK 10/25/2023 00:09:18'!
TransferLegs subclass: #DepositLeg
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classRemoval: #TransferLegs stamp: 'LK 10/25/2023 00:09:18'!
AccountTransaction subclass: #TransferLegs
	instanceVariableNames: 'transfer'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classRemoval: #Deposit stamp: 'LK 10/25/2023 00:09:19'!
AccountTransaction subclass: #Deposit
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classRemoval: #AccountTransaction stamp: 'LK 10/25/2023 00:09:19'!
Object subclass: #AccountTransaction
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classRemoval: #ReceptiveAccount stamp: 'LK 10/25/2023 00:09:19'!
Account subclass: #ReceptiveAccount
	instanceVariableNames: 'transactions'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classRemoval: #Portfolio stamp: 'LK 10/25/2023 00:09:19'!
Account subclass: #Portfolio
	instanceVariableNames: 'accounts parents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classRemoval: #Account stamp: 'LK 10/25/2023 00:09:19'!
Object subclass: #Account
	instanceVariableNames: 'reportes'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classRemoval: #XXXTest stamp: 'LK 10/25/2023 00:09:19'!
TestCase subclass: #XXXTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classRemoval: #ReceptiveAccountTest stamp: 'LK 10/25/2023 00:09:20'!
TestCase subclass: #ReceptiveAccountTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classRemoval: #PortfolioTest stamp: 'LK 10/25/2023 00:09:20'!
TestCase subclass: #PortfolioTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

----End fileIn of C:\Users\lucas\OneDrive\Desktop\Portfolio1-Solucion\Portfolio-Solucion.st----!

TestCase subclass: #XXXTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #XXXTest category: 'Portfolio-Solucion' stamp: 'LK 10/25/2023 00:15:49'!
TestCase subclass: #XXXTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!
!XXXTest methodsFor: 'nil' stamp: 'LK 10/25/2023 00:16:52'!
test01
! !

!classDefinition: #Transfer category: 'Portfolio-Solucion' stamp: 'LK 10/25/2023 00:19:52'!
Object subclass: #Transfer
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!
!XXXTest methodsFor: 'as yet unclassified' stamp: 'LK 10/25/2023 00:19:37' prior: 50701200!
test01
	
	|withdrawingAcc depositAcc transfer|
	
	withdrawingAcc := ReceptiveAccount new.
	depositAcc := ReceptiveAccount new.
	
	transfer := Transfer with: 50 from: withdrawingAcc to: depositAcc.
	
	self assert: depositAcc balance = 50.
	self assert: withdrawingAcc balance = -50.! !
!Transfer methodsFor: 'nil' stamp: 'LK 10/25/2023 00:20:06' overrides: 16902254!
value
	^value! !
!Transfer methodsFor: 'as yet unclassified' stamp: 'LK 10/25/2023 00:21:48'!
initializeWith: aValue from: aWithdrawAccount to: aDepositAccount
	! !
!Transfer methodsFor: 'as yet unclassified' stamp: 'LK 10/25/2023 00:22:18' prior: 50701226!
initializeWith: aValue from: aWithdrawAccount to: aDepositAccount
	
	value := aValue.
	! !

Object subclass: #Transfer
	instanceVariableNames: 'value withdrawingLeg receivingLeg'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #Transfer category: 'Portfolio-Solucion' stamp: 'LK 10/25/2023 00:22:30'!
Object subclass: #Transfer
	instanceVariableNames: 'value withdrawingLeg receivingLeg'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!
!Transfer methodsFor: 'as yet unclassified' stamp: 'LK 10/25/2023 00:22:40' prior: 50701232!
initializeWith: aValue from: aWithdrawLeg to: aDepositLeg
	
	value := aValue.
	! !
!Transfer methodsFor: 'as yet unclassified' stamp: 'LK 10/25/2023 00:23:04' prior: 50701252!
initializeWith: aValue from: aWithdrawLeg to: aDepositLeg
	
	value := aValue.
	withdrawingLeg := aWithdrawLeg.
	receivingLeg := aDepositLeg.! !

Object subclass: #Transfer
	instanceVariableNames: 'value withdrawingLeg depositLeg'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #Transfer category: 'Portfolio-Solucion' stamp: 'LK 10/25/2023 00:23:14'!
Object subclass: #Transfer
	instanceVariableNames: 'value withdrawingLeg depositLeg'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!
!Transfer methodsFor: 'as yet unclassified' stamp: 'LK 10/25/2023 00:23:20' prior: 50701258!
initializeWith: aValue from: aWithdrawLeg to: aDepositLeg
	
	value := aValue.
	withdrawingLeg := aWithdrawLeg.
	depositLeg := aDepositLeg.! !
!Transfer methodsFor: 'as yet unclassified' stamp: 'LK 10/25/2023 00:23:33'!
withdrawLeg
	^withdrawingLeg.! !
!Transfer methodsFor: 'as yet unclassified' stamp: 'LK 10/25/2023 00:23:44'!
depositingLeg
	^depositLeg! !
!XXXTest class methodsFor: 'no messages' stamp: 'LK 10/25/2023 00:24:44'!
for: aValue from: aWithdrawAccount to: aDepositAccount

! !

!methodRemoval: XXXTest class #for:from:to: stamp: 'LK 10/25/2023 00:24:55'!
for: aValue from: aWithdrawAccount to: aDepositAccount

!
!Transfer class methodsFor: 'no messages' stamp: 'LK 10/25/2023 00:25:01'!
for: aValue from: aWithdrawAccount to: aDepositAccount

! !
!XXXTest methodsFor: 'as yet unclassified' stamp: 'LK 10/25/2023 00:25:31' prior: 50701211!
test01
	
	|withdrawingAcc depositAcc transfer|
	
	withdrawingAcc := ReceptiveAccount new.
	depositAcc := ReceptiveAccount new.
	
	transfer := Transfer for: 50 from: withdrawingAcc to: depositAcc.
	
	self assert: depositAcc balance = 50.
	self assert: withdrawingAcc balance = -50.! !
!Transfer class methodsFor: 'as yet unclassified' stamp: 'LK 10/25/2023 00:25:59' prior: 50701303!
for: aValue from: aWithdrawAccount to: aDepositAccount

	|transfer withdrawLeg depositLeg|
	
	transfer := Transfer new.! !
!Transfer class methodsFor: 'as yet unclassified' stamp: 'LK 10/25/2023 00:26:19' prior: 50701320!
for: aValue from: aWithdrawAccount to: aDepositAccount

	|transfer withdrawLeg depositLeg|
	
	transfer := self new.! !

AccountTransaction subclass: #TransferLegs
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #TransferLegs category: 'Portfolio-Solucion' stamp: 'LK 10/25/2023 00:26:37'!
AccountTransaction subclass: #TransferLegs
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

TransferLegs subclass: #DepositLeg
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #DepositLeg category: 'Portfolio-Solucion' stamp: 'LK 10/25/2023 00:27:01'!
TransferLegs subclass: #DepositLeg
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

TransferLegs subclass: #WithdrawLeg
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #WithdrawLeg category: 'Portfolio-Solucion' stamp: 'LK 10/25/2023 00:27:07'!
TransferLegs subclass: #WithdrawLeg
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

AccountTransaction subclass: #TransferLegs
	instanceVariableNames: 'transfer'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #TransferLegs category: 'Portfolio-Solucion' stamp: 'LK 10/25/2023 00:27:46'!
AccountTransaction subclass: #TransferLegs
	instanceVariableNames: 'transfer'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!
!TransferLegs class methodsFor: 'no messages' stamp: 'LK 10/25/2023 00:28:28'!
for: aTransfer
	^self new initializeFor: aTransfer.! !
!TransferLegs methodsFor: 'nil' stamp: 'LK 10/25/2023 00:28:49'!
initializeFor: aTransfer

	transfer := aTransfer.! !
!DepositLeg methodsFor: 'as yet unclassified' stamp: 'LK 10/25/2023 00:29:06' overrides: 50701387!
initializeFor: aTransfer

	transfer := aTransfer.! !
!WithdrawLeg methodsFor: 'as yet unclassified' stamp: 'LK 10/25/2023 00:29:06' overrides: 50701387!
initializeFor: aTransfer

	transfer := aTransfer.! !
!TransferLegs methodsFor: 'as yet unclassified' stamp: 'LK 10/25/2023 00:29:06' prior: 50701387!
initializeFor: aTransfer

	self subclassResponsibility! !
!TransferLegs methodsFor: 'as yet unclassified' stamp: 'LK 10/25/2023 00:29:24' overrides: 50701086!
value
	 ^(transfer value).! !
!Transfer class methodsFor: 'as yet unclassified' stamp: 'LK 10/25/2023 00:31:58' prior: 50701327!
for: aValue from: aWithdrawAccount to: aDepositAccount

	|transfer withdrawingAccLeg depositingAccLeg|
	
	transfer := self new.
	
	withdrawingAccLeg := WithdrawLeg for: transfer.
	
	depositingAccLeg := DepositLeg for: transfer.
	
	transfer initializeWith: aValue from: withdrawingAccLeg to: depositingAccLeg.
	
	aWithdrawAccount register: withdrawingAccLeg.
	aDepositAccount register: depositingAccLeg.
	
	^transfer.
	
	! !
!Transfer class methodsFor: 'as yet unclassified' stamp: 'LK 10/25/2023 00:32:03' prior: 50701412!
for: aValue from: aWithdrawAccount to: aDepositAccount

	|transfer withdrawingAccLeg depositingAccLeg|
	
	transfer := self new.
	
	withdrawingAccLeg := WithdrawLeg for: transfer.
	depositingAccLeg := DepositLeg for: transfer.
	
	transfer initializeWith: aValue from: withdrawingAccLeg to: depositingAccLeg.
	
	aWithdrawAccount register: withdrawingAccLeg.
	aDepositAccount register: depositingAccLeg.
	
	^transfer.
	
	! !
!TransferLegs methodsFor: 'as yet unclassified' stamp: 'LK 10/25/2023 00:32:36' overrides: 50701090!
affectBalance: aBalance! !
!DepositLeg methodsFor: 'as yet unclassified' stamp: 'LK 10/25/2023 00:32:39' overrides: 50701446!
affectBalance: aBalance! !
!WithdrawLeg methodsFor: 'as yet unclassified' stamp: 'LK 10/25/2023 00:32:39' overrides: 50701446!
affectBalance: aBalance! !
!TransferLegs methodsFor: 'as yet unclassified' stamp: 'LK 10/25/2023 00:32:39' prior: 50701446 overrides: 50701090!
affectBalance: aBalance

	self subclassResponsibility! !
!DepositLeg methodsFor: 'as yet unclassified' stamp: 'LK 10/25/2023 00:32:53' prior: 50701450 overrides: 50701459!
affectBalance: aBalance
	^aBalance + transfer value.! !
!DepositLeg methodsFor: 'as yet unclassified' stamp: 'LK 10/25/2023 00:32:54' prior: 50701465 overrides: 50701459!
affectBalance: aBalance

	^aBalance + transfer value.! !
!WithdrawLeg methodsFor: 'as yet unclassified' stamp: 'LK 10/25/2023 00:33:03' prior: 50701454 overrides: 50701459!
affectBalance: aBalance

	^aBalance - transfer value.! !
!AccountTransaction methodsFor: 'value' stamp: 'LK 10/25/2023 00:33:43'!
valueForTransferNet! !
!Deposit methodsFor: 'value' stamp: 'LK 10/25/2023 00:33:47' overrides: 50701482!
valueForTransferNet! !
!Withdraw methodsFor: 'value' stamp: 'LK 10/25/2023 00:33:47' overrides: 50701482!
valueForTransferNet! !
!TransferLegs methodsFor: 'value' stamp: 'LK 10/25/2023 00:33:47' overrides: 50701482!
valueForTransferNet! !
!AccountTransaction methodsFor: 'value' stamp: 'LK 10/25/2023 00:33:47' prior: 50701482!
valueForTransferNet

	self subclassResponsibility! !
!Deposit methodsFor: 'value' stamp: 'LK 10/25/2023 00:33:52' prior: 50701486 overrides: 50701498!
valueForTransferNet
	^0.! !
!Withdraw methodsFor: 'value' stamp: 'LK 10/25/2023 00:33:57' prior: 50701490 overrides: 50701498!
valueForTransferNet
	^0.! !
!DepositLeg methodsFor: 'value' stamp: 'LK 10/25/2023 00:34:07' overrides: 50701494!
valueForTransferNet! !
!WithdrawLeg methodsFor: 'value' stamp: 'LK 10/25/2023 00:34:07' overrides: 50701494!
valueForTransferNet! !
!TransferLegs methodsFor: 'value' stamp: 'LK 10/25/2023 00:34:07' prior: 50701494 overrides: 50701498!
valueForTransferNet

	self subclassResponsibility! !
!DepositLeg methodsFor: 'value' stamp: 'LK 10/25/2023 00:34:19' prior: 50701511 overrides: 50701519!
valueForTransferNet
	^transfer value.! !
!WithdrawLeg methodsFor: 'value' stamp: 'LK 10/25/2023 00:34:38' prior: 50701515 overrides: 50701519!
valueForTransferNet
	^(transfer value) negated.! !

!testRun: #XXXTest #test01 stamp: 'LK 10/25/2023 00:34:55'!
PASSED!
!XXXTest methodsFor: 'as yet unclassified' stamp: 'LK 10/25/2023 00:36:02'!
test02
	
	|withdrawingAcc depositAcc transfer|
	
	withdrawingAcc := ReceptiveAccount new.
	depositAcc := ReceptiveAccount new.
	
	transfer := Transfer for: 50 from: withdrawingAcc to: depositAcc.
	
	self assert: (depositAcc hasRegistered: transfer depositingLeg).
	self assert: (withdrawingAcc hasRegistered: transfer withdrawLeg).! !

!testRun: #XXXTest #test02 stamp: 'LK 10/25/2023 00:36:03'!
PASSED!

!testRun: #XXXTest #test01 stamp: 'LK 10/25/2023 00:36:03'!
PASSED!

!testRun: #XXXTest #test02 stamp: 'LK 10/25/2023 00:36:03'!
PASSED!
!XXXTest methodsFor: 'as yet unclassified' stamp: 'LK 10/25/2023 00:36:47'!
test03
	
	|withdrawingAcc depositAcc transfer|
	
	withdrawingAcc := ReceptiveAccount new.
	depositAcc := ReceptiveAccount new.
	
	transfer := Transfer for: 50 from: withdrawingAcc to: depositAcc.
	
	self assert: (depositAcc hasRegistered: transfer depositingLeg).
	self assert: (withdrawingAcc hasRegistered: transfer withdrawLeg).! !
!XXXTest methodsFor: 'as yet unclassified' stamp: 'LK 10/25/2023 00:42:26'!
test01trasferringModifiesBalance
	
	|withdrawingAcc depositAcc transfer|
	
	withdrawingAcc := ReceptiveAccount new.
	depositAcc := ReceptiveAccount new.
	
	transfer := Transfer for: 50 from: withdrawingAcc to: depositAcc.
	
	self assert: depositAcc balance = 50.
	self assert: withdrawingAcc balance = -50.! !

!methodRemoval: XXXTest #test01 stamp: 'LK 10/25/2023 00:42:26'!
test01
	
	|withdrawingAcc depositAcc transfer|
	
	withdrawingAcc := ReceptiveAccount new.
	depositAcc := ReceptiveAccount new.
	
	transfer := Transfer for: 50 from: withdrawingAcc to: depositAcc.
	
	self assert: depositAcc balance = 50.
	self assert: withdrawingAcc balance = -50.!
!XXXTest methodsFor: 'as yet unclassified' stamp: 'LK 10/25/2023 00:42:37'!
test01trasferringModifiesBalanceByCorrectAmount
	
	|withdrawingAcc depositAcc transfer|
	
	withdrawingAcc := ReceptiveAccount new.
	depositAcc := ReceptiveAccount new.
	
	transfer := Transfer for: 50 from: withdrawingAcc to: depositAcc.
	
	self assert: depositAcc balance = 50.
	self assert: withdrawingAcc balance = -50.! !

!methodRemoval: XXXTest #test01trasferringModifiesBalance stamp: 'LK 10/25/2023 00:42:37'!
test01trasferringModifiesBalance
	
	|withdrawingAcc depositAcc transfer|
	
	withdrawingAcc := ReceptiveAccount new.
	depositAcc := ReceptiveAccount new.
	
	transfer := Transfer for: 50 from: withdrawingAcc to: depositAcc.
	
	self assert: depositAcc balance = 50.
	self assert: withdrawingAcc balance = -50.!
!XXXTest methodsFor: 'as yet unclassified' stamp: 'LK 10/25/2023 00:42:54'!
test02transferringGetsRegisteredInBothAccounts
	
	|withdrawingAcc depositAcc transfer|
	
	withdrawingAcc := ReceptiveAccount new.
	depositAcc := ReceptiveAccount new.
	
	transfer := Transfer for: 50 from: withdrawingAcc to: depositAcc.
	
	self assert: (depositAcc hasRegistered: transfer depositingLeg).
	self assert: (withdrawingAcc hasRegistered: transfer withdrawLeg).! !

!methodRemoval: XXXTest #test02 stamp: 'LK 10/25/2023 00:42:55'!
test02
	
	|withdrawingAcc depositAcc transfer|
	
	withdrawingAcc := ReceptiveAccount new.
	depositAcc := ReceptiveAccount new.
	
	transfer := Transfer for: 50 from: withdrawingAcc to: depositAcc.
	
	self assert: (depositAcc hasRegistered: transfer depositingLeg).
	self assert: (withdrawingAcc hasRegistered: transfer withdrawLeg).!
!XXXTest methodsFor: 'as yet unclassified' stamp: 'LK 10/25/2023 00:43:16'!
test03canNavigateBetweenTransferLegs
	
	|withdrawingAcc depositAcc transfer|
	
	withdrawingAcc := ReceptiveAccount new.
	depositAcc := ReceptiveAccount new.
	
	transfer := Transfer for: 50 from: withdrawingAcc to: depositAcc.
	
	self assert: (depositAcc hasRegistered: transfer depositingLeg).
	self assert: (withdrawingAcc hasRegistered: transfer withdrawLeg).! !

!methodRemoval: XXXTest #test03 stamp: 'LK 10/25/2023 00:43:16'!
test03
	
	|withdrawingAcc depositAcc transfer|
	
	withdrawingAcc := ReceptiveAccount new.
	depositAcc := ReceptiveAccount new.
	
	transfer := Transfer for: 50 from: withdrawingAcc to: depositAcc.
	
	self assert: (depositAcc hasRegistered: transfer depositingLeg).
	self assert: (withdrawingAcc hasRegistered: transfer withdrawLeg).!
!XXXTest methodsFor: 'as yet unclassified' stamp: 'LK 10/25/2023 00:44:37'!
test04

	|account stringEsperado| 
	
	account := ReceptiveAccount new.
	
	stringEsperado := OrderedCollection new.
	stringEsperado add: 'Balance = 0'.
	
	self assert: stringEsperado = account reportAccountSummary.! !
!ReceptiveAccount methodsFor: 'transactions' stamp: 'LK 10/25/2023 00:45:30'!
reportAccountSummary
	
	|reports|
	
	reports := OrderedCollection new.
	
	transactions do: [:aTransaction | 
		(aTransaction isKindOf: Deposit) ifTrue: [ reports addLast:
										 'Depósito por ', aTransaction value asString, '.'].
		(aTransaction isKindOf: Withdraw)							ifTrue: [reports addLast: 
										 'Extracción por ', aTransaction value asString, '.'].
	
	].
	
	reports addLast: ('Balance = ', self balance asString).
	
	^reports.! !

!testRun: #XXXTest #test04 stamp: 'LK 10/25/2023 00:45:32'!
PASSED!
!XXXTest methodsFor: 'as yet unclassified' stamp: 'LK 10/25/2023 00:45:52'!
test05

	|account deposit stringEsperado| 
	
	account := ReceptiveAccount new.
	deposit := Withdraw register: 50 on: account.
	
	stringEsperado := OrderedCollection new.
	stringEsperado add: 'Extracción por 50.'.
	stringEsperado add: 'Balance = -50'.
	
	self assert: stringEsperado = account reportAccountSummary.
	
	! !

!testRun: #XXXTest #test05 stamp: 'LK 10/25/2023 00:46:02'!
PASSED!

!testRun: #XXXTest #test01trasferringModifiesBalanceByCorrectAmount stamp: 'LK 10/25/2023 00:46:02'!
PASSED!

!testRun: #XXXTest #test02transferringGetsRegisteredInBothAccounts stamp: 'LK 10/25/2023 00:46:03'!
PASSED!

!testRun: #XXXTest #test03canNavigateBetweenTransferLegs stamp: 'LK 10/25/2023 00:46:03'!
PASSED!

!testRun: #XXXTest #test04 stamp: 'LK 10/25/2023 00:46:03'!
PASSED!

!testRun: #XXXTest #test05 stamp: 'LK 10/25/2023 00:46:03'!
PASSED!
!ReceptiveAccount methodsFor: 'transactions' stamp: 'LK 10/25/2023 00:48:04' prior: 50701682!
reportAccountSummary
	
	|reports|
	
	reports := OrderedCollection new.
	
	transactions do: [:aTransaction | 
		(aTransaction isKindOf: Deposit) ifTrue: [ reports addLast:
										 'Depósito por ', aTransaction value asString, '.'].
		(aTransaction isKindOf: Withdraw)							ifTrue: [reports addLast: 
										 'Extracción por ', aTransaction value asString, '.'].
		(aTransaction isKindOf: DepositLeg) ifTrue: [reports addLast:
										 'Entrada por transferencia por ', aTransaction value asString, '.'].
		(aTransaction isKindOf: WithdrawLeg) ifTrue: [reports addLast:
										 'Salida por transferencia por ', aTransaction value asString, '.'].
		
	].
	
	reports addLast: ('Balance = ', self balance asString).
	
	^reports.! !
!ReceptiveAccount methodsFor: 'transactions' stamp: 'LK 10/25/2023 00:48:26' prior: 50701731!
reportAccountSummary
	
	|reports|
	
	reports := OrderedCollection new.
	
	transactions do: [:aTransaction | 
		(aTransaction isKindOf: Deposit) ifTrue: [ reports addLast:
										 'Depósito por ', aTransaction value asString, '.'].
		(aTransaction isKindOf: Withdraw)							ifTrue: [reports addLast: 
										 'Extracción por ', aTransaction value asString, '.'].
		(aTransaction isKindOf: DepositLeg) ifTrue: [reports addLast:
										 'Entrada por transferencia por ', aTransaction value asString, '.'].
		(aTransaction isKindOf: WithdrawLeg) ifTrue: [reports addLast:
										 'Salida por transferencia por ', aTransaction value asString, '.'].
	].
	
	reports addLast: ('Balance = ', self balance asString).
	
	^reports.! !
!XXXTest methodsFor: 'as yet unclassified' stamp: 'LK 10/25/2023 00:51:15'!
test06

	|depositAccount withdrawAccount transfer stringEsperado| 
	
	depositAccount := ReceptiveAccount new.
	withdrawAccount := ReceptiveAccount new.
	transfer := Transfer for: 30 from: withdrawAccount to: depositAccount.
	
	stringEsperado := OrderedCollection new.
	stringEsperado add: 'Salida por transferencia por 30.'.
	stringEsperado add: 'Balance = -30'.
	
	self assert: stringEsperado = withdrawAccount reportAccountSummary.
	
	! !
!XXXTest methodsFor: 'as yet unclassified' stamp: 'LK 10/25/2023 00:51:23' prior: 50701784!
test06

	|depositAccount withdrawAccount transfer stringEsperado| 
	
	depositAccount := ReceptiveAccount new.
	withdrawAccount := ReceptiveAccount new.
	transfer := Transfer for: 30 from: withdrawAccount to: depositAccount.
	
	stringEsperado := OrderedCollection new.
	stringEsperado add: 'Salida por transferencia por 30.'.
	stringEsperado add: 'Balance = -30'.
	
	self assert: stringEsperado = withdrawAccount reportAccountSummary.
	
	! !

!testRun: #XXXTest #test06 stamp: 'LK 10/25/2023 00:51:25'!
PASSED!

!testRun: #XXXTest #test01trasferringModifiesBalanceByCorrectAmount stamp: 'LK 10/25/2023 00:51:25'!
PASSED!

!testRun: #XXXTest #test02transferringGetsRegisteredInBothAccounts stamp: 'LK 10/25/2023 00:51:25'!
PASSED!

!testRun: #XXXTest #test03canNavigateBetweenTransferLegs stamp: 'LK 10/25/2023 00:51:25'!
PASSED!

!testRun: #XXXTest #test04 stamp: 'LK 10/25/2023 00:51:25'!
PASSED!

!testRun: #XXXTest #test05 stamp: 'LK 10/25/2023 00:51:25'!
PASSED!

!testRun: #XXXTest #test06 stamp: 'LK 10/25/2023 00:51:25'!
PASSED!
!XXXTest methodsFor: 'as yet unclassified' stamp: 'LK 10/25/2023 00:51:42'!
test07

	|depositAccount withdrawAccount transfer stringEsperado| 
	
	depositAccount := ReceptiveAccount new.
	withdrawAccount := ReceptiveAccount new.
	transfer := Transfer for: 30 from: withdrawAccount to: depositAccount.
	
	stringEsperado := OrderedCollection new.
	stringEsperado add: 'Entrada por transferencia por 30.'.
	stringEsperado add: 'Balance = -30'.
	
	self assert: stringEsperado = depositAccount reportAccountSummary.
	
	! !

!testRun: #XXXTest #test07 stamp: 'LK 10/25/2023 00:51:44'!
FAILURE!

!testRun: #XXXTest #test06 stamp: 'LK 10/25/2023 00:53:07'!
PASSED!

!testRun: #XXXTest #test07 stamp: 'LK 10/25/2023 00:53:08'!
FAILURE!

!testRun: #XXXTest #test07 stamp: 'LK 10/25/2023 00:53:08'!
FAILURE!

depositAccount := ReceptiveAccount new.!

withdrawAccount := ReceptiveAccount new.!

transfer := Transfer for: 30 from: withdrawAccount to: depositAccount.!

depositAccount reportAccountSummary!

stringEsperado := OrderedCollection new.
stringEsperado add: 'Entrada por transferencia por 30.'.
stringEsperado add: 'Balance = -30'.!

stringEsperado = depositAccount reportAccountSummary.!

stringEsperado!

depositAccount reportAccountSummary!
!XXXTest methodsFor: 'as yet unclassified' stamp: 'LK 10/25/2023 00:56:35' prior: 50701836!
test07

	|depositAccount withdrawAccount transfer stringEsperado| 
	
	depositAccount := ReceptiveAccount new.
	withdrawAccount := ReceptiveAccount new.
	transfer := Transfer for: 30 from: withdrawAccount to: depositAccount.
	
	stringEsperado := OrderedCollection new.
	stringEsperado add: 'Entrada por transferencia por 30.'.
	stringEsperado add: 'Balance = 30'.
	
	self assert: stringEsperado = depositAccount reportAccountSummary.
	
	! !

!testRun: #XXXTest #test07 stamp: 'LK 10/25/2023 00:56:38'!
PASSED!

!testRun: #XXXTest #test01trasferringModifiesBalanceByCorrectAmount stamp: 'LK 10/25/2023 00:56:38'!
PASSED!

!testRun: #XXXTest #test02transferringGetsRegisteredInBothAccounts stamp: 'LK 10/25/2023 00:56:38'!
PASSED!

!testRun: #XXXTest #test03canNavigateBetweenTransferLegs stamp: 'LK 10/25/2023 00:56:38'!
PASSED!

!testRun: #XXXTest #test04 stamp: 'LK 10/25/2023 00:56:39'!
PASSED!

!testRun: #XXXTest #test05 stamp: 'LK 10/25/2023 00:56:39'!
PASSED!

!testRun: #XXXTest #test06 stamp: 'LK 10/25/2023 00:56:39'!
PASSED!

!testRun: #XXXTest #test07 stamp: 'LK 10/25/2023 00:56:39'!
PASSED!
!XXXTest methodsFor: 'as yet unclassified' stamp: 'LK 10/25/2023 00:57:07'!
test08

	|depositAccount withdrawAccount transfer stringEsperado| 
	
	depositAccount := ReceptiveAccount new.
	withdrawAccount := ReceptiveAccount new.
	transfer := Transfer for: 30 from: withdrawAccount to: depositAccount.
	
	stringEsperado := OrderedCollection new.
	stringEsperado add: 'Salida por transferencia por 30.'.
	stringEsperado add: 'Balance = -30'.
	
	self assert: stringEsperado = withdrawAccount reportAccountSummary.
	
	! !

!methodRemoval: XXXTest #test06 stamp: 'LK 10/25/2023 00:57:07'!
test06

	|depositAccount withdrawAccount transfer stringEsperado| 
	
	depositAccount := ReceptiveAccount new.
	withdrawAccount := ReceptiveAccount new.
	transfer := Transfer for: 30 from: withdrawAccount to: depositAccount.
	
	stringEsperado := OrderedCollection new.
	stringEsperado add: 'Salida por transferencia por 30.'.
	stringEsperado add: 'Balance = -30'.
	
	self assert: stringEsperado = withdrawAccount reportAccountSummary.
	
	!
!XXXTest methodsFor: 'as yet unclassified' stamp: 'LK 10/25/2023 00:57:38'!
test06

	|account deposit stringEsperado| 
	
	account := ReceptiveAccount new.
	deposit := Deposit register: 50 on: account.
	
	stringEsperado := OrderedCollection new.
	stringEsperado add: 'Depósito por 50.'.
	stringEsperado add: 'Balance = 50'.
	
	self assert: stringEsperado = account reportAccountSummary.
	
	! !

!testRun: #XXXTest #test06 stamp: 'LK 10/25/2023 00:57:40'!
PASSED!

!testRun: #XXXTest #test01trasferringModifiesBalanceByCorrectAmount stamp: 'LK 10/25/2023 00:57:40'!
PASSED!

!testRun: #XXXTest #test02transferringGetsRegisteredInBothAccounts stamp: 'LK 10/25/2023 00:57:40'!
PASSED!

!testRun: #XXXTest #test03canNavigateBetweenTransferLegs stamp: 'LK 10/25/2023 00:57:40'!
PASSED!

!testRun: #XXXTest #test04 stamp: 'LK 10/25/2023 00:57:40'!
PASSED!

!testRun: #XXXTest #test05 stamp: 'LK 10/25/2023 00:57:40'!
PASSED!

!testRun: #XXXTest #test06 stamp: 'LK 10/25/2023 00:57:40'!
PASSED!

!testRun: #XXXTest #test07 stamp: 'LK 10/25/2023 00:57:40'!
PASSED!

!testRun: #XXXTest #test08 stamp: 'LK 10/25/2023 00:57:40'!
PASSED!
!Portfolio methodsFor: 'transactions' stamp: 'LK 10/25/2023 00:59:52'!
reportAccountSummary

	|reports|
	
	reports := OrderedCollection new.
	
	reports addLast: ('Balance = ', self balance asString).
	
	^reports.! !
!XXXTest methodsFor: 'as yet unclassified' stamp: 'LK 10/25/2023 01:01:03'!
test09

	| account portfolio accountDeposit anotherAccount portfolioTransactions anotherAccountWithdraw |
	
	account := ReceptiveAccount new.
	accountDeposit := Deposit register: 100 on: account.
	anotherAccount := ReceptiveAccount new.
	anotherAccountWithdraw := Withdraw register: 100 on: account.
	portfolio := Portfolio with: account.
	! !
!XXXTest methodsFor: 'as yet unclassified' stamp: 'LK 10/25/2023 01:02:20' prior: 50701988!
test09

	| account portfolio accountDeposit anotherAccount anotherAccountWithdraw |
	
	account := ReceptiveAccount new.
	accountDeposit := Deposit register: 100 on: account.
	anotherAccount := ReceptiveAccount new.
	anotherAccountWithdraw := Withdraw register: 100 on: account.
	portfolio := Portfolio with: account.
	
	
	! !
!XXXTest methodsFor: 'as yet unclassified' stamp: 'LK 10/25/2023 01:02:36' prior: 50702002!
test09

	| account portfolio accountDeposit anotherAccount anotherAccountWithdraw expectedString|
	
	account := ReceptiveAccount new.
	accountDeposit := Deposit register: 100 on: account.
	anotherAccount := ReceptiveAccount new.
	anotherAccountWithdraw := Withdraw register: 100 on: account.
	portfolio := Portfolio with: account.
	
	expectedString := OrderedCollection new.
	
	! !
!XXXTest methodsFor: 'as yet unclassified' stamp: 'LK 10/25/2023 01:02:50' prior: 50701913!
test08

	|depositAccount withdrawAccount transfer expectedString| 
	
	depositAccount := ReceptiveAccount new.
	withdrawAccount := ReceptiveAccount new.
	transfer := Transfer for: 30 from: withdrawAccount to: depositAccount.
	
	expectedString := OrderedCollection new.
	expectedString add: 'Salida por transferencia por 30.'.
	expectedString add: 'Balance = -30'.
	
	self assert: expectedString = withdrawAccount reportAccountSummary.
	
	! !
!XXXTest methodsFor: 'as yet unclassified' stamp: 'LK 10/25/2023 01:03:04' prior: 50701876!
test07

	|depositAccount withdrawAccount transfer expectedString| 
	
	depositAccount := ReceptiveAccount new.
	withdrawAccount := ReceptiveAccount new.
	transfer := Transfer for: 30 from: withdrawAccount to: depositAccount.
	
	expectedString := OrderedCollection new.
	expectedString add: 'Entrada por transferencia por 30.'.
	expectedString add: 'Balance = 30'.
	
	self assert: expectedString = depositAccount reportAccountSummary.
	
	! !
!XXXTest methodsFor: 'as yet unclassified' stamp: 'LK 10/25/2023 01:03:12' prior: 50701945!
test06

	|account deposit expectedString| 
	
	account := ReceptiveAccount new.
	deposit := Deposit register: 50 on: account.
	
	expectedString := OrderedCollection new.
	expectedString add: 'Depósito por 50.'.
	expectedString add: 'Balance = 50'.
	
	self assert: expectedString = account reportAccountSummary.
	
	! !
!XXXTest methodsFor: 'as yet unclassified' stamp: 'LK 10/25/2023 01:03:33' prior: 50701701!
test05

	|account deposit expectedString| 
	
	account := ReceptiveAccount new.
	deposit := Withdraw register: 50 on: account.
	
	expectedString := OrderedCollection new.
	expectedString add: 'Extracción por 50.'.
	expectedString add: 'Balance = -50'.
	
	self assert: expectedString = account reportAccountSummary.
	
	! !
!XXXTest methodsFor: 'as yet unclassified' stamp: 'LK 10/25/2023 01:03:46' prior: 50701672!
test04

	|account expectedString| 
	
	account := ReceptiveAccount new.
	
	expectedString := OrderedCollection new.
	expectedString add: 'Balance = 0'.
	
	self assert: expectedString = account reportAccountSummary.! !

!testRun: #XXXTest #test01trasferringModifiesBalanceByCorrectAmount stamp: 'LK 10/25/2023 01:03:53'!
PASSED!

!testRun: #XXXTest #test02transferringGetsRegisteredInBothAccounts stamp: 'LK 10/25/2023 01:03:53'!
PASSED!

!testRun: #XXXTest #test03canNavigateBetweenTransferLegs stamp: 'LK 10/25/2023 01:03:53'!
PASSED!

!testRun: #XXXTest #test04 stamp: 'LK 10/25/2023 01:03:53'!
PASSED!

!testRun: #XXXTest #test05 stamp: 'LK 10/25/2023 01:03:53'!
PASSED!

!testRun: #XXXTest #test06 stamp: 'LK 10/25/2023 01:03:53'!
PASSED!

!testRun: #XXXTest #test07 stamp: 'LK 10/25/2023 01:03:53'!
PASSED!

!testRun: #XXXTest #test08 stamp: 'LK 10/25/2023 01:03:53'!
PASSED!

!testRun: #XXXTest #test09 stamp: 'LK 10/25/2023 01:03:53'!
PASSED!
!XXXTest methodsFor: 'testing' stamp: 'LK 10/25/2023 01:06:05' prior: 50702016!
test09

	| account portfolio accountDeposit anotherAccount anotherAccountWithdraw expectedString|
	
	account := ReceptiveAccount new.
	accountDeposit := Deposit register: 100 on: account.
	anotherAccount := ReceptiveAccount new.
	anotherAccountWithdraw := Withdraw register: 100 on: account.
	portfolio := Portfolio with: account.
	
	expectedString := OrderedCollection new.
	expectedString addLast: 'Depósito por 100.'.
	expectedString addLast: 'Extracción por 100.'.
	expectedString addLast: 'Balance = 0'.
	
	self assert: expectedString = portfolio reportAccountSummary.
	
	! !

!testRun: #XXXTest #test09 stamp: 'LK 10/25/2023 01:06:17'!
FAILURE!
!Portfolio methodsFor: 'transactions' stamp: 'LK 10/25/2023 01:13:18' prior: 50701981!
reportAccountSummary

	|reports temp|
	
	reports := OrderedCollection new.
	
	accounts do: [ :anAccount | temp := anAccount reportAccountSummary.
						    temp removeLast.
						    reports addAll: temp.].
	
	reports addLast: ('Balance = ', self balance asString).
	
	^reports.! !

!testRun: #XXXTest #test09 stamp: 'LK 10/25/2023 01:13:25'!
PASSED!
!ReceptiveAccount methodsFor: 'transactions' stamp: 'LK 10/25/2023 01:20:50'!
reportTransferNet! !
!XXXTest methodsFor: 'testing' stamp: 'LK 10/25/2023 01:22:04'!
test04reportingAccountSummaryOfEmptyAccount

	|account expectedString| 
	
	account := ReceptiveAccount new.
	
	expectedString := OrderedCollection new.
	expectedString add: 'Balance = 0'.
	
	self assert: expectedString = account reportAccountSummary.! !

!methodRemoval: XXXTest #test04 stamp: 'LK 10/25/2023 01:22:04'!
test04

	|account expectedString| 
	
	account := ReceptiveAccount new.
	
	expectedString := OrderedCollection new.
	expectedString add: 'Balance = 0'.
	
	self assert: expectedString = account reportAccountSummary.!
!XXXTest methodsFor: 'testing' stamp: 'LK 10/25/2023 01:22:25'!
test04accountSummaryOfEmptyAccount

	|account expectedString| 
	
	account := ReceptiveAccount new.
	
	expectedString := OrderedCollection new.
	expectedString add: 'Balance = 0'.
	
	self assert: expectedString = account reportAccountSummary.! !

!methodRemoval: XXXTest #test04reportingAccountSummaryOfEmptyAccount stamp: 'LK 10/25/2023 01:22:25'!
test04reportingAccountSummaryOfEmptyAccount

	|account expectedString| 
	
	account := ReceptiveAccount new.
	
	expectedString := OrderedCollection new.
	expectedString add: 'Balance = 0'.
	
	self assert: expectedString = account reportAccountSummary.!
!XXXTest methodsFor: 'testing' stamp: 'LK 10/25/2023 01:22:52'!
test05accountSummaryOfW

	|account deposit expectedString| 
	
	account := ReceptiveAccount new.
	deposit := Withdraw register: 50 on: account.
	
	expectedString := OrderedCollection new.
	expectedString add: 'Extracción por 50.'.
	expectedString add: 'Balance = -50'.
	
	self assert: expectedString = account reportAccountSummary.
	
	! !

!methodRemoval: XXXTest #test05 stamp: 'LK 10/25/2023 01:22:52'!
test05

	|account deposit expectedString| 
	
	account := ReceptiveAccount new.
	deposit := Withdraw register: 50 on: account.
	
	expectedString := OrderedCollection new.
	expectedString add: 'Extracción por 50.'.
	expectedString add: 'Balance = -50'.
	
	self assert: expectedString = account reportAccountSummary.
	
	!
!XXXTest methodsFor: 'testing' stamp: 'LK 10/25/2023 01:23:14'!
test04reportsAccountSummaryOfEmptyAccount

	|account expectedString| 
	
	account := ReceptiveAccount new.
	
	expectedString := OrderedCollection new.
	expectedString add: 'Balance = 0'.
	
	self assert: expectedString = account reportAccountSummary.! !

!methodRemoval: XXXTest #test04accountSummaryOfEmptyAccount stamp: 'LK 10/25/2023 01:23:14'!
test04accountSummaryOfEmptyAccount

	|account expectedString| 
	
	account := ReceptiveAccount new.
	
	expectedString := OrderedCollection new.
	expectedString add: 'Balance = 0'.
	
	self assert: expectedString = account reportAccountSummary.!
!XXXTest methodsFor: 'testing' stamp: 'LK 10/25/2023 01:23:25'!
test05reportsAccountSummaryWithWithdrawal

	|account deposit expectedString| 
	
	account := ReceptiveAccount new.
	deposit := Withdraw register: 50 on: account.
	
	expectedString := OrderedCollection new.
	expectedString add: 'Extracción por 50.'.
	expectedString add: 'Balance = -50'.
	
	self assert: expectedString = account reportAccountSummary.
	
	! !

!methodRemoval: XXXTest #test05accountSummaryOfW stamp: 'LK 10/25/2023 01:23:25'!
test05accountSummaryOfW

	|account deposit expectedString| 
	
	account := ReceptiveAccount new.
	deposit := Withdraw register: 50 on: account.
	
	expectedString := OrderedCollection new.
	expectedString add: 'Extracción por 50.'.
	expectedString add: 'Balance = -50'.
	
	self assert: expectedString = account reportAccountSummary.
	
	!
!XXXTest methodsFor: 'testing' stamp: 'LK 10/25/2023 01:23:33'!
test06reportsAccountSummaryWithDeposit

	|account deposit expectedString| 
	
	account := ReceptiveAccount new.
	deposit := Deposit register: 50 on: account.
	
	expectedString := OrderedCollection new.
	expectedString add: 'Depósito por 50.'.
	expectedString add: 'Balance = 50'.
	
	self assert: expectedString = account reportAccountSummary.
	
	! !

!methodRemoval: XXXTest #test06 stamp: 'LK 10/25/2023 01:23:34'!
test06

	|account deposit expectedString| 
	
	account := ReceptiveAccount new.
	deposit := Deposit register: 50 on: account.
	
	expectedString := OrderedCollection new.
	expectedString add: 'Depósito por 50.'.
	expectedString add: 'Balance = 50'.
	
	self assert: expectedString = account reportAccountSummary.
	
	!
!XXXTest methodsFor: 'testing' stamp: 'LK 10/25/2023 01:24:09'!
test07reportsAccountSummaryWithDepositTransferLeg

	|depositAccount withdrawAccount transfer expectedString| 
	
	depositAccount := ReceptiveAccount new.
	withdrawAccount := ReceptiveAccount new.
	transfer := Transfer for: 30 from: withdrawAccount to: depositAccount.
	
	expectedString := OrderedCollection new.
	expectedString add: 'Entrada por transferencia por 30.'.
	expectedString add: 'Balance = 30'.
	
	self assert: expectedString = depositAccount reportAccountSummary.
	
	! !

!methodRemoval: XXXTest #test07 stamp: 'LK 10/25/2023 01:24:09'!
test07

	|depositAccount withdrawAccount transfer expectedString| 
	
	depositAccount := ReceptiveAccount new.
	withdrawAccount := ReceptiveAccount new.
	transfer := Transfer for: 30 from: withdrawAccount to: depositAccount.
	
	expectedString := OrderedCollection new.
	expectedString add: 'Entrada por transferencia por 30.'.
	expectedString add: 'Balance = 30'.
	
	self assert: expectedString = depositAccount reportAccountSummary.
	
	!
!XXXTest methodsFor: 'testing' stamp: 'LK 10/25/2023 01:24:16'!
test08reportsAccountSummaryWithWithdrawTransferLeg

	|depositAccount withdrawAccount transfer expectedString| 
	
	depositAccount := ReceptiveAccount new.
	withdrawAccount := ReceptiveAccount new.
	transfer := Transfer for: 30 from: withdrawAccount to: depositAccount.
	
	expectedString := OrderedCollection new.
	expectedString add: 'Salida por transferencia por 30.'.
	expectedString add: 'Balance = -30'.
	
	self assert: expectedString = withdrawAccount reportAccountSummary.
	
	! !

!methodRemoval: XXXTest #test08 stamp: 'LK 10/25/2023 01:24:16'!
test08

	|depositAccount withdrawAccount transfer expectedString| 
	
	depositAccount := ReceptiveAccount new.
	withdrawAccount := ReceptiveAccount new.
	transfer := Transfer for: 30 from: withdrawAccount to: depositAccount.
	
	expectedString := OrderedCollection new.
	expectedString add: 'Salida por transferencia por 30.'.
	expectedString add: 'Balance = -30'.
	
	self assert: expectedString = withdrawAccount reportAccountSummary.
	
	!
!XXXTest methodsFor: 'testing' stamp: 'LK 10/25/2023 01:24:37'!
test09reportsPortfolioSummaryWithManyAccounts

	| account portfolio accountDeposit anotherAccount anotherAccountWithdraw expectedString|
	
	account := ReceptiveAccount new.
	accountDeposit := Deposit register: 100 on: account.
	anotherAccount := ReceptiveAccount new.
	anotherAccountWithdraw := Withdraw register: 100 on: account.
	portfolio := Portfolio with: account.
	
	expectedString := OrderedCollection new.
	expectedString addLast: 'Depósito por 100.'.
	expectedString addLast: 'Extracción por 100.'.
	expectedString addLast: 'Balance = 0'.
	
	self assert: expectedString = portfolio reportAccountSummary.
	
	! !

!methodRemoval: XXXTest #test09 stamp: 'LK 10/25/2023 01:24:37'!
test09

	| account portfolio accountDeposit anotherAccount anotherAccountWithdraw expectedString|
	
	account := ReceptiveAccount new.
	accountDeposit := Deposit register: 100 on: account.
	anotherAccount := ReceptiveAccount new.
	anotherAccountWithdraw := Withdraw register: 100 on: account.
	portfolio := Portfolio with: account.
	
	expectedString := OrderedCollection new.
	expectedString addLast: 'Depósito por 100.'.
	expectedString addLast: 'Extracción por 100.'.
	expectedString addLast: 'Balance = 0'.
	
	self assert: expectedString = portfolio reportAccountSummary.
	
	!
!XXXTest methodsFor: 'testing' stamp: 'LK 10/25/2023 01:24:42'!
test10! !
!XXXTest methodsFor: 'testing' stamp: 'LK 10/25/2023 01:26:57' prior: 50702411!
test10
	
	|withdrawAccount depositAccount expectedValue|
	
	withdrawAccount := ReceptiveAccount new.
	depositAccount := ReceptiveAccount new.
	
	Transfer for: 10 from: withdrawAccount to: depositAccount.
	
	expectedValue := -10.
	
	self assert: withdrawAccount reportTransferNet = expectedValue.! !
!XXXTest methodsFor: 'testing' stamp: 'LK 10/25/2023 01:27:16' prior: 50701592!
test01trasferringModifiesBalanceByCorrectAmount
	
	|withdrawingAcc depositAcc |
	
	withdrawingAcc := ReceptiveAccount new.
	depositAcc := ReceptiveAccount new.
	
	Transfer for: 50 from: withdrawingAcc to: depositAcc.
	
	self assert: depositAcc balance = 50.
	self assert: withdrawingAcc balance = -50.! !

!testRun: #XXXTest #test01trasferringModifiesBalanceByCorrectAmount stamp: 'LK 10/25/2023 01:27:22'!
PASSED!

!testRun: #XXXTest #test01trasferringModifiesBalanceByCorrectAmount stamp: 'LK 10/25/2023 01:27:22'!
PASSED!

!testRun: #XXXTest #test02transferringGetsRegisteredInBothAccounts stamp: 'LK 10/25/2023 01:27:22'!
PASSED!

!testRun: #XXXTest #test03canNavigateBetweenTransferLegs stamp: 'LK 10/25/2023 01:27:23'!
PASSED!

!testRun: #XXXTest #test04reportsAccountSummaryOfEmptyAccount stamp: 'LK 10/25/2023 01:27:23'!
PASSED!

!testRun: #XXXTest #test05reportsAccountSummaryWithWithdrawal stamp: 'LK 10/25/2023 01:27:23'!
PASSED!

!testRun: #XXXTest #test06reportsAccountSummaryWithDeposit stamp: 'LK 10/25/2023 01:27:23'!
PASSED!

!testRun: #XXXTest #test07reportsAccountSummaryWithDepositTransferLeg stamp: 'LK 10/25/2023 01:27:23'!
PASSED!

!testRun: #XXXTest #test08reportsAccountSummaryWithWithdrawTransferLeg stamp: 'LK 10/25/2023 01:27:23'!
PASSED!

!testRun: #XXXTest #test09reportsPortfolioSummaryWithManyAccounts stamp: 'LK 10/25/2023 01:27:23'!
PASSED!

!testRun: #XXXTest #test10 stamp: 'LK 10/25/2023 01:27:23'!
FAILURE!

!testRun: #XXXTest #test10 stamp: 'LK 10/25/2023 01:27:23'!
FAILURE!

!testRun: #XXXTest #test01trasferringModifiesBalanceByCorrectAmount stamp: 'LK 10/25/2023 01:27:27'!
PASSED!

!testRun: #XXXTest #test02transferringGetsRegisteredInBothAccounts stamp: 'LK 10/25/2023 01:27:38'!
PASSED!

!testRun: #XXXTest #test01trasferringModifiesBalanceByCorrectAmount stamp: 'LK 10/25/2023 01:27:38'!
PASSED!

!testRun: #XXXTest #test02transferringGetsRegisteredInBothAccounts stamp: 'LK 10/25/2023 01:27:38'!
PASSED!

!testRun: #XXXTest #test03canNavigateBetweenTransferLegs stamp: 'LK 10/25/2023 01:27:39'!
PASSED!

!testRun: #XXXTest #test04reportsAccountSummaryOfEmptyAccount stamp: 'LK 10/25/2023 01:27:39'!
PASSED!

!testRun: #XXXTest #test05reportsAccountSummaryWithWithdrawal stamp: 'LK 10/25/2023 01:27:39'!
PASSED!

!testRun: #XXXTest #test06reportsAccountSummaryWithDeposit stamp: 'LK 10/25/2023 01:27:39'!
PASSED!

!testRun: #XXXTest #test07reportsAccountSummaryWithDepositTransferLeg stamp: 'LK 10/25/2023 01:27:39'!
PASSED!

!testRun: #XXXTest #test08reportsAccountSummaryWithWithdrawTransferLeg stamp: 'LK 10/25/2023 01:27:39'!
PASSED!

!testRun: #XXXTest #test09reportsPortfolioSummaryWithManyAccounts stamp: 'LK 10/25/2023 01:27:39'!
PASSED!

!testRun: #XXXTest #test10 stamp: 'LK 10/25/2023 01:27:39'!
FAILURE!

!testRun: #XXXTest #test10 stamp: 'LK 10/25/2023 01:27:39'!
FAILURE!

!testRun: #XXXTest #test02transferringGetsRegisteredInBothAccounts stamp: 'LK 10/25/2023 01:27:43'!
PASSED!

!testRun: #XXXTest #test03canNavigateBetweenTransferLegs stamp: 'LK 10/25/2023 01:27:47'!
PASSED!

!testRun: #XXXTest #test01trasferringModifiesBalanceByCorrectAmount stamp: 'LK 10/25/2023 01:27:47'!
PASSED!

!testRun: #XXXTest #test02transferringGetsRegisteredInBothAccounts stamp: 'LK 10/25/2023 01:27:47'!
PASSED!

!testRun: #XXXTest #test03canNavigateBetweenTransferLegs stamp: 'LK 10/25/2023 01:27:47'!
PASSED!

!testRun: #XXXTest #test04reportsAccountSummaryOfEmptyAccount stamp: 'LK 10/25/2023 01:27:47'!
PASSED!

!testRun: #XXXTest #test05reportsAccountSummaryWithWithdrawal stamp: 'LK 10/25/2023 01:27:47'!
PASSED!

!testRun: #XXXTest #test06reportsAccountSummaryWithDeposit stamp: 'LK 10/25/2023 01:27:48'!
PASSED!

!testRun: #XXXTest #test07reportsAccountSummaryWithDepositTransferLeg stamp: 'LK 10/25/2023 01:27:48'!
PASSED!

!testRun: #XXXTest #test08reportsAccountSummaryWithWithdrawTransferLeg stamp: 'LK 10/25/2023 01:27:48'!
PASSED!

!testRun: #XXXTest #test09reportsPortfolioSummaryWithManyAccounts stamp: 'LK 10/25/2023 01:27:48'!
PASSED!

!testRun: #XXXTest #test10 stamp: 'LK 10/25/2023 01:27:48'!
FAILURE!

!testRun: #XXXTest #test10 stamp: 'LK 10/25/2023 01:27:48'!
FAILURE!

!testRun: #XXXTest #test03canNavigateBetweenTransferLegs stamp: 'LK 10/25/2023 01:27:51'!
PASSED!
!XXXTest methodsFor: 'testing' stamp: 'LK 10/25/2023 01:28:08' prior: 50702303!
test07reportsAccountSummaryWithDepositTransferLeg

	|depositAccount withdrawAccount transfer expectedString| 
	
	depositAccount := ReceptiveAccount new.
	withdrawAccount := ReceptiveAccount new.
	transfer := Transfer for: 30 from: withdrawAccount to: depositAccount.
	
	expectedString := OrderedCollection new.
	expectedString add: 'Entrada por transferencia por 30.'.
	expectedString add: 'Balance = 30'.
	
	self assert: expectedString = depositAccount reportAccountSummary
	
	! !
!XXXTest methodsFor: 'testing' stamp: 'LK 10/25/2023 01:28:15' prior: 50702562!
test07reportsAccountSummaryWithDepositTransferLeg

	|depositAccount withdrawAccount expectedString| 
	
	depositAccount := ReceptiveAccount new.
	withdrawAccount := ReceptiveAccount new.
	Transfer for: 30 from: withdrawAccount to: depositAccount.
	
	expectedString := OrderedCollection new.
	expectedString add: 'Entrada por transferencia por 30.'.
	expectedString add: 'Balance = 30'.
	
	self assert: expectedString = depositAccount reportAccountSummary
	
	! !

!testRun: #XXXTest #test07reportsAccountSummaryWithDepositTransferLeg stamp: 'LK 10/25/2023 01:28:19'!
PASSED!
!XXXTest methodsFor: 'testing' stamp: 'LK 10/25/2023 01:28:26' prior: 50702336!
test08reportsAccountSummaryWithWithdrawTransferLeg

	|depositAccount withdrawAccount expectedString| 
	
	depositAccount := ReceptiveAccount new.
	withdrawAccount := ReceptiveAccount new.
	Transfer for: 30 from: withdrawAccount to: depositAccount.
	
	expectedString := OrderedCollection new.
	expectedString add: 'Salida por transferencia por 30.'.
	expectedString add: 'Balance = -30'.
	
	self assert: expectedString = withdrawAccount reportAccountSummary.
	
	! !

!testRun: #XXXTest #test10 stamp: 'LK 10/25/2023 01:28:57'!
FAILURE!
!ReceptiveAccount methodsFor: 'transactions' stamp: 'LK 10/25/2023 01:29:14' prior: 50702162!
reportTransferNet
	 ^-10.! !

!testRun: #XXXTest #test10 stamp: 'LK 10/25/2023 01:29:16'!
PASSED!
!XXXTest methodsFor: 'testing' stamp: 'LK 10/25/2023 01:29:28'!
test11
	
	|withdrawAccount depositAccount expectedValue|
	
	withdrawAccount := ReceptiveAccount new.
	depositAccount := ReceptiveAccount new.
	
	Transfer for: 10 from: withdrawAccount to: depositAccount.
	
	expectedValue := 10.
	
	self assert: depositAccount reportTransferNet = expectedValue.! !

!testRun: #XXXTest #test11 stamp: 'LK 10/25/2023 01:29:32'!
FAILURE!
!ReceptiveAccount methodsFor: 'transactions' stamp: 'LK 10/25/2023 01:36:22' prior: 50702621!
reportTransferNet
	 
	|netValue|
	
	netValue := 0.
	
	transactions do: [:aTransaction | (aTransaction isKindOf: DepositLeg) ifTrue: 
								[netValue := netValue].
							    (aTransaction isKindOf: WithdrawLeg) ifTrue: 
								[netValue := netValue].
		
		]! !
!ReceptiveAccount methodsFor: 'transactions' stamp: 'LK 10/25/2023 01:37:25' prior: 50702642!
reportTransferNet
	 
	|netValue|
	
	netValue := 0.
	
	transactions do: [:aTransaction | (aTransaction isKindOf: DepositLeg) ifTrue: 
								[netValue := netValue + aTransaction value].
							    (aTransaction isKindOf: WithdrawLeg) ifTrue: 
								[netValue := netValue - aTransaction value].
		
		]! !
!ReceptiveAccount methodsFor: 'transactions' stamp: 'LK 10/25/2023 01:37:39' prior: 50702654!
reportTransferNet
	 
	|netValue|
	
	netValue := 0.
	
	transactions do: [:aTransaction | (aTransaction isKindOf: DepositLeg) ifTrue: 
								[netValue := netValue + aTransaction value].
							    (aTransaction isKindOf: WithdrawLeg) ifTrue: 
								[netValue := netValue - aTransaction value].
	].

	^netValue! !

!testRun: #XXXTest #test10 stamp: 'LK 10/25/2023 01:37:43'!
PASSED!

!testRun: #XXXTest #test11 stamp: 'LK 10/25/2023 01:37:44'!
PASSED!
!XXXTest methodsFor: 'testing' stamp: 'LK 10/25/2023 01:38:24'!
test12
	
	|withdrawAccount depositAccount expectedValue|
	
	withdrawAccount := ReceptiveAccount new.
	depositAccount := ReceptiveAccount new.
	
	Transfer for: 10 from: withdrawAccount to: depositAccount.
	Transfer for: 50 from: depositAccount to: withdrawAccount.
	
	expectedValue := -40.
	
	self assert: depositAccount reportTransferNet = expectedValue.! !

!testRun: #XXXTest #test12 stamp: 'LK 10/25/2023 01:38:25'!
PASSED!

!testRun: #XXXTest #test01trasferringModifiesBalanceByCorrectAmount stamp: 'LK 10/25/2023 01:38:25'!
PASSED!

!testRun: #XXXTest #test02transferringGetsRegisteredInBothAccounts stamp: 'LK 10/25/2023 01:38:25'!
PASSED!

!testRun: #XXXTest #test03canNavigateBetweenTransferLegs stamp: 'LK 10/25/2023 01:38:25'!
PASSED!

!testRun: #XXXTest #test04reportsAccountSummaryOfEmptyAccount stamp: 'LK 10/25/2023 01:38:25'!
PASSED!

!testRun: #XXXTest #test05reportsAccountSummaryWithWithdrawal stamp: 'LK 10/25/2023 01:38:25'!
PASSED!

!testRun: #XXXTest #test06reportsAccountSummaryWithDeposit stamp: 'LK 10/25/2023 01:38:25'!
PASSED!

!testRun: #XXXTest #test07reportsAccountSummaryWithDepositTransferLeg stamp: 'LK 10/25/2023 01:38:25'!
PASSED!

!testRun: #XXXTest #test08reportsAccountSummaryWithWithdrawTransferLeg stamp: 'LK 10/25/2023 01:38:25'!
PASSED!

!testRun: #XXXTest #test09reportsPortfolioSummaryWithManyAccounts stamp: 'LK 10/25/2023 01:38:25'!
PASSED!

!testRun: #XXXTest #test10 stamp: 'LK 10/25/2023 01:38:25'!
PASSED!

!testRun: #XXXTest #test11 stamp: 'LK 10/25/2023 01:38:25'!
PASSED!

!testRun: #XXXTest #test12 stamp: 'LK 10/25/2023 01:38:25'!
PASSED!
!XXXTest methodsFor: 'testing' stamp: 'LK 10/25/2023 01:39:09'!
test10reportsTransferNetForWithdrawLegs
	
	|withdrawAccount depositAccount expectedValue|
	
	withdrawAccount := ReceptiveAccount new.
	depositAccount := ReceptiveAccount new.
	
	Transfer for: 10 from: withdrawAccount to: depositAccount.
	
	expectedValue := -10.
	
	self assert: withdrawAccount reportTransferNet = expectedValue.! !

!methodRemoval: XXXTest #test10 stamp: 'LK 10/25/2023 01:39:10'!
test10
	
	|withdrawAccount depositAccount expectedValue|
	
	withdrawAccount := ReceptiveAccount new.
	depositAccount := ReceptiveAccount new.
	
	Transfer for: 10 from: withdrawAccount to: depositAccount.
	
	expectedValue := -10.
	
	self assert: withdrawAccount reportTransferNet = expectedValue.!
!XXXTest methodsFor: 'testing' stamp: 'LK 10/25/2023 01:39:24'!
test11reportsTransferNetForDepositLegs
	
	|withdrawAccount depositAccount expectedValue|
	
	withdrawAccount := ReceptiveAccount new.
	depositAccount := ReceptiveAccount new.
	
	Transfer for: 10 from: withdrawAccount to: depositAccount.
	
	expectedValue := 10.
	
	self assert: depositAccount reportTransferNet = expectedValue.! !

!methodRemoval: XXXTest #test11 stamp: 'LK 10/25/2023 01:39:24'!
test11
	
	|withdrawAccount depositAccount expectedValue|
	
	withdrawAccount := ReceptiveAccount new.
	depositAccount := ReceptiveAccount new.
	
	Transfer for: 10 from: withdrawAccount to: depositAccount.
	
	expectedValue := 10.
	
	self assert: depositAccount reportTransferNet = expectedValue.!
!XXXTest methodsFor: 'testing' stamp: 'LK 10/25/2023 01:39:43'!
test12reportsTransferNetForMultipleTransfers
	
	|withdrawAccount depositAccount expectedValue|
	
	withdrawAccount := ReceptiveAccount new.
	depositAccount := ReceptiveAccount new.
	
	Transfer for: 10 from: withdrawAccount to: depositAccount.
	Transfer for: 50 from: depositAccount to: withdrawAccount.
	
	expectedValue := -40.
	
	self assert: depositAccount reportTransferNet = expectedValue.! !

!methodRemoval: XXXTest #test12 stamp: 'LK 10/25/2023 01:39:43'!
test12
	
	|withdrawAccount depositAccount expectedValue|
	
	withdrawAccount := ReceptiveAccount new.
	depositAccount := ReceptiveAccount new.
	
	Transfer for: 10 from: withdrawAccount to: depositAccount.
	Transfer for: 50 from: depositAccount to: withdrawAccount.
	
	expectedValue := -40.
	
	self assert: depositAccount reportTransferNet = expectedValue.!
!XXXTest methodsFor: 'testing' stamp: 'LK 10/25/2023 01:40:14'!
test13reportsTransferNetForPortfoliosWithMultipleAccounts
	
	|withdrawAccount depositAccount expectedValue|
	
	withdrawAccount := ReceptiveAccount new.
	depositAccount := ReceptiveAccount new.
	
	Transfer for: 10 from: withdrawAccount to: depositAccount.
	Transfer for: 50 from: depositAccount to: withdrawAccount.
	
	expectedValue := -40.
	
	self assert: depositAccount reportTransferNet = expectedValue.! !
!XXXTest methodsFor: 'testing' stamp: 'LK 10/25/2023 01:41:07' prior: 50702812!
test13reportsTransferNetForPortfoliosWithMultipleAccounts
	
	|withdrawAccount depositAccount expectedValue|
	
	withdrawAccount := ReceptiveAccount new.
	depositAccount := ReceptiveAccount new.
	
	Transfer for: 10 from: withdrawAccount to: depositAccount.
	Transfer for: 50 from: depositAccount to: withdrawAccount.
	
	expectedValue := 0.
	
	self assert: depositAccount reportTransferNet = expectedValue.! !
!XXXTest methodsFor: 'testing' stamp: 'LK 10/25/2023 01:42:57' prior: 50702828!
test13reportsTransferNetForPortfoliosWithMultipleAccounts
	
	|withdrawAccount depositAccount expectedValue portfolio|
	
	withdrawAccount := ReceptiveAccount new.
	depositAccount := ReceptiveAccount new.
	
	portfolio := Portfolio with: withdrawAccount.
	portfolio add: depositAccount.
	
	Transfer for: 10 from: withdrawAccount to: depositAccount.
	Transfer for: 50 from: depositAccount to: withdrawAccount.
	
	expectedValue := 0.
	
	self assert: portfolio reportTransferNet = expectedValue.! !

!testRun: #XXXTest #test13reportsTransferNetForPortfoliosWithMultipleAccounts stamp: 'LK 10/25/2023 01:43:01'!
ERROR!
!Portfolio methodsFor: 'transactions' stamp: 'LK 10/25/2023 01:43:09'!
reportTransferNet
	self shouldBeImplemented.! !
!Portfolio methodsFor: 'transactions' stamp: 'LK 10/25/2023 01:43:40' prior: 50702866!
reportTransferNet
	^0.! !

!testRun: #XXXTest #test13reportsTransferNetForPortfoliosWithMultipleAccounts stamp: 'LK 10/25/2023 01:43:42'!
PASSED!
!Portfolio methodsFor: 'transactions' stamp: 'LK 10/25/2023 01:44:46' prior: 50702871!
reportTransferNet
	^accounts sum: [:anAccount | anAccount reportTransferNet].! !

!testRun: #XXXTest #test13reportsTransferNetForPortfoliosWithMultipleAccounts stamp: 'LK 10/25/2023 01:44:49'!
PASSED!
!XXXTest methodsFor: 'testing' stamp: 'LK 10/25/2023 01:45:00' prior: 50702844!
test13reportsTransferNetForPortfoliosWithMultipleAccounts
	
	|withdrawAccount depositAccount expectedValue portfolio|
	
	withdrawAccount := ReceptiveAccount new.
	depositAccount := ReceptiveAccount new.
	
	portfolio := Portfolio with: withdrawAccount.
	portfolio add: depositAccount.
	
	Transfer for: 10 from: withdrawAccount to: depositAccount.
	
	expectedValue := 0.
	
	self assert: portfolio reportTransferNet = expectedValue.! !

!testRun: #XXXTest #test13reportsTransferNetForPortfoliosWithMultipleAccounts stamp: 'LK 10/25/2023 01:45:01'!
PASSED!

!testRun: #XXXTest #test01trasferringModifiesBalanceByCorrectAmount stamp: 'LK 10/25/2023 01:45:01'!
PASSED!

!testRun: #XXXTest #test02transferringGetsRegisteredInBothAccounts stamp: 'LK 10/25/2023 01:45:01'!
PASSED!

!testRun: #XXXTest #test03canNavigateBetweenTransferLegs stamp: 'LK 10/25/2023 01:45:01'!
PASSED!

!testRun: #XXXTest #test04reportsAccountSummaryOfEmptyAccount stamp: 'LK 10/25/2023 01:45:01'!
PASSED!

!testRun: #XXXTest #test05reportsAccountSummaryWithWithdrawal stamp: 'LK 10/25/2023 01:45:01'!
PASSED!

!testRun: #XXXTest #test06reportsAccountSummaryWithDeposit stamp: 'LK 10/25/2023 01:45:01'!
PASSED!

!testRun: #XXXTest #test07reportsAccountSummaryWithDepositTransferLeg stamp: 'LK 10/25/2023 01:45:01'!
PASSED!

!testRun: #XXXTest #test08reportsAccountSummaryWithWithdrawTransferLeg stamp: 'LK 10/25/2023 01:45:01'!
PASSED!

!testRun: #XXXTest #test09reportsPortfolioSummaryWithManyAccounts stamp: 'LK 10/25/2023 01:45:01'!
PASSED!

!testRun: #XXXTest #test10reportsTransferNetForWithdrawLegs stamp: 'LK 10/25/2023 01:45:01'!
PASSED!

!testRun: #XXXTest #test11reportsTransferNetForDepositLegs stamp: 'LK 10/25/2023 01:45:01'!
PASSED!

!testRun: #XXXTest #test12reportsTransferNetForMultipleTransfers stamp: 'LK 10/25/2023 01:45:01'!
PASSED!

!testRun: #XXXTest #test13reportsTransferNetForPortfoliosWithMultipleAccounts stamp: 'LK 10/25/2023 01:45:01'!
PASSED!

!testRun: #XXXTest #test13reportsTransferNetForPortfoliosWithMultipleAccounts stamp: 'LK 10/25/2023 01:45:06'!
PASSED!

!testRun: #XXXTest #test01trasferringModifiesBalanceByCorrectAmount stamp: 'LK 10/25/2023 01:45:06'!
PASSED!

!testRun: #XXXTest #test02transferringGetsRegisteredInBothAccounts stamp: 'LK 10/25/2023 01:45:06'!
PASSED!

!testRun: #XXXTest #test03canNavigateBetweenTransferLegs stamp: 'LK 10/25/2023 01:45:06'!
PASSED!

!testRun: #XXXTest #test04reportsAccountSummaryOfEmptyAccount stamp: 'LK 10/25/2023 01:45:06'!
PASSED!

!testRun: #XXXTest #test05reportsAccountSummaryWithWithdrawal stamp: 'LK 10/25/2023 01:45:06'!
PASSED!

!testRun: #XXXTest #test06reportsAccountSummaryWithDeposit stamp: 'LK 10/25/2023 01:45:06'!
PASSED!

!testRun: #XXXTest #test07reportsAccountSummaryWithDepositTransferLeg stamp: 'LK 10/25/2023 01:45:06'!
PASSED!

!testRun: #XXXTest #test08reportsAccountSummaryWithWithdrawTransferLeg stamp: 'LK 10/25/2023 01:45:06'!
PASSED!

!testRun: #XXXTest #test09reportsPortfolioSummaryWithManyAccounts stamp: 'LK 10/25/2023 01:45:06'!
PASSED!

!testRun: #XXXTest #test10reportsTransferNetForWithdrawLegs stamp: 'LK 10/25/2023 01:45:06'!
PASSED!

!testRun: #XXXTest #test11reportsTransferNetForDepositLegs stamp: 'LK 10/25/2023 01:45:06'!
PASSED!

!testRun: #XXXTest #test12reportsTransferNetForMultipleTransfers stamp: 'LK 10/25/2023 01:45:06'!
PASSED!

!testRun: #XXXTest #test13reportsTransferNetForPortfoliosWithMultipleAccounts stamp: 'LK 10/25/2023 01:45:06'!
PASSED!

TestCase subclass: #Portfolio2Test
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #Portfolio2Test category: 'Portfolio-Solucion' stamp: 'LK 10/25/2023 01:46:57'!
TestCase subclass: #Portfolio2Test
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classRemoval: #Portfolio2Test stamp: 'LK 10/25/2023 01:47:03'!
TestCase subclass: #Portfolio2Test
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classRenamed: #XXXTest as: #Portfolio2Test stamp: 'LK 10/25/2023 01:47:07'!
Smalltalk renameClassNamed: #XXXTest as: #Portfolio2Test!

----QUIT----(25 October 2023 01:47:31) CuisUniversity-5981.image priorSource: 11791185!

----STARTUP---- (26 October 2023 11:36:29) as C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\CuisUniversity-5981.image!


Object subclass: #AccountSummary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #AccountSummary category: 'Portfolio-Solucion' stamp: 'LK 10/26/2023 11:55:21'!
Object subclass: #AccountSummary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classRenamed: #AccountSummary as: #AccountSummaryReport stamp: 'LK 10/26/2023 11:55:31'!
Smalltalk renameClassNamed: #AccountSummary as: #AccountSummaryReport!
!AccountSummaryReport class methodsFor: 'nil' stamp: 'LK 10/26/2023 11:59:05'!
for: xxx
	
	^self new initializeFor: xxx.! !

!classDefinition: #AccountSummaryReport category: 'Portfolio-Solucion' stamp: 'LK 10/26/2023 12:00:21'!
Object subclass: #AccountSummaryReport
	instanceVariableNames: 'xx'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!
!AccountSummaryReport methodsFor: 'no messages' stamp: 'LK 10/26/2023 12:00:19'!
initializeFor: xxx
	
	xx := xxx.! !

!classDefinition: #AccountSummaryReport category: 'Portfolio-Solucion' stamp: 'LK 10/26/2023 12:00:43'!
Object subclass: #AccountSummaryReport
	instanceVariableNames: 'xx account'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!
!AccountSummaryReport methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 12:00:41' prior: 50703057!
initializeFor: anAccount
	
	account := anAccount.! !
!AccountSummaryReport class methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 12:00:51' prior: 50703045!
for: anAccount
	
	^self new initializeFor: anAccount.! !
!AccountSummaryReport methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 12:01:25'!
process: s! !

Object subclass: #AccountSummaryReport
	instanceVariableNames: 'reports account'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #AccountSummaryReport category: 'Portfolio-Solucion' stamp: 'LK 10/26/2023 12:01:45'!
Object subclass: #AccountSummaryReport
	instanceVariableNames: 'reports account'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!
!AccountSummaryReport methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 12:01:56' prior: 50703070!
initializeFor: anAccount
	
	account := anAccount.
	reports := OrderedCollection new.! !

Object subclass: #TransferNetReport
	instanceVariableNames: 'reports account'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #TransferNetReport category: 'Portfolio-Solucion' stamp: 'LK 10/26/2023 12:03:19'!
Object subclass: #TransferNetReport
	instanceVariableNames: 'reports account'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

Object subclass: #Report
	instanceVariableNames: 'reports account'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #Report category: 'Portfolio-Solucion' stamp: 'LK 10/26/2023 12:03:25'!
Object subclass: #Report
	instanceVariableNames: 'reports account'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classRemoval: #Report stamp: 'LK 10/26/2023 12:03:33'!
Object subclass: #Report
	instanceVariableNames: 'reports account'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

Object subclass: #NodeVisitor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #NodeVisitor category: 'Portfolio-Solucion' stamp: 'LK 10/26/2023 12:03:46'!
Object subclass: #NodeVisitor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

NodeVisitor subclass: #TransferNetReport
	instanceVariableNames: 'reports account'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #TransferNetReport category: 'Portfolio-Solucion' stamp: 'LK 10/26/2023 12:06:24'!
NodeVisitor subclass: #TransferNetReport
	instanceVariableNames: 'reports account'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

NodeVisitor subclass: #AccountSummaryReport
	instanceVariableNames: 'reports account'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #AccountSummaryReport category: 'Portfolio-Solucion' stamp: 'LK 10/26/2023 12:06:34'!
NodeVisitor subclass: #AccountSummaryReport
	instanceVariableNames: 'reports account'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

Object subclass: #NodeVisitor
	instanceVariableNames: 'account'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

NodeVisitor subclass: #AccountSummaryReport
	instanceVariableNames: 'reports'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #AccountSummaryReport category: 'Portfolio-Solucion' stamp: 'LK 10/26/2023 12:07:03'!
NodeVisitor subclass: #AccountSummaryReport
	instanceVariableNames: 'reports'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

Object subclass: #NodeVisitor
	instanceVariableNames: 'account'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

NodeVisitor subclass: #TransferNetReport
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #TransferNetReport category: 'Portfolio-Solucion' stamp: 'LK 10/26/2023 12:07:15'!
NodeVisitor subclass: #TransferNetReport
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

Object subclass: #NodeVisitor
	instanceVariableNames: 'account'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #NodeVisitor category: 'Portfolio-Solucion' stamp: 'LK 10/26/2023 12:07:25'!
Object subclass: #NodeVisitor
	instanceVariableNames: 'account'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

NodeVisitor subclass: #TransferNetReport
	instanceVariableNames: 'netValue'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #TransferNetReport category: 'Portfolio-Solucion' stamp: 'LK 10/26/2023 12:07:36'!
NodeVisitor subclass: #TransferNetReport
	instanceVariableNames: 'netValue'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #AccountSummaryReport category: 'Portfolio-Solucion' stamp: 'LK 10/26/2023 12:07:52'!
NodeVisitor subclass: #AccountSummaryReport
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #NodeVisitor category: 'Portfolio-Solucion' stamp: 'LK 10/26/2023 12:07:53'!
Object subclass: #NodeVisitor
	instanceVariableNames: 'account reports'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!
!NodeVisitor methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 12:07:53'!
initializeFor: anAccount
	
	account := anAccount.
	reports := OrderedCollection new.! !

!methodRemoval: AccountSummaryReport #initializeFor: stamp: 'LK 10/26/2023 12:07:53'!
initializeFor: anAccount
	
	account := anAccount.
	reports := OrderedCollection new.!
!NodeVisitor methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 12:08:01' prior: 50703250!
initializeFor: anAccount
	
	account := anAccount.! !

!methodRemoval: AccountSummaryReport #process: stamp: 'LK 10/26/2023 12:09:02'!
process: s!

NodeVisitor subclass: #AccountSummaryReport
	instanceVariableNames: 'reports'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

Object subclass: #NodeVisitor
	instanceVariableNames: 'account'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #NodeVisitor category: 'Portfolio-Solucion' stamp: 'LK 10/26/2023 12:09:19'!
Object subclass: #NodeVisitor
	instanceVariableNames: 'account'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

NodeVisitor subclass: #AccountSummaryReport
	instanceVariableNames: 'reports'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #AccountSummaryReport category: 'Portfolio-Solucion' stamp: 'LK 10/26/2023 12:09:22'!
NodeVisitor subclass: #AccountSummaryReport
	instanceVariableNames: 'reports'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!
!AccountSummaryReport methodsFor: 'nil' stamp: 'LK 10/26/2023 12:09:40' overrides: 16920235!
initialize

	reports := OrderedCollection new.! !
!TransferNetReport methodsFor: 'no messages' stamp: 'LK 10/26/2023 12:09:52' overrides: 16920235!
initialize
	
	netValue := 0.! !
!NodeVisitor methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 12:34:40'!
process
	! !
!TransferNetReport methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 12:37:30' overrides: 50703309!
process
	! !
!AccountSummaryReport methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 12:37:30' overrides: 50703309!
process
	! !
!NodeVisitor methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 12:37:30' prior: 50703309!
process

	self subclassResponsibility! !
!AccountSummaryReport methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 12:37:57' prior: 50703317 overrides: 50703321!
process

	^account reportAccountSummary.! !
!TransferNetReport methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 12:38:26' prior: 50703313 overrides: 50703321!
process
	
	netValue := account reportTransferNet 
	^netValue! !
!AccountSummaryReport methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 12:38:35' prior: 50703327 overrides: 50703321!
process

	account reportAccountSummary.! !
!AccountSummaryReport methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 12:38:46' prior: 50703339 overrides: 50703321!
process

	reports := account reportAccountSummary.
	^reports.! !
!Portfolio2Test methodsFor: 'testing' stamp: 'LK 10/26/2023 12:41:46' prior: 50702230!
test04reportsAccountSummaryOfEmptyAccount

	|account expectedString s| 
	
	account := ReceptiveAccount new.
	
	
	s := AccountSummaryReport for: account.
	
	
	expectedString := OrderedCollection new.
	expectedString add: 'Balance = 0'.
	
	self assert: expectedString = s process.! !

!testRun: #Portfolio2Test #test04reportsAccountSummaryOfEmptyAccount stamp: 'LK 10/26/2023 12:41:47'!
PASSED!

!testRun: #Portfolio2Test #test01trasferringModifiesBalanceByCorrectAmount stamp: 'LK 10/26/2023 12:41:47'!
PASSED!

!testRun: #Portfolio2Test #test02transferringGetsRegisteredInBothAccounts stamp: 'LK 10/26/2023 12:41:47'!
PASSED!

!testRun: #Portfolio2Test #test03canNavigateBetweenTransferLegs stamp: 'LK 10/26/2023 12:41:47'!
PASSED!

!testRun: #Portfolio2Test #test04reportsAccountSummaryOfEmptyAccount stamp: 'LK 10/26/2023 12:41:47'!
PASSED!

!testRun: #Portfolio2Test #test05reportsAccountSummaryWithWithdrawal stamp: 'LK 10/26/2023 12:41:47'!
PASSED!

!testRun: #Portfolio2Test #test06reportsAccountSummaryWithDeposit stamp: 'LK 10/26/2023 12:41:47'!
PASSED!

!testRun: #Portfolio2Test #test07reportsAccountSummaryWithDepositTransferLeg stamp: 'LK 10/26/2023 12:41:47'!
PASSED!

!testRun: #Portfolio2Test #test08reportsAccountSummaryWithWithdrawTransferLeg stamp: 'LK 10/26/2023 12:41:47'!
PASSED!

!testRun: #Portfolio2Test #test09reportsPortfolioSummaryWithManyAccounts stamp: 'LK 10/26/2023 12:41:47'!
PASSED!

!testRun: #Portfolio2Test #test10reportsTransferNetForWithdrawLegs stamp: 'LK 10/26/2023 12:41:47'!
PASSED!

!testRun: #Portfolio2Test #test11reportsTransferNetForDepositLegs stamp: 'LK 10/26/2023 12:41:47'!
PASSED!

!testRun: #Portfolio2Test #test12reportsTransferNetForMultipleTransfers stamp: 'LK 10/26/2023 12:41:47'!
PASSED!

!testRun: #Portfolio2Test #test13reportsTransferNetForPortfoliosWithMultipleAccounts stamp: 'LK 10/26/2023 12:41:47'!
PASSED!
!Portfolio2Test methodsFor: 'testing' stamp: 'LK 10/26/2023 12:42:38' prior: 50703350!
test04reportsAccountSummaryOfEmptyAccount

	|account expectedString report| 
	
	account := ReceptiveAccount new.
	report := AccountSummaryReport for: account.
	
	
	expectedString := OrderedCollection new.
	expectedString add: 'Balance = 0'.
	
	self assert: expectedString = report process.! !
!Portfolio2Test methodsFor: 'testing' stamp: 'LK 10/26/2023 12:42:49' prior: 50702251!
test05reportsAccountSummaryWithWithdrawal

	|account deposit expectedString report| 
	
	account := ReceptiveAccount new.
	deposit := Withdraw register: 50 on: account.
	
	expectedString := OrderedCollection new.
	expectedString add: 'Extracción por 50.'.
	expectedString add: 'Balance = -50'.
	
	self assert: expectedString = account reportAccountSummary.
	
	! !
!Portfolio2Test methodsFor: 'testing' stamp: 'LK 10/26/2023 12:43:34' prior: 50703424!
test05reportsAccountSummaryWithWithdrawal

	|account  expectedString report| 
	
	account := ReceptiveAccount new.
	Withdraw register: 50 on: account.
	report := AccountSummaryReport for: account.
	
	expectedString := OrderedCollection new.
	expectedString add: 'Extracción por 50.'.
	expectedString add: 'Balance = -50'.
	
	self assert: expectedString = report process.
	
	! !

!testRun: #Portfolio2Test #test05reportsAccountSummaryWithWithdrawal stamp: 'LK 10/26/2023 12:43:36'!
PASSED!
!Portfolio2Test methodsFor: 'testing' stamp: 'LK 10/26/2023 12:45:25' prior: 50702278!
test06reportsAccountSummaryWithDeposit

	|account report expectedString| 
	
	account := ReceptiveAccount new.
	Deposit register: 50 on: account.
	report := AccountSummaryReport for: account.
	
	expectedString := OrderedCollection new.
	expectedString add: 'Depósito por 50.'.
	expectedString add: 'Balance = 50'.
	
	self assert: expectedString = account reportAccountSummary.
	
	! !
!Portfolio2Test methodsFor: 'testing' stamp: 'LK 10/26/2023 12:45:37' prior: 50703457!
test06reportsAccountSummaryWithDeposit

	|account report expectedString| 
	
	account := ReceptiveAccount new.
	Deposit register: 50 on: account.
	report := AccountSummaryReport for: account.
	
	expectedString := OrderedCollection new.
	expectedString add: 'Depósito por 50.'.
	expectedString add: 'Balance = 50'.
	
	self assert: expectedString = report process.
	
	! !

!testRun: #Portfolio2Test #test06reportsAccountSummaryWithDeposit stamp: 'LK 10/26/2023 12:45:40'!
PASSED!
!Portfolio2Test methodsFor: 'testing' stamp: 'LK 10/26/2023 12:46:23' prior: 50702580!
test07reportsAccountSummaryWithDepositTransferLeg

	|depositAccount withdrawAccount expectedString report| 
	
	depositAccount := ReceptiveAccount new.
	withdrawAccount := ReceptiveAccount new.
	Transfer for: 30 from: withdrawAccount to: depositAccount.
	report := AccountSummaryReport for: depositAccount.
	
	expectedString := OrderedCollection new.
	expectedString add: 'Entrada por transferencia por 30.'.
	expectedString add: 'Balance = 30'.
	
	self assert: expectedString = report process.
	
	! !

!testRun: #Portfolio2Test #test07reportsAccountSummaryWithDepositTransferLeg stamp: 'LK 10/26/2023 12:46:25'!
PASSED!

!testRun: #Portfolio2Test #test01trasferringModifiesBalanceByCorrectAmount stamp: 'LK 10/26/2023 12:46:25'!
PASSED!

!testRun: #Portfolio2Test #test02transferringGetsRegisteredInBothAccounts stamp: 'LK 10/26/2023 12:46:25'!
PASSED!

!testRun: #Portfolio2Test #test03canNavigateBetweenTransferLegs stamp: 'LK 10/26/2023 12:46:25'!
PASSED!

!testRun: #Portfolio2Test #test04reportsAccountSummaryOfEmptyAccount stamp: 'LK 10/26/2023 12:46:25'!
PASSED!

!testRun: #Portfolio2Test #test05reportsAccountSummaryWithWithdrawal stamp: 'LK 10/26/2023 12:46:25'!
PASSED!

!testRun: #Portfolio2Test #test06reportsAccountSummaryWithDeposit stamp: 'LK 10/26/2023 12:46:25'!
PASSED!

!testRun: #Portfolio2Test #test07reportsAccountSummaryWithDepositTransferLeg stamp: 'LK 10/26/2023 12:46:25'!
PASSED!

!testRun: #Portfolio2Test #test08reportsAccountSummaryWithWithdrawTransferLeg stamp: 'LK 10/26/2023 12:46:25'!
PASSED!

!testRun: #Portfolio2Test #test09reportsPortfolioSummaryWithManyAccounts stamp: 'LK 10/26/2023 12:46:25'!
PASSED!

!testRun: #Portfolio2Test #test10reportsTransferNetForWithdrawLegs stamp: 'LK 10/26/2023 12:46:25'!
PASSED!

!testRun: #Portfolio2Test #test11reportsTransferNetForDepositLegs stamp: 'LK 10/26/2023 12:46:25'!
PASSED!

!testRun: #Portfolio2Test #test12reportsTransferNetForMultipleTransfers stamp: 'LK 10/26/2023 12:46:25'!
PASSED!

!testRun: #Portfolio2Test #test13reportsTransferNetForPortfoliosWithMultipleAccounts stamp: 'LK 10/26/2023 12:46:26'!
PASSED!
!Portfolio2Test methodsFor: 'testing' stamp: 'LK 10/26/2023 12:46:52' prior: 50702601!
test08reportsAccountSummaryWithWithdrawTransferLeg

	|depositAccount withdrawAccount expectedString report| 
	
	depositAccount := ReceptiveAccount new.
	withdrawAccount := ReceptiveAccount new.
	Transfer for: 30 from: withdrawAccount to: depositAccount.
	report := AccountSummaryReport for: withdrawAccount.
	
	expectedString := OrderedCollection new.
	expectedString add: 'Salida por transferencia por 30.'.
	expectedString add: 'Balance = -30'.
	
	self assert: expectedString = report process.
	
	! !

!testRun: #Portfolio2Test #test08reportsAccountSummaryWithWithdrawTransferLeg stamp: 'LK 10/26/2023 12:46:53'!
PASSED!

!testRun: #Portfolio2Test #test01trasferringModifiesBalanceByCorrectAmount stamp: 'LK 10/26/2023 12:46:53'!
PASSED!

!testRun: #Portfolio2Test #test02transferringGetsRegisteredInBothAccounts stamp: 'LK 10/26/2023 12:46:53'!
PASSED!

!testRun: #Portfolio2Test #test03canNavigateBetweenTransferLegs stamp: 'LK 10/26/2023 12:46:53'!
PASSED!

!testRun: #Portfolio2Test #test04reportsAccountSummaryOfEmptyAccount stamp: 'LK 10/26/2023 12:46:53'!
PASSED!

!testRun: #Portfolio2Test #test05reportsAccountSummaryWithWithdrawal stamp: 'LK 10/26/2023 12:46:53'!
PASSED!

!testRun: #Portfolio2Test #test06reportsAccountSummaryWithDeposit stamp: 'LK 10/26/2023 12:46:53'!
PASSED!

!testRun: #Portfolio2Test #test07reportsAccountSummaryWithDepositTransferLeg stamp: 'LK 10/26/2023 12:46:53'!
PASSED!

!testRun: #Portfolio2Test #test08reportsAccountSummaryWithWithdrawTransferLeg stamp: 'LK 10/26/2023 12:46:53'!
PASSED!

!testRun: #Portfolio2Test #test09reportsPortfolioSummaryWithManyAccounts stamp: 'LK 10/26/2023 12:46:53'!
PASSED!

!testRun: #Portfolio2Test #test10reportsTransferNetForWithdrawLegs stamp: 'LK 10/26/2023 12:46:53'!
PASSED!

!testRun: #Portfolio2Test #test11reportsTransferNetForDepositLegs stamp: 'LK 10/26/2023 12:46:53'!
PASSED!

!testRun: #Portfolio2Test #test12reportsTransferNetForMultipleTransfers stamp: 'LK 10/26/2023 12:46:53'!
PASSED!

!testRun: #Portfolio2Test #test13reportsTransferNetForPortfoliosWithMultipleAccounts stamp: 'LK 10/26/2023 12:46:53'!
PASSED!
!Portfolio2Test methodsFor: 'testing' stamp: 'LK 10/26/2023 12:47:21' prior: 50702369!
test09reportsPortfolioSummaryWithManyAccounts

	| account portfolio accountDeposit anotherAccount anotherAccountWithdraw expectedString report|
	
	account := ReceptiveAccount new.
	accountDeposit := Deposit register: 100 on: account.
	anotherAccount := ReceptiveAccount new.
	anotherAccountWithdraw := Withdraw register: 100 on: account.
	portfolio := Portfolio with: account.
	report := AccountSummaryReport for: portfolio.
		
	expectedString := OrderedCollection new.
	expectedString addLast: 'Depósito por 100.'.
	expectedString addLast: 'Extracción por 100.'.
	expectedString addLast: 'Balance = 0'.
	
	self assert: expectedString = report process.
	
	! !
!Portfolio2Test methodsFor: 'testing' stamp: 'LK 10/26/2023 12:48:34' prior: 50703628!
test09reportsPortfolioSummaryWithManyAccounts

	| account portfolio accountDeposit anotherAccount anotherAccountWithdraw expectedString report|
	
	account := ReceptiveAccount new.
	accountDeposit := Deposit register: 100 on: account.
	anotherAccount := ReceptiveAccount new.
	anotherAccountWithdraw := Withdraw register: 100 on: anotherAccount.
	portfolio := Portfolio with: account.
	portfolio add: anotherAccount.
	report := AccountSummaryReport for: portfolio.
		
	expectedString := OrderedCollection new.
	expectedString addLast: 'Depósito por 100.'.
	expectedString addLast: 'Extracción por 100.'.
	expectedString addLast: 'Balance = 0'.
	
	self assert: expectedString = report process.
	
	! !

!testRun: #Portfolio2Test #test09reportsPortfolioSummaryWithManyAccounts stamp: 'LK 10/26/2023 12:48:50'!
PASSED!

!testRun: #Portfolio2Test #test01trasferringModifiesBalanceByCorrectAmount stamp: 'LK 10/26/2023 12:48:50'!
PASSED!

!testRun: #Portfolio2Test #test02transferringGetsRegisteredInBothAccounts stamp: 'LK 10/26/2023 12:48:50'!
PASSED!

!testRun: #Portfolio2Test #test03canNavigateBetweenTransferLegs stamp: 'LK 10/26/2023 12:48:50'!
PASSED!

!testRun: #Portfolio2Test #test04reportsAccountSummaryOfEmptyAccount stamp: 'LK 10/26/2023 12:48:51'!
PASSED!

!testRun: #Portfolio2Test #test05reportsAccountSummaryWithWithdrawal stamp: 'LK 10/26/2023 12:48:51'!
PASSED!

!testRun: #Portfolio2Test #test06reportsAccountSummaryWithDeposit stamp: 'LK 10/26/2023 12:48:51'!
PASSED!

!testRun: #Portfolio2Test #test07reportsAccountSummaryWithDepositTransferLeg stamp: 'LK 10/26/2023 12:48:51'!
PASSED!

!testRun: #Portfolio2Test #test08reportsAccountSummaryWithWithdrawTransferLeg stamp: 'LK 10/26/2023 12:48:51'!
PASSED!

!testRun: #Portfolio2Test #test09reportsPortfolioSummaryWithManyAccounts stamp: 'LK 10/26/2023 12:48:51'!
PASSED!

!testRun: #Portfolio2Test #test10reportsTransferNetForWithdrawLegs stamp: 'LK 10/26/2023 12:48:51'!
PASSED!

!testRun: #Portfolio2Test #test11reportsTransferNetForDepositLegs stamp: 'LK 10/26/2023 12:48:51'!
PASSED!

!testRun: #Portfolio2Test #test12reportsTransferNetForMultipleTransfers stamp: 'LK 10/26/2023 12:48:51'!
PASSED!

!testRun: #Portfolio2Test #test13reportsTransferNetForPortfoliosWithMultipleAccounts stamp: 'LK 10/26/2023 12:48:51'!
PASSED!
!Portfolio2Test methodsFor: 'testing' stamp: 'LK 10/26/2023 12:49:16' prior: 50703652!
test09reportsPortfolioSummaryWithManyAccounts

	| account portfolio anotherAccount expectedString report|
	
	account := ReceptiveAccount new.
	Deposit register: 100 on: account.
	anotherAccount := ReceptiveAccount new.
	Withdraw register: 100 on: anotherAccount.
	portfolio := Portfolio with: account.
	portfolio add: anotherAccount.
	report := AccountSummaryReport for: portfolio.
		
	expectedString := OrderedCollection new.
	expectedString addLast: 'Depósito por 100.'.
	expectedString addLast: 'Extracción por 100.'.
	expectedString addLast: 'Balance = 0'.
	
	self assert: expectedString = report process.
	
	! !

!testRun: #Portfolio2Test #test09reportsPortfolioSummaryWithManyAccounts stamp: 'LK 10/26/2023 12:49:17'!
PASSED!

!testRun: #Portfolio2Test #test01trasferringModifiesBalanceByCorrectAmount stamp: 'LK 10/26/2023 12:49:17'!
PASSED!

!testRun: #Portfolio2Test #test02transferringGetsRegisteredInBothAccounts stamp: 'LK 10/26/2023 12:49:17'!
PASSED!

!testRun: #Portfolio2Test #test03canNavigateBetweenTransferLegs stamp: 'LK 10/26/2023 12:49:17'!
PASSED!

!testRun: #Portfolio2Test #test04reportsAccountSummaryOfEmptyAccount stamp: 'LK 10/26/2023 12:49:17'!
PASSED!

!testRun: #Portfolio2Test #test05reportsAccountSummaryWithWithdrawal stamp: 'LK 10/26/2023 12:49:17'!
PASSED!

!testRun: #Portfolio2Test #test06reportsAccountSummaryWithDeposit stamp: 'LK 10/26/2023 12:49:17'!
PASSED!

!testRun: #Portfolio2Test #test07reportsAccountSummaryWithDepositTransferLeg stamp: 'LK 10/26/2023 12:49:17'!
PASSED!

!testRun: #Portfolio2Test #test08reportsAccountSummaryWithWithdrawTransferLeg stamp: 'LK 10/26/2023 12:49:17'!
PASSED!

!testRun: #Portfolio2Test #test09reportsPortfolioSummaryWithManyAccounts stamp: 'LK 10/26/2023 12:49:17'!
PASSED!

!testRun: #Portfolio2Test #test10reportsTransferNetForWithdrawLegs stamp: 'LK 10/26/2023 12:49:17'!
PASSED!

!testRun: #Portfolio2Test #test11reportsTransferNetForDepositLegs stamp: 'LK 10/26/2023 12:49:17'!
PASSED!

!testRun: #Portfolio2Test #test12reportsTransferNetForMultipleTransfers stamp: 'LK 10/26/2023 12:49:17'!
PASSED!

!testRun: #Portfolio2Test #test13reportsTransferNetForPortfoliosWithMultipleAccounts stamp: 'LK 10/26/2023 12:49:17'!
PASSED!
!Portfolio2Test methodsFor: 'testing' stamp: 'LK 10/26/2023 12:49:57' prior: 50702736!
test10reportsTransferNetForWithdrawLegs
	
	|withdrawAccount depositAccount expectedValue report|
	
	withdrawAccount := ReceptiveAccount new.
	depositAccount := ReceptiveAccount new.
	Transfer for: 10 from: withdrawAccount to: depositAccount.
	report := TransferNetReport for: withdrawAccount.
	
	expectedValue := -10.
	
	self assert: report process = expectedValue.! !
!Portfolio2Test methodsFor: 'testing' stamp: 'LK 10/26/2023 12:50:24' prior: 50702760!
test11reportsTransferNetForDepositLegs
	
	|withdrawAccount depositAccount expectedValue report|
	
	withdrawAccount := ReceptiveAccount new.
	depositAccount := ReceptiveAccount new.
	Transfer for: 10 from: withdrawAccount to: depositAccount.
	report := TransferNetReport for: depositAccount.
	
	expectedValue := 10.
	
	self assert: report process = expectedValue.! !

!testRun: #Portfolio2Test #test11reportsTransferNetForDepositLegs stamp: 'LK 10/26/2023 12:50:24'!
ERROR!

!testRun: #Portfolio2Test #test10reportsTransferNetForWithdrawLegs stamp: 'LK 10/26/2023 12:50:53'!
ERROR!
!TransferNetReport class methodsFor: 'no messages' stamp: 'LK 10/26/2023 12:51:34'!
for: anAccount
	
	^self new initializeFor: anAccount.! !

!testRun: #Portfolio2Test #test10reportsTransferNetForWithdrawLegs stamp: 'LK 10/26/2023 12:52:25'!
FAILURE!
!TransferNetReport methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 12:52:55' prior: 50703333 overrides: 50703321!
process
	
	netValue := account reportTransferNet.
	
	^netValue! !

!testRun: #Portfolio2Test #test10reportsTransferNetForWithdrawLegs stamp: 'LK 10/26/2023 12:52:59'!
PASSED!

!testRun: #Portfolio2Test #test11reportsTransferNetForDepositLegs stamp: 'LK 10/26/2023 12:53:11'!
PASSED!
!Portfolio2Test methodsFor: 'testing' stamp: 'LK 10/26/2023 12:53:55' prior: 50702784!
test12reportsTransferNetForMultipleTransfers
	
	|withdrawAccount depositAccount expectedValue report|
	
	withdrawAccount := ReceptiveAccount new.
	depositAccount := ReceptiveAccount new.
	Transfer for: 10 from: withdrawAccount to: depositAccount.
	Transfer for: 50 from: depositAccount to: withdrawAccount.
	report := TransferNetReport for: depositAccount.
		
	expectedValue := -40.
	
	self assert: report process = expectedValue.! !

!testRun: #Portfolio2Test #test12reportsTransferNetForMultipleTransfers stamp: 'LK 10/26/2023 12:53:56'!
PASSED!

!testRun: #Portfolio2Test #test01trasferringModifiesBalanceByCorrectAmount stamp: 'LK 10/26/2023 12:53:56'!
PASSED!

!testRun: #Portfolio2Test #test02transferringGetsRegisteredInBothAccounts stamp: 'LK 10/26/2023 12:53:56'!
PASSED!

!testRun: #Portfolio2Test #test03canNavigateBetweenTransferLegs stamp: 'LK 10/26/2023 12:53:56'!
PASSED!

!testRun: #Portfolio2Test #test04reportsAccountSummaryOfEmptyAccount stamp: 'LK 10/26/2023 12:53:56'!
PASSED!

!testRun: #Portfolio2Test #test05reportsAccountSummaryWithWithdrawal stamp: 'LK 10/26/2023 12:53:56'!
PASSED!

!testRun: #Portfolio2Test #test06reportsAccountSummaryWithDeposit stamp: 'LK 10/26/2023 12:53:56'!
PASSED!

!testRun: #Portfolio2Test #test07reportsAccountSummaryWithDepositTransferLeg stamp: 'LK 10/26/2023 12:53:56'!
PASSED!

!testRun: #Portfolio2Test #test08reportsAccountSummaryWithWithdrawTransferLeg stamp: 'LK 10/26/2023 12:53:56'!
PASSED!

!testRun: #Portfolio2Test #test09reportsPortfolioSummaryWithManyAccounts stamp: 'LK 10/26/2023 12:53:56'!
PASSED!

!testRun: #Portfolio2Test #test10reportsTransferNetForWithdrawLegs stamp: 'LK 10/26/2023 12:53:56'!
PASSED!

!testRun: #Portfolio2Test #test11reportsTransferNetForDepositLegs stamp: 'LK 10/26/2023 12:53:56'!
PASSED!

!testRun: #Portfolio2Test #test12reportsTransferNetForMultipleTransfers stamp: 'LK 10/26/2023 12:53:56'!
PASSED!

!testRun: #Portfolio2Test #test13reportsTransferNetForPortfoliosWithMultipleAccounts stamp: 'LK 10/26/2023 12:53:56'!
PASSED!
!Portfolio2Test methodsFor: 'testing' stamp: 'LK 10/26/2023 12:54:30' prior: 50702888!
test13reportsTransferNetForPortfoliosWithMultipleAccounts
	
	|withdrawAccount depositAccount expectedValue portfolio report|
	
	withdrawAccount := ReceptiveAccount new.
	depositAccount := ReceptiveAccount new.
	portfolio := Portfolio with: withdrawAccount.
	portfolio add: depositAccount.
	Transfer for: 10 from: withdrawAccount to: depositAccount.
	report := TransferNetReport for: portfolio.
	
	expectedValue := 0.
	
	self assert: report process = expectedValue.! !

!testRun: #Portfolio2Test #test13reportsTransferNetForPortfoliosWithMultipleAccounts stamp: 'LK 10/26/2023 12:54:32'!
PASSED!

!testRun: #Portfolio2Test #test01trasferringModifiesBalanceByCorrectAmount stamp: 'LK 10/26/2023 12:54:32'!
PASSED!

!testRun: #Portfolio2Test #test02transferringGetsRegisteredInBothAccounts stamp: 'LK 10/26/2023 12:54:32'!
PASSED!

!testRun: #Portfolio2Test #test03canNavigateBetweenTransferLegs stamp: 'LK 10/26/2023 12:54:32'!
PASSED!

!testRun: #Portfolio2Test #test04reportsAccountSummaryOfEmptyAccount stamp: 'LK 10/26/2023 12:54:32'!
PASSED!

!testRun: #Portfolio2Test #test05reportsAccountSummaryWithWithdrawal stamp: 'LK 10/26/2023 12:54:32'!
PASSED!

!testRun: #Portfolio2Test #test06reportsAccountSummaryWithDeposit stamp: 'LK 10/26/2023 12:54:32'!
PASSED!

!testRun: #Portfolio2Test #test07reportsAccountSummaryWithDepositTransferLeg stamp: 'LK 10/26/2023 12:54:32'!
PASSED!

!testRun: #Portfolio2Test #test08reportsAccountSummaryWithWithdrawTransferLeg stamp: 'LK 10/26/2023 12:54:32'!
PASSED!

!testRun: #Portfolio2Test #test09reportsPortfolioSummaryWithManyAccounts stamp: 'LK 10/26/2023 12:54:32'!
PASSED!

!testRun: #Portfolio2Test #test10reportsTransferNetForWithdrawLegs stamp: 'LK 10/26/2023 12:54:32'!
PASSED!

!testRun: #Portfolio2Test #test11reportsTransferNetForDepositLegs stamp: 'LK 10/26/2023 12:54:32'!
PASSED!

!testRun: #Portfolio2Test #test12reportsTransferNetForMultipleTransfers stamp: 'LK 10/26/2023 12:54:33'!
PASSED!

!testRun: #Portfolio2Test #test13reportsTransferNetForPortfoliosWithMultipleAccounts stamp: 'LK 10/26/2023 12:54:33'!
PASSED!
!NodeVisitor methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 13:07:44' prior: 50703321!
process

	account processForReport: self.! !
!NodeVisitor methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 13:07:54' prior: 50703992!
process

	account processForReport: self.! !
!ReceptiveAccount methodsFor: 'testing' stamp: 'LK 10/26/2023 13:08:38'!
processForReport: aVisitor
! !
!ReceptiveAccount methodsFor: 'process' stamp: 'LK 10/26/2023 13:09:38' prior: 50704001!
processForReport: aVisitor

	transactions do: [:aTransaction | aTransaction processForReport: aVisitor]! !
!AccountTransaction methodsFor: 'nil' stamp: 'LK 10/26/2023 13:10:27'!
processForReport: aVisitor! !
!AccountTransaction methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 13:10:59' prior: 50704011!
processForReport: aVisitor
! !
!Deposit methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 13:11:08' overrides: 50704016!
processForReport: aVisitor
! !
!Withdraw methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 13:11:08' overrides: 50704016!
processForReport: aVisitor
! !
!TransferLegs methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 13:11:08' overrides: 50704016!
processForReport: aVisitor
! !
!AccountTransaction methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 13:11:08' prior: 50704016!
processForReport: aVisitor

	self subclassResponsibility! !
!Deposit methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 13:11:43' prior: 50704020 overrides: 50704034!
processForReport: aVisitor
	aVisitor processForDeposit: self.! !
!DepositLeg methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 13:11:56' overrides: 50704029!
processForReport: aVisitor
! !
!WithdrawLeg methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 13:11:56' overrides: 50704029!
processForReport: aVisitor
! !
!TransferLegs methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 13:11:56' prior: 50704029 overrides: 50704034!
processForReport: aVisitor

	self subclassResponsibility! !
!DepositLeg methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 13:12:09' prior: 50704046 overrides: 50704056!
processForReport: aVisitor

	aVisitor processForDepositLeg: self.! !
!WithdrawLeg methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 13:12:36' prior: 50704051 overrides: 50704056!
processForReport: aVisitor

	aVisitor processForWithdrawLeg: self.! !
!Withdraw methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 13:12:52' prior: 50704024 overrides: 50704034!
processForReport: aVisitor
	
	aVisitor processForWithdraw: self.! !
!AccountSummaryReport methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 13:13:25'!
processForWithdraw! !
!AccountSummaryReport methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 13:13:33'!
processForDeposit! !
!AccountSummaryReport methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 13:13:36'!
processForDepositLeg! !
!AccountSummaryReport methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 13:13:39'!
processForWithdrawLeg! !
!AccountSummaryReport methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 13:14:29'!
processForDeposit: aTransaction! !

!methodRemoval: AccountSummaryReport #processForDeposit stamp: 'LK 10/26/2023 13:14:29'!
processForDeposit!
!AccountSummaryReport methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 13:15:11'!
processForDepositLeg: aTransaction! !
!AccountSummaryReport methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 13:15:16'!
processForWithdraw: aTransaction! !
!AccountSummaryReport methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 13:15:21'!
processForWithdrawLeg: aTransaction! !

!methodRemoval: AccountSummaryReport #processForWithdrawLeg stamp: 'LK 10/26/2023 13:15:23'!
processForWithdrawLeg!

!methodRemoval: AccountSummaryReport #processForWithdraw stamp: 'LK 10/26/2023 13:15:24'!
processForWithdraw!

!methodRemoval: AccountSummaryReport #processForDepositLeg stamp: 'LK 10/26/2023 13:15:25'!
processForDepositLeg!
!TransferNetReport methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 13:15:41'!
processForWithdraw: aTransaction
	
	netValue := account reportTransferNet.
	
	^netValue! !
!TransferNetReport methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 13:15:51'!
processForDeposit: aTransaction
	
	netValue := account reportTransferNet.
	
	^netValue! !
!TransferNetReport methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 13:15:54'!
processForDepositLeg: aTransaction
	
	netValue := account reportTransferNet.
	
	^netValue! !
!TransferNetReport methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 13:15:58'!
processForWithdrawLeg: aTransaction
	
	netValue := account reportTransferNet.
	
	^netValue! !
!AccountSummaryReport methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 13:16:50' prior: 50704095!
processForDeposit: aTransaction

	reports addLast: 'Depósito por ', aTransaction value asString, '.'.! !
!AccountSummaryReport methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 13:17:23' prior: 50704103!
processForDepositLeg: aTransaction
	
	reports addLast: 'Entrada por transferencia por ', aTransaction value asString, '.'! !
!AccountSummaryReport methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 13:17:44' prior: 50704107!
processForWithdraw: aTransaction
	
	reports addLast: 'Extracción por ', aTransaction value asString, '.'! !
!AccountSummaryReport methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 13:17:59' prior: 50704111!
processForWithdrawLeg: aTransaction

	reports addLast: 'Salida por transferencia por ', aTransaction value asString, '.'! !
!AccountSummaryReport methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 13:20:16' prior: 50703345 overrides: 50703997!
process

	reports addLast: ('Balance = ', account balance asString).
	^reports.! !
!TransferNetReport methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 13:20:34' prior: 50703845 overrides: 50703997!
process
	
	^netValue! !
!TransferNetReport methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 13:20:42' prior: 50704132!
processForDeposit: aTransaction
	! !
!TransferNetReport methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 13:20:46' prior: 50704126!
processForWithdraw: aTransaction
	! !
!TransferNetReport methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 13:21:08' prior: 50704138!
processForDepositLeg: aTransaction
	
	netValue := netValue + aTransaction value! !
!TransferNetReport methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 13:21:12' prior: 50704144!
processForWithdrawLeg: aTransaction
	
	netValue := netValue - aTransaction value! !
!TransferNetReport methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 13:21:36'!
endProcess
	
	^netValue! !

!methodRemoval: TransferNetReport #process stamp: 'LK 10/26/2023 13:21:36'!
process
	
	^netValue!
!AccountSummaryReport methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 13:21:49'!
endProcess

	reports addLast: ('Balance = ', account balance asString).
	^reports.! !

!methodRemoval: AccountSummaryReport #process stamp: 'LK 10/26/2023 13:21:49'!
process

	reports addLast: ('Balance = ', account balance asString).
	^reports.!
!NodeVisitor methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 13:22:05' prior: 50703997!
process

	account processForReport: self.
	^self endProcess.! !
!NodeVisitor methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 13:22:22'!
endProcess

	self subclassResponsibility ! !

!methodRemoval: ReceptiveAccount #reportAccountSummary stamp: 'LK 10/26/2023 13:22:49'!
reportAccountSummary
	
	|reports|
	
	reports := OrderedCollection new.
	
	transactions do: [:aTransaction | 
		(aTransaction isKindOf: Deposit) ifTrue: [ reports addLast:
										 'Depósito por ', aTransaction value asString, '.'].
		(aTransaction isKindOf: Withdraw)							ifTrue: [reports addLast: 
										 'Extracción por ', aTransaction value asString, '.'].
		(aTransaction isKindOf: DepositLeg) ifTrue: [reports addLast:
										 'Entrada por transferencia por ', aTransaction value asString, '.'].
		(aTransaction isKindOf: WithdrawLeg) ifTrue: [reports addLast:
										 'Salida por transferencia por ', aTransaction value asString, '.'].
	].
	
	reports addLast: ('Balance = ', self balance asString).
	
	^reports.!

!methodRemoval: ReceptiveAccount #reportTransferNet stamp: 'LK 10/26/2023 13:22:51'!
reportTransferNet
	 
	|netValue|
	
	netValue := 0.
	
	transactions do: [:aTransaction | (aTransaction isKindOf: DepositLeg) ifTrue: 
								[netValue := netValue + aTransaction value].
							    (aTransaction isKindOf: WithdrawLeg) ifTrue: 
								[netValue := netValue - aTransaction value].
	].

	^netValue!

!testRun: #Portfolio2Test #test04reportsAccountSummaryOfEmptyAccount stamp: 'LK 10/26/2023 13:23:14'!
PASSED!

!testRun: #Portfolio2Test #test01trasferringModifiesBalanceByCorrectAmount stamp: 'LK 10/26/2023 13:23:16'!
PASSED!

!testRun: #Portfolio2Test #test02transferringGetsRegisteredInBothAccounts stamp: 'LK 10/26/2023 13:23:16'!
PASSED!

!testRun: #Portfolio2Test #test03canNavigateBetweenTransferLegs stamp: 'LK 10/26/2023 13:23:16'!
PASSED!

!testRun: #Portfolio2Test #test04reportsAccountSummaryOfEmptyAccount stamp: 'LK 10/26/2023 13:23:16'!
PASSED!

!testRun: #Portfolio2Test #test05reportsAccountSummaryWithWithdrawal stamp: 'LK 10/26/2023 13:23:16'!
PASSED!

!testRun: #Portfolio2Test #test06reportsAccountSummaryWithDeposit stamp: 'LK 10/26/2023 13:23:17'!
PASSED!

!testRun: #Portfolio2Test #test07reportsAccountSummaryWithDepositTransferLeg stamp: 'LK 10/26/2023 13:23:17'!
PASSED!

!testRun: #Portfolio2Test #test08reportsAccountSummaryWithWithdrawTransferLeg stamp: 'LK 10/26/2023 13:23:17'!
PASSED!

!testRun: #Portfolio2Test #test09reportsPortfolioSummaryWithManyAccounts stamp: 'LK 10/26/2023 13:23:17'!
ERROR!

!testRun: #Portfolio2Test #test10reportsTransferNetForWithdrawLegs stamp: 'LK 10/26/2023 13:23:17'!
PASSED!

!testRun: #Portfolio2Test #test11reportsTransferNetForDepositLegs stamp: 'LK 10/26/2023 13:23:17'!
PASSED!

!testRun: #Portfolio2Test #test12reportsTransferNetForMultipleTransfers stamp: 'LK 10/26/2023 13:23:17'!
PASSED!

!testRun: #Portfolio2Test #test13reportsTransferNetForPortfoliosWithMultipleAccounts stamp: 'LK 10/26/2023 13:23:17'!
ERROR!
!Portfolio methodsFor: 'accounts management' stamp: 'LK 10/26/2023 13:24:57'!
processForReport: aVisitor
	
	accounts do: [:anAccount | anAccount processForReport: aVisitor].! !
!Account methodsFor: 'transactions' stamp: 'LK 10/26/2023 13:25:23'!
processForReport: aVisitor
	
	self subclassResponsibility ! !

!testRun: #Portfolio2Test #test01trasferringModifiesBalanceByCorrectAmount stamp: 'LK 10/26/2023 13:25:27'!
PASSED!

!testRun: #Portfolio2Test #test02transferringGetsRegisteredInBothAccounts stamp: 'LK 10/26/2023 13:25:27'!
PASSED!

!testRun: #Portfolio2Test #test03canNavigateBetweenTransferLegs stamp: 'LK 10/26/2023 13:25:27'!
PASSED!

!testRun: #Portfolio2Test #test04reportsAccountSummaryOfEmptyAccount stamp: 'LK 10/26/2023 13:25:27'!
PASSED!

!testRun: #Portfolio2Test #test05reportsAccountSummaryWithWithdrawal stamp: 'LK 10/26/2023 13:25:27'!
PASSED!

!testRun: #Portfolio2Test #test06reportsAccountSummaryWithDeposit stamp: 'LK 10/26/2023 13:25:27'!
PASSED!

!testRun: #Portfolio2Test #test07reportsAccountSummaryWithDepositTransferLeg stamp: 'LK 10/26/2023 13:25:27'!
PASSED!

!testRun: #Portfolio2Test #test08reportsAccountSummaryWithWithdrawTransferLeg stamp: 'LK 10/26/2023 13:25:27'!
PASSED!

!testRun: #Portfolio2Test #test09reportsPortfolioSummaryWithManyAccounts stamp: 'LK 10/26/2023 13:25:28'!
PASSED!

!testRun: #Portfolio2Test #test10reportsTransferNetForWithdrawLegs stamp: 'LK 10/26/2023 13:25:28'!
PASSED!

!testRun: #Portfolio2Test #test11reportsTransferNetForDepositLegs stamp: 'LK 10/26/2023 13:25:28'!
PASSED!

!testRun: #Portfolio2Test #test12reportsTransferNetForMultipleTransfers stamp: 'LK 10/26/2023 13:25:28'!
PASSED!

!testRun: #Portfolio2Test #test13reportsTransferNetForPortfoliosWithMultipleAccounts stamp: 'LK 10/26/2023 13:25:28'!
PASSED!
!Portfolio2Test methodsFor: 'testing' stamp: 'LK 10/26/2023 13:26:46'!
test14! !

!methodRemoval: Portfolio #reportTransferNet stamp: 'LK 10/26/2023 13:34:26'!
reportTransferNet
	^accounts sum: [:anAccount | anAccount reportTransferNet].!

!methodRemoval: Portfolio #reportAccountSummary stamp: 'LK 10/26/2023 13:34:28'!
reportAccountSummary

	|reports temp|
	
	reports := OrderedCollection new.
	
	accounts do: [ :anAccount | temp := anAccount reportAccountSummary.
						    temp removeLast.
						    reports addAll: temp.].
	
	reports addLast: ('Balance = ', self balance asString).
	
	^reports.!

Account subclass: #Portfolio
	instanceVariableNames: 'accounts parents name'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #Portfolio category: 'Portfolio-Solucion' stamp: 'LK 10/26/2023 13:44:34'!
Account subclass: #Portfolio
	instanceVariableNames: 'accounts parents name'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

Account subclass: #Portfolio
	instanceVariableNames: 'accounts parents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #Portfolio category: 'Portfolio-Solucion' stamp: 'LK 10/26/2023 13:45:53'!
Account subclass: #Portfolio
	instanceVariableNames: 'accounts parents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

Object subclass: #Account
	instanceVariableNames: 'name'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #Account category: 'Portfolio-Solucion' stamp: 'LK 10/26/2023 13:45:58'!
Object subclass: #Account
	instanceVariableNames: 'name'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

NodeVisitor subclass: #PortfolioTreeReport
	instanceVariableNames: 'reports'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #PortfolioTreeReport category: 'Portfolio-Solucion' stamp: 'LK 10/26/2023 13:49:16'!
NodeVisitor subclass: #PortfolioTreeReport
	instanceVariableNames: 'reports'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #AccountSummaryReport category: 'Portfolio-Solucion' stamp: 'LK 10/26/2023 13:49:40'!
NodeVisitor subclass: #AccountSummaryReport
	instanceVariableNames: 'summary'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!
!AccountSummaryReport methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 13:49:40' prior: 50704173!
processForWithdrawLeg: aTransaction

	summary addLast: 'Salida por transferencia por ', aTransaction value asString, '.'! !
!AccountSummaryReport methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 13:49:41' prior: 50704166!
processForWithdraw: aTransaction
	
	summary addLast: 'Extracción por ', aTransaction value asString, '.'! !
!AccountSummaryReport methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 13:49:41' prior: 50703300 overrides: 16920235!
initialize

	summary := OrderedCollection new.! !
!AccountSummaryReport methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 13:49:41' prior: 50704221 overrides: 50704237!
endProcess

	summary addLast: ('Balance = ', account balance asString).
	^summary.! !
!AccountSummaryReport methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 13:49:41' prior: 50704151!
processForDeposit: aTransaction

	summary addLast: 'Depósito por ', aTransaction value asString, '.'.! !
!AccountSummaryReport methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 13:49:41' prior: 50704158!
processForDepositLeg: aTransaction
	
	summary addLast: 'Entrada por transferencia por ', aTransaction value asString, '.'! !

NodeVisitor subclass: #PortfolioTreeReport
	instanceVariableNames: 'tree'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #PortfolioTreeReport category: 'Portfolio-Solucion' stamp: 'LK 10/26/2023 13:49:50'!
NodeVisitor subclass: #PortfolioTreeReport
	instanceVariableNames: 'tree'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!
!PortfolioTreeReport methodsFor: 'nil' stamp: 'LK 10/26/2023 13:50:03' overrides: 16920235!
initialize
	tree := OrderedCollection new.! !
!NodeVisitor methodsFor: 'processing' stamp: 'LK 10/26/2023 13:51:24'!
processReceptiveAccount: anAccount! !
!TransferNetReport methodsFor: 'processing' stamp: 'LK 10/26/2023 13:51:33' overrides: 50704523!
processReceptiveAccount: anAccount! !
!AccountSummaryReport methodsFor: 'processing' stamp: 'LK 10/26/2023 13:51:33' overrides: 50704523!
processReceptiveAccount: anAccount! !
!PortfolioTreeReport methodsFor: 'processing' stamp: 'LK 10/26/2023 13:51:33' overrides: 50704523!
processReceptiveAccount: anAccount! !
!NodeVisitor methodsFor: 'processing' stamp: 'LK 10/26/2023 13:51:33' prior: 50704523!
processReceptiveAccount: anAccount

	self subclassResponsibility! !
!NodeVisitor methodsFor: 'processing' stamp: 'LK 10/26/2023 13:51:41'!
processPortfolio: anAccount

	self subclassResponsibility! !
!TransferNetReport methodsFor: 'processing' stamp: 'LK 10/26/2023 13:51:44' overrides: 50704547!
processPortfolio: anAccount

	self subclassResponsibility! !
!AccountSummaryReport methodsFor: 'processing' stamp: 'LK 10/26/2023 13:51:44' overrides: 50704547!
processPortfolio: anAccount

	self subclassResponsibility! !
!PortfolioTreeReport methodsFor: 'processing' stamp: 'LK 10/26/2023 13:51:45' overrides: 50704547!
processPortfolio: anAccount

	self subclassResponsibility! !
!NodeVisitor methodsFor: 'processing' stamp: 'LK 10/26/2023 13:51:45' prior: 50704547!
processPortfolio: anAccount

	self subclassResponsibility! !
!AccountSummaryReport methodsFor: 'processing' stamp: 'LK 10/26/2023 13:51:52' prior: 50704558 overrides: 50704568!
processPortfolio: anAccount

	! !
!TransferNetReport methodsFor: 'processing' stamp: 'LK 10/26/2023 13:51:58' prior: 50704552 overrides: 50704568!
processPortfolio: anAccount

	! !
!NodeVisitor methodsFor: 'processing' stamp: 'LK 10/26/2023 13:52:17'!
processForDeposit: aTransaction

	self subclassResponsibility! !
!NodeVisitor methodsFor: 'processing' stamp: 'LK 10/26/2023 13:52:22'!
processForDepositLeg: aTransaction

	self subclassResponsibility! !
!NodeVisitor methodsFor: 'processing' stamp: 'LK 10/26/2023 13:52:25'!
processForWithdraw: aTransaction

	self subclassResponsibility! !
!NodeVisitor methodsFor: 'processing' stamp: 'LK 10/26/2023 13:52:29'!
processForWithdrawLeg: aTransaction

	self subclassResponsibility! !
!PortfolioTreeReport methodsFor: 'processing' stamp: 'LK 10/26/2023 13:52:42' overrides: 50704583!
processForDeposit: aTransaction

	self subclassResponsibility! !
!NodeVisitor methodsFor: 'processing' stamp: 'LK 10/26/2023 13:52:43' prior: 50704583!
processForDeposit: aTransaction

	self subclassResponsibility! !
!PortfolioTreeReport methodsFor: 'processing' stamp: 'LK 10/26/2023 13:52:50' overrides: 50704588!
processForDepositLeg: aTransaction

	self subclassResponsibility! !
!NodeVisitor methodsFor: 'processing' stamp: 'LK 10/26/2023 13:52:51' prior: 50704588!
processForDepositLeg: aTransaction

	self subclassResponsibility! !
!PortfolioTreeReport methodsFor: 'processing' stamp: 'LK 10/26/2023 13:52:56' overrides: 50704593!
processForWithdraw: aTransaction

	self subclassResponsibility! !
!NodeVisitor methodsFor: 'processing' stamp: 'LK 10/26/2023 13:52:56' prior: 50704593!
processForWithdraw: aTransaction

	self subclassResponsibility! !
!PortfolioTreeReport methodsFor: 'processing' stamp: 'LK 10/26/2023 13:53:01' overrides: 50704598!
processForWithdrawLeg: aTransaction

	self subclassResponsibility! !
!NodeVisitor methodsFor: 'processing' stamp: 'LK 10/26/2023 13:53:01' prior: 50704598!
processForWithdrawLeg: aTransaction

	self subclassResponsibility! !
!Account methodsFor: 'name' stamp: 'LK 10/26/2023 13:54:46' overrides: 16903442!
name
	^name! !
!Account methodsFor: 'name' stamp: 'LK 10/26/2023 13:55:17'!
named: anAccountName
	
	name := anAccountName.! !
!Portfolio2Test methodsFor: 'tests' stamp: 'LK 10/26/2023 14:11:06' prior: 50704386!
test14

	|portfolio report expectedString|
	
	portfolio := Portfolio named: 'Portfolio de Hijos'.
	report := PortfolioTreeReport for: portfolio.
	
	expectedString := OrderedCollection new.
	
	self assert: (report process = expectedString)
	
	! !
!Portfolio2Test methodsFor: 'tests' stamp: 'LK 10/26/2023 14:11:11' prior: 50704655!
test14

	|portfolio report expectedString|
	
	portfolio := Portfolio named: 'Portfolio de Hijos'.
	report := PortfolioTreeReport for: portfolio.
	
	expectedString := OrderedCollection new.
	
	self assert: report process = expectedString
	
	! !
!Portfolio2Test methodsFor: 'tests' stamp: 'LK 10/26/2023 14:11:32' prior: 50704666!
test14

	|portfolio report expectedString|
	
	portfolio := Portfolio named: 'Portfolio de Hijos'.
	report := PortfolioTreeReport for: portfolio.
	
	expectedString := OrderedCollection new.
	expectedString add: 'Portfolio de Hijos'.
	
	self assert: report process = expectedString
	
	! !
!Portfolio2Test methodsFor: 'tests' stamp: 'LK 10/26/2023 14:12:05'!
test14reportsPortfolioTreeWithEmptyPortfolio

	|portfolio report expectedString|
	
	portfolio := Portfolio named: 'Portfolio de Hijos'.
	report := PortfolioTreeReport for: portfolio.
	
	expectedString := OrderedCollection new.
	expectedString add: 'Portfolio de Hijos'.
	
	self assert: report process = expectedString
	
	! !

!methodRemoval: Portfolio2Test #test14 stamp: 'LK 10/26/2023 14:12:05'!
test14

	|portfolio report expectedString|
	
	portfolio := Portfolio named: 'Portfolio de Hijos'.
	report := PortfolioTreeReport for: portfolio.
	
	expectedString := OrderedCollection new.
	expectedString add: 'Portfolio de Hijos'.
	
	self assert: report process = expectedString
	
	!
!PortfolioTreeReport methodsFor: 'processing' stamp: 'LK 10/26/2023 14:12:28' overrides: 50704237!
endProcess

	self subclassResponsibility ! !
!NodeVisitor methodsFor: 'processing' stamp: 'LK 10/26/2023 14:12:29' prior: 50704237!
endProcess

	self subclassResponsibility! !
!PortfolioTreeReport methodsFor: 'processing' stamp: 'LK 10/26/2023 14:12:45' prior: 50704714 overrides: 50704719!
endProcess

	^tree! !
!PortfolioTreeReport methodsFor: 'processing' stamp: 'LK 10/26/2023 14:13:11' prior: 50704563 overrides: 50704568!
processPortfolio: anAccount

	anAccount processForReport: self.! !
!PortfolioTreeReport methodsFor: 'processing' stamp: 'LK 10/26/2023 14:13:26' prior: 50704604 overrides: 50704609!
processForDeposit: aTransaction

	! !
!PortfolioTreeReport methodsFor: 'processing' stamp: 'LK 10/26/2023 14:13:31' prior: 50704615 overrides: 50704620!
processForDepositLeg: aTransaction

	! !
!PortfolioTreeReport methodsFor: 'processing' stamp: 'LK 10/26/2023 14:13:34' prior: 50704626 overrides: 50704631!
processForWithdraw: aTransaction

	! !
!PortfolioTreeReport methodsFor: 'processing' stamp: 'LK 10/26/2023 14:13:36' prior: 50704637 overrides: 50704642!
processForWithdrawLeg: aTransaction

	! !
!Portfolio methodsFor: 'processing' stamp: 'LK 10/26/2023 14:14:30' prior: 50704329 overrides: 50704335!
processForReport: aVisitor
	
	aVisitor processPortfolio: self.
	accounts do: [:anAccount | anAccount processForReport: aVisitor].! !
!ReceptiveAccount methodsFor: 'processing' stamp: 'LK 10/26/2023 14:14:48' prior: 50704005 overrides: 50704335!
processForReport: aVisitor

	transactions do: [:aTransaction | aTransaction processForReport: aVisitor]! !
!PortfolioTreeReport methodsFor: 'processing' stamp: 'LK 10/26/2023 14:15:09' prior: 50704729 overrides: 50704568!
processPortfolio: anAccount

	tree addLast: anAccount name! !

!testRun: #Portfolio2Test #test14reportsPortfolioTreeWithEmptyPortfolio stamp: 'LK 10/26/2023 14:15:13'!
ERROR!

!testRun: #Portfolio2Test #test14reportsPortfolioTreeWithEmptyPortfolio stamp: 'LK 10/26/2023 14:15:13'!
ERROR!
!Portfolio class methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 14:15:45'!
named: anAccountName

	^self new name: anAccountName.! !

!methodRemoval: Account #named: stamp: 'LK 10/26/2023 14:15:56'!
named: anAccountName
	
	name := anAccountName.!

!testRun: #Portfolio2Test #test14reportsPortfolioTreeWithEmptyPortfolio stamp: 'LK 10/26/2023 14:16:18'!
ERROR!

!testRun: #Portfolio2Test #test14reportsPortfolioTreeWithEmptyPortfolio stamp: 'LK 10/26/2023 14:16:18'!
ERROR!
!Account methodsFor: 'name' stamp: 'LK 10/26/2023 14:16:54'!
named: anAccountName

	name := anAccountName.! !

!testRun: #Portfolio2Test #test14reportsPortfolioTreeWithEmptyPortfolio stamp: 'LK 10/26/2023 14:16:58'!
ERROR!

!testRun: #Portfolio2Test #test14reportsPortfolioTreeWithEmptyPortfolio stamp: 'LK 10/26/2023 14:16:58'!
ERROR!
!Account class methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 14:18:16'!
named: anAccountName

	^self new name: anAccountName.! !

!methodRemoval: Portfolio class #named: stamp: 'LK 10/26/2023 14:18:16'!
named: anAccountName

	^self new name: anAccountName.!

!testRun: #Portfolio2Test #test14reportsPortfolioTreeWithEmptyPortfolio stamp: 'LK 10/26/2023 14:18:23'!
ERROR!

!testRun: #Portfolio2Test #test14reportsPortfolioTreeWithEmptyPortfolio stamp: 'LK 10/26/2023 14:18:23'!
ERROR!
!Account class methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 14:18:36' prior: 50704809!
named: anAccountName

	^self new named: anAccountName.! !

!testRun: #Portfolio2Test #test14reportsPortfolioTreeWithEmptyPortfolio stamp: 'LK 10/26/2023 14:18:40'!
ERROR!

!testRun: #Portfolio2Test #test14reportsPortfolioTreeWithEmptyPortfolio stamp: 'LK 10/26/2023 14:18:40'!
ERROR!
!NodeVisitor class methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 14:19:18'!
for: anAccount
	
	^self new initializeFor: anAccount.! !

!methodRemoval: AccountSummaryReport class #for: stamp: 'LK 10/26/2023 14:19:18'!
for: anAccount
	
	^self new initializeFor: anAccount.!

!methodRemoval: TransferNetReport class #for: stamp: 'LK 10/26/2023 14:19:18'!
for: anAccount
	
	^self new initializeFor: anAccount.!

!testRun: #Portfolio2Test #test14reportsPortfolioTreeWithEmptyPortfolio stamp: 'LK 10/26/2023 14:19:25'!
PASSED!
!Portfolio2Test methodsFor: 'tests' stamp: 'LK 10/26/2023 14:19:42'!
test15

	|portfolio report expectedString|
	
	portfolio := Portfolio named: 'Portfolio de Hijos'.
	report := PortfolioTreeReport for: portfolio.
	
	expectedString := OrderedCollection new.
	expectedString add: 'Portfolio de Hijos'.
	
	self assert: report process = expectedString
	
	! !
!Portfolio2Test methodsFor: 'tests' stamp: 'LK 10/26/2023 14:20:20'!
test15reportsPortfolioTreeWithEmptyPortfolio

	|portfolio report expectedString|
	
	portfolio := Portfolio named: 'Portfolio de Hijos'.
	report := PortfolioTreeReport for: portfolio.
	
	expectedString := OrderedCollection new.
	expectedString add: 'Portfolio de Hijos'.
	
	self assert: report process = expectedString
	
	! !

!methodRemoval: Portfolio2Test #test14reportsPortfolioTreeWithEmptyPortfolio stamp: 'LK 10/26/2023 14:20:21'!
test14reportsPortfolioTreeWithEmptyPortfolio

	|portfolio report expectedString|
	
	portfolio := Portfolio named: 'Portfolio de Hijos'.
	report := PortfolioTreeReport for: portfolio.
	
	expectedString := OrderedCollection new.
	expectedString add: 'Portfolio de Hijos'.
	
	self assert: report process = expectedString
	
	!
!Portfolio2Test methodsFor: 'tests' stamp: 'LK 10/26/2023 14:20:55'!
test14reportsTransferNetForEmptyAccount
	
	|account expectedValue report|
	
	account := ReceptiveAccount new.
	report := TransferNetReport for: account.
	
	expectedValue := 0.
	
	self assert: report process = expectedValue.! !

!testRun: #Portfolio2Test #test14reportsTransferNetForEmptyAccount stamp: 'LK 10/26/2023 14:20:56'!
PASSED!

!testRun: #Portfolio2Test #test01trasferringModifiesBalanceByCorrectAmount stamp: 'LK 10/26/2023 14:20:56'!
PASSED!

!testRun: #Portfolio2Test #test02transferringGetsRegisteredInBothAccounts stamp: 'LK 10/26/2023 14:20:56'!
PASSED!

!testRun: #Portfolio2Test #test03canNavigateBetweenTransferLegs stamp: 'LK 10/26/2023 14:20:56'!
PASSED!

!testRun: #Portfolio2Test #test04reportsAccountSummaryOfEmptyAccount stamp: 'LK 10/26/2023 14:20:56'!
PASSED!

!testRun: #Portfolio2Test #test05reportsAccountSummaryWithWithdrawal stamp: 'LK 10/26/2023 14:20:56'!
PASSED!

!testRun: #Portfolio2Test #test06reportsAccountSummaryWithDeposit stamp: 'LK 10/26/2023 14:20:56'!
PASSED!

!testRun: #Portfolio2Test #test07reportsAccountSummaryWithDepositTransferLeg stamp: 'LK 10/26/2023 14:20:56'!
PASSED!

!testRun: #Portfolio2Test #test08reportsAccountSummaryWithWithdrawTransferLeg stamp: 'LK 10/26/2023 14:20:56'!
PASSED!

!testRun: #Portfolio2Test #test09reportsPortfolioSummaryWithManyAccounts stamp: 'LK 10/26/2023 14:20:56'!
PASSED!

!testRun: #Portfolio2Test #test10reportsTransferNetForWithdrawLegs stamp: 'LK 10/26/2023 14:20:56'!
PASSED!

!testRun: #Portfolio2Test #test11reportsTransferNetForDepositLegs stamp: 'LK 10/26/2023 14:20:56'!
PASSED!

!testRun: #Portfolio2Test #test12reportsTransferNetForMultipleTransfers stamp: 'LK 10/26/2023 14:20:56'!
PASSED!

!testRun: #Portfolio2Test #test13reportsTransferNetForPortfoliosWithMultipleAccounts stamp: 'LK 10/26/2023 14:20:56'!
PASSED!

!testRun: #Portfolio2Test #test14reportsTransferNetForEmptyAccount stamp: 'LK 10/26/2023 14:20:56'!
PASSED!

!testRun: #Portfolio2Test #test15 stamp: 'LK 10/26/2023 14:20:56'!
PASSED!

!testRun: #Portfolio2Test #test15reportsPortfolioTreeWithEmptyPortfolio stamp: 'LK 10/26/2023 14:20:56'!
PASSED!
!Portfolio2Test methodsFor: 'tests' stamp: 'LK 10/26/2023 14:21:01'!
test16

	|portfolio report expectedString|
	
	portfolio := Portfolio named: 'Portfolio de Hijos'.
	report := PortfolioTreeReport for: portfolio.
	
	expectedString := OrderedCollection new.
	expectedString add: 'Portfolio de Hijos'.
	
	self assert: report process = expectedString
	
	! !

!methodRemoval: Portfolio2Test #test15 stamp: 'LK 10/26/2023 14:21:02'!
test15

	|portfolio report expectedString|
	
	portfolio := Portfolio named: 'Portfolio de Hijos'.
	report := PortfolioTreeReport for: portfolio.
	
	expectedString := OrderedCollection new.
	expectedString add: 'Portfolio de Hijos'.
	
	self assert: report process = expectedString
	
	!
!Portfolio2Test methodsFor: 'tests' stamp: 'LK 10/26/2023 14:24:42' prior: 50704961!
test16

	|account portfolio report expectedString|
	
	account := ReceptiveAccount named: 'Cuenta de Juan'.
	portfolio := Portfolio named: 'Portfolio de Hijos' with: account.
	report := PortfolioTreeReport for: portfolio.
	
	expectedString := OrderedCollection new.
	expectedString add: 'Portfolio de Hijos'.
	
	self assert: report process = expectedString
	
	! !
!Portfolio class methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 14:25:45'!
named: anAccountName with: anAccount

	|portfolio|
	
	portfolio named: anAccountName.
	
	portfolio := self new add: anAccount;yourself.
	! !
!Portfolio class methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 14:25:55' prior: 50704998!
named: anAccountName with: anAccount

	|portfolio|
	
	portfolio named: anAccountName.
	
	portfolio := self new add: anAccount;yourself.
	
	^portfolio.! !
!Portfolio class methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 14:26:20' prior: 50705006!
named: anAccountName with: anAccount

	|portfolio|
	
	self named: anAccountName.
	
	portfolio := self new add: anAccount;yourself.
	
	^portfolio.! !
!Portfolio class methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 14:26:30' prior: 50705014!
named: anAccountName with: anAccount

	|portfolio|
	
	portfolio := self named: anAccountName.
	
	portfolio add: anAccount.
	
	^portfolio.! !
!Portfolio class methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 14:26:50'!
named: anAccountName with: anAccount with: aSecondAccount

	|portfolio|
	
	portfolio := self named: anAccountName.
	
	portfolio add: anAccount.
	
	portfolio add: aSecondAccount.
	
	^portfolio.! !

!testRun: #Portfolio2Test #test16 stamp: 'LK 10/26/2023 14:27:16'!
PASSED!

!testRun: #Portfolio2Test #test01trasferringModifiesBalanceByCorrectAmount stamp: 'LK 10/26/2023 14:27:16'!
PASSED!

!testRun: #Portfolio2Test #test02transferringGetsRegisteredInBothAccounts stamp: 'LK 10/26/2023 14:27:16'!
PASSED!

!testRun: #Portfolio2Test #test03canNavigateBetweenTransferLegs stamp: 'LK 10/26/2023 14:27:16'!
PASSED!

!testRun: #Portfolio2Test #test04reportsAccountSummaryOfEmptyAccount stamp: 'LK 10/26/2023 14:27:16'!
PASSED!

!testRun: #Portfolio2Test #test05reportsAccountSummaryWithWithdrawal stamp: 'LK 10/26/2023 14:27:16'!
PASSED!

!testRun: #Portfolio2Test #test06reportsAccountSummaryWithDeposit stamp: 'LK 10/26/2023 14:27:16'!
PASSED!

!testRun: #Portfolio2Test #test07reportsAccountSummaryWithDepositTransferLeg stamp: 'LK 10/26/2023 14:27:17'!
PASSED!

!testRun: #Portfolio2Test #test08reportsAccountSummaryWithWithdrawTransferLeg stamp: 'LK 10/26/2023 14:27:17'!
PASSED!

!testRun: #Portfolio2Test #test09reportsPortfolioSummaryWithManyAccounts stamp: 'LK 10/26/2023 14:27:17'!
PASSED!

!testRun: #Portfolio2Test #test10reportsTransferNetForWithdrawLegs stamp: 'LK 10/26/2023 14:27:17'!
PASSED!

!testRun: #Portfolio2Test #test11reportsTransferNetForDepositLegs stamp: 'LK 10/26/2023 14:27:17'!
PASSED!

!testRun: #Portfolio2Test #test12reportsTransferNetForMultipleTransfers stamp: 'LK 10/26/2023 14:27:17'!
PASSED!

!testRun: #Portfolio2Test #test13reportsTransferNetForPortfoliosWithMultipleAccounts stamp: 'LK 10/26/2023 14:27:17'!
PASSED!

!testRun: #Portfolio2Test #test14reportsTransferNetForEmptyAccount stamp: 'LK 10/26/2023 14:27:17'!
PASSED!

!testRun: #Portfolio2Test #test15reportsPortfolioTreeWithEmptyPortfolio stamp: 'LK 10/26/2023 14:27:17'!
PASSED!

!testRun: #Portfolio2Test #test16 stamp: 'LK 10/26/2023 14:27:17'!
PASSED!
!Portfolio2Test methodsFor: 'tests' stamp: 'LK 10/26/2023 14:29:50'!
test16reportPortfolioTreeWithOneChild

	|account portfolio report expectedString|
	
	account := ReceptiveAccount named: 'Cuenta de Juan'.
	portfolio := Portfolio named: 'Portfolio de Hijos' with: account.
	report := PortfolioTreeReport for: portfolio.
	
	expectedString := OrderedCollection new.
	expectedString add: 'Portfolio de Hijos'.
	
	self assert: report process = expectedString
	
	! !

!methodRemoval: Portfolio2Test #test16 stamp: 'LK 10/26/2023 14:29:50'!
test16

	|account portfolio report expectedString|
	
	account := ReceptiveAccount named: 'Cuenta de Juan'.
	portfolio := Portfolio named: 'Portfolio de Hijos' with: account.
	report := PortfolioTreeReport for: portfolio.
	
	expectedString := OrderedCollection new.
	expectedString add: 'Portfolio de Hijos'.
	
	self assert: report process = expectedString
	
	!
!Portfolio2Test methodsFor: 'tests' stamp: 'LK 10/26/2023 14:30:12'!
test17reportPortfolioTreeWithBigHierarchy

	|account portfolio report expectedString|
	
	account := ReceptiveAccount named: 'Cuenta de Juan'.
	portfolio := Portfolio named: 'Portfolio de Hijos' with: account.
	report := PortfolioTreeReport for: portfolio.
	
	expectedString := OrderedCollection new.
	expectedString add: 'Portfolio de Hijos'.
	
	self assert: report process = expectedString
	
	! !

!classDefinition: #Portfolio2Test category: 'Portfolio-Solucion' stamp: 'LK 10/26/2023 14:37:36'!
TestCase subclass: #Portfolio2Test
	instanceVariableNames: 'johnsAccount'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #Portfolio2Test category: 'Portfolio-Solucion' stamp: 'LK 10/26/2023 14:37:37'!
TestCase subclass: #Portfolio2Test
	instanceVariableNames: 'johnsAccount angiesAccount'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

TestCase subclass: #Portfolio2Test
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #Portfolio2Test category: 'Portfolio-Solucion' stamp: 'LK 10/26/2023 14:38:34'!
TestCase subclass: #Portfolio2Test
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!
!Portfolio2Test methodsFor: 'tests' stamp: 'LK 10/26/2023 14:41:26' prior: 50705126!
test17reportPortfolioTreeWithBigHierarchy

	|johnsAccount angiesAccount childrenPortfolio myAccount familyPortfolio report expectedString|
	
	johnsAccount := ReceptiveAccount named: 'Cuenta de Juan'.
	angiesAccount := ReceptiveAccount named: 'Cuenta de Angeles'.
	childrenPortfolio := Portfolio named: 'Portfolio de hijos' with: johnsAccount with: angiesAccount.
	myAccount := ReceptiveAccount named: 'Cuenta mia'.
	familyPortfolio := Portfolio named: 'Portfolio de la familia' with: myAccount with: childrenPortfolio.
	report := PortfolioTreeReport for: familyPortfolio.
	
	expectedString := OrderedCollection new.
	expectedString add: 'Portfolio de Hijos'.
	
	self assert: report process = expectedString
	
	! !

!testRun: #Portfolio2Test #test17reportPortfolioTreeWithBigHierarchy stamp: 'LK 10/26/2023 14:41:27'!
FAILURE!
!Portfolio2Test methodsFor: 'tests' stamp: 'LK 10/26/2023 14:41:37' prior: 50705170!
test17reportPortfolioTreeWithBigHierarchy

	|johnsAccount angiesAccount childrenPortfolio myAccount familyPortfolio report expectedString|
	
	johnsAccount := ReceptiveAccount named: 'Cuenta de Juan'.
	angiesAccount := ReceptiveAccount named: 'Cuenta de Angeles'.
	childrenPortfolio := Portfolio named: 'Portfolio de hijos' with: johnsAccount with: angiesAccount.
	myAccount := ReceptiveAccount named: 'Cuenta mia'.
	familyPortfolio := Portfolio named: 'Portfolio de la familia' with: myAccount with: childrenPortfolio.
	report := PortfolioTreeReport for: familyPortfolio.
	
	expectedString := OrderedCollection new.
	expectedString add: 'Portfolio de la familia'.
	
	self assert: report process = expectedString
	
	! !

!testRun: #Portfolio2Test #test17reportPortfolioTreeWithBigHierarchy stamp: 'LK 10/26/2023 14:41:37'!
FAILURE!
!AccountSummaryReport methodsFor: 'processing' stamp: 'LK 10/26/2023 14:44:57' prior: 50704486 overrides: 50704719!
endProcess

	summary addLast: ('Balance = ', account balance asString).
	^(summary do: [:a | Transcript show: a printString; newLine]).! !
!Portfolio2Test methodsFor: 'tests' stamp: 'LK 10/26/2023 14:45:44' prior: 50703412!
test04reportsAccountSummaryOfEmptyAccount

	|account expectedString report| 
	
	account := ReceptiveAccount new.
	report := AccountSummaryReport for: account.
	
	
	expectedString := OrderedCollection new.
	expectedString add: 'Balance = 0'.
	
	self assert: 'Balance = 0' = report process.! !

!testRun: #Portfolio2Test #test04reportsAccountSummaryOfEmptyAccount stamp: 'LK 10/26/2023 14:45:45'!
FAILURE!

!testRun: #Portfolio2Test #test04reportsAccountSummaryOfEmptyAccount stamp: 'LK 10/26/2023 14:45:49'!
FAILURE!

!testRun: #Portfolio2Test #test04reportsAccountSummaryOfEmptyAccount stamp: 'LK 10/26/2023 14:45:49'!
FAILURE!

account := ReceptiveAccount new.!

report := AccountSummaryReport for: account.!

report process!
!AccountSummaryReport methodsFor: 'processing' stamp: 'LK 10/26/2023 14:48:38' prior: 50705229 overrides: 50704719!
endProcess

	|string|
	summary addLast: ('Balance = ', account balance asString).
	^(summary do: [:a | Transcript show: a printString; newLine]).! !
!AccountSummaryReport methodsFor: 'processing' stamp: 'LK 10/26/2023 14:48:56' prior: 50705263 overrides: 50704719!
endProcess

	|string|
	summary addLast: ('Balance = ', account balance asString).
	(summary do: [:a | Transcript show: a printString; newLine]).! !

report process!
!AccountSummaryReport methodsFor: 'processing' stamp: 'LK 10/26/2023 13:49:41' prior: 50705272 overrides: 50704719!
endProcess

	summary addLast: ('Balance = ', account balance asString).
	^summary.! !
!AccountSummaryReport methodsFor: 'processing' stamp: 'LK 10/26/2023 13:49:41' prior: 50705281 overrides: 50704719!
endProcess

	summary addLast: ('Balance = ', account balance asString).
	^summary.! !
!Portfolio2Test methodsFor: 'tests' stamp: 'LK 10/26/2023 14:56:14' prior: 50705236!
test04reportsAccountSummaryOfEmptyAccount

	|account expectedString report| 
	
	account := ReceptiveAccount new.
	report := AccountSummaryReport for: account.
	
	
	expectedString := OrderedCollection new.
	expectedString add: 'Balance = 0'.
	
	self assert: expectedString = report process.! !

!testRun: #Portfolio2Test #test04reportsAccountSummaryOfEmptyAccount stamp: 'LK 10/26/2023 14:56:15'!
PASSED!

!testRun: #Portfolio2Test #test01trasferringModifiesBalanceByCorrectAmount stamp: 'LK 10/26/2023 14:56:15'!
PASSED!

!testRun: #Portfolio2Test #test02transferringGetsRegisteredInBothAccounts stamp: 'LK 10/26/2023 14:56:15'!
PASSED!

!testRun: #Portfolio2Test #test03canNavigateBetweenTransferLegs stamp: 'LK 10/26/2023 14:56:15'!
PASSED!

!testRun: #Portfolio2Test #test04reportsAccountSummaryOfEmptyAccount stamp: 'LK 10/26/2023 14:56:15'!
PASSED!

!testRun: #Portfolio2Test #test05reportsAccountSummaryWithWithdrawal stamp: 'LK 10/26/2023 14:56:15'!
PASSED!

!testRun: #Portfolio2Test #test06reportsAccountSummaryWithDeposit stamp: 'LK 10/26/2023 14:56:15'!
PASSED!

!testRun: #Portfolio2Test #test07reportsAccountSummaryWithDepositTransferLeg stamp: 'LK 10/26/2023 14:56:15'!
PASSED!

!testRun: #Portfolio2Test #test08reportsAccountSummaryWithWithdrawTransferLeg stamp: 'LK 10/26/2023 14:56:15'!
PASSED!

!testRun: #Portfolio2Test #test09reportsPortfolioSummaryWithManyAccounts stamp: 'LK 10/26/2023 14:56:15'!
PASSED!

!testRun: #Portfolio2Test #test10reportsTransferNetForWithdrawLegs stamp: 'LK 10/26/2023 14:56:15'!
PASSED!

!testRun: #Portfolio2Test #test11reportsTransferNetForDepositLegs stamp: 'LK 10/26/2023 14:56:15'!
PASSED!

!testRun: #Portfolio2Test #test12reportsTransferNetForMultipleTransfers stamp: 'LK 10/26/2023 14:56:15'!
PASSED!

!testRun: #Portfolio2Test #test13reportsTransferNetForPortfoliosWithMultipleAccounts stamp: 'LK 10/26/2023 14:56:15'!
PASSED!

!testRun: #Portfolio2Test #test14reportsTransferNetForEmptyAccount stamp: 'LK 10/26/2023 14:56:15'!
PASSED!

!testRun: #Portfolio2Test #test15reportsPortfolioTreeWithEmptyPortfolio stamp: 'LK 10/26/2023 14:56:15'!
PASSED!

!testRun: #Portfolio2Test #test16reportPortfolioTreeWithOneChild stamp: 'LK 10/26/2023 14:56:16'!
PASSED!

!testRun: #Portfolio2Test #test17reportPortfolioTreeWithBigHierarchy stamp: 'LK 10/26/2023 14:56:16'!
FAILURE!

!testRun: #Portfolio2Test #test17reportPortfolioTreeWithBigHierarchy stamp: 'LK 10/26/2023 14:56:16'!
FAILURE!
!Portfolio2Test methodsFor: 'tests' stamp: 'LK 10/26/2023 14:56:23' prior: 50705294!
test04reportsAccountSummaryOfEmptyAccount

	|account expectedString report| 
	
	account := ReceptiveAccount new.
	report := AccountSummaryReport for: account.
	
	expectedString := OrderedCollection new.
	expectedString add: 'Balance = 0'.
	
	self assert: expectedString = report process.! !

!testRun: #Portfolio2Test #test04reportsAccountSummaryOfEmptyAccount stamp: 'LK 10/26/2023 14:56:25'!
PASSED!

!testRun: #Portfolio2Test #test01trasferringModifiesBalanceByCorrectAmount stamp: 'LK 10/26/2023 14:56:25'!
PASSED!

!testRun: #Portfolio2Test #test02transferringGetsRegisteredInBothAccounts stamp: 'LK 10/26/2023 14:56:25'!
PASSED!

!testRun: #Portfolio2Test #test03canNavigateBetweenTransferLegs stamp: 'LK 10/26/2023 14:56:25'!
PASSED!

!testRun: #Portfolio2Test #test04reportsAccountSummaryOfEmptyAccount stamp: 'LK 10/26/2023 14:56:25'!
PASSED!

!testRun: #Portfolio2Test #test05reportsAccountSummaryWithWithdrawal stamp: 'LK 10/26/2023 14:56:26'!
PASSED!

!testRun: #Portfolio2Test #test06reportsAccountSummaryWithDeposit stamp: 'LK 10/26/2023 14:56:26'!
PASSED!

!testRun: #Portfolio2Test #test07reportsAccountSummaryWithDepositTransferLeg stamp: 'LK 10/26/2023 14:56:26'!
PASSED!

!testRun: #Portfolio2Test #test08reportsAccountSummaryWithWithdrawTransferLeg stamp: 'LK 10/26/2023 14:56:26'!
PASSED!

!testRun: #Portfolio2Test #test09reportsPortfolioSummaryWithManyAccounts stamp: 'LK 10/26/2023 14:56:26'!
PASSED!

!testRun: #Portfolio2Test #test10reportsTransferNetForWithdrawLegs stamp: 'LK 10/26/2023 14:56:26'!
PASSED!

!testRun: #Portfolio2Test #test11reportsTransferNetForDepositLegs stamp: 'LK 10/26/2023 14:56:26'!
PASSED!

!testRun: #Portfolio2Test #test12reportsTransferNetForMultipleTransfers stamp: 'LK 10/26/2023 14:56:26'!
PASSED!

!testRun: #Portfolio2Test #test13reportsTransferNetForPortfoliosWithMultipleAccounts stamp: 'LK 10/26/2023 14:56:26'!
PASSED!

!testRun: #Portfolio2Test #test14reportsTransferNetForEmptyAccount stamp: 'LK 10/26/2023 14:56:26'!
PASSED!

!testRun: #Portfolio2Test #test15reportsPortfolioTreeWithEmptyPortfolio stamp: 'LK 10/26/2023 14:56:26'!
PASSED!

!testRun: #Portfolio2Test #test16reportPortfolioTreeWithOneChild stamp: 'LK 10/26/2023 14:56:26'!
PASSED!

!testRun: #Portfolio2Test #test17reportPortfolioTreeWithBigHierarchy stamp: 'LK 10/26/2023 14:56:26'!
FAILURE!

!testRun: #Portfolio2Test #test17reportPortfolioTreeWithBigHierarchy stamp: 'LK 10/26/2023 14:56:26'!
FAILURE!

!testRun: #Portfolio2Test #test16reportPortfolioTreeWithOneChild stamp: 'LK 10/26/2023 14:56:33'!
PASSED!

!testRun: #Portfolio2Test #test15reportsPortfolioTreeWithEmptyPortfolio stamp: 'LK 10/26/2023 14:56:34'!
PASSED!
!Portfolio2Test methodsFor: 'tests' stamp: 'LK 10/26/2023 14:56:39' prior: 50705199!
test17reportPortfolioTreeWithBigHierarchy

	"|johnsAccount angiesAccount childrenPortfolio myAccount familyPortfolio report expectedString|
	
	johnsAccount := ReceptiveAccount named: 'Cuenta de Juan'.
	angiesAccount := ReceptiveAccount named: 'Cuenta de Angeles'.
	childrenPortfolio := Portfolio named: 'Portfolio de hijos' with: johnsAccount with: angiesAccount.
	myAccount := ReceptiveAccount named: 'Cuenta mia'.
	familyPortfolio := Portfolio named: 'Portfolio de la familia' with: myAccount with: childrenPortfolio.
	report := PortfolioTreeReport for: familyPortfolio.
	
	expectedString := OrderedCollection new.
	expectedString add: 'Portfolio de la familia'.
	
	self assert: report process = expectedString
	
	"! !

!testRun: #Portfolio2Test #test01trasferringModifiesBalanceByCorrectAmount stamp: 'LK 10/26/2023 14:56:41'!
PASSED!

!testRun: #Portfolio2Test #test02transferringGetsRegisteredInBothAccounts stamp: 'LK 10/26/2023 14:56:41'!
PASSED!

!testRun: #Portfolio2Test #test03canNavigateBetweenTransferLegs stamp: 'LK 10/26/2023 14:56:41'!
PASSED!

!testRun: #Portfolio2Test #test04reportsAccountSummaryOfEmptyAccount stamp: 'LK 10/26/2023 14:56:42'!
PASSED!

!testRun: #Portfolio2Test #test05reportsAccountSummaryWithWithdrawal stamp: 'LK 10/26/2023 14:56:42'!
PASSED!

!testRun: #Portfolio2Test #test06reportsAccountSummaryWithDeposit stamp: 'LK 10/26/2023 14:56:42'!
PASSED!

!testRun: #Portfolio2Test #test07reportsAccountSummaryWithDepositTransferLeg stamp: 'LK 10/26/2023 14:56:42'!
PASSED!

!testRun: #Portfolio2Test #test08reportsAccountSummaryWithWithdrawTransferLeg stamp: 'LK 10/26/2023 14:56:42'!
PASSED!

!testRun: #Portfolio2Test #test09reportsPortfolioSummaryWithManyAccounts stamp: 'LK 10/26/2023 14:56:42'!
PASSED!

!testRun: #Portfolio2Test #test10reportsTransferNetForWithdrawLegs stamp: 'LK 10/26/2023 14:56:42'!
PASSED!

!testRun: #Portfolio2Test #test11reportsTransferNetForDepositLegs stamp: 'LK 10/26/2023 14:56:42'!
PASSED!

!testRun: #Portfolio2Test #test12reportsTransferNetForMultipleTransfers stamp: 'LK 10/26/2023 14:56:42'!
PASSED!

!testRun: #Portfolio2Test #test13reportsTransferNetForPortfoliosWithMultipleAccounts stamp: 'LK 10/26/2023 14:56:42'!
PASSED!

!testRun: #Portfolio2Test #test14reportsTransferNetForEmptyAccount stamp: 'LK 10/26/2023 14:56:42'!
PASSED!

!testRun: #Portfolio2Test #test15reportsPortfolioTreeWithEmptyPortfolio stamp: 'LK 10/26/2023 14:56:42'!
PASSED!

!testRun: #Portfolio2Test #test16reportPortfolioTreeWithOneChild stamp: 'LK 10/26/2023 14:56:42'!
PASSED!

!testRun: #Portfolio2Test #test17reportPortfolioTreeWithBigHierarchy stamp: 'LK 10/26/2023 14:56:42'!
PASSED!
!Portfolio2Test methodsFor: 'tests' stamp: 'LK 10/26/2023 14:56:51' prior: 50705459!
test17reportPortfolioTreeWithBigHierarchy

	|johnsAccount angiesAccount childrenPortfolio myAccount familyPortfolio report expectedString|
	
	johnsAccount := ReceptiveAccount named: 'Cuenta de Juan'.
	angiesAccount := ReceptiveAccount named: 'Cuenta de Angeles'.
	childrenPortfolio := Portfolio named: 'Portfolio de hijos' with: johnsAccount with: angiesAccount.
	myAccount := ReceptiveAccount named: 'Cuenta mia'.
	familyPortfolio := Portfolio named: 'Portfolio de la familia' with: myAccount with: childrenPortfolio.
	report := PortfolioTreeReport for: familyPortfolio.
	
	expectedString := OrderedCollection new.
	expectedString add: 'Portfolio de la familia'.
	
	self assert: report process = expectedString
	! !
!ReceptiveAccount methodsFor: 'processing' stamp: 'LK 10/26/2023 14:57:57' prior: 50704763 overrides: 50704335!
processForReport: aVisitor

	aVisitor processReceptiveAccount: self.
	transactions do: [:aTransaction | aTransaction processForReport: aVisitor]! !
!Portfolio2Test methodsFor: 'tests' stamp: 'LK 10/26/2023 15:00:27' prior: 50705097!
test16reportPortfolioTreeWithOneChild

	|account portfolio report expectedString|
	
	account := ReceptiveAccount named: 'Cuenta de Juan'.
	portfolio := Portfolio named: 'Portfolio de Hijos' with: account.
	report := PortfolioTreeReport for: portfolio.
	
	expectedString := OrderedCollection new.
	expectedString add: 'Portfolio de Hijos'.
	expectedString add: String tab, 'Cuenta de Juan'.
	
	self assert: report process = expectedString
	
	! !
!PortfolioTreeReport methodsFor: 'processing' stamp: 'LK 10/26/2023 15:01:24' prior: 50704538 overrides: 50704542!
processReceptiveAccount: anAccount

	tree addLast: String tab, anAccount name.! !

!testRun: #Portfolio2Test #test15reportsPortfolioTreeWithEmptyPortfolio stamp: 'LK 10/26/2023 15:01:31'!
PASSED!

!testRun: #Portfolio2Test #test16reportPortfolioTreeWithOneChild stamp: 'LK 10/26/2023 15:01:33'!
PASSED!
!Portfolio2Test methodsFor: 'tests' stamp: 'LK 10/26/2023 15:04:20' prior: 50705545!
test17reportPortfolioTreeWithBigHierarchy

	|johnsAccount angiesAccount childrenPortfolio myAccount familyPortfolio report expectedString|
	
	johnsAccount := ReceptiveAccount named: 'Cuenta de Juan'.
	angiesAccount := ReceptiveAccount named: 'Cuenta de Angeles'.
	childrenPortfolio := Portfolio named: 'Portfolio de hijos' with: johnsAccount with: angiesAccount.
	myAccount := ReceptiveAccount named: 'Cuenta mia'.
	familyPortfolio := Portfolio named: 'Portfolio de la familia' with: myAccount with: childrenPortfolio.
	report := PortfolioTreeReport for: familyPortfolio.
	
	expectedString := OrderedCollection new.
	expectedString add: 'Portfolio de la familia'.
	expectedString add: String tab, 'Cuenta Mia'.
	expectedString add: String tab, 'Portfolio de hijos'.
	expectedString add: String tab, String tab, 'Cuenta de Juan'.
	expectedString add: String tab, String tab, 'Cuenta de Angeles'.
	
	self assert: report process = expectedString
	! !
!Portfolio2Test methodsFor: 'tests' stamp: 'LK 10/26/2023 15:04:30' prior: 50705610!
test17reportPortfolioTreeWithBigHierarchy

	|johnsAccount angiesAccount childrenPortfolio myAccount familyPortfolio report expectedString|
	
	johnsAccount := ReceptiveAccount named: 'Cuenta de Juan'.
	angiesAccount := ReceptiveAccount named: 'Cuenta de Angeles'.
	childrenPortfolio := Portfolio named: 'Portfolio de hijos' with: johnsAccount with: angiesAccount.
	myAccount := ReceptiveAccount named: 'Cuenta Mia'.
	familyPortfolio := Portfolio named: 'Portfolio de la familia' with: myAccount with: childrenPortfolio.
	report := PortfolioTreeReport for: familyPortfolio.
	
	expectedString := OrderedCollection new.
	expectedString add: 'Portfolio de la familia'.
	expectedString add: String tab, 'Cuenta Mia'.
	expectedString add: String tab, 'Portfolio de hijos'.
	expectedString add: String tab, String tab, 'Cuenta de Juan'.
	expectedString add: String tab, String tab, 'Cuenta de Angeles'.
	
	self assert: report process = expectedString
	! !

NodeVisitor subclass: #PortfolioTreeReport
	instanceVariableNames: 'tree depth'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #PortfolioTreeReport category: 'Portfolio-Solucion' stamp: 'LK 10/26/2023 15:30:06'!
NodeVisitor subclass: #PortfolioTreeReport
	instanceVariableNames: 'tree depth'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!
!PortfolioTreeReport methodsFor: 'initialization' stamp: 'LK 10/26/2023 15:30:15' prior: 50704519 overrides: 16920235!
initialize

	tree := OrderedCollection new.
	depth := 0.! !
!PortfolioTreeReport methodsFor: 'processing' stamp: 'LK 10/26/2023 15:31:59' prior: 50704770 overrides: 50704568!
processPortfolio: anAccount

	|string tabs|
	tabs := ''.
	depth timesRepeat: [tabs := tabs, String tab].
	string := tabs, anAccount name.
	tree addLast: string.
	depth := depth + 1.! !
!PortfolioTreeReport methodsFor: 'processing' stamp: 'LK 10/26/2023 15:32:37' prior: 50705597 overrides: 50704542!
processReceptiveAccount: anAccount

	|string tabs|
	tabs := ''.
	depth timesRepeat: [tabs := tabs, String tab].
	string := tabs, anAccount name.
	tree addLast: string.! !
!Portfolio methodsFor: 'processing' stamp: 'LK 10/26/2023 15:32:56' prior: 50704755 overrides: 50704335!
processForReport: aVisitor
	
	aVisitor processPortfolio: self.
	accounts do: [:anAccount | anAccount processForReport: aVisitor].
	aVisitor processEndPortfolio.! !
!PortfolioTreeReport methodsFor: 'processing' stamp: 'LK 10/26/2023 15:33:19'!
processEndPortfolio
	depth := depth - 1.! !

!testRun: #Portfolio2Test #test16reportPortfolioTreeWithOneChild stamp: 'LK 10/26/2023 15:33:22'!
PASSED!

!testRun: #Portfolio2Test #test17reportPortfolioTreeWithBigHierarchy stamp: 'LK 10/26/2023 15:33:24'!
PASSED!
!PortfolioTreeReport methodsFor: 'processing' stamp: 'LK 10/26/2023 15:34:27' prior: 50705696 overrides: 50704568!
processPortfolio: anAccount

	|string tabs|
	tabs := ''.
	depth timesRepeat: [tabs := tabs, String tab].
	string := tabs, anAccount name.
	tree addLast: string.
	depth := depth + 1.! !
!PortfolioTreeReport methodsFor: 'processing' stamp: 'LK 10/26/2023 15:39:08'!
getNameWithTabs: anAccount

	|string tabs|
	
	tabs := ''.
	depth timesRepeat: [tabs := tabs, String tab].
	string := tabs, anAccount name.
	^string.! !
!PortfolioTreeReport methodsFor: 'processing' stamp: 'LK 10/26/2023 15:39:46' prior: 50705735 overrides: 50704568!
processPortfolio: anAccount

	tree addLast: (self getNameWithTabs: anAccount name).
	depth := depth + 1.! !
!PortfolioTreeReport methodsFor: 'processing' stamp: 'LK 10/26/2023 15:39:58' prior: 50705744!
getNameWithTabs: aName

	|string tabs|
	
	tabs := ''.
	depth timesRepeat: [tabs := tabs, String tab].
	string := tabs, aName.
	
	^string.! !
!PortfolioTreeReport methodsFor: 'processing' stamp: 'LK 10/26/2023 15:40:35' prior: 50705706 overrides: 50704542!
processReceptiveAccount: anAccount

	tree addLast: (self getNameWithTabs: anAccount name).! !

!testRun: #Portfolio2Test #test01trasferringModifiesBalanceByCorrectAmount stamp: 'LK 10/26/2023 15:40:39'!
PASSED!

!testRun: #Portfolio2Test #test02transferringGetsRegisteredInBothAccounts stamp: 'LK 10/26/2023 15:40:39'!
PASSED!

!testRun: #Portfolio2Test #test03canNavigateBetweenTransferLegs stamp: 'LK 10/26/2023 15:40:39'!
PASSED!

!testRun: #Portfolio2Test #test04reportsAccountSummaryOfEmptyAccount stamp: 'LK 10/26/2023 15:40:39'!
PASSED!

!testRun: #Portfolio2Test #test05reportsAccountSummaryWithWithdrawal stamp: 'LK 10/26/2023 15:40:39'!
PASSED!

!testRun: #Portfolio2Test #test06reportsAccountSummaryWithDeposit stamp: 'LK 10/26/2023 15:40:39'!
PASSED!

!testRun: #Portfolio2Test #test07reportsAccountSummaryWithDepositTransferLeg stamp: 'LK 10/26/2023 15:40:39'!
PASSED!

!testRun: #Portfolio2Test #test08reportsAccountSummaryWithWithdrawTransferLeg stamp: 'LK 10/26/2023 15:40:39'!
PASSED!

!testRun: #Portfolio2Test #test09reportsPortfolioSummaryWithManyAccounts stamp: 'LK 10/26/2023 15:40:39'!
ERROR!

!testRun: #Portfolio2Test #test10reportsTransferNetForWithdrawLegs stamp: 'LK 10/26/2023 15:40:39'!
PASSED!

!testRun: #Portfolio2Test #test11reportsTransferNetForDepositLegs stamp: 'LK 10/26/2023 15:40:39'!
PASSED!

!testRun: #Portfolio2Test #test12reportsTransferNetForMultipleTransfers stamp: 'LK 10/26/2023 15:40:39'!
PASSED!

!testRun: #Portfolio2Test #test13reportsTransferNetForPortfoliosWithMultipleAccounts stamp: 'LK 10/26/2023 15:40:39'!
ERROR!

!testRun: #Portfolio2Test #test14reportsTransferNetForEmptyAccount stamp: 'LK 10/26/2023 15:40:39'!
PASSED!

!testRun: #Portfolio2Test #test15reportsPortfolioTreeWithEmptyPortfolio stamp: 'LK 10/26/2023 15:40:39'!
PASSED!

!testRun: #Portfolio2Test #test16reportPortfolioTreeWithOneChild stamp: 'LK 10/26/2023 15:40:39'!
PASSED!

!testRun: #Portfolio2Test #test17reportPortfolioTreeWithBigHierarchy stamp: 'LK 10/26/2023 15:40:39'!
PASSED!

!testRun: #Portfolio2Test #test09reportsPortfolioSummaryWithManyAccounts stamp: 'LK 10/26/2023 15:40:45'!
ERROR!

!testRun: #Portfolio2Test #test09reportsPortfolioSummaryWithManyAccounts stamp: 'LK 10/26/2023 15:41:03'!
ERROR!

!testRun: #Portfolio2Test #test09reportsPortfolioSummaryWithManyAccounts stamp: 'LK 10/26/2023 15:41:03'!
ERROR!
!AccountSummaryReport methodsFor: 'processing' stamp: 'LK 10/26/2023 15:42:15'!
processEndPortfolio! !
!TransferNetReport methodsFor: 'processing' stamp: 'LK 10/26/2023 15:42:22'!
processEndPortfolio
	! !

!testRun: #Portfolio2Test #test01trasferringModifiesBalanceByCorrectAmount stamp: 'LK 10/26/2023 15:42:25'!
PASSED!

!testRun: #Portfolio2Test #test02transferringGetsRegisteredInBothAccounts stamp: 'LK 10/26/2023 15:42:25'!
PASSED!

!testRun: #Portfolio2Test #test03canNavigateBetweenTransferLegs stamp: 'LK 10/26/2023 15:42:25'!
PASSED!

!testRun: #Portfolio2Test #test04reportsAccountSummaryOfEmptyAccount stamp: 'LK 10/26/2023 15:42:25'!
PASSED!

!testRun: #Portfolio2Test #test05reportsAccountSummaryWithWithdrawal stamp: 'LK 10/26/2023 15:42:25'!
PASSED!

!testRun: #Portfolio2Test #test06reportsAccountSummaryWithDeposit stamp: 'LK 10/26/2023 15:42:25'!
PASSED!

!testRun: #Portfolio2Test #test07reportsAccountSummaryWithDepositTransferLeg stamp: 'LK 10/26/2023 15:42:25'!
PASSED!

!testRun: #Portfolio2Test #test08reportsAccountSummaryWithWithdrawTransferLeg stamp: 'LK 10/26/2023 15:42:25'!
PASSED!

!testRun: #Portfolio2Test #test09reportsPortfolioSummaryWithManyAccounts stamp: 'LK 10/26/2023 15:42:25'!
PASSED!

!testRun: #Portfolio2Test #test10reportsTransferNetForWithdrawLegs stamp: 'LK 10/26/2023 15:42:25'!
PASSED!

!testRun: #Portfolio2Test #test11reportsTransferNetForDepositLegs stamp: 'LK 10/26/2023 15:42:25'!
PASSED!

!testRun: #Portfolio2Test #test12reportsTransferNetForMultipleTransfers stamp: 'LK 10/26/2023 15:42:25'!
PASSED!

!testRun: #Portfolio2Test #test13reportsTransferNetForPortfoliosWithMultipleAccounts stamp: 'LK 10/26/2023 15:42:25'!
PASSED!

!testRun: #Portfolio2Test #test14reportsTransferNetForEmptyAccount stamp: 'LK 10/26/2023 15:42:25'!
PASSED!

!testRun: #Portfolio2Test #test15reportsPortfolioTreeWithEmptyPortfolio stamp: 'LK 10/26/2023 15:42:25'!
PASSED!

!testRun: #Portfolio2Test #test16reportPortfolioTreeWithOneChild stamp: 'LK 10/26/2023 15:42:25'!
PASSED!

!testRun: #Portfolio2Test #test17reportPortfolioTreeWithBigHierarchy stamp: 'LK 10/26/2023 15:42:25'!
PASSED!
!Portfolio2Test methodsFor: 'tests' stamp: 'LK 10/26/2023 15:43:18' prior: 50701645!
test03canNavigateBetweenTransferLegs
	! !

!classRenamed: #NodeVisitor as: #Reports stamp: 'LK 10/26/2023 15:44:00'!
Smalltalk renameClassNamed: #NodeVisitor as: #Reports!
!TransferLegs methodsFor: 'value' stamp: 'LK 10/26/2023 15:46:48'!
navigateToOtherLeg! !
!DepositLeg methodsFor: 'value' stamp: 'LK 10/26/2023 15:46:52' overrides: 50705921!
navigateToOtherLeg! !
!WithdrawLeg methodsFor: 'value' stamp: 'LK 10/26/2023 15:46:52' overrides: 50705921!
navigateToOtherLeg! !
!TransferLegs methodsFor: 'value' stamp: 'LK 10/26/2023 15:46:52' prior: 50705921!
navigateToOtherLeg

	self subclassResponsibility! !
!DepositLeg methodsFor: 'navigate' stamp: 'LK 10/26/2023 15:47:39' prior: 50705925 overrides: 50705933!
navigateToOtherLeg
	^(transfer withdrawLeg)! !
!WithdrawLeg methodsFor: 'navigate' stamp: 'LK 10/26/2023 15:47:53' prior: 50705929 overrides: 50705933!
navigateToOtherLeg
	^(transfer depositingLeg).! !
!Portfolio2Test methodsFor: 'tests' stamp: 'LK 10/26/2023 15:49:33' prior: 50705913!
test03canNavigateBetweenTransferLegs
	
	|withdrawingAcc depositAcc transfer withdrawLeg depositLeg|
	
	withdrawingAcc := ReceptiveAccount new.
	depositAcc := ReceptiveAccount new.
	
	transfer := Transfer for: 50 from: withdrawingAcc to: depositAcc.
	
	withdrawLeg := transfer withdrawLeg.
	depositLeg := transfer depositingLeg.
	
	self assert: (withdrawLeg = depositLeg navigateToOtherLeg).
	self assert: (depositLeg = withdrawLeg navigateToOtherLeg).! !

!testRun: #Portfolio2Test #test03canNavigateBetweenTransferLegs stamp: 'LK 10/26/2023 15:49:34'!
PASSED!

!testRun: #Portfolio2Test #test01trasferringModifiesBalanceByCorrectAmount stamp: 'LK 10/26/2023 15:49:34'!
PASSED!

!testRun: #Portfolio2Test #test02transferringGetsRegisteredInBothAccounts stamp: 'LK 10/26/2023 15:49:34'!
PASSED!

!testRun: #Portfolio2Test #test03canNavigateBetweenTransferLegs stamp: 'LK 10/26/2023 15:49:34'!
PASSED!

!testRun: #Portfolio2Test #test04reportsAccountSummaryOfEmptyAccount stamp: 'LK 10/26/2023 15:49:34'!
PASSED!

!testRun: #Portfolio2Test #test05reportsAccountSummaryWithWithdrawal stamp: 'LK 10/26/2023 15:49:35'!
PASSED!

!testRun: #Portfolio2Test #test06reportsAccountSummaryWithDeposit stamp: 'LK 10/26/2023 15:49:35'!
PASSED!

!testRun: #Portfolio2Test #test07reportsAccountSummaryWithDepositTransferLeg stamp: 'LK 10/26/2023 15:49:35'!
PASSED!

!testRun: #Portfolio2Test #test08reportsAccountSummaryWithWithdrawTransferLeg stamp: 'LK 10/26/2023 15:49:35'!
PASSED!

!testRun: #Portfolio2Test #test09reportsPortfolioSummaryWithManyAccounts stamp: 'LK 10/26/2023 15:49:35'!
PASSED!

!testRun: #Portfolio2Test #test10reportsTransferNetForWithdrawLegs stamp: 'LK 10/26/2023 15:49:35'!
PASSED!

!testRun: #Portfolio2Test #test11reportsTransferNetForDepositLegs stamp: 'LK 10/26/2023 15:49:35'!
PASSED!

!testRun: #Portfolio2Test #test12reportsTransferNetForMultipleTransfers stamp: 'LK 10/26/2023 15:49:35'!
PASSED!

!testRun: #Portfolio2Test #test13reportsTransferNetForPortfoliosWithMultipleAccounts stamp: 'LK 10/26/2023 15:49:35'!
PASSED!

!testRun: #Portfolio2Test #test14reportsTransferNetForEmptyAccount stamp: 'LK 10/26/2023 15:49:35'!
PASSED!

!testRun: #Portfolio2Test #test15reportsPortfolioTreeWithEmptyPortfolio stamp: 'LK 10/26/2023 15:49:35'!
PASSED!

!testRun: #Portfolio2Test #test16reportPortfolioTreeWithOneChild stamp: 'LK 10/26/2023 15:49:35'!
PASSED!

!testRun: #Portfolio2Test #test17reportPortfolioTreeWithBigHierarchy stamp: 'LK 10/26/2023 15:49:35'!
PASSED!

!testRun: #Portfolio2Test #test03canNavigateBetweenTransferLegs stamp: 'LK 10/26/2023 15:49:38'!
PASSED!
!TransferLegs methodsFor: 'initialization' stamp: 'LK 10/26/2023 15:52:30' prior: 50701402!
initializeFor: aTransfer

	transfer := aTransfer.! !

!methodRemoval: WithdrawLeg #initializeFor: stamp: 'LK 10/26/2023 15:52:30'!
initializeFor: aTransfer

	transfer := aTransfer.!

!methodRemoval: DepositLeg #initializeFor: stamp: 'LK 10/26/2023 15:52:30'!
initializeFor: aTransfer

	transfer := aTransfer.!

!classDefinition: #PortfolioTreeReport category: 'Portfolio-Solucion' stamp: 'LK 10/26/2023 15:55:06'!
Reports subclass: #PortfolioTreeReport
	instanceVariableNames: 'tree cantidadTabs'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!
!PortfolioTreeReport methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 15:55:06' prior: 50705723!
processEndPortfolio
	cantidadTabs := cantidadTabs - 1.! !
!PortfolioTreeReport methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 15:55:06' prior: 50705690 overrides: 16920235!
initialize

	tree := OrderedCollection new.
	cantidadTabs := 0.! !
!PortfolioTreeReport methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 15:55:06' prior: 50705760!
getNameWithTabs: aName

	|string tabs|
	
	tabs := ''.
	cantidadTabs timesRepeat: [tabs := tabs, String tab].
	string := tabs, aName.
	
	^string.! !
!PortfolioTreeReport methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 15:55:06' prior: 50705753 overrides: 50704568!
processPortfolio: anAccount

	tree addLast: (self getNameWithTabs: anAccount name).
	cantidadTabs := cantidadTabs + 1.! !
!PortfolioTreeReport methodsFor: 'processing' stamp: 'LK 10/26/2023 15:33:19' prior: 50706054!
processEndPortfolio
	depth := depth - 1.! !

Reports subclass: #PortfolioTreeReport
	instanceVariableNames: 'tree depth'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #PortfolioTreeReport category: 'Portfolio-Solucion' stamp: 'LK 10/26/2023 15:55:32'!
Reports subclass: #PortfolioTreeReport
	instanceVariableNames: 'tree depth'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!
!PortfolioTreeReport methodsFor: 'initialization' stamp: 'LK 10/26/2023 15:55:41' prior: 50706060 overrides: 16920235!
initialize

	tree := OrderedCollection new.
	depth := 0.! !
!PortfolioTreeReport methodsFor: 'processing' stamp: 'LK 10/26/2023 15:55:48' prior: 50706066!
getNameWithTabs: aName

	|string tabs|
	
	tabs := ''.
	depth timesRepeat: [tabs := tabs, String tab].
	string := tabs, aName.
	
	^string.! !
!PortfolioTreeReport methodsFor: 'processing' stamp: 'LK 10/26/2023 15:55:59' prior: 50706075 overrides: 50704568!
processPortfolio: anAccount

	tree addLast: (self getNameWithTabs: anAccount name).
	depth := depth + 1.! !

----End fileIn of /home/oscar/Downloads/linux64/linux64/Portfolio-Solucion.st----!

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'OA 10/26/2023 16:04:19'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'OA 10/26/2023 16:04:19'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'OA 10/26/2023 16:04:19'!
PASSED!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'OA 10/26/2023 16:04:19'!
PASSED!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'OA 10/26/2023 16:04:19'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'OA 10/26/2023 16:04:19'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'OA 10/26/2023 16:04:19'!
PASSED!

!testRun: #PortfolioTest #test01BalanceOfPortfolioWithoutAccountsIsZero stamp: 'OA 10/26/2023 16:04:21'!
PASSED!

!testRun: #PortfolioTest #test02BalanceOfPortfolioWithAccountsIsSumOfAccountsBalance stamp: 'OA 10/26/2023 16:04:21'!
PASSED!

!testRun: #PortfolioTest #test03BalanceOfPortfolioIsCalculatedRecursivelyOnPortfolios stamp: 'OA 10/26/2023 16:04:21'!
PASSED!

!testRun: #PortfolioTest #test04PortfolioWithoutAccountsHasNoRegisteredTransaction stamp: 'OA 10/26/2023 16:04:21'!
PASSED!

!testRun: #PortfolioTest #test05PortfolioHasRegisteredItsAccountsTransactions stamp: 'OA 10/26/2023 16:04:21'!
PASSED!

!testRun: #PortfolioTest #test06PortfolioLooksForRegisteredTransactionsRecursively stamp: 'OA 10/26/2023 16:04:21'!
PASSED!

!testRun: #PortfolioTest #test07PortfolioHasNoTransactionWhenHasNoAccounts stamp: 'OA 10/26/2023 16:04:21'!
PASSED!

!testRun: #PortfolioTest #test08PortfolioTransactionsIncludesAllItsAccountsTransactions stamp: 'OA 10/26/2023 16:04:21'!
PASSED!

!testRun: #PortfolioTest #test09PortfolioTransactionsAreCalculatedRecursively stamp: 'OA 10/26/2023 16:04:21'!
PASSED!

!testRun: #PortfolioTest #test10PortfolioCanNotIncludeTheSameAccountMoreThanOnce stamp: 'OA 10/26/2023 16:04:21'!
PASSED!

!testRun: #PortfolioTest #test11PortfolioCanNotIncludeAccountOfItsPortfolios stamp: 'OA 10/26/2023 16:04:21'!
PASSED!

!testRun: #PortfolioTest #test12PortfolioCanNotIncludeItself stamp: 'OA 10/26/2023 16:04:21'!
PASSED!

!testRun: #PortfolioTest #test13ComposedPortfolioCanNotHaveParentPortfolioAccount stamp: 'OA 10/26/2023 16:04:21'!
PASSED!

!testRun: #PortfolioTest #test14ComposedPortfolioCanNotHaveAccountOfAnyRootParentRecursively stamp: 'OA 10/26/2023 16:04:21'!
PASSED!

!testRun: #PortfolioTest #test15PortfolioCanNotIncludeAnyOfTheComposedAccountOfPortfolioToAdd stamp: 'OA 10/26/2023 16:04:21'!
PASSED!

!testRun: #Portfolio2Test #test01trasferringModifiesBalanceByCorrectAmount stamp: 'OA 10/26/2023 16:04:22'!
PASSED!

!testRun: #Portfolio2Test #test02transferringGetsRegisteredInBothAccounts stamp: 'OA 10/26/2023 16:04:22'!
PASSED!

!testRun: #Portfolio2Test #test03canNavigateBetweenTransferLegs stamp: 'OA 10/26/2023 16:04:22'!
PASSED!

!testRun: #Portfolio2Test #test04reportsAccountSummaryOfEmptyAccount stamp: 'OA 10/26/2023 16:04:22'!
PASSED!

!testRun: #Portfolio2Test #test05reportsAccountSummaryWithWithdrawal stamp: 'OA 10/26/2023 16:04:22'!
PASSED!

!testRun: #Portfolio2Test #test06reportsAccountSummaryWithDeposit stamp: 'OA 10/26/2023 16:04:22'!
PASSED!

!testRun: #Portfolio2Test #test07reportsAccountSummaryWithDepositTransferLeg stamp: 'OA 10/26/2023 16:04:22'!
PASSED!

!testRun: #Portfolio2Test #test08reportsAccountSummaryWithWithdrawTransferLeg stamp: 'OA 10/26/2023 16:04:22'!
PASSED!

!testRun: #Portfolio2Test #test09reportsPortfolioSummaryWithManyAccounts stamp: 'OA 10/26/2023 16:04:22'!
PASSED!

!testRun: #Portfolio2Test #test10reportsTransferNetForWithdrawLegs stamp: 'OA 10/26/2023 16:04:22'!
PASSED!

!testRun: #Portfolio2Test #test11reportsTransferNetForDepositLegs stamp: 'OA 10/26/2023 16:04:22'!
PASSED!

!testRun: #Portfolio2Test #test12reportsTransferNetForMultipleTransfers stamp: 'OA 10/26/2023 16:04:22'!
PASSED!

!testRun: #Portfolio2Test #test13reportsTransferNetForPortfoliosWithMultipleAccounts stamp: 'OA 10/26/2023 16:04:22'!
PASSED!

!testRun: #Portfolio2Test #test14reportsTransferNetForEmptyAccount stamp: 'OA 10/26/2023 16:04:22'!
PASSED!

!testRun: #Portfolio2Test #test15reportsPortfolioTreeWithEmptyPortfolio stamp: 'OA 10/26/2023 16:04:22'!
PASSED!

!testRun: #Portfolio2Test #test16reportPortfolioTreeWithOneChild stamp: 'OA 10/26/2023 16:04:22'!
PASSED!

!testRun: #Portfolio2Test #test17reportPortfolioTreeWithBigHierarchy stamp: 'OA 10/26/2023 16:04:22'!
PASSED!
!Portfolio2Test methodsFor: 'tests' stamp: 'OA 10/26/2023 16:08:09'!
test18
	
	|withdrawingAcc depositAcc |
	
	withdrawingAcc := ReceptiveAccount new.
	depositAcc := ReceptiveAccount new.
	
! !
!Portfolio2Test methodsFor: 'tests' stamp: 'OA 10/26/2023 16:10:11' prior: 50666263!
test18
	
	|withdrawingAcc depositAcc |
	
	withdrawingAcc := ReceptiveAccount new.
	depositAcc := ReceptiveAccount new.
	
	self should: [Transfer for: -30 from: withdrawingAcc to: depositAcc]
		raise: Error
		withExceptionDo: [:anError |
				self assert: anError messageText = 'CannotTransferNonPositiveAmount']! !

!testRun: #Portfolio2Test #test18 stamp: 'OA 10/26/2023 16:10:17'!
FAILURE!

!testRun: #Portfolio2Test #test18 stamp: 'OA 10/26/2023 16:10:17'!
FAILURE!
!Transfer class methodsFor: 'as yet unclassified' stamp: 'OA 10/26/2023 16:12:14' prior: 50666100!
for: aValue from: aWithdrawAccount to: aDepositAccount

	|transfer withdrawingAccLeg depositingAccLeg|
	self requiresPositiveValue: aValue.
	self requiresAccount: aWithdrawAccount isNotTheSameAs: aDepositAccount .
	
	transfer := self new.
	
	withdrawingAccLeg := WithdrawLeg for: transfer.
	depositingAccLeg := DepositLeg for: transfer.
	
	transfer initializeWith: aValue from: withdrawingAccLeg to: depositingAccLeg.
	
	aWithdrawAccount register: withdrawingAccLeg.
	aDepositAccount register: depositingAccLeg.
	
	^transfer.
	
	! !
!Transfer class methodsFor: 'nil' stamp: 'OA 10/26/2023 16:13:20'!
requiresPositiveValue: aValue
	aValue > 0 ifFalse: [self error: 'CannotTransferNonPositiveAmount']! !

!testRun: #Portfolio2Test #test18 stamp: 'OA 10/26/2023 16:13:28'!
PASSED!
!Portfolio2Test methodsFor: 'tests' stamp: 'OA 10/26/2023 16:14:06'!
test18transferAmountShouldBePositive
	
	|withdrawingAcc depositAcc |
	
	withdrawingAcc := ReceptiveAccount new.
	depositAcc := ReceptiveAccount new.
	
	self should: [Transfer for: -30 from: withdrawingAcc to: depositAcc]
		raise: Error
		withExceptionDo: [:anError |
				self assert: anError messageText = 'CannotTransferNonPositiveAmount']! !

!methodRemoval: Portfolio2Test #test18 stamp: 'OA 10/26/2023 16:14:09'!
test18
	
	|withdrawingAcc depositAcc |
	
	withdrawingAcc := ReceptiveAccount new.
	depositAcc := ReceptiveAccount new.
	
	self should: [Transfer for: -30 from: withdrawingAcc to: depositAcc]
		raise: Error
		withExceptionDo: [:anError |
				self assert: anError messageText = 'CannotTransferNonPositiveAmount']!

!testRun: #Portfolio2Test #test18transferAmountShouldBePositive stamp: 'OA 10/26/2023 16:14:10'!
PASSED!
!Portfolio2Test methodsFor: 'tests' stamp: 'OA 10/26/2023 16:16:57'!
test19transferToYourselfIsNotAllowed
	
	|account |
	
	account := ReceptiveAccount new.
	
	self should: [Transfer for: 50 from: account to: account]
		raise: Error
		withExceptionDo: [:anError |
				self assert: anError messageText = 'CannotTransferToYourself']! !

!testRun: #Portfolio2Test #test19transferToYourselfIsNotAllowed stamp: 'OA 10/26/2023 16:16:59'!
FAILURE!

!testRun: #Portfolio2Test #test19transferToYourselfIsNotAllowed stamp: 'OA 10/26/2023 16:16:59'!
FAILURE!
!Transfer class methodsFor: 'nil' stamp: 'OA 10/26/2023 16:17:58'!
requiresAccount: aWithdrawAccount isNotTheSameAs: aDepositAccount .
	(aWithdrawAccount = aDepositAccount ) ifTrue: 
				[self error: 'CannotTransferToYourself']! !

!testRun: #Portfolio2Test #test01trasferringModifiesBalanceByCorrectAmount stamp: 'OA 10/26/2023 16:18:12'!
PASSED!

!testRun: #Portfolio2Test #test02transferringGetsRegisteredInBothAccounts stamp: 'OA 10/26/2023 16:18:12'!
PASSED!

!testRun: #Portfolio2Test #test03canNavigateBetweenTransferLegs stamp: 'OA 10/26/2023 16:18:12'!
PASSED!

!testRun: #Portfolio2Test #test04reportsAccountSummaryOfEmptyAccount stamp: 'OA 10/26/2023 16:18:12'!
PASSED!

!testRun: #Portfolio2Test #test05reportsAccountSummaryWithWithdrawal stamp: 'OA 10/26/2023 16:18:12'!
PASSED!

!testRun: #Portfolio2Test #test06reportsAccountSummaryWithDeposit stamp: 'OA 10/26/2023 16:18:12'!
PASSED!

!testRun: #Portfolio2Test #test07reportsAccountSummaryWithDepositTransferLeg stamp: 'OA 10/26/2023 16:18:12'!
PASSED!

!testRun: #Portfolio2Test #test08reportsAccountSummaryWithWithdrawTransferLeg stamp: 'OA 10/26/2023 16:18:12'!
PASSED!

!testRun: #Portfolio2Test #test09reportsPortfolioSummaryWithManyAccounts stamp: 'OA 10/26/2023 16:18:12'!
PASSED!

!testRun: #Portfolio2Test #test10reportsTransferNetForWithdrawLegs stamp: 'OA 10/26/2023 16:18:12'!
PASSED!

!testRun: #Portfolio2Test #test11reportsTransferNetForDepositLegs stamp: 'OA 10/26/2023 16:18:12'!
PASSED!

!testRun: #Portfolio2Test #test12reportsTransferNetForMultipleTransfers stamp: 'OA 10/26/2023 16:18:12'!
PASSED!

!testRun: #Portfolio2Test #test13reportsTransferNetForPortfoliosWithMultipleAccounts stamp: 'OA 10/26/2023 16:18:12'!
PASSED!

!testRun: #Portfolio2Test #test14reportsTransferNetForEmptyAccount stamp: 'OA 10/26/2023 16:18:12'!
PASSED!

!testRun: #Portfolio2Test #test15reportsPortfolioTreeWithEmptyPortfolio stamp: 'OA 10/26/2023 16:18:12'!
PASSED!

!testRun: #Portfolio2Test #test16reportPortfolioTreeWithOneChild stamp: 'OA 10/26/2023 16:18:12'!
PASSED!

!testRun: #Portfolio2Test #test17reportPortfolioTreeWithBigHierarchy stamp: 'OA 10/26/2023 16:18:12'!
PASSED!

!testRun: #Portfolio2Test #test18transferAmountShouldBePositive stamp: 'OA 10/26/2023 16:18:12'!
PASSED!

!testRun: #Portfolio2Test #test19transferToYourselfIsNotAllowed stamp: 'OA 10/26/2023 16:18:12'!
PASSED!

!testRun: #Portfolio2Test #test01trasferringModifiesBalanceByCorrectAmount stamp: 'OA 10/26/2023 16:19:00'!
PASSED!

!testRun: #Portfolio2Test #test02transferringGetsRegisteredInBothAccounts stamp: 'OA 10/26/2023 16:19:00'!
PASSED!

!testRun: #Portfolio2Test #test03canNavigateBetweenTransferLegs stamp: 'OA 10/26/2023 16:19:00'!
PASSED!

!testRun: #Portfolio2Test #test04reportsAccountSummaryOfEmptyAccount stamp: 'OA 10/26/2023 16:19:00'!
PASSED!

!testRun: #Portfolio2Test #test05reportsAccountSummaryWithWithdrawal stamp: 'OA 10/26/2023 16:19:00'!
PASSED!

!testRun: #Portfolio2Test #test06reportsAccountSummaryWithDeposit stamp: 'OA 10/26/2023 16:19:00'!
PASSED!

!testRun: #Portfolio2Test #test07reportsAccountSummaryWithDepositTransferLeg stamp: 'OA 10/26/2023 16:19:00'!
PASSED!

!testRun: #Portfolio2Test #test08reportsAccountSummaryWithWithdrawTransferLeg stamp: 'OA 10/26/2023 16:19:00'!
PASSED!

!testRun: #Portfolio2Test #test09reportsPortfolioSummaryWithManyAccounts stamp: 'OA 10/26/2023 16:19:00'!
PASSED!

!testRun: #Portfolio2Test #test10reportsTransferNetForWithdrawLegs stamp: 'OA 10/26/2023 16:19:00'!
PASSED!

!testRun: #Portfolio2Test #test11reportsTransferNetForDepositLegs stamp: 'OA 10/26/2023 16:19:00'!
PASSED!

!testRun: #Portfolio2Test #test12reportsTransferNetForMultipleTransfers stamp: 'OA 10/26/2023 16:19:00'!
PASSED!

!testRun: #Portfolio2Test #test13reportsTransferNetForPortfoliosWithMultipleAccounts stamp: 'OA 10/26/2023 16:19:00'!
PASSED!

!testRun: #Portfolio2Test #test14reportsTransferNetForEmptyAccount stamp: 'OA 10/26/2023 16:19:00'!
PASSED!

!testRun: #Portfolio2Test #test15reportsPortfolioTreeWithEmptyPortfolio stamp: 'OA 10/26/2023 16:19:00'!
PASSED!

!testRun: #Portfolio2Test #test16reportPortfolioTreeWithOneChild stamp: 'OA 10/26/2023 16:19:00'!
PASSED!

!testRun: #Portfolio2Test #test17reportPortfolioTreeWithBigHierarchy stamp: 'OA 10/26/2023 16:19:00'!
PASSED!

!testRun: #Portfolio2Test #test18transferAmountShouldBePositive stamp: 'OA 10/26/2023 16:19:00'!
PASSED!

!testRun: #Portfolio2Test #test19transferToYourselfIsNotAllowed stamp: 'OA 10/26/2023 16:19:00'!
PASSED!

!testRun: #PortfolioTest #test01BalanceOfPortfolioWithoutAccountsIsZero stamp: 'OA 10/26/2023 16:19:10'!
PASSED!

!testRun: #PortfolioTest #test02BalanceOfPortfolioWithAccountsIsSumOfAccountsBalance stamp: 'OA 10/26/2023 16:19:10'!
PASSED!

!testRun: #PortfolioTest #test03BalanceOfPortfolioIsCalculatedRecursivelyOnPortfolios stamp: 'OA 10/26/2023 16:19:10'!
PASSED!

!testRun: #PortfolioTest #test04PortfolioWithoutAccountsHasNoRegisteredTransaction stamp: 'OA 10/26/2023 16:19:10'!
PASSED!

!testRun: #PortfolioTest #test05PortfolioHasRegisteredItsAccountsTransactions stamp: 'OA 10/26/2023 16:19:10'!
PASSED!

!testRun: #PortfolioTest #test06PortfolioLooksForRegisteredTransactionsRecursively stamp: 'OA 10/26/2023 16:19:10'!
PASSED!

!testRun: #PortfolioTest #test07PortfolioHasNoTransactionWhenHasNoAccounts stamp: 'OA 10/26/2023 16:19:10'!
PASSED!

!testRun: #PortfolioTest #test08PortfolioTransactionsIncludesAllItsAccountsTransactions stamp: 'OA 10/26/2023 16:19:10'!
PASSED!

!testRun: #PortfolioTest #test09PortfolioTransactionsAreCalculatedRecursively stamp: 'OA 10/26/2023 16:19:10'!
PASSED!

!testRun: #PortfolioTest #test10PortfolioCanNotIncludeTheSameAccountMoreThanOnce stamp: 'OA 10/26/2023 16:19:10'!
PASSED!

!testRun: #PortfolioTest #test11PortfolioCanNotIncludeAccountOfItsPortfolios stamp: 'OA 10/26/2023 16:19:10'!
PASSED!

!testRun: #PortfolioTest #test12PortfolioCanNotIncludeItself stamp: 'OA 10/26/2023 16:19:10'!
PASSED!

!testRun: #PortfolioTest #test13ComposedPortfolioCanNotHaveParentPortfolioAccount stamp: 'OA 10/26/2023 16:19:10'!
PASSED!

!testRun: #PortfolioTest #test14ComposedPortfolioCanNotHaveAccountOfAnyRootParentRecursively stamp: 'OA 10/26/2023 16:19:10'!
PASSED!

!testRun: #PortfolioTest #test15PortfolioCanNotIncludeAnyOfTheComposedAccountOfPortfolioToAdd stamp: 'OA 10/26/2023 16:19:10'!
PASSED!

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'OA 10/26/2023 16:19:15'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'OA 10/26/2023 16:19:15'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'OA 10/26/2023 16:19:15'!
PASSED!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'OA 10/26/2023 16:19:15'!
PASSED!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'OA 10/26/2023 16:19:15'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'OA 10/26/2023 16:19:15'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'OA 10/26/2023 16:19:15'!
PASSED!

----QUIT----(26 October 2023 16:19:33) CuisUniversity-5981.image priorSource: 10585502!

----STARTUP---- (26 October 2023 16:20:28) as /home/oscar/Downloads/linux64/linux64/CuisUniversity-5981.image!


!testRun: #Portfolio2Test #test01trasferringModifiesBalanceByCorrectAmount stamp: 'OA 10/26/2023 16:20:31'!
PASSED!

!testRun: #Portfolio2Test #test02transferringGetsRegisteredInBothAccounts stamp: 'OA 10/26/2023 16:20:31'!
PASSED!

!testRun: #Portfolio2Test #test03canNavigateBetweenTransferLegs stamp: 'OA 10/26/2023 16:20:31'!
PASSED!

!testRun: #Portfolio2Test #test04reportsAccountSummaryOfEmptyAccount stamp: 'OA 10/26/2023 16:20:31'!
PASSED!

!testRun: #Portfolio2Test #test05reportsAccountSummaryWithWithdrawal stamp: 'OA 10/26/2023 16:20:31'!
PASSED!

!testRun: #Portfolio2Test #test06reportsAccountSummaryWithDeposit stamp: 'OA 10/26/2023 16:20:31'!
PASSED!

!testRun: #Portfolio2Test #test07reportsAccountSummaryWithDepositTransferLeg stamp: 'OA 10/26/2023 16:20:31'!
PASSED!

!testRun: #Portfolio2Test #test08reportsAccountSummaryWithWithdrawTransferLeg stamp: 'OA 10/26/2023 16:20:31'!
PASSED!

!testRun: #Portfolio2Test #test09reportsPortfolioSummaryWithManyAccounts stamp: 'OA 10/26/2023 16:20:31'!
PASSED!

!testRun: #Portfolio2Test #test10reportsTransferNetForWithdrawLegs stamp: 'OA 10/26/2023 16:20:31'!
PASSED!

!testRun: #Portfolio2Test #test11reportsTransferNetForDepositLegs stamp: 'OA 10/26/2023 16:20:31'!
PASSED!

!testRun: #Portfolio2Test #test12reportsTransferNetForMultipleTransfers stamp: 'OA 10/26/2023 16:20:31'!
PASSED!

!testRun: #Portfolio2Test #test13reportsTransferNetForPortfoliosWithMultipleAccounts stamp: 'OA 10/26/2023 16:20:31'!
PASSED!

!testRun: #Portfolio2Test #test14reportsTransferNetForEmptyAccount stamp: 'OA 10/26/2023 16:20:31'!
PASSED!

!testRun: #Portfolio2Test #test15reportsPortfolioTreeWithEmptyPortfolio stamp: 'OA 10/26/2023 16:20:31'!
PASSED!

!testRun: #Portfolio2Test #test16reportPortfolioTreeWithOneChild stamp: 'OA 10/26/2023 16:20:31'!
PASSED!

!testRun: #Portfolio2Test #test17reportPortfolioTreeWithBigHierarchy stamp: 'OA 10/26/2023 16:20:31'!
PASSED!

!testRun: #Portfolio2Test #test18transferAmountShouldBePositive stamp: 'OA 10/26/2023 16:20:31'!
PASSED!

!testRun: #Portfolio2Test #test19transferToYourselfIsNotAllowed stamp: 'OA 10/26/2023 16:20:31'!
PASSED!

!testRun: #PortfolioTest #test01BalanceOfPortfolioWithoutAccountsIsZero stamp: 'OA 10/26/2023 16:20:37'!
PASSED!

!testRun: #PortfolioTest #test02BalanceOfPortfolioWithAccountsIsSumOfAccountsBalance stamp: 'OA 10/26/2023 16:20:37'!
PASSED!

!testRun: #PortfolioTest #test03BalanceOfPortfolioIsCalculatedRecursivelyOnPortfolios stamp: 'OA 10/26/2023 16:20:37'!
PASSED!

!testRun: #PortfolioTest #test04PortfolioWithoutAccountsHasNoRegisteredTransaction stamp: 'OA 10/26/2023 16:20:37'!
PASSED!

!testRun: #PortfolioTest #test05PortfolioHasRegisteredItsAccountsTransactions stamp: 'OA 10/26/2023 16:20:37'!
PASSED!

!testRun: #PortfolioTest #test06PortfolioLooksForRegisteredTransactionsRecursively stamp: 'OA 10/26/2023 16:20:37'!
PASSED!

!testRun: #PortfolioTest #test07PortfolioHasNoTransactionWhenHasNoAccounts stamp: 'OA 10/26/2023 16:20:37'!
PASSED!

!testRun: #PortfolioTest #test08PortfolioTransactionsIncludesAllItsAccountsTransactions stamp: 'OA 10/26/2023 16:20:37'!
PASSED!

!testRun: #PortfolioTest #test09PortfolioTransactionsAreCalculatedRecursively stamp: 'OA 10/26/2023 16:20:37'!
PASSED!

!testRun: #PortfolioTest #test10PortfolioCanNotIncludeTheSameAccountMoreThanOnce stamp: 'OA 10/26/2023 16:20:37'!
PASSED!

!testRun: #PortfolioTest #test11PortfolioCanNotIncludeAccountOfItsPortfolios stamp: 'OA 10/26/2023 16:20:37'!
PASSED!

!testRun: #PortfolioTest #test12PortfolioCanNotIncludeItself stamp: 'OA 10/26/2023 16:20:37'!
PASSED!

!testRun: #PortfolioTest #test13ComposedPortfolioCanNotHaveParentPortfolioAccount stamp: 'OA 10/26/2023 16:20:37'!
PASSED!

!testRun: #PortfolioTest #test14ComposedPortfolioCanNotHaveAccountOfAnyRootParentRecursively stamp: 'OA 10/26/2023 16:20:37'!
PASSED!

!testRun: #PortfolioTest #test15PortfolioCanNotIncludeAnyOfTheComposedAccountOfPortfolioToAdd stamp: 'OA 10/26/2023 16:20:37'!
PASSED!

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'OA 10/26/2023 16:20:39'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'OA 10/26/2023 16:20:39'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'OA 10/26/2023 16:20:39'!
PASSED!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'OA 10/26/2023 16:20:39'!
PASSED!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'OA 10/26/2023 16:20:39'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'OA 10/26/2023 16:20:39'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'OA 10/26/2023 16:20:39'!
PASSED!

!testRun: #PortfolioTest #test01BalanceOfPortfolioWithoutAccountsIsZero stamp: 'OA 10/26/2023 16:20:41'!
PASSED!

!testRun: #PortfolioTest #test02BalanceOfPortfolioWithAccountsIsSumOfAccountsBalance stamp: 'OA 10/26/2023 16:20:41'!
PASSED!

!testRun: #PortfolioTest #test03BalanceOfPortfolioIsCalculatedRecursivelyOnPortfolios stamp: 'OA 10/26/2023 16:20:41'!
PASSED!

!testRun: #PortfolioTest #test04PortfolioWithoutAccountsHasNoRegisteredTransaction stamp: 'OA 10/26/2023 16:20:41'!
PASSED!

!testRun: #PortfolioTest #test05PortfolioHasRegisteredItsAccountsTransactions stamp: 'OA 10/26/2023 16:20:41'!
PASSED!

!testRun: #PortfolioTest #test06PortfolioLooksForRegisteredTransactionsRecursively stamp: 'OA 10/26/2023 16:20:41'!
PASSED!

!testRun: #PortfolioTest #test07PortfolioHasNoTransactionWhenHasNoAccounts stamp: 'OA 10/26/2023 16:20:41'!
PASSED!

!testRun: #PortfolioTest #test08PortfolioTransactionsIncludesAllItsAccountsTransactions stamp: 'OA 10/26/2023 16:20:41'!
PASSED!

!testRun: #PortfolioTest #test09PortfolioTransactionsAreCalculatedRecursively stamp: 'OA 10/26/2023 16:20:41'!
PASSED!

!testRun: #PortfolioTest #test10PortfolioCanNotIncludeTheSameAccountMoreThanOnce stamp: 'OA 10/26/2023 16:20:41'!
PASSED!

!testRun: #PortfolioTest #test11PortfolioCanNotIncludeAccountOfItsPortfolios stamp: 'OA 10/26/2023 16:20:41'!
PASSED!

!testRun: #PortfolioTest #test12PortfolioCanNotIncludeItself stamp: 'OA 10/26/2023 16:20:41'!
PASSED!

!testRun: #PortfolioTest #test13ComposedPortfolioCanNotHaveParentPortfolioAccount stamp: 'OA 10/26/2023 16:20:41'!
PASSED!

!testRun: #PortfolioTest #test14ComposedPortfolioCanNotHaveAccountOfAnyRootParentRecursively stamp: 'OA 10/26/2023 16:20:41'!
PASSED!

!testRun: #PortfolioTest #test15PortfolioCanNotIncludeAnyOfTheComposedAccountOfPortfolioToAdd stamp: 'OA 10/26/2023 16:20:41'!
PASSED!

!testRun: #Portfolio2Test #test01trasferringModifiesBalanceByCorrectAmount stamp: 'OA 10/26/2023 16:20:42'!
PASSED!

!testRun: #Portfolio2Test #test02transferringGetsRegisteredInBothAccounts stamp: 'OA 10/26/2023 16:20:42'!
PASSED!

!testRun: #Portfolio2Test #test03canNavigateBetweenTransferLegs stamp: 'OA 10/26/2023 16:20:42'!
PASSED!

!testRun: #Portfolio2Test #test04reportsAccountSummaryOfEmptyAccount stamp: 'OA 10/26/2023 16:20:42'!
PASSED!

!testRun: #Portfolio2Test #test05reportsAccountSummaryWithWithdrawal stamp: 'OA 10/26/2023 16:20:42'!
PASSED!

!testRun: #Portfolio2Test #test06reportsAccountSummaryWithDeposit stamp: 'OA 10/26/2023 16:20:42'!
PASSED!

!testRun: #Portfolio2Test #test07reportsAccountSummaryWithDepositTransferLeg stamp: 'OA 10/26/2023 16:20:42'!
PASSED!

!testRun: #Portfolio2Test #test08reportsAccountSummaryWithWithdrawTransferLeg stamp: 'OA 10/26/2023 16:20:42'!
PASSED!

!testRun: #Portfolio2Test #test09reportsPortfolioSummaryWithManyAccounts stamp: 'OA 10/26/2023 16:20:42'!
PASSED!

!testRun: #Portfolio2Test #test10reportsTransferNetForWithdrawLegs stamp: 'OA 10/26/2023 16:20:42'!
PASSED!

!testRun: #Portfolio2Test #test11reportsTransferNetForDepositLegs stamp: 'OA 10/26/2023 16:20:42'!
PASSED!

!testRun: #Portfolio2Test #test12reportsTransferNetForMultipleTransfers stamp: 'OA 10/26/2023 16:20:42'!
PASSED!

!testRun: #Portfolio2Test #test13reportsTransferNetForPortfoliosWithMultipleAccounts stamp: 'OA 10/26/2023 16:20:42'!
PASSED!

!testRun: #Portfolio2Test #test14reportsTransferNetForEmptyAccount stamp: 'OA 10/26/2023 16:20:42'!
PASSED!

!testRun: #Portfolio2Test #test15reportsPortfolioTreeWithEmptyPortfolio stamp: 'OA 10/26/2023 16:20:42'!
PASSED!

!testRun: #Portfolio2Test #test16reportPortfolioTreeWithOneChild stamp: 'OA 10/26/2023 16:20:42'!
PASSED!

!testRun: #Portfolio2Test #test17reportPortfolioTreeWithBigHierarchy stamp: 'OA 10/26/2023 16:20:42'!
PASSED!

!testRun: #Portfolio2Test #test18transferAmountShouldBePositive stamp: 'OA 10/26/2023 16:20:42'!
PASSED!

!testRun: #Portfolio2Test #test19transferToYourselfIsNotAllowed stamp: 'OA 10/26/2023 16:20:42'!
PASSED!

----QUIT----(26 October 2023 16:20:46) CuisUniversity-5981.image priorSource: 10717973!

----STARTUP---- (26 October 2023 16:26:28) as /home/oscar/Downloads/linux64/linux64/CuisUniversity-5981.image!


!testRun: #Portfolio2Test #test18transferAmountShouldBePositive stamp: 'OA 10/26/2023 16:26:41'!
PASSED!

!testRun: #Portfolio2Test #test19transferToYourselfIsNotAllowed stamp: 'OA 10/26/2023 16:26:42'!
PASSED!

!testRun: #Portfolio2Test #test01trasferringModifiesBalanceByCorrectAmount stamp: 'OA 10/26/2023 16:31:29'!
PASSED!

!testRun: #Portfolio2Test #test02transferringGetsRegisteredInBothAccounts stamp: 'OA 10/26/2023 16:31:29'!
PASSED!

!testRun: #Portfolio2Test #test03canNavigateBetweenTransferLegs stamp: 'OA 10/26/2023 16:31:29'!
PASSED!

!testRun: #Portfolio2Test #test04reportsAccountSummaryOfEmptyAccount stamp: 'OA 10/26/2023 16:31:29'!
PASSED!

!testRun: #Portfolio2Test #test05reportsAccountSummaryWithWithdrawal stamp: 'OA 10/26/2023 16:31:29'!
PASSED!

!testRun: #Portfolio2Test #test06reportsAccountSummaryWithDeposit stamp: 'OA 10/26/2023 16:31:29'!
PASSED!

!testRun: #Portfolio2Test #test07reportsAccountSummaryWithDepositTransferLeg stamp: 'OA 10/26/2023 16:31:29'!
PASSED!

!testRun: #Portfolio2Test #test08reportsAccountSummaryWithWithdrawTransferLeg stamp: 'OA 10/26/2023 16:31:29'!
PASSED!

!testRun: #Portfolio2Test #test09reportsPortfolioSummaryWithManyAccounts stamp: 'OA 10/26/2023 16:31:29'!
PASSED!

!testRun: #Portfolio2Test #test10reportsTransferNetForWithdrawLegs stamp: 'OA 10/26/2023 16:31:29'!
PASSED!

!testRun: #Portfolio2Test #test11reportsTransferNetForDepositLegs stamp: 'OA 10/26/2023 16:31:29'!
PASSED!

!testRun: #Portfolio2Test #test12reportsTransferNetForMultipleTransfers stamp: 'OA 10/26/2023 16:31:29'!
PASSED!

!testRun: #Portfolio2Test #test13reportsTransferNetForPortfoliosWithMultipleAccounts stamp: 'OA 10/26/2023 16:31:29'!
PASSED!

!testRun: #Portfolio2Test #test14reportsTransferNetForEmptyAccount stamp: 'OA 10/26/2023 16:31:29'!
PASSED!

!testRun: #Portfolio2Test #test15reportsPortfolioTreeWithEmptyPortfolio stamp: 'OA 10/26/2023 16:31:29'!
PASSED!

!testRun: #Portfolio2Test #test16reportPortfolioTreeWithOneChild stamp: 'OA 10/26/2023 16:31:29'!
PASSED!

!testRun: #Portfolio2Test #test17reportPortfolioTreeWithBigHierarchy stamp: 'OA 10/26/2023 16:31:29'!
PASSED!

!testRun: #Portfolio2Test #test18transferAmountShouldBePositive stamp: 'OA 10/26/2023 16:31:29'!
PASSED!

!testRun: #Portfolio2Test #test19transferToYourselfIsNotAllowed stamp: 'OA 10/26/2023 16:31:29'!
PASSED!

!testRun: #Portfolio2Test #test01trasferringModifiesBalanceByCorrectAmount stamp: 'OA 10/26/2023 16:32:14'!
PASSED!

!testRun: #Portfolio2Test #test02transferringGetsRegisteredInBothAccounts stamp: 'OA 10/26/2023 16:32:14'!
PASSED!

!testRun: #Portfolio2Test #test03canNavigateBetweenTransferLegs stamp: 'OA 10/26/2023 16:32:14'!
PASSED!

!testRun: #Portfolio2Test #test04reportsAccountSummaryOfEmptyAccount stamp: 'OA 10/26/2023 16:32:14'!
PASSED!

!testRun: #Portfolio2Test #test05reportsAccountSummaryWithWithdrawal stamp: 'OA 10/26/2023 16:32:14'!
PASSED!

!testRun: #Portfolio2Test #test06reportsAccountSummaryWithDeposit stamp: 'OA 10/26/2023 16:32:14'!
PASSED!

!testRun: #Portfolio2Test #test07reportsAccountSummaryWithDepositTransferLeg stamp: 'OA 10/26/2023 16:32:14'!
PASSED!

!testRun: #Portfolio2Test #test08reportsAccountSummaryWithWithdrawTransferLeg stamp: 'OA 10/26/2023 16:32:14'!
PASSED!

!testRun: #Portfolio2Test #test09reportsPortfolioSummaryWithManyAccounts stamp: 'OA 10/26/2023 16:32:14'!
PASSED!

!testRun: #Portfolio2Test #test10reportsTransferNetForWithdrawLegs stamp: 'OA 10/26/2023 16:32:14'!
PASSED!

!testRun: #Portfolio2Test #test11reportsTransferNetForDepositLegs stamp: 'OA 10/26/2023 16:32:14'!
PASSED!

!testRun: #Portfolio2Test #test12reportsTransferNetForMultipleTransfers stamp: 'OA 10/26/2023 16:32:14'!
PASSED!

!testRun: #Portfolio2Test #test13reportsTransferNetForPortfoliosWithMultipleAccounts stamp: 'OA 10/26/2023 16:32:14'!
PASSED!

!testRun: #Portfolio2Test #test14reportsTransferNetForEmptyAccount stamp: 'OA 10/26/2023 16:32:14'!
PASSED!

!testRun: #Portfolio2Test #test15reportsPortfolioTreeWithEmptyPortfolio stamp: 'OA 10/26/2023 16:32:14'!
PASSED!

!testRun: #Portfolio2Test #test16reportPortfolioTreeWithOneChild stamp: 'OA 10/26/2023 16:32:14'!
PASSED!

!testRun: #Portfolio2Test #test17reportPortfolioTreeWithBigHierarchy stamp: 'OA 10/26/2023 16:32:14'!
PASSED!

!testRun: #Portfolio2Test #test18transferAmountShouldBePositive stamp: 'OA 10/26/2023 16:32:14'!
PASSED!

!testRun: #Portfolio2Test #test19transferToYourselfIsNotAllowed stamp: 'OA 10/26/2023 16:32:14'!
PASSED!

!testRun: #PortfolioTest #test01BalanceOfPortfolioWithoutAccountsIsZero stamp: 'OA 10/26/2023 16:32:16'!
PASSED!

!testRun: #PortfolioTest #test02BalanceOfPortfolioWithAccountsIsSumOfAccountsBalance stamp: 'OA 10/26/2023 16:32:16'!
PASSED!

!testRun: #PortfolioTest #test03BalanceOfPortfolioIsCalculatedRecursivelyOnPortfolios stamp: 'OA 10/26/2023 16:32:16'!
PASSED!

!testRun: #PortfolioTest #test04PortfolioWithoutAccountsHasNoRegisteredTransaction stamp: 'OA 10/26/2023 16:32:16'!
PASSED!

!testRun: #PortfolioTest #test05PortfolioHasRegisteredItsAccountsTransactions stamp: 'OA 10/26/2023 16:32:16'!
PASSED!

!testRun: #PortfolioTest #test06PortfolioLooksForRegisteredTransactionsRecursively stamp: 'OA 10/26/2023 16:32:16'!
PASSED!

!testRun: #PortfolioTest #test07PortfolioHasNoTransactionWhenHasNoAccounts stamp: 'OA 10/26/2023 16:32:17'!
PASSED!

!testRun: #PortfolioTest #test08PortfolioTransactionsIncludesAllItsAccountsTransactions stamp: 'OA 10/26/2023 16:32:17'!
PASSED!

!testRun: #PortfolioTest #test09PortfolioTransactionsAreCalculatedRecursively stamp: 'OA 10/26/2023 16:32:17'!
PASSED!

!testRun: #PortfolioTest #test10PortfolioCanNotIncludeTheSameAccountMoreThanOnce stamp: 'OA 10/26/2023 16:32:17'!
PASSED!

!testRun: #PortfolioTest #test11PortfolioCanNotIncludeAccountOfItsPortfolios stamp: 'OA 10/26/2023 16:32:17'!
PASSED!

!testRun: #PortfolioTest #test12PortfolioCanNotIncludeItself stamp: 'OA 10/26/2023 16:32:17'!
PASSED!

!testRun: #PortfolioTest #test13ComposedPortfolioCanNotHaveParentPortfolioAccount stamp: 'OA 10/26/2023 16:32:17'!
PASSED!

!testRun: #PortfolioTest #test14ComposedPortfolioCanNotHaveAccountOfAnyRootParentRecursively stamp: 'OA 10/26/2023 16:32:17'!
PASSED!

!testRun: #PortfolioTest #test15PortfolioCanNotIncludeAnyOfTheComposedAccountOfPortfolioToAdd stamp: 'OA 10/26/2023 16:32:17'!
PASSED!

!testRun: #Portfolio2Test #test01trasferringModifiesBalanceByCorrectAmount stamp: 'OA 10/26/2023 16:32:21'!
PASSED!

!testRun: #Portfolio2Test #test02transferringGetsRegisteredInBothAccounts stamp: 'OA 10/26/2023 16:32:21'!
PASSED!

!testRun: #Portfolio2Test #test03canNavigateBetweenTransferLegs stamp: 'OA 10/26/2023 16:32:21'!
PASSED!

!testRun: #Portfolio2Test #test04reportsAccountSummaryOfEmptyAccount stamp: 'OA 10/26/2023 16:32:21'!
PASSED!

!testRun: #Portfolio2Test #test05reportsAccountSummaryWithWithdrawal stamp: 'OA 10/26/2023 16:32:21'!
PASSED!

!testRun: #Portfolio2Test #test06reportsAccountSummaryWithDeposit stamp: 'OA 10/26/2023 16:32:21'!
PASSED!

!testRun: #Portfolio2Test #test07reportsAccountSummaryWithDepositTransferLeg stamp: 'OA 10/26/2023 16:32:21'!
PASSED!

!testRun: #Portfolio2Test #test08reportsAccountSummaryWithWithdrawTransferLeg stamp: 'OA 10/26/2023 16:32:21'!
PASSED!

!testRun: #Portfolio2Test #test09reportsPortfolioSummaryWithManyAccounts stamp: 'OA 10/26/2023 16:32:21'!
PASSED!

!testRun: #Portfolio2Test #test10reportsTransferNetForWithdrawLegs stamp: 'OA 10/26/2023 16:32:21'!
PASSED!

!testRun: #Portfolio2Test #test11reportsTransferNetForDepositLegs stamp: 'OA 10/26/2023 16:32:21'!
PASSED!

!testRun: #Portfolio2Test #test12reportsTransferNetForMultipleTransfers stamp: 'OA 10/26/2023 16:32:21'!
PASSED!

!testRun: #Portfolio2Test #test13reportsTransferNetForPortfoliosWithMultipleAccounts stamp: 'OA 10/26/2023 16:32:21'!
PASSED!

!testRun: #Portfolio2Test #test14reportsTransferNetForEmptyAccount stamp: 'OA 10/26/2023 16:32:21'!
PASSED!

!testRun: #Portfolio2Test #test15reportsPortfolioTreeWithEmptyPortfolio stamp: 'OA 10/26/2023 16:32:21'!
PASSED!

!testRun: #Portfolio2Test #test16reportPortfolioTreeWithOneChild stamp: 'OA 10/26/2023 16:32:21'!
PASSED!

!testRun: #Portfolio2Test #test17reportPortfolioTreeWithBigHierarchy stamp: 'OA 10/26/2023 16:32:21'!
PASSED!

!testRun: #Portfolio2Test #test18transferAmountShouldBePositive stamp: 'OA 10/26/2023 16:32:21'!
PASSED!

!testRun: #Portfolio2Test #test19transferToYourselfIsNotAllowed stamp: 'OA 10/26/2023 16:32:21'!
PASSED!

!testRun: #PortfolioTest #test01BalanceOfPortfolioWithoutAccountsIsZero stamp: 'OA 10/26/2023 16:32:23'!
PASSED!

!testRun: #PortfolioTest #test02BalanceOfPortfolioWithAccountsIsSumOfAccountsBalance stamp: 'OA 10/26/2023 16:32:23'!
PASSED!

!testRun: #PortfolioTest #test03BalanceOfPortfolioIsCalculatedRecursivelyOnPortfolios stamp: 'OA 10/26/2023 16:32:23'!
PASSED!

!testRun: #PortfolioTest #test04PortfolioWithoutAccountsHasNoRegisteredTransaction stamp: 'OA 10/26/2023 16:32:23'!
PASSED!

!testRun: #PortfolioTest #test05PortfolioHasRegisteredItsAccountsTransactions stamp: 'OA 10/26/2023 16:32:23'!
PASSED!

!testRun: #PortfolioTest #test06PortfolioLooksForRegisteredTransactionsRecursively stamp: 'OA 10/26/2023 16:32:23'!
PASSED!

!testRun: #PortfolioTest #test07PortfolioHasNoTransactionWhenHasNoAccounts stamp: 'OA 10/26/2023 16:32:23'!
PASSED!

!testRun: #PortfolioTest #test08PortfolioTransactionsIncludesAllItsAccountsTransactions stamp: 'OA 10/26/2023 16:32:23'!
PASSED!

!testRun: #PortfolioTest #test09PortfolioTransactionsAreCalculatedRecursively stamp: 'OA 10/26/2023 16:32:23'!
PASSED!

!testRun: #PortfolioTest #test10PortfolioCanNotIncludeTheSameAccountMoreThanOnce stamp: 'OA 10/26/2023 16:32:23'!
PASSED!

!testRun: #PortfolioTest #test11PortfolioCanNotIncludeAccountOfItsPortfolios stamp: 'OA 10/26/2023 16:32:23'!
PASSED!

!testRun: #PortfolioTest #test12PortfolioCanNotIncludeItself stamp: 'OA 10/26/2023 16:32:23'!
PASSED!

!testRun: #PortfolioTest #test13ComposedPortfolioCanNotHaveParentPortfolioAccount stamp: 'OA 10/26/2023 16:32:23'!
PASSED!

!testRun: #PortfolioTest #test14ComposedPortfolioCanNotHaveAccountOfAnyRootParentRecursively stamp: 'OA 10/26/2023 16:32:23'!
PASSED!

!testRun: #PortfolioTest #test15PortfolioCanNotIncludeAnyOfTheComposedAccountOfPortfolioToAdd stamp: 'OA 10/26/2023 16:32:23'!
PASSED!

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'OA 10/26/2023 16:32:24'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'OA 10/26/2023 16:32:24'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'OA 10/26/2023 16:32:24'!
PASSED!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'OA 10/26/2023 16:32:24'!
PASSED!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'OA 10/26/2023 16:32:24'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'OA 10/26/2023 16:32:24'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'OA 10/26/2023 16:32:24'!
PASSED!

----STARTUP---- (26 October 2023 17:26:54) as C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\CuisUniversity-5981.image!


----QUIT----(26 October 2023 18:08:16) CuisUniversity-5981.image priorSource: 12036172!

----STARTUP---- (26 October 2023 18:11:50) as C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\CuisUniversity-5981.image!


!classRenamed: #Reports as: #TransactionVisitor stamp: 'LK 10/26/2023 18:32:36'!
Smalltalk renameClassNamed: #Reports as: #TransactionVisitor!
!Portfolio2Test methodsFor: 'tests' stamp: 'LK 10/26/2023 18:34:23'!
test14reportsTransferNetDoesntChangeWithOtherOperations
	
	|account expectedValue report|
	
	
	account := ReceptiveAccount new.
	report := TransferNetReport for: account.
	
	expectedValue := 0.
	
	self assert: report process = expectedValue.! !
!Portfolio2Test methodsFor: 'tests' stamp: 'LK 10/26/2023 18:35:25' prior: 50707799!
test14reportsTransferNetDoesntChangeWithOtherOperations
	
	|account expectedValue report|
	account := ReceptiveAccount new.	
	report := TransferNetReport for: account.
	Withdraw register: 50 for: account.
	
	expectedValue := 0.
	
	self assert: report process = expectedValue.! !
!Portfolio2Test methodsFor: 'tests' stamp: 'LK 10/26/2023 18:36:56' prior: 50707810!
test14reportsTransferNetDoesntChangeWithOtherOperations
	
	|account expectedValue report|
	account := ReceptiveAccount new.	
	report := TransferNetReport for: account.
	Withdraw register: 50 on: account.
	
	expectedValue := 0.
	
	self assert: report process = expectedValue.! !

!testRun: #Portfolio2Test #test14reportsTransferNetDoesntChangeWithOtherOperations stamp: 'LK 10/26/2023 18:36:57'!
PASSED!

!testRun: #Portfolio2Test #test01trasferringModifiesBalanceByCorrectAmount stamp: 'LK 10/26/2023 18:36:57'!
PASSED!

!testRun: #Portfolio2Test #test02transferringGetsRegisteredInBothAccounts stamp: 'LK 10/26/2023 18:36:57'!
PASSED!

!testRun: #Portfolio2Test #test03canNavigateBetweenTransferLegs stamp: 'LK 10/26/2023 18:36:57'!
PASSED!

!testRun: #Portfolio2Test #test04reportsAccountSummaryOfEmptyAccount stamp: 'LK 10/26/2023 18:36:57'!
PASSED!

!testRun: #Portfolio2Test #test05reportsAccountSummaryWithWithdrawal stamp: 'LK 10/26/2023 18:36:57'!
PASSED!

!testRun: #Portfolio2Test #test06reportsAccountSummaryWithDeposit stamp: 'LK 10/26/2023 18:36:57'!
PASSED!

!testRun: #Portfolio2Test #test07reportsAccountSummaryWithDepositTransferLeg stamp: 'LK 10/26/2023 18:36:57'!
PASSED!

!testRun: #Portfolio2Test #test08reportsAccountSummaryWithWithdrawTransferLeg stamp: 'LK 10/26/2023 18:36:57'!
PASSED!

!testRun: #Portfolio2Test #test09reportsPortfolioSummaryWithManyAccounts stamp: 'LK 10/26/2023 18:36:57'!
PASSED!

!testRun: #Portfolio2Test #test10reportsTransferNetForWithdrawLegs stamp: 'LK 10/26/2023 18:36:57'!
PASSED!

!testRun: #Portfolio2Test #test11reportsTransferNetForDepositLegs stamp: 'LK 10/26/2023 18:36:57'!
PASSED!

!testRun: #Portfolio2Test #test12reportsTransferNetForMultipleTransfers stamp: 'LK 10/26/2023 18:36:57'!
PASSED!

!testRun: #Portfolio2Test #test13reportsTransferNetForPortfoliosWithMultipleAccounts stamp: 'LK 10/26/2023 18:36:57'!
PASSED!

!testRun: #Portfolio2Test #test14reportsTransferNetDoesntChangeWithOtherOperations stamp: 'LK 10/26/2023 18:36:57'!
PASSED!

!testRun: #Portfolio2Test #test14reportsTransferNetForEmptyAccount stamp: 'LK 10/26/2023 18:36:57'!
PASSED!

!testRun: #Portfolio2Test #test15reportsPortfolioTreeWithEmptyPortfolio stamp: 'LK 10/26/2023 18:36:57'!
PASSED!

!testRun: #Portfolio2Test #test16reportPortfolioTreeWithOneChild stamp: 'LK 10/26/2023 18:36:57'!
PASSED!

!testRun: #Portfolio2Test #test17reportPortfolioTreeWithBigHierarchy stamp: 'LK 10/26/2023 18:36:57'!
PASSED!

!testRun: #Portfolio2Test #test18transferAmountShouldBePositive stamp: 'LK 10/26/2023 18:36:57'!
PASSED!

!testRun: #Portfolio2Test #test19transferToYourselfIsNotAllowed stamp: 'LK 10/26/2023 18:36:57'!
PASSED!

----End fileIn of C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\MarsRover-WithHeading.st----!

!classRemoval: #MarsRoverHeadingWest stamp: 'LK 10/26/2023 20:25:24'!
MarsRoverHeading subclass: #MarsRoverHeadingWest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!

!classRemoval: #MarsRoverHeadingSouth stamp: 'LK 10/26/2023 20:25:24'!
MarsRoverHeading subclass: #MarsRoverHeadingSouth
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!

!classRemoval: #MarsRoverHeadingNorth stamp: 'LK 10/26/2023 20:25:25'!
MarsRoverHeading subclass: #MarsRoverHeadingNorth
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!

!classRemoval: #MarsRoverHeadingEast stamp: 'LK 10/26/2023 20:25:25'!
MarsRoverHeading subclass: #MarsRoverHeadingEast
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!

!classRemoval: #MarsRoverHeading stamp: 'LK 10/26/2023 20:25:25'!
Object subclass: #MarsRoverHeading
	instanceVariableNames: 'marsRover'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!

!classRemoval: #MarsRover stamp: 'LK 10/26/2023 20:25:25'!
Object subclass: #MarsRover
	instanceVariableNames: 'position head'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!

!classRemoval: #MarsRoverTest stamp: 'LK 10/26/2023 20:25:26'!
TestCase subclass: #MarsRoverTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!

----End fileIn of C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\MarsRover-WithHeading.st----!

TestCase subclass: #XXXTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!

!classDefinition: #XXXTest category: 'MarsRover-WithHeading' stamp: 'LK 10/26/2023 20:56:30'!
TestCase subclass: #XXXTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!
!XXXTest methodsFor: 'nil' stamp: 'LK 10/26/2023 20:57:26'!
test01

	|marsRover|
	
	marsRover := MarsRover at: 1@1 heading: MarsRoverHeadingSouth.
	
	self assert: (marsRover log = OrderedCollection new).! !

!testRun: #XXXTest #test01 stamp: 'LK 10/26/2023 20:57:27'!
ERROR!
!MarsRover methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 20:57:36'!
log
	self shouldBeImplemented.! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 20:57:51' prior: 50708952!
log
	
	^OrderedCollection new.! !

!testRun: #XXXTest #test01 stamp: 'LK 10/26/2023 20:57:56'!
PASSED!

!testRun: #XXXTest #test01 stamp: 'LK 10/26/2023 20:57:56'!
PASSED!
!XXXTest methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 20:58:02'!
test02! !
!XXXTest methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 20:59:39' prior: 50708964!
test02
	
	|marsRover expectedLog| 
	
	marsRover := MarsRover at: 1@1 heading: MarsRoverHeadingSouth.
	
	marsRover process: 'f'.
	
	expectedLog := OrderedCollection new.
	expectedLog add: 1@2.
	
	self assert:(marsRover log = expectedLog).! !

Object subclass: #MarsRover
	instanceVariableNames: 'position head log'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!

!classDefinition: #MarsRover category: 'MarsRover-WithHeading' stamp: 'LK 10/26/2023 20:59:50'!
Object subclass: #MarsRover
	instanceVariableNames: 'position head log'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!
!MarsRover methodsFor: 'as yet unclassified' stamp: 'LK 10/26/2023 21:00:02' prior: 50708956!
log
	
	^log.! !

----QUIT----(26 October 2023 21:10:27) CuisUniversity-5981.image priorSource: 12036392!

----STARTUP---- (29 October 2023 15:40:08) as C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\CuisUniversity-5981.image!


----QUIT----(29 October 2023 15:48:23) CuisUniversity-5981.image priorSource: 12075023!

----STARTUP---- (29 October 2023 23:37:25) as C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\CuisUniversity-5981.image!

!XXXTest methodsFor: 'as yet unclassified' stamp: 'LK 10/29/2023 23:39:40' prior: 50708942!
test01

	|marsRover logs|
	
	marsRover := MarsRover at: 1@1 heading: MarsRoverHeadingSouth.
	logs := OrderedCollection new.
	
	self assert: (marsRover log = logs).! !

!testRun: #XXXTest #test01 stamp: 'LK 10/29/2023 23:39:44'!
FAILURE!

!testRun: #XXXTest #test01 stamp: 'LK 10/29/2023 23:39:44'!
FAILURE!

!testRun: #XXXTest #test01 stamp: 'LK 10/29/2023 23:39:47'!
FAILURE!

!testRun: #XXXTest #test01 stamp: 'LK 10/29/2023 23:39:47'!
FAILURE!
!MarsRover methodsFor: 'initialization' stamp: 'LK 10/29/2023 23:41:42' prior: 50708633!
initializeAt: aPosition heading: aHeadingType

	position := aPosition.
	head := aHeadingType for: self.
	log := OrderedCollection new.! !

!testRun: #XXXTest #test01 stamp: 'LK 10/29/2023 23:41:44'!
PASSED!

!testRun: #XXXTest #test01 stamp: 'LK 10/29/2023 23:41:44'!
PASSED!

!testRun: #XXXTest #test02 stamp: 'LK 10/29/2023 23:41:44'!
FAILURE!

!testRun: #XXXTest #test02 stamp: 'LK 10/29/2023 23:41:44'!
FAILURE!

Object subclass: #MarsRover
	instanceVariableNames: 'position head logs'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!

!classDefinition: #MarsRover category: 'MarsRover-WithHeading' stamp: 'LK 10/29/2023 23:42:00'!
Object subclass: #MarsRover
	instanceVariableNames: 'position head logs'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!
!MarsRover methodsFor: 'as yet unclassified' stamp: 'LK 10/29/2023 23:42:08' prior: 50708992!
log
	
	^logs! !
!MarsRover methodsFor: 'initialization' stamp: 'LK 10/29/2023 23:42:14' prior: 50709027!
initializeAt: aPosition heading: aHeadingType

	position := aPosition.
	head := aHeadingType for: self.
	logs := OrderedCollection new.! !

!testRun: #XXXTest #test01 stamp: 'LK 10/29/2023 23:42:17'!
PASSED!

!classRemoval: #XXXTest stamp: 'LK 10/30/2023 00:01:13'!
TestCase subclass: #XXXTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!

TestCase subclass: #MarsRoverExtendedFuncionalityTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!

!classDefinition: #MarsRoverExtendedFuncionalityTest category: 'MarsRover-WithHeading' stamp: 'LK 10/30/2023 00:01:42'!
TestCase subclass: #MarsRoverExtendedFuncionalityTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!
!MarsRoverExtendedFuncionalityTest methodsFor: 'no messages' stamp: 'LK 10/30/2023 00:02:04'!
test01
	! !
!MarsRoverExtendedFuncionalityTest methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 00:03:11' prior: 50709090!
test01
	
	|marsRover logs|
	
	marsRover := MarsRover new. ! !
!MarsRoverExtendedFuncionalityTest methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 00:03:30' prior: 50709095!
test01
	
	|marsRover |
	
	marsRover := MarsRover at: 1@1 heading: self north.! !
!MarsRoverExtendedFuncionalityTest methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 00:03:35' prior: 50709101!
test01
	
	|marsRover|
	
	marsRover := MarsRover at: 1@1 heading: self north.! !
!MarsRoverExtendedFuncionalityTest methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 00:03:57'!
north

	^ MarsRoverHeadingNorth ! !
!MarsRoverExtendedFuncionalityTest methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 00:04:01'!
south

	^ MarsRoverHeadingSouth! !
!MarsRoverExtendedFuncionalityTest methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 00:04:07'!
east

	^ MarsRoverHeadingEast! !
!MarsRoverExtendedFuncionalityTest methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 00:04:15'!
west

	^ MarsRoverHeadingWest! !
!MarsRoverExtendedFuncionalityTest methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 00:04:56' prior: 50709108!
test01
	
	|marsRover|
	
	marsRover := MarsRover at: 1@1 heading: self north.
	
	self assert: (marsRover log = OrderedCollection new)! !

!testRun: #MarsRoverExtendedFuncionalityTest #test01 stamp: 'LK 10/30/2023 00:05:09'!
PASSED!
!MarsRoverExtendedFuncionalityTest methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 00:05:31'!
test01logsAreEmptyAtStart
	
	|marsRover|
	
	marsRover := MarsRover at: 1@1 heading: self north.
	
	self assert: (marsRover log = OrderedCollection new)! !

!methodRemoval: MarsRoverExtendedFuncionalityTest #test01 stamp: 'LK 10/30/2023 00:05:31'!
test01
	
	|marsRover|
	
	marsRover := MarsRover at: 1@1 heading: self north.
	
	self assert: (marsRover log = OrderedCollection new)!
!MarsRoverExtendedFuncionalityTest methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 00:05:34'!
test02
	
	|marsRover|
	
	marsRover := MarsRover at: 1@1 heading: self north.
	
	self assert: (marsRover log = OrderedCollection new)! !
!MarsRoverExtendedFuncionalityTest methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 00:06:09' prior: 50709161!
test02
	
	|marsRover expectedLogs|
	
	marsRover := MarsRover at: 1@1 heading: self north.
	expectedLogs := OrderedCollection new.
	
	self assert: (marsRover log = expectedLogs)! !
!MarsRoverExtendedFuncionalityTest methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 00:07:42' prior: 50709169!
test02
	
	|marsRover expectedLogs|
	
	marsRover := MarsRover at: 1@1 heading: self north.
	expectedLogs := OrderedCollection new.
	marsRover addNewPositionLogger.
	
	marsRover process:'f'.
	
	self assert: (marsRover log = expectedLogs)! !
!MarsRoverExtendedFuncionalityTest methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 00:07:47' prior: 50709179!
test02
	
	|marsRover expectedLogs|
	
	marsRover := MarsRover at: 1@1 heading: self north.
	expectedLogs := OrderedCollection new.
	marsRover addNewPositionLogger.
	
	marsRover process: 'f'.
	
	self assert: (marsRover log = expectedLogs)! !
!MarsRover methodsFor: 'heading' stamp: 'LK 10/30/2023 00:08:16'!
addNewPositionLogger! !

Object subclass: #MarsRover
	instanceVariableNames: 'position head positionLogs directionLogs positionAndDirectionLogs'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!

!classDefinition: #MarsRover category: 'MarsRover-WithHeading' stamp: 'LK 10/30/2023 00:10:20'!
Object subclass: #MarsRover
	instanceVariableNames: 'position head positionLogs directionLogs positionAndDirectionLogs'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!
!MarsRover methodsFor: 'initialization' stamp: 'LK 10/30/2023 00:10:44' prior: 50709060!
initializeAt: aPosition heading: aHeadingType

	position := aPosition.
	head := aHeadingType for: self.
	positionLogs := OrderedCollection new.
	directionLogs := OrderedCollection new.
	positionAndDirectionLogs := OrderedCollection new.! !
!MarsRover methodsFor: 'loggers' stamp: 'LK 10/30/2023 00:13:02'!
areLoggersEmpty! !
!MarsRover methodsFor: 'loggers' stamp: 'LK 10/30/2023 00:13:48' prior: 50709231!
areLoggersEmpty
	
	^ positionLogs isEmpty and: [directionLogs isEmpty and: [positionAndDirectionLogs isEmpty]].! !
!MarsRover methodsFor: 'loggers' stamp: 'LK 10/30/2023 00:14:08'!
positionLoggerAt: aNumber
	
	^positionLogs! !
!MarsRover methodsFor: 'loggers' stamp: 'LK 10/30/2023 00:14:32' prior: 50709241!
positionLoggerAt: aNumber
	
	^positionLogs at: aNumber.! !
!MarsRover methodsFor: 'loggers' stamp: 'LK 10/30/2023 00:14:44'!
directionLoggerAt: aNumber
	
	^directionLogs at: aNumber.! !
!MarsRover methodsFor: 'loggers' stamp: 'LK 10/30/2023 00:14:54'!
bothLoggerAt: aNumber
	
	^positionAndDirectionLogs at: aNumber.! !

!methodRemoval: MarsRover #log stamp: 'LK 10/30/2023 00:14:59'!
log
	
	^logs!
!MarsRoverExtendedFuncionalityTest methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 00:15:14' prior: 50709145!
test01logsAreEmptyAtStart
	
	|marsRover|
	
	marsRover := MarsRover at: 1@1 heading: self north.
	
	self assert: (marsRover areLoggersEmpty)! !

!testRun: #MarsRoverExtendedFuncionalityTest #test01logsAreEmptyAtStart stamp: 'LK 10/30/2023 00:15:16'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test01logsAreEmptyAtStart stamp: 'LK 10/30/2023 00:15:17'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test02 stamp: 'LK 10/30/2023 00:15:17'!
ERROR!

!testRun: #MarsRoverExtendedFuncionalityTest #test02 stamp: 'LK 10/30/2023 00:15:17'!
ERROR!

!testRun: #MarsRoverExtendedFuncionalityTest #test01logsAreEmptyAtStart stamp: 'LK 10/30/2023 00:15:22'!
PASSED!
!MarsRoverExtendedFuncionalityTest methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 00:17:53' prior: 50709191!
test02
	
	|marsRover expectedLogs|
	
	marsRover := MarsRover at: 1@1 heading: self north.
	expectedLogs := OrderedCollection new.
	expectedLogs add: 1@2.
	
	marsRover addNewPositionLogger.
	marsRover process: 'f'.
	
	self assert: ((marsRover positionLoggerAt: 1) = expectedLogs).! !

!testRun: #MarsRoverExtendedFuncionalityTest #test02 stamp: 'LK 10/30/2023 00:17:54'!
ERROR!
!MarsRover methodsFor: 'moving' stamp: 'LK 10/30/2023 00:19:59' prior: 50708689!
moveEast
	
	position := position + (1@0).
	positionLogs do: [:aLogger | aLogger add: position].! !
!MarsRover methodsFor: 'moving' stamp: 'LK 10/30/2023 00:20:12' prior: 50708697!
moveNorth
	
	position := position + (0@1).
	positionLogs do: [:aLogger | aLogger add: position].! !
!MarsRover methodsFor: 'moving' stamp: 'LK 10/30/2023 00:20:15' prior: 50708701!
moveSouth
	
	position := position + (0@-1).
	positionLogs do: [:aLogger | aLogger add: position].! !
!MarsRover methodsFor: 'moving' stamp: 'LK 10/30/2023 00:20:17' prior: 50708705!
moveWest
	
	position := position + (-1@0).
	positionLogs do: [:aLogger | aLogger add: position].! !

!testRun: #MarsRoverExtendedFuncionalityTest #test02 stamp: 'LK 10/30/2023 00:20:23'!
ERROR!
!MarsRover methodsFor: 'heading' stamp: 'LK 10/30/2023 00:21:02' prior: 50709201!
addNewPositionLogger

	positionLogs add: (OrderedCollection new).! !

!testRun: #MarsRoverExtendedFuncionalityTest #test02 stamp: 'LK 10/30/2023 00:21:22'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test01logsAreEmptyAtStart stamp: 'LK 10/30/2023 00:21:22'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test02 stamp: 'LK 10/30/2023 00:21:22'!
PASSED!
!MarsRoverExtendedFuncionalityTest methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 00:21:54'!
test03
	
	|marsRover expectedLogs|
	
	marsRover := MarsRover at: 1@1 heading: self north.
	expectedLogs := OrderedCollection new.
	expectedLogs add: 1@2.
	
	marsRover addNewPositionLogger.
	marsRover process: 'f'.
	marsRover addNewPositionLogger.
	marsRover process: 'ff'.
	
	self assert: ((marsRover positionLoggerAt: 1) = expectedLogs).! !
!MarsRoverExtendedFuncionalityTest methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 00:24:07' prior: 50709344!
test03
	
	|marsRover expectedFirstLog expectedSecondLog|
	
	marsRover := MarsRover at: 1@1 heading: self north.
	expectedFirstLog := OrderedCollection new.
	expectedFirstLog add: 1@2; add: 1@3; add: 1@4.
	expectedSecondLog := OrderedCollection new.
	expectedSecondLog add: 1@3; add: 1@4.
	
	marsRover addNewPositionLogger.
	marsRover process: 'f'.
	marsRover addNewPositionLogger.
	marsRover process: 'ff'.
	
	self assert: ((marsRover positionLoggerAt: 1) = expectedFirstLog).
	self assert: ((marsRover positionLoggerAt: 2) = expectedSecondLog).! !

!testRun: #MarsRoverExtendedFuncionalityTest #test03 stamp: 'LK 10/30/2023 00:24:08'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test01logsAreEmptyAtStart stamp: 'LK 10/30/2023 00:24:08'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test02 stamp: 'LK 10/30/2023 00:24:08'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test03 stamp: 'LK 10/30/2023 00:24:08'!
PASSED!
!MarsRoverExtendedFuncionalityTest methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 00:33:20'!
test02logsPositionForSingleLogger
	
	|marsRover expectedLogs|
	
	marsRover := MarsRover at: 1@1 heading: self north.
	expectedLogs := OrderedCollection new.
	expectedLogs add: 1@2.
	
	marsRover addNewPositionLogger.
	marsRover process: 'f'.
	
	self assert: ((marsRover positionLoggerAt: 1) = expectedLogs).! !

!methodRemoval: MarsRoverExtendedFuncionalityTest #test02 stamp: 'LK 10/30/2023 00:33:20'!
test02
	
	|marsRover expectedLogs|
	
	marsRover := MarsRover at: 1@1 heading: self north.
	expectedLogs := OrderedCollection new.
	expectedLogs add: 1@2.
	
	marsRover addNewPositionLogger.
	marsRover process: 'f'.
	
	self assert: ((marsRover positionLoggerAt: 1) = expectedLogs).!
!MarsRoverExtendedFuncionalityTest methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 00:33:30'!
test03logsPositionForMultipleLoggers
	
	|marsRover expectedFirstLog expectedSecondLog|
	
	marsRover := MarsRover at: 1@1 heading: self north.
	expectedFirstLog := OrderedCollection new.
	expectedFirstLog add: 1@2; add: 1@3; add: 1@4.
	expectedSecondLog := OrderedCollection new.
	expectedSecondLog add: 1@3; add: 1@4.
	
	marsRover addNewPositionLogger.
	marsRover process: 'f'.
	marsRover addNewPositionLogger.
	marsRover process: 'ff'.
	
	self assert: ((marsRover positionLoggerAt: 1) = expectedFirstLog).
	self assert: ((marsRover positionLoggerAt: 2) = expectedSecondLog).! !

!methodRemoval: MarsRoverExtendedFuncionalityTest #test03 stamp: 'LK 10/30/2023 00:33:30'!
test03
	
	|marsRover expectedFirstLog expectedSecondLog|
	
	marsRover := MarsRover at: 1@1 heading: self north.
	expectedFirstLog := OrderedCollection new.
	expectedFirstLog add: 1@2; add: 1@3; add: 1@4.
	expectedSecondLog := OrderedCollection new.
	expectedSecondLog add: 1@3; add: 1@4.
	
	marsRover addNewPositionLogger.
	marsRover process: 'f'.
	marsRover addNewPositionLogger.
	marsRover process: 'ff'.
	
	self assert: ((marsRover positionLoggerAt: 1) = expectedFirstLog).
	self assert: ((marsRover positionLoggerAt: 2) = expectedSecondLog).!
!MarsRoverExtendedFuncionalityTest methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 00:33:53'!
test04
	|marsRover expectedFirstLog expectedSecondLog|
	
	marsRover := MarsRover at: 1@1 heading: self north.
	expectedFirstLog := OrderedCollection new.
	expectedFirstLog add: 1@2; add: 1@3; add: 1@4.
	expectedSecondLog := OrderedCollection new.
	expectedSecondLog add: 1@3; add: 1@4.
	
	marsRover addNewPositionLogger.
	marsRover process: 'f'.
	marsRover addNewPositionLogger.
	marsRover process: 'ff'.
	
	self assert: ((marsRover positionLoggerAt: 1) = expectedFirstLog).
	self assert: ((marsRover positionLoggerAt: 2) = expectedSecondLog).! !
!MarsRoverExtendedFuncionalityTest methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 00:33:54' prior: 50709459!
test04

	|marsRover expectedFirstLog expectedSecondLog|
	
	marsRover := MarsRover at: 1@1 heading: self north.
	expectedFirstLog := OrderedCollection new.
	expectedFirstLog add: 1@2; add: 1@3; add: 1@4.
	expectedSecondLog := OrderedCollection new.
	expectedSecondLog add: 1@3; add: 1@4.
	
	marsRover addNewPositionLogger.
	marsRover process: 'f'.
	marsRover addNewPositionLogger.
	marsRover process: 'ff'.
	
	self assert: ((marsRover positionLoggerAt: 1) = expectedFirstLog).
	self assert: ((marsRover positionLoggerAt: 2) = expectedSecondLog).! !
!MarsRoverExtendedFuncionalityTest methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 00:34:07' prior: 50709480!
test04

	|marsRover expectedFirstLog|
	
	marsRover := MarsRover at: 1@1 heading: self north.
	expectedFirstLog := OrderedCollection new.
	expectedFirstLog add: 1@2; add: 1@3; add: 1@4.
	
	marsRover addNewPositionLogger.
	marsRover process: 'f'.
	marsRover addNewPositionLogger.
	marsRover process: 'ff'.
	
	self assert: ((marsRover positionLoggerAt: 1) = expectedFirstLog).! !
!MarsRoverExtendedFuncionalityTest methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 00:34:48' prior: 50709501!
test04

	|marsRover expectedFirstLog|
	
	marsRover := MarsRover at: 1@1 heading: self north.
	expectedFirstLog := OrderedCollection new.
	expectedFirstLog add: East.
	
	marsRover addNewPositionLogger.
	marsRover process: 'f'.
	marsRover addNewPositionLogger.
	marsRover process: 'ff'.
	
	self assert: ((marsRover positionLoggerAt: 1) = expectedFirstLog).! !
!MarsRoverExtendedFuncionalityTest methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 00:36:33' prior: 50709517!
test04

	|marsRover expectedFirstLog|
	
	marsRover := MarsRover at: 1@1 heading: self north.
	expectedFirstLog := OrderedCollection new.
	expectedFirstLog add: East.
	
	marsRover addNewPositionLogger.
	marsRover process: 'f'.
	
	self assert: ((marsRover positionLoggerAt: 1) = expectedFirstLog).! !
!MarsRoverExtendedFuncionalityTest methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 00:37:50' prior: 50709532!
test04

	|marsRover expectedFirstLog|
	
	marsRover := MarsRover at: 1@1 heading: self north.
	expectedFirstLog := OrderedCollection new.
	expectedFirstLog add: East.
	
	marsRover addNewPositionLogger.
	marsRover process: 'l'.
	
	self assert: ((marsRover positionLoggerAt: 1) = expectedFirstLog).! !
!MarsRoverExtendedFuncionalityTest methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 00:38:27' prior: 50709546!
test04

	|marsRover expectedFirstLog|
	
	marsRover := MarsRover at: 1@1 heading: self north.
	expectedFirstLog := OrderedCollection new.
	expectedFirstLog add: 'West'.
	
	marsRover addNewPositionLogger.
	marsRover process: 'l'.
	
	self assert: ((marsRover directionLoggerAt: 1) = expectedFirstLog).! !
!MarsRoverExtendedFuncionalityTest methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 00:38:33' prior: 50709560!
test04

	|marsRover expectedLog|
	
	marsRover := MarsRover at: 1@1 heading: self north.
	expectedLog := OrderedCollection new.
	expectedLog add: 'West'.
	
	marsRover addNewPositionLogger.
	marsRover process: 'l'.
	
	self assert: ((marsRover directionLoggerAt: 1) = expectedLog).! !
!MarsRoverExtendedFuncionalityTest methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 00:38:54' prior: 50709574!
test04

	|marsRover expectedLog|
	
	marsRover := MarsRover at: 1@1 heading: self north.
	expectedLog := OrderedCollection new.
	expectedLog add: 'West'.
	
	marsRover addNewDirectionLogger.
	marsRover process: 'l'.
	
	self assert: ((marsRover directionLoggerAt: 1) = expectedLog).! !
!MarsRover methodsFor: 'loggers' stamp: 'LK 10/30/2023 00:39:11'!
addNewDirectionLogger

	directionLogs add: (OrderedCollection new).! !
!MarsRover methodsFor: 'heading' stamp: 'LK 10/30/2023 00:39:49' prior: 50708639!
headEast
	
	head := MarsRoverHeadingEast for: self.
	directionLogs do: [:aLogger | aLogger add: 'East']! !
!MarsRover methodsFor: 'heading' stamp: 'LK 10/30/2023 00:40:19' prior: 50708643!
headNorth
	
	head := MarsRoverHeadingNorth for: self.
	directionLogs do: [:aLogger | aLogger add: 'North']! !
!MarsRover methodsFor: 'heading' stamp: 'LK 10/30/2023 00:40:29' prior: 50708647!
headSouth
	
	head := MarsRoverHeadingSouth for: self.
	directionLogs do: [:aLogger | aLogger add: 'South']! !
!MarsRover methodsFor: 'heading' stamp: 'LK 10/30/2023 00:40:34' prior: 50708651!
headWest
	
	head := MarsRoverHeadingWest for: self.
	directionLogs do: [:aLogger | aLogger add: 'West']! !

!testRun: #MarsRoverExtendedFuncionalityTest #test04 stamp: 'LK 10/30/2023 00:40:38'!
PASSED!
!MarsRoverExtendedFuncionalityTest methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 00:42:25'!
test05

	|marsRover expectedFirstLog expectedSecondLog|
	
	marsRover := MarsRover at: 1@1 heading: self north.
	expectedFirstLog := OrderedCollection new.
	expectedFirstLog add: 'West'; add: 'North'; add: 'West'.
	expectedSecondLog := OrderedCollection new.
	expectedSecondLog add: 'North'; add: 'West'.
	
	marsRover addNewDirectionLogger.
	marsRover process: 'l'.
	marsRover addNewDirectionLogger.
	marsRover process: 'rl'.
	
	self assert: ((marsRover directionLoggerAt: 1) = expectedFirstLog).
	self assert: ((marsRover directionLoggerAt: 2) = expectedSecondLog).! !

!testRun: #MarsRoverExtendedFuncionalityTest #test05 stamp: 'LK 10/30/2023 00:42:26'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test01logsAreEmptyAtStart stamp: 'LK 10/30/2023 00:42:26'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test02logsPositionForSingleLogger stamp: 'LK 10/30/2023 00:42:26'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test03logsPositionForMultipleLoggers stamp: 'LK 10/30/2023 00:42:26'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test04 stamp: 'LK 10/30/2023 00:42:26'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test05 stamp: 'LK 10/30/2023 00:42:26'!
PASSED!
!MarsRoverExtendedFuncionalityTest methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 00:44:58'!
test04logsDirectionForSingleLogger

	|marsRover expectedLog|
	
	marsRover := MarsRover at: 1@1 heading: self north.
	expectedLog := OrderedCollection new.
	expectedLog add: 'West'.
	
	marsRover addNewDirectionLogger.
	marsRover process: 'l'.
	
	self assert: ((marsRover directionLoggerAt: 1) = expectedLog).! !

!methodRemoval: MarsRoverExtendedFuncionalityTest #test04 stamp: 'LK 10/30/2023 00:44:58'!
test04

	|marsRover expectedLog|
	
	marsRover := MarsRover at: 1@1 heading: self north.
	expectedLog := OrderedCollection new.
	expectedLog add: 'West'.
	
	marsRover addNewDirectionLogger.
	marsRover process: 'l'.
	
	self assert: ((marsRover directionLoggerAt: 1) = expectedLog).!
!MarsRoverExtendedFuncionalityTest methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 00:45:07'!
test05logsDirectionForMultipleLoggers

	|marsRover expectedFirstLog expectedSecondLog|
	
	marsRover := MarsRover at: 1@1 heading: self north.
	expectedFirstLog := OrderedCollection new.
	expectedFirstLog add: 'West'; add: 'North'; add: 'West'.
	expectedSecondLog := OrderedCollection new.
	expectedSecondLog add: 'North'; add: 'West'.
	
	marsRover addNewDirectionLogger.
	marsRover process: 'l'.
	marsRover addNewDirectionLogger.
	marsRover process: 'rl'.
	
	self assert: ((marsRover directionLoggerAt: 1) = expectedFirstLog).
	self assert: ((marsRover directionLoggerAt: 2) = expectedSecondLog).! !

!methodRemoval: MarsRoverExtendedFuncionalityTest #test05 stamp: 'LK 10/30/2023 00:45:07'!
test05

	|marsRover expectedFirstLog expectedSecondLog|
	
	marsRover := MarsRover at: 1@1 heading: self north.
	expectedFirstLog := OrderedCollection new.
	expectedFirstLog add: 'West'; add: 'North'; add: 'West'.
	expectedSecondLog := OrderedCollection new.
	expectedSecondLog add: 'North'; add: 'West'.
	
	marsRover addNewDirectionLogger.
	marsRover process: 'l'.
	marsRover addNewDirectionLogger.
	marsRover process: 'rl'.
	
	self assert: ((marsRover directionLoggerAt: 1) = expectedFirstLog).
	self assert: ((marsRover directionLoggerAt: 2) = expectedSecondLog).!
!MarsRoverExtendedFuncionalityTest methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 00:46:10'!
test06
	
	|marsRover expectedLogs|
	
	marsRover := MarsRover at: 1@1 heading: self north.
	expectedLogs := OrderedCollection new.
	expectedLogs add: 1@2.
	
	marsRover addNewPositionLogger.
	marsRover process: 'f'.
	
	self assert: ((marsRover positionLoggerAt: 1) = expectedLogs).! !
!MarsRoverExtendedFuncionalityTest methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 00:49:35'!
test06logsBothDirectionAndPositionForSingleLogger
	
	|marsRover expectedLogs|
	
	marsRover := MarsRover at: 1@1 heading: self north.
	expectedLogs := OrderedCollection new.
	expectedLogs add: 1@2.
	
	marsRover addNewPositionLogger.
	marsRover process: 'f'.
	
	self assert: ((marsRover positionLoggerAt: 1) = expectedLogs).! !

!methodRemoval: MarsRoverExtendedFuncionalityTest #test06 stamp: 'LK 10/30/2023 00:49:39'!
test06
	
	|marsRover expectedLogs|
	
	marsRover := MarsRover at: 1@1 heading: self north.
	expectedLogs := OrderedCollection new.
	expectedLogs add: 1@2.
	
	marsRover addNewPositionLogger.
	marsRover process: 'f'.
	
	self assert: ((marsRover positionLoggerAt: 1) = expectedLogs).!
!MarsRoverExtendedFuncionalityTest methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 00:50:15' prior: 50709754!
test06logsBothDirectionAndPositionForSingleLogger
	
	|marsRover expectedLogs|
	
	marsRover := MarsRover at: 1@1 heading: self north.
	expectedLogs := OrderedCollection new.
	expectedLogs add: 1@2.
	
	marsRover addNewPositionAndDirectionLogger.
	marsRover process: 'fr'.
	
	self assert: ((marsRover positionLoggerAt: 1) = expectedLogs).! !
!MarsRoverExtendedFuncionalityTest methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 00:50:46' prior: 50709780!
test06logsBothDirectionAndPositionForSingleLogger
	
	|marsRover expectedLogs|
	
	marsRover := MarsRover at: 1@1 heading: self north.
	expectedLogs := OrderedCollection new.
	expectedLogs add: 1@2; add:'East'.
	
	marsRover addNewPositionAndDirectionLogger.
	marsRover process: 'fr'.
	
	self assert: ((marsRover positionLoggerAt: 1) = expectedLogs).! !
!MarsRoverExtendedFuncionalityTest methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 00:51:04' prior: 50709795!
test06logsBothDirectionAndPositionForSingleLogger
	
	|marsRover expectedLogs|
	
	marsRover := MarsRover at: 1@1 heading: self north.
	expectedLogs := OrderedCollection new.
	expectedLogs add: 1@2; add: 'East'.
	
	marsRover addNewPositionAndDirectionLogger.
	marsRover process: 'fr'.
	
	self assert: ((marsRover positionLoggerAt: 1) = expectedLogs).! !
!MarsRover methodsFor: 'loggers' stamp: 'LK 10/30/2023 00:51:49'!
addNewPositionAndDirectionLogger

	positionAndDirectionLogs add: (OrderedCollection new).! !
!MarsRover methodsFor: 'heading' stamp: 'LK 10/30/2023 00:52:35' prior: 50709603!
headEast
	
	head := MarsRoverHeadingEast for: self.
	directionLogs do: [:aLogger | aLogger add: 'East'].
	positionAndDirectionLogs do: [:aLogger | aLogger add: 'East'].! !
!MarsRover methodsFor: 'heading' stamp: 'LK 10/30/2023 00:52:41' prior: 50709609!
headNorth
	
	head := MarsRoverHeadingNorth for: self.
	directionLogs do: [:aLogger | aLogger add: 'North'].
	positionAndDirectionLogs do: [:aLogger | aLogger add: 'North'].! !
!MarsRover methodsFor: 'heading' stamp: 'LK 10/30/2023 00:52:46' prior: 50709615!
headSouth
	
	head := MarsRoverHeadingSouth for: self.
	directionLogs do: [:aLogger | aLogger add: 'South'].
	positionAndDirectionLogs do: [:aLogger | aLogger add: 'South'].! !
!MarsRover methodsFor: 'heading' stamp: 'LK 10/30/2023 00:52:51' prior: 50709621!
headWest
	
	head := MarsRoverHeadingWest for: self.
	directionLogs do: [:aLogger | aLogger add: 'West'].
	positionAndDirectionLogs do: [:aLogger | aLogger add: 'West'].! !
!MarsRover methodsFor: 'moving' stamp: 'LK 10/30/2023 00:53:14' prior: 50709302!
moveEast
	
	position := position + (1@0).
	positionLogs do: [:aLogger | aLogger add: position].
	positionAndDirectionLogs do: [:aLogger | aLogger add: position].! !
!MarsRover methodsFor: 'moving' stamp: 'LK 10/30/2023 00:53:19' prior: 50709308!
moveNorth
	
	position := position + (0@1).
	positionLogs do: [:aLogger | aLogger add: position]..
	positionAndDirectionLogs do: [:aLogger | aLogger add: position].! !
!MarsRover methodsFor: 'moving' stamp: 'LK 10/30/2023 00:53:21' prior: 50709314!
moveSouth
	
	position := position + (0@-1).
	positionLogs do: [:aLogger | aLogger add: position]..
	positionAndDirectionLogs do: [:aLogger | aLogger add: position].! !
!MarsRover methodsFor: 'moving' stamp: 'LK 10/30/2023 00:53:25' prior: 50709880!
moveSouth
	
	position := position + (0@-1).
	positionLogs do: [:aLogger | aLogger add: position].
	positionAndDirectionLogs do: [:aLogger | aLogger add: position].! !
!MarsRover methodsFor: 'moving' stamp: 'LK 10/30/2023 00:53:29' prior: 50709320!
moveWest
	
	position := position + (-1@0).
	positionLogs do: [:aLogger | aLogger add: position].
	positionAndDirectionLogs do: [:aLogger | aLogger add: position].! !
!MarsRover methodsFor: 'moving' stamp: 'LK 10/30/2023 00:53:34' prior: 50709872!
moveNorth
	
	position := position + (0@1).
	positionLogs do: [:aLogger | aLogger add: position].
	positionAndDirectionLogs do: [:aLogger | aLogger add: position].! !

!testRun: #MarsRoverExtendedFuncionalityTest #test06logsBothDirectionAndPositionForSingleLogger stamp: 'LK 10/30/2023 00:53:43'!
ERROR!
!MarsRoverExtendedFuncionalityTest methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 00:53:53' prior: 50709810!
test06logsBothDirectionAndPositionForSingleLogger
	
	|marsRover expectedLogs|
	
	marsRover := MarsRover at: 1@1 heading: self north.
	expectedLogs := OrderedCollection new.
	expectedLogs add: 1@2; add: 'East'.
	
	marsRover addNewPositionAndDirectionLogger.
	marsRover process: 'fr'.
	
	self assert: ((marsRover bothLoggerAt: 1) = expectedLogs).! !

!testRun: #MarsRoverExtendedFuncionalityTest #test06logsBothDirectionAndPositionForSingleLogger stamp: 'LK 10/30/2023 00:53:54'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test01logsAreEmptyAtStart stamp: 'LK 10/30/2023 00:53:54'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test02logsPositionForSingleLogger stamp: 'LK 10/30/2023 00:53:54'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test03logsPositionForMultipleLoggers stamp: 'LK 10/30/2023 00:53:54'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test04logsDirectionForSingleLogger stamp: 'LK 10/30/2023 00:53:54'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test05logsDirectionForMultipleLoggers stamp: 'LK 10/30/2023 00:53:54'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test06logsBothDirectionAndPositionForSingleLogger stamp: 'LK 10/30/2023 00:53:54'!
PASSED!
!MarsRoverExtendedFuncionalityTest methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 00:54:09'!
test06logsBothDirectionAndPositionForMultipleLoggers
	
	|marsRover expectedLogs|
	
	marsRover := MarsRover at: 1@1 heading: self north.
	expectedLogs := OrderedCollection new.
	expectedLogs add: 1@2; add: 'East'.
	
	marsRover addNewPositionAndDirectionLogger.
	marsRover process: 'fr'.
	
	self assert: ((marsRover bothLoggerAt: 1) = expectedLogs).! !
!MarsRoverExtendedFuncionalityTest methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 00:54:20' prior: 50709960!
test06logsBothDirectionAndPositionForMultipleLoggers
	
	|marsRover expectedLogs|
	
	marsRover := MarsRover at: 1@1 heading: self north.
	expectedLogs := OrderedCollection new.
	expectedLogs add: 1@2; add: 'East'.
	
	marsRover addNewPositionAndDirectionLogger.
	marsRover process: 'fr'.
	
	self assert: ((marsRover bothLoggerAt: 1) = expectedLogs).! !
!MarsRoverExtendedFuncionalityTest methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 00:54:30' prior: 50709975!
test06logsBothDirectionAndPositionForMultipleLoggers
	
	|marsRover expectedFirstLog|
	
	marsRover := MarsRover at: 1@1 heading: self north.
	expectedFirstLog := OrderedCollection new.
	expectedFirstLog add: 1@2; add: 'East'.
	
	marsRover addNewPositionAndDirectionLogger.
	marsRover process: 'fr'.
	
	self assert: ((marsRover bothLoggerAt: 1) = expectedFirstLog).! !
!MarsRoverExtendedFuncionalityTest methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 00:54:34' prior: 50709990!
test06logsBothDirectionAndPositionForMultipleLoggers
	
	|marsRover expectedFirstLog expectedSecondLog|
	
	marsRover := MarsRover at: 1@1 heading: self north.
	expectedFirstLog := OrderedCollection new.
	expectedFirstLog add: 1@2; add: 'East'.
	
	marsRover addNewPositionAndDirectionLogger.
	marsRover process: 'fr'.
	
	self assert: ((marsRover bothLoggerAt: 1) = expectedFirstLog).! !
!MarsRoverExtendedFuncionalityTest methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 00:55:14' prior: 50710006!
test06logsBothDirectionAndPositionForMultipleLoggers
	
	|marsRover expectedFirstLog expectedSecondLog|
	
	marsRover := MarsRover at: 1@1 heading: self north.
	expectedFirstLog := OrderedCollection new.
	expectedFirstLog add: 1@2; add: 'East'.
	expectedSecondLog := OrderedCollection new.
	
	
	marsRover addNewPositionAndDirectionLogger.
	marsRover process: 'fr'.
	marsRover addNewPositionAndDirectionLogger.
	marsRover process: 'lff'.
	
	self assert: ((marsRover bothLoggerAt: 1) = expectedFirstLog).! !
!MarsRoverExtendedFuncionalityTest methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 00:55:30' prior: 50710022!
test06logsBothDirectionAndPositionForMultipleLoggers
	
	|marsRover expectedFirstLog expectedSecondLog|
	
	marsRover := MarsRover at: 1@1 heading: self north.
	expectedFirstLog := OrderedCollection new.
	expectedFirstLog add: 1@2; add: 'East'.
	expectedSecondLog := OrderedCollection new.
	
	
	marsRover addNewPositionAndDirectionLogger.
	marsRover process: 'fr'.
	marsRover addNewPositionAndDirectionLogger.
	marsRover process: 'lff'.
	
	self assert: ((marsRover bothLoggerAt: 1) = expectedFirstLog).
	self assert: ((marsRover bothLoggerAt: 2) = expectedSecondLog).! !
!MarsRoverExtendedFuncionalityTest methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 00:55:55' prior: 50710042!
test06logsBothDirectionAndPositionForMultipleLoggers
	
	|marsRover expectedFirstLog expectedSecondLog|
	
	marsRover := MarsRover at: 1@1 heading: self north.
	expectedFirstLog := OrderedCollection new.
	expectedFirstLog add: 1@2; add: 'East'; add: 'North'; add: 1@3; add: 1@4.
	expectedSecondLog := OrderedCollection new.
	
	
	marsRover addNewPositionAndDirectionLogger.
	marsRover process: 'fr'.
	marsRover addNewPositionAndDirectionLogger.
	marsRover process: 'lff'.
	
	self assert: ((marsRover bothLoggerAt: 1) = expectedFirstLog).
	self assert: ((marsRover bothLoggerAt: 2) = expectedSecondLog).! !
!MarsRoverExtendedFuncionalityTest methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 00:56:07' prior: 50710064!
test06logsBothDirectionAndPositionForMultipleLoggers
	
	|marsRover expectedFirstLog expectedSecondLog|
	
	marsRover := MarsRover at: 1@1 heading: self north.
	expectedFirstLog := OrderedCollection new.
	expectedFirstLog add: 1@2; add: 'East'; add: 'North'; add: 1@3; add: 1@4.
	expectedSecondLog := OrderedCollection new.
	expectedSecondLog add: 'North'; add: 1@3; add: 1@4.
	
	
	marsRover addNewPositionAndDirectionLogger.
	marsRover process: 'fr'.
	marsRover addNewPositionAndDirectionLogger.
	marsRover process: 'lff'.
	
	self assert: ((marsRover bothLoggerAt: 1) = expectedFirstLog).
	self assert: ((marsRover bothLoggerAt: 2) = expectedSecondLog).! !
!MarsRoverExtendedFuncionalityTest methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 00:56:09' prior: 50710087!
test06logsBothDirectionAndPositionForMultipleLoggers
	
	|marsRover expectedFirstLog expectedSecondLog|
	
	marsRover := MarsRover at: 1@1 heading: self north.
	expectedFirstLog := OrderedCollection new.
	expectedFirstLog add: 1@2; add: 'East'; add: 'North'; add: 1@3; add: 1@4.
	expectedSecondLog := OrderedCollection new.
	expectedSecondLog add: 'North'; add: 1@3; add: 1@4.
	
	marsRover addNewPositionAndDirectionLogger.
	marsRover process: 'fr'.
	marsRover addNewPositionAndDirectionLogger.
	marsRover process: 'lff'.
	
	self assert: ((marsRover bothLoggerAt: 1) = expectedFirstLog).
	self assert: ((marsRover bothLoggerAt: 2) = expectedSecondLog).! !
!MarsRoverExtendedFuncionalityTest methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 00:56:22'!
test07logsBothDirectionAndPositionForMultipleLoggers
	
	|marsRover expectedFirstLog expectedSecondLog|
	
	marsRover := MarsRover at: 1@1 heading: self north.
	expectedFirstLog := OrderedCollection new.
	expectedFirstLog add: 1@2; add: 'East'; add: 'North'; add: 1@3; add: 1@4.
	expectedSecondLog := OrderedCollection new.
	expectedSecondLog add: 'North'; add: 1@3; add: 1@4.
	
	marsRover addNewPositionAndDirectionLogger.
	marsRover process: 'fr'.
	marsRover addNewPositionAndDirectionLogger.
	marsRover process: 'lff'.
	
	self assert: ((marsRover bothLoggerAt: 1) = expectedFirstLog).
	self assert: ((marsRover bothLoggerAt: 2) = expectedSecondLog).! !

!methodRemoval: MarsRoverExtendedFuncionalityTest #test06logsBothDirectionAndPositionForMultipleLoggers stamp: 'LK 10/30/2023 00:56:22'!
test06logsBothDirectionAndPositionForMultipleLoggers
	
	|marsRover expectedFirstLog expectedSecondLog|
	
	marsRover := MarsRover at: 1@1 heading: self north.
	expectedFirstLog := OrderedCollection new.
	expectedFirstLog add: 1@2; add: 'East'; add: 'North'; add: 1@3; add: 1@4.
	expectedSecondLog := OrderedCollection new.
	expectedSecondLog add: 'North'; add: 1@3; add: 1@4.
	
	marsRover addNewPositionAndDirectionLogger.
	marsRover process: 'fr'.
	marsRover addNewPositionAndDirectionLogger.
	marsRover process: 'lff'.
	
	self assert: ((marsRover bothLoggerAt: 1) = expectedFirstLog).
	self assert: ((marsRover bothLoggerAt: 2) = expectedSecondLog).!

!testRun: #MarsRoverExtendedFuncionalityTest #test07logsBothDirectionAndPositionForMultipleLoggers stamp: 'LK 10/30/2023 00:56:24'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test01logsAreEmptyAtStart stamp: 'LK 10/30/2023 00:56:24'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test02logsPositionForSingleLogger stamp: 'LK 10/30/2023 00:56:24'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test03logsPositionForMultipleLoggers stamp: 'LK 10/30/2023 00:56:24'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test04logsDirectionForSingleLogger stamp: 'LK 10/30/2023 00:56:24'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test05logsDirectionForMultipleLoggers stamp: 'LK 10/30/2023 00:56:24'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test06logsBothDirectionAndPositionForSingleLogger stamp: 'LK 10/30/2023 00:56:24'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test07logsBothDirectionAndPositionForMultipleLoggers stamp: 'LK 10/30/2023 00:56:24'!
PASSED!
!MarsRoverExtendedFuncionalityTest methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 01:00:33' prior: 50709392!
test02logsPositionForSingleLogger
	
	|marsRover expectedLogs|
	
	marsRover := MarsRover at: 1@1 heading: self north.
	expectedLogs := OrderedCollection new.
	expectedLogs add: 1@2; add: 1@3.
	
	marsRover addNewPositionLogger.
	marsRover process: 'ff'.
	
	self assert: ((marsRover positionLoggerAt: 1) = expectedLogs).! !
!MarsRoverExtendedFuncionalityTest methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 01:02:48'!
test03logsMoreThanOnePositionForSingleLogger
	
	|marsRover expectedLogs|
	
	marsRover := MarsRover at: 1@1 heading: self north.
	expectedLogs := OrderedCollection new.
	expectedLogs add: 1@2; add: 1@3.
	
	marsRover addNewPositionLogger.
	marsRover process: 'ff'.
	
	self assert: ((marsRover positionLoggerAt: 1) = expectedLogs).! !
!MarsRoverExtendedFuncionalityTest methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 01:02:59'!
test04logsPositionForMultipleLoggers
	
	|marsRover expectedFirstLog expectedSecondLog|
	
	marsRover := MarsRover at: 1@1 heading: self north.
	expectedFirstLog := OrderedCollection new.
	expectedFirstLog add: 1@2; add: 1@3; add: 1@4.
	expectedSecondLog := OrderedCollection new.
	expectedSecondLog add: 1@3; add: 1@4.
	
	marsRover addNewPositionLogger.
	marsRover process: 'f'.
	marsRover addNewPositionLogger.
	marsRover process: 'ff'.
	
	self assert: ((marsRover positionLoggerAt: 1) = expectedFirstLog).
	self assert: ((marsRover positionLoggerAt: 2) = expectedSecondLog).! !

!methodRemoval: MarsRoverExtendedFuncionalityTest #test03logsPositionForMultipleLoggers stamp: 'LK 10/30/2023 01:02:59'!
test03logsPositionForMultipleLoggers
	
	|marsRover expectedFirstLog expectedSecondLog|
	
	marsRover := MarsRover at: 1@1 heading: self north.
	expectedFirstLog := OrderedCollection new.
	expectedFirstLog add: 1@2; add: 1@3; add: 1@4.
	expectedSecondLog := OrderedCollection new.
	expectedSecondLog add: 1@3; add: 1@4.
	
	marsRover addNewPositionLogger.
	marsRover process: 'f'.
	marsRover addNewPositionLogger.
	marsRover process: 'ff'.
	
	self assert: ((marsRover positionLoggerAt: 1) = expectedFirstLog).
	self assert: ((marsRover positionLoggerAt: 2) = expectedSecondLog).!
!MarsRoverExtendedFuncionalityTest methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 01:03:05'!
test05logsDirectionForSingleLogger

	|marsRover expectedLog|
	
	marsRover := MarsRover at: 1@1 heading: self north.
	expectedLog := OrderedCollection new.
	expectedLog add: 'West'.
	
	marsRover addNewDirectionLogger.
	marsRover process: 'l'.
	
	self assert: ((marsRover directionLoggerAt: 1) = expectedLog).! !

!methodRemoval: MarsRoverExtendedFuncionalityTest #test04logsDirectionForSingleLogger stamp: 'LK 10/30/2023 01:03:05'!
test04logsDirectionForSingleLogger

	|marsRover expectedLog|
	
	marsRover := MarsRover at: 1@1 heading: self north.
	expectedLog := OrderedCollection new.
	expectedLog add: 'West'.
	
	marsRover addNewDirectionLogger.
	marsRover process: 'l'.
	
	self assert: ((marsRover directionLoggerAt: 1) = expectedLog).!
!MarsRoverExtendedFuncionalityTest methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 01:03:25'!
test06logsMoreThanOneDirectionForSingleLogger

	|marsRover expectedLog|
	
	marsRover := MarsRover at: 1@1 heading: self north.
	expectedLog := OrderedCollection new.
	expectedLog add: 'West'.
	
	marsRover addNewDirectionLogger.
	marsRover process: 'l'.
	
	self assert: ((marsRover directionLoggerAt: 1) = expectedLog).! !
!MarsRoverExtendedFuncionalityTest methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 01:03:32'!
test07logsDirectionForMultipleLoggers

	|marsRover expectedFirstLog expectedSecondLog|
	
	marsRover := MarsRover at: 1@1 heading: self north.
	expectedFirstLog := OrderedCollection new.
	expectedFirstLog add: 'West'; add: 'North'; add: 'West'.
	expectedSecondLog := OrderedCollection new.
	expectedSecondLog add: 'North'; add: 'West'.
	
	marsRover addNewDirectionLogger.
	marsRover process: 'l'.
	marsRover addNewDirectionLogger.
	marsRover process: 'rl'.
	
	self assert: ((marsRover directionLoggerAt: 1) = expectedFirstLog).
	self assert: ((marsRover directionLoggerAt: 2) = expectedSecondLog).! !

!methodRemoval: MarsRoverExtendedFuncionalityTest #test05logsDirectionForMultipleLoggers stamp: 'LK 10/30/2023 01:03:32'!
test05logsDirectionForMultipleLoggers

	|marsRover expectedFirstLog expectedSecondLog|
	
	marsRover := MarsRover at: 1@1 heading: self north.
	expectedFirstLog := OrderedCollection new.
	expectedFirstLog add: 'West'; add: 'North'; add: 'West'.
	expectedSecondLog := OrderedCollection new.
	expectedSecondLog add: 'North'; add: 'West'.
	
	marsRover addNewDirectionLogger.
	marsRover process: 'l'.
	marsRover addNewDirectionLogger.
	marsRover process: 'rl'.
	
	self assert: ((marsRover directionLoggerAt: 1) = expectedFirstLog).
	self assert: ((marsRover directionLoggerAt: 2) = expectedSecondLog).!
!MarsRoverExtendedFuncionalityTest methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 01:04:23'!
test08logsBothDirectionAndPositionForSingleLogger
	
	|marsRover expectedLogs|
	
	marsRover := MarsRover at: 1@1 heading: self north.
	expectedLogs := OrderedCollection new.
	expectedLogs add: 1@2; add: 'East'.
	
	marsRover addNewPositionAndDirectionLogger.
	marsRover process: 'fr'.
	
	self assert: ((marsRover bothLoggerAt: 1) = expectedLogs).! !

!methodRemoval: MarsRoverExtendedFuncionalityTest #test06logsBothDirectionAndPositionForSingleLogger stamp: 'LK 10/30/2023 01:04:23'!
test06logsBothDirectionAndPositionForSingleLogger
	
	|marsRover expectedLogs|
	
	marsRover := MarsRover at: 1@1 heading: self north.
	expectedLogs := OrderedCollection new.
	expectedLogs add: 1@2; add: 'East'.
	
	marsRover addNewPositionAndDirectionLogger.
	marsRover process: 'fr'.
	
	self assert: ((marsRover bothLoggerAt: 1) = expectedLogs).!
!MarsRoverExtendedFuncionalityTest methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 01:04:37'!
test09logsBothDirectionAndPositionForMultipleLoggers
	
	|marsRover expectedFirstLog expectedSecondLog|
	
	marsRover := MarsRover at: 1@1 heading: self north.
	expectedFirstLog := OrderedCollection new.
	expectedFirstLog add: 1@2; add: 'East'; add: 'North'; add: 1@3; add: 1@4.
	expectedSecondLog := OrderedCollection new.
	expectedSecondLog add: 'North'; add: 1@3; add: 1@4.
	
	marsRover addNewPositionAndDirectionLogger.
	marsRover process: 'fr'.
	marsRover addNewPositionAndDirectionLogger.
	marsRover process: 'lff'.
	
	self assert: ((marsRover bothLoggerAt: 1) = expectedFirstLog).
	self assert: ((marsRover bothLoggerAt: 2) = expectedSecondLog).! !

!methodRemoval: MarsRoverExtendedFuncionalityTest #test07logsBothDirectionAndPositionForMultipleLoggers stamp: 'LK 10/30/2023 01:04:38'!
test07logsBothDirectionAndPositionForMultipleLoggers
	
	|marsRover expectedFirstLog expectedSecondLog|
	
	marsRover := MarsRover at: 1@1 heading: self north.
	expectedFirstLog := OrderedCollection new.
	expectedFirstLog add: 1@2; add: 'East'; add: 'North'; add: 1@3; add: 1@4.
	expectedSecondLog := OrderedCollection new.
	expectedSecondLog add: 'North'; add: 1@3; add: 1@4.
	
	marsRover addNewPositionAndDirectionLogger.
	marsRover process: 'fr'.
	marsRover addNewPositionAndDirectionLogger.
	marsRover process: 'lff'.
	
	self assert: ((marsRover bothLoggerAt: 1) = expectedFirstLog).
	self assert: ((marsRover bothLoggerAt: 2) = expectedSecondLog).!
!MarsRoverExtendedFuncionalityTest methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 01:04:53' prior: 50710217!
test02logsPositionForSingleLogger
	
	|marsRover expectedLogs|
	
	marsRover := MarsRover at: 1@1 heading: self north.
	expectedLogs := OrderedCollection new.
	expectedLogs add: 1@2.
	
	marsRover addNewPositionLogger.
	marsRover process: 'f'.
	
	self assert: ((marsRover positionLoggerAt: 1) = expectedLogs).! !

!testRun: #MarsRoverExtendedFuncionalityTest #test01logsAreEmptyAtStart stamp: 'LK 10/30/2023 01:04:55'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test02logsPositionForSingleLogger stamp: 'LK 10/30/2023 01:04:57'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test03logsMoreThanOnePositionForSingleLogger stamp: 'LK 10/30/2023 01:04:58'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test04logsPositionForMultipleLoggers stamp: 'LK 10/30/2023 01:05:00'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test05logsDirectionForSingleLogger stamp: 'LK 10/30/2023 01:05:04'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test06logsMoreThanOneDirectionForSingleLogger stamp: 'LK 10/30/2023 01:05:06'!
PASSED!
!MarsRoverExtendedFuncionalityTest methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 01:05:21' prior: 50710316!
test06logsMoreThanOneDirectionForSingleLogger

	|marsRover expectedLog|
	
	marsRover := MarsRover at: 1@1 heading: self north.
	expectedLog := OrderedCollection new.
	expectedLog add: 'West'; add: 'South'.
	
	marsRover addNewDirectionLogger.
	marsRover process: 'll'.
	
	self assert: ((marsRover directionLoggerAt: 1) = expectedLog).! !

!testRun: #MarsRoverExtendedFuncionalityTest #test06logsMoreThanOneDirectionForSingleLogger stamp: 'LK 10/30/2023 01:05:21'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test01logsAreEmptyAtStart stamp: 'LK 10/30/2023 01:05:21'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test02logsPositionForSingleLogger stamp: 'LK 10/30/2023 01:05:22'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test03logsMoreThanOnePositionForSingleLogger stamp: 'LK 10/30/2023 01:05:22'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test04logsPositionForMultipleLoggers stamp: 'LK 10/30/2023 01:05:22'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test05logsDirectionForSingleLogger stamp: 'LK 10/30/2023 01:05:22'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test06logsMoreThanOneDirectionForSingleLogger stamp: 'LK 10/30/2023 01:05:22'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test07logsDirectionForMultipleLoggers stamp: 'LK 10/30/2023 01:05:22'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test08logsBothDirectionAndPositionForSingleLogger stamp: 'LK 10/30/2023 01:05:22'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test09logsBothDirectionAndPositionForMultipleLoggers stamp: 'LK 10/30/2023 01:05:22'!
PASSED!
!MarsRoverExtendedFuncionalityTest methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 01:06:48'!
test10logsDifferentTypeOfLoggersAtOnce
	
	|marsRover expectedFirstLog expectedSecondLog|
	
	marsRover := MarsRover at: 1@1 heading: self north.
	expectedFirstLog := OrderedCollection new.
	expectedFirstLog add: 1@2; add: 'East'; add: 'North'; add: 1@3; add: 1@4.
	expectedSecondLog := OrderedCollection new.
	expectedSecondLog add: 'North'; add: 1@3; add: 1@4.
	
	marsRover addNewPositionAndDirectionLogger.
	marsRover process: 'fr'.
	marsRover addNewPositionAndDirectionLogger.
	marsRover process: 'lff'.
	
	self assert: ((marsRover bothLoggerAt: 1) = expectedFirstLog).
	self assert: ((marsRover bothLoggerAt: 2) = expectedSecondLog).! !
!MarsRoverExtendedFuncionalityTest methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 01:09:59' prior: 50710546!
test10logsDifferentTypeOfLoggersAtOnce
	
	|marsRover expectedPositionLog expectedDirectionLog expectedBothLogs|
	
	marsRover := MarsRover at: 1@1 heading: self north.
	expectedPositionLog := OrderedCollection new.
	expectedPositionLog add: 1@2.
	expectedDirectionLog := OrderedCollection new.
	expectedDirectionLog add: 'East'.
	expectedBothLogs := OrderedCollection new.
	expectedBothLogs add: 1@2; add: 'East'.
	
	marsRover addNewPositionAndDirectionLogger.
	marsRover addNewDirectionLogger.
	marsRover addNewPositionLogger.
	marsRover process: 'fr'.
	
	self assert: ((marsRover bothLoggerAt: 1) = expectedBothLogs ).
	self assert: ((marsRover directionLoggerAt: 1) = expectedDirectionLog).
	self assert: ((marsRover positionLoggerAt: 1) = expectedPositionLog).! !

!testRun: #MarsRoverExtendedFuncionalityTest #test10logsDifferentTypeOfLoggersAtOnce stamp: 'LK 10/30/2023 01:10:00'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test01logsAreEmptyAtStart stamp: 'LK 10/30/2023 01:10:00'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test02logsPositionForSingleLogger stamp: 'LK 10/30/2023 01:10:00'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test03logsMoreThanOnePositionForSingleLogger stamp: 'LK 10/30/2023 01:10:01'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test04logsPositionForMultipleLoggers stamp: 'LK 10/30/2023 01:10:01'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test05logsDirectionForSingleLogger stamp: 'LK 10/30/2023 01:10:01'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test06logsMoreThanOneDirectionForSingleLogger stamp: 'LK 10/30/2023 01:10:01'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test07logsDirectionForMultipleLoggers stamp: 'LK 10/30/2023 01:10:01'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test08logsBothDirectionAndPositionForSingleLogger stamp: 'LK 10/30/2023 01:10:01'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test09logsBothDirectionAndPositionForMultipleLoggers stamp: 'LK 10/30/2023 01:10:01'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test10logsDifferentTypeOfLoggersAtOnce stamp: 'LK 10/30/2023 01:10:01'!
PASSED!

----QUIT----(30 October 2023 01:10:45) CuisUniversity-5981.image priorSource: 12075243!

----STARTUP---- (30 October 2023 03:59:38) as C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\CuisUniversity-5981.image!


Object subclass: #Proxy
	instanceVariableNames: 'variable'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!

!classDefinition: #Proxy category: 'MarsRover-WithHeading' stamp: 'LK 10/30/2023 04:07:18'!
Object subclass: #Proxy
	instanceVariableNames: 'variable'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!
!Proxy class methodsFor: 'no messages' stamp: 'LK 10/30/2023 04:07:48'!
for: aCollaborator

	^self new initializeFor: aCollaborator! !
!Proxy methodsFor: 'nil' stamp: 'LK 10/30/2023 04:08:07'!
initializeFor: aCollaborator

	variable := aCollaborator.! !

Object subclass: #Logger
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!

!classDefinition: #Logger category: 'MarsRover-WithHeading' stamp: 'LK 10/30/2023 04:09:51'!
Object subclass: #Logger
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!
!Logger methodsFor: 'nil' stamp: 'LK 10/30/2023 04:13:26' overrides: 16920235!
initialize
	
	! !

Object subclass: #Logger
	instanceVariableNames: 'logs'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!

!classDefinition: #Logger category: 'MarsRover-WithHeading' stamp: 'LK 10/30/2023 04:13:31'!
Object subclass: #Logger
	instanceVariableNames: 'logs'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!
!Logger methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 04:13:39' prior: 50710679 overrides: 16920235!
initialize
	
	logs := OrderedCollection new.! !
!Logger methodsFor: 'nil' stamp: 'LK 10/30/2023 04:13:58' overrides: 16903929!
update: aThing

	logs add: aThing.! !

----QUIT----(30 October 2023 04:30:44) CuisUniversity-5981.image priorSource: 12127680!

----STARTUP---- (30 October 2023 11:52:40) as C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\CuisUniversity-5981.image!

!Proxy methodsFor: 'nil' stamp: 'LK 10/30/2023 11:57:49'!
do: aClosure

	aClosure value.
	! !

Object subclass: #Proxy
	instanceVariableNames: 'variable subscribers'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!

!classDefinition: #Proxy category: 'MarsRover-WithHeading' stamp: 'LK 10/30/2023 11:58:03'!
Object subclass: #Proxy
	instanceVariableNames: 'variable subscribers'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!
!Proxy methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 11:58:13' prior: 50710663!
initializeFor: aCollaborator

	variable := aCollaborator.
	subscribers := OrderedCollection new.! !
!Proxy methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 11:59:39'!
addSubscriber: aSubscriber

	subscribers add: aSubscriber.! !
!Proxy methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 12:00:35' prior: 50710709!
do: aClosure

	|gooby|
	
	aClosure value.
	subscribers do: [:aSubscriber | aSubscriber updateWith: gooby].
	! !

!classDefinition: #Logger category: 'MarsRover-WithHeading' stamp: 'LK 10/30/2023 12:06:06'!
Object subclass: #Logger
	instanceVariableNames: 'logs proxy'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!
!Logger methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 12:06:02'!
initializeFor: aProxy

	proxy := aProxy.
	
	logs := OrderedCollection new.! !

!methodRemoval: Logger #initialize stamp: 'LK 10/30/2023 12:06:14'!
initialize
	
	logs := OrderedCollection new.!
!Logger methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 12:06:34' prior: 50710751!
initializeFor: aProxy

	proxy := aProxy.
	
	proxy addSubscriber: self.
	
	logs := OrderedCollection new.! !
!Logger methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 12:06:42' prior: 50710760!
initializeFor: aProxy

	proxy := aProxy.
	proxy addSubscriber: self.
	
	logs := OrderedCollection new.! !
!Logger methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 12:07:39' prior: 50710767!
initializeFor: aProxy

	proxy := OrderedCollection new.
	proxy add: aProxy.
	proxy addSubscriber: self.
	
	logs := OrderedCollection new.! !
!Logger methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 12:10:28' prior: 50710774!
initializeFor: aProxy

	proxy := OrderedCollection new.
	proxy add: aProxy.
	proxy addSubscriber: self.
	logs := OrderedCollection new.! !
!Logger methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 12:10:46'!
addSubscriber: aProxy

	! !
!Logger methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 12:11:03' prior: 50710789!
addSubscriber: aProxy

	proxy add: aProxy.
	aProxy addSubscriber: self.! !
!Logger class methodsFor: 'nil' stamp: 'LK 10/30/2023 12:11:25'!
with: aProxy

	^self new initializeFor: aProxy! !
!Logger class methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 12:12:06'!
with: aProxy with: aSecondProxy

	|logger|
	
	logger := self new initializeFor: aProxy.
	
	^logger! !
!Logger class methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 12:12:27' prior: 50710803!
with: aProxy with: aSecondProxy

	|logger|
	
	logger := self new initializeFor: aProxy.
	
	logger addSubscriber: aSecondProxy.
	
	^logger! !
!Logger methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 12:12:37' prior: 50710782!
initializeFor: aProxy

	proxy := OrderedCollection new.
	proxy add: aProxy.
	proxy addSubscriber: self.
	
	logs := OrderedCollection new.! !
!Logger methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 12:13:12'!
subscribeTo: aProxy

	proxy add: aProxy.
	aProxy addSubscriber: self.! !
!Logger methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 12:13:12' prior: 50710793!
addSubscriber: aProxy

	proxy add: aProxy.
	aProxy subscribeTo: self.! !
!Logger class methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 12:13:12' prior: 50710810!
with: aProxy with: aSecondProxy

	|logger|
	
	logger := self new initializeFor: aProxy.
	
	logger subscribeTo: aSecondProxy.
	
	^logger! !
!Logger methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 12:13:12' prior: 50710818!
initializeFor: aProxy

	proxy := OrderedCollection new.
	proxy add: aProxy.
	proxy subscribeTo: self.
	
	logs := OrderedCollection new.! !
!Logger methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 12:13:12' prior: 50710825!
subscribeTo: aProxy

	proxy add: aProxy.
	aProxy subscribeTo: self.! !

!methodRemoval: Logger #addSubscriber: stamp: 'LK 10/30/2023 12:13:12'!
addSubscriber: aProxy

	proxy add: aProxy.
	aProxy subscribeTo: self.!
!Logger methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 12:13:20' prior: 50710853!
subscribeTo: aProxy

	proxy add: aProxy.
	aProxy addSubscriber: self.! !

!classRenamed: #Proxy as: #MarsRoverObservableVariable stamp: 'LK 10/30/2023 12:25:22'!
Smalltalk renameClassNamed: #Proxy as: #MarsRoverObservableVariable!

!classRenamed: #Logger as: #MarsRoverLogger stamp: 'LK 10/30/2023 12:25:28'!
Smalltalk renameClassNamed: #Logger as: #MarsRoverLogger!
!MarsRover methodsFor: 'initialization' stamp: 'LK 10/30/2023 12:26:32' prior: 50709221!
initializeAt: aPosition heading: aHeadingType

	position := MarsRoverObservableVariable new.
	head := aHeadingType for: self.
	positionLogs := OrderedCollection new.
	directionLogs := OrderedCollection new.
	positionAndDirectionLogs := OrderedCollection new.! !
!MarsRover methodsFor: 'initialization' stamp: 'LK 10/30/2023 12:27:24' prior: 50710878!
initializeAt: aPosition heading: aHeadingType

	position := MarsRoverObservableVariable for: aPosition.
	head := MarsRoverObservableVariable for: (aHeadingType for: self).
	
	
	positionLogs := OrderedCollection new.
	directionLogs := OrderedCollection new.
	positionAndDirectionLogs := OrderedCollection new.! !
!MarsRover methodsFor: 'initialization' stamp: 'LK 10/30/2023 12:27:29' prior: 50710889!
initializeAt: aPosition heading: aHeadingType

	position := MarsRoverObservableVariable for: aPosition.
	head := MarsRoverObservableVariable for: (aHeadingType for: self).
	
	
	"positionLogs := OrderedCollection new.
	directionLogs := OrderedCollection new.
	positionAndDirectionLogs := OrderedCollection new."! !
!MarsRover methodsFor: 'moving' stamp: 'LK 10/30/2023 12:28:11' prior: 50709864!
moveEast
	
	position do: [position := position + (1@0)].
	positionLogs do: [:aLogger | aLogger add: position].
	positionAndDirectionLogs do: [:aLogger | aLogger add: position].! !
!MarsRoverObservableVariable methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 12:31:47' prior: 50710737!
do: aClosure

	|gooby|
	
	aClosure value.
	subscribers do: [:aSubscriber | aSubscriber update: gooby].
	! !
!MarsRoverLogger methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 12:46:48'!
loggggggg
	^logs! !
!MarsRoverLogger methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 13:03:58'!
getLog

	^logs! !

!methodRemoval: MarsRoverLogger #loggggggg stamp: 'LK 10/30/2023 13:04:04'!
loggggggg
	^logs!
!MarsRover methodsFor: 'loggers' stamp: 'LK 10/30/2023 13:05:37' prior: 50709598!
addNewDirectionLogger

	directionLogs add: (MarsRoverLogger with: head)! !
!MarsRover methodsFor: 'loggers' stamp: 'LK 10/30/2023 13:06:03' prior: 50709824!
addNewPositionAndDirectionLogger

	positionAndDirectionLogs add: (MarsRoverLogger with: head with: position)! !
!MarsRover methodsFor: 'loggers' stamp: 'LK 10/30/2023 13:06:16' prior: 50709329!
addNewPositionLogger

	positionLogs add: (MarsRoverLogger with: position).! !
!MarsRover methodsFor: 'loggers' stamp: 'LK 10/30/2023 13:06:48' prior: 50709253!
bothLoggerAt: aNumber
	
	^(positionAndDirectionLogs at: aNumber) getLog.! !
!MarsRover methodsFor: 'loggers' stamp: 'LK 10/30/2023 13:07:02' prior: 50709249!
directionLoggerAt: aNumber
	
	^(directionLogs at: aNumber) getLog.! !
!MarsRover methodsFor: 'loggers' stamp: 'LK 10/30/2023 13:07:15' prior: 50709245!
positionLoggerAt: aNumber
	
	^(positionLogs at: aNumber) getLog.! !
!MarsRoverLogger methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 13:27:11' prior: 50710935!
getLog

	^logs copy! !
!MarsRoverObservableVariable methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 13:29:37' prior: 50710925!
do: aClosure
	
	variable := aClosure.
	subscribers do: [:aSubscriber | aSubscriber update: variable].
	! !
!MarsRoverObservableVariable methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 13:30:28'!
bla: aClosure
	
	variable := aClosure.
	subscribers do: [:aSubscriber | aSubscriber update: variable].
	! !
!MarsRoverObservableVariable methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 13:30:28' prior: 50710980!
do: aClosure
	
	variable := aClosure.
	subscribers bla: [:aSubscriber | aSubscriber update: variable].
	! !
!MarsRoverObservableVariable methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 13:30:28' prior: 50710987!
bla: aClosure
	
	variable := aClosure.
	subscribers bla: [:aSubscriber | aSubscriber update: variable].
	! !

!methodRemoval: MarsRoverObservableVariable #do: stamp: 'LK 10/30/2023 13:30:28'!
do: aClosure
	
	variable := aClosure.
	subscribers bla: [:aSubscriber | aSubscriber update: variable].
	!
!MarsRoverObservableVariable methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 13:32:45'!
updateContent: aClosure
	
	variable := aClosure.
	subscribers bla: [:aSubscriber | aSubscriber update: variable].
	! !
!MarsRoverObservableVariable methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 13:32:45' prior: 50711001!
bla: aClosure
	
	variable := aClosure.
	subscribers updateContent: [:aSubscriber | aSubscriber update: variable].
	! !
!MarsRoverObservableVariable methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 13:32:45' prior: 50711014!
updateContent: aClosure
	
	variable := aClosure.
	subscribers updateContent: [:aSubscriber | aSubscriber update: variable].
	! !

!methodRemoval: MarsRoverObservableVariable #bla: stamp: 'LK 10/30/2023 13:32:45'!
bla: aClosure
	
	variable := aClosure.
	subscribers updateContent: [:aSubscriber | aSubscriber update: variable].
	!
!MarsRover methodsFor: 'heading' stamp: 'LK 10/30/2023 13:33:24' prior: 50709830!
headEast
	
	head update: (MarsRoverHeadingEast for: self).
	
	"directionLogs do: [:aLogger | aLogger add: 'East'].
	positionAndDirectionLogs do: [:aLogger | aLogger add: 'East']."! !
!MarsRover methodsFor: 'heading' stamp: 'LK 10/30/2023 13:33:50' prior: 50709838!
headNorth
	
	head update: (MarsRoverHeadingNorth for: self).
	
	"directionLogs do: [:aLogger | aLogger add: 'North'].
	positionAndDirectionLogs do: [:aLogger | aLogger add: 'North']."! !
!MarsRover methodsFor: 'heading' stamp: 'LK 10/30/2023 13:33:59' prior: 50709847!
headSouth
	
	head update: (MarsRoverHeadingEast for: self).	
	
	"directionLogs do: [:aLogger | aLogger add: 'South'].
	positionAndDirectionLogs do: [:aLogger | aLogger add: 'South']."! !
!MarsRover methodsFor: 'heading' stamp: 'LK 10/30/2023 13:34:05' prior: 50711061!
headSouth
	
	head update: (MarsRoverHeadingSouth for: self).	
	
	"directionLogs do: [:aLogger | aLogger add: 'South'].
	positionAndDirectionLogs do: [:aLogger | aLogger add: 'South']."! !
!MarsRover methodsFor: 'heading' stamp: 'LK 10/30/2023 13:34:27' prior: 50709856!
headWest
	
	head update: (MarsRoverHeadingWest for: self).
	
	"directionLogs do: [:aLogger | aLogger add: 'West'].
	positionAndDirectionLogs do: [:aLogger | aLogger add: 'West']."! !
!MarsRover methodsFor: 'heading' stamp: 'LK 10/30/2023 13:35:09' prior: 50711043!
headEast
	
	head updateContent: (MarsRoverHeadingEast for: self).
	
	"directionLogs do: [:aLogger | aLogger add: 'East'].
	positionAndDirectionLogs do: [:aLogger | aLogger add: 'East']."! !
!MarsRover methodsFor: 'heading' stamp: 'LK 10/30/2023 13:35:20' prior: 50711052!
headNorth
	
	head updateContent: (MarsRoverHeadingNorth for: self).
	
	"directionLogs do: [:aLogger | aLogger add: 'North'].
	positionAndDirectionLogs do: [:aLogger | aLogger add: 'North']."! !
!MarsRover methodsFor: 'heading' stamp: 'LK 10/30/2023 13:35:25' prior: 50711070!
headSouth
	
	head updateContent: (MarsRoverHeadingSouth for: self).	
	
	"directionLogs do: [:aLogger | aLogger add: 'South'].
	positionAndDirectionLogs do: [:aLogger | aLogger add: 'South']."! !
!MarsRover methodsFor: 'heading' stamp: 'LK 10/30/2023 13:35:29' prior: 50711079!
headWest
	
	head updateContent: (MarsRoverHeadingWest for: self).
	
	"directionLogs do: [:aLogger | aLogger add: 'West'].
	positionAndDirectionLogs do: [:aLogger | aLogger add: 'West']."! !
!MarsRover methodsFor: 'moving' stamp: 'LK 10/30/2023 13:36:12' prior: 50710915!
moveEast
	
	position updateContent: (position + (1@0)).
	
	"positionLogs do: [:aLogger | aLogger add: position].
	positionAndDirectionLogs do: [:aLogger | aLogger add: position]."! !
!MarsRover methodsFor: 'moving' stamp: 'LK 10/30/2023 13:36:39' prior: 50709904!
moveNorth
	
	position updateContent: (position + (0@1))
	
	"positionLogs do: [:aLogger | aLogger add: position].
	positionAndDirectionLogs do: [:aLogger | aLogger add: position]."! !
!MarsRover methodsFor: 'moving' stamp: 'LK 10/30/2023 13:37:36' prior: 50711133!
moveNorth
	
	position updateContent: (position value + (0@1))
	
	"positionLogs do: [:aLogger | aLogger add: position].
	positionAndDirectionLogs do: [:aLogger | aLogger add: position]."! !
!MarsRoverObservableVariable methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 13:37:51' overrides: 16902254!
value
	^variable! !
!MarsRover methodsFor: 'moving' stamp: 'LK 10/30/2023 13:41:53' prior: 50711124!
moveEast
	
	position updateContent: (position value + (1@0)).
	
	"positionLogs do: [:aLogger | aLogger add: position].
	positionAndDirectionLogs do: [:aLogger | aLogger add: position]."! !
!MarsRover methodsFor: 'moving' stamp: 'LK 10/30/2023 13:42:15' prior: 50709888!
moveSouth
	
	position updateContent: (position value + (0@-1)).
	
	"positionLogs do: [:aLogger | aLogger add: position].
	positionAndDirectionLogs do: [:aLogger | aLogger add: position]."! !
!MarsRover methodsFor: 'moving' stamp: 'LK 10/30/2023 13:42:35' prior: 50709896!
moveWest
	
	position updateContent: (position value + (-1@0)).
	
	"positionLogs do: [:aLogger | aLogger add: position].
	positionAndDirectionLogs do: [:aLogger | aLogger add: position]."! !

!classDefinition: #MarsRoverFun category: 'MarsRover-WithHeading' stamp: 'LK 10/30/2023 13:55:10'!
Object subclass: #MarsRoverFun
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!

!classDefinition: #MarsRoverLogger category: 'MarsRover-WithHeading' stamp: 'LK 10/30/2023 13:55:10'!
MarsRoverFun subclass: #MarsRoverLogger
	instanceVariableNames: 'logs proxy'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!

!classDefinition: #MarsRoverLogger category: 'MarsRover-WithHeading' stamp: 'LK 10/30/2023 13:55:57'!
MarsRoverFun subclass: #MarsRoverLogger
	instanceVariableNames: 'proxy'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!

!classDefinition: #MarsRoverFun category: 'MarsRover-WithHeading' stamp: 'LK 10/30/2023 13:55:57'!
Object subclass: #MarsRoverFun
	instanceVariableNames: 'logs'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!

!classDefinition: #MarsRoverLogger category: 'MarsRover-WithHeading' stamp: 'LK 10/30/2023 13:55:57'!
MarsRoverFun subclass: #MarsRoverLogger
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!

!classDefinition: #MarsRoverFun category: 'MarsRover-WithHeading' stamp: 'LK 10/30/2023 13:55:57'!
Object subclass: #MarsRoverFun
	instanceVariableNames: 'logs proxy'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!
!MarsRoverFun methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 13:55:57'!
initializeFor: aProxy

	proxy := OrderedCollection new.
	proxy add: aProxy.
	proxy subscribeTo: self.
	
	logs := OrderedCollection new.! !

!methodRemoval: MarsRoverLogger #initializeFor: stamp: 'LK 10/30/2023 13:55:57'!
initializeFor: aProxy

	proxy := OrderedCollection new.
	proxy add: aProxy.
	proxy subscribeTo: self.
	
	logs := OrderedCollection new.!
!MarsRoverFun methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 13:56:06' prior: 50711230!
initializeFor: aProxy

	proxy := OrderedCollection new.
	proxy add: aProxy.
	proxy subscribeTo: self.
	! !

Object subclass: #MarsRoverFun
	instanceVariableNames: 'proxy'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!

!classDefinition: #MarsRoverFun category: 'MarsRover-WithHeading' stamp: 'LK 10/30/2023 13:56:14'!
Object subclass: #MarsRoverFun
	instanceVariableNames: 'proxy'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!

MarsRoverFun subclass: #MarsRoverLogger
	instanceVariableNames: 'logs'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!

!classDefinition: #MarsRoverLogger category: 'MarsRover-WithHeading' stamp: 'LK 10/30/2023 13:56:18'!
MarsRoverFun subclass: #MarsRoverLogger
	instanceVariableNames: 'logs'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!
!MarsRoverLogger methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 13:56:27' overrides: 16920235!
initialize

	logs := OrderedCollection new.! !
!MarsRoverFun methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 13:56:41'!
subscribeTo: aProxy

	proxy add: aProxy.
	aProxy addSubscriber: self.! !

!methodRemoval: MarsRoverLogger #subscribeTo: stamp: 'LK 10/30/2023 13:56:41'!
subscribeTo: aProxy

	proxy add: aProxy.
	aProxy addSubscriber: self.!

!classDefinition: #MarsRoverLogger category: 'MarsRover-WithHeading' stamp: 'LK 10/30/2023 13:58:46'!
MarsRoverFun subclass: #MarsRoverLogger
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!

!classDefinition: #MarsRoverFun category: 'MarsRover-WithHeading' stamp: 'LK 10/30/2023 13:58:46'!
Object subclass: #MarsRoverFun
	instanceVariableNames: 'proxy logs'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!
!MarsRoverFun methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 13:58:46' overrides: 16903929!
update: aThing

	logs add: aThing.! !

!methodRemoval: MarsRoverLogger #update: stamp: 'LK 10/30/2023 13:58:46'!
update: aThing

	logs add: aThing.!
!MarsRoverLogger methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 13:58:53' overrides: 50711307!
update: aThing

	logs add: aThing.! !

!methodRemoval: MarsRoverFun #update: stamp: 'LK 10/30/2023 13:58:54'!
update: aThing

	logs add: aThing.!

Object subclass: #MarsRoverFun
	instanceVariableNames: 'proxy'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!

!classDefinition: #MarsRoverFun category: 'MarsRover-WithHeading' stamp: 'LK 10/30/2023 14:04:01'!
Object subclass: #MarsRoverFun
	instanceVariableNames: 'proxy'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!

MarsRoverFun subclass: #MarsRoverLogger
	instanceVariableNames: 'logs'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!

!classDefinition: #MarsRoverLogger category: 'MarsRover-WithHeading' stamp: 'LK 10/30/2023 14:04:05'!
MarsRoverFun subclass: #MarsRoverLogger
	instanceVariableNames: 'logs'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!

MarsRoverFun subclass: #MarsRoverWindow
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!

!classDefinition: #MarsRoverWindow category: 'MarsRover-WithHeading' stamp: 'LK 10/30/2023 14:04:22'!
MarsRoverFun subclass: #MarsRoverWindow
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!
!MarsRoverWindow methodsFor: 'no messages' stamp: 'LK 10/30/2023 14:05:08'!
show! !

!testRun: #MarsRoverExtendedFuncionalityTest #test01logsAreEmptyAtStart stamp: 'LK 10/30/2023 14:29:45'!
ERROR!

!testRun: #MarsRoverExtendedFuncionalityTest #test01logsAreEmptyAtStart stamp: 'LK 10/30/2023 14:29:45'!
ERROR!

!testRun: #MarsRoverExtendedFuncionalityTest #test02logsPositionForSingleLogger stamp: 'LK 10/30/2023 14:29:53'!
ERROR!

!testRun: #MarsRoverExtendedFuncionalityTest #test02logsPositionForSingleLogger stamp: 'LK 10/30/2023 14:29:53'!
ERROR!
!MarsRoverFun methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 14:31:06' prior: 50711245!
initializeFor: aProxy

	proxy := OrderedCollection new.
	proxy add: aProxy.
	proxy do: [:proxt | proxt subscribeTo: self].
	! !

!testRun: #MarsRoverExtendedFuncionalityTest #test02logsPositionForSingleLogger stamp: 'LK 10/30/2023 14:31:12'!
ERROR!

!testRun: #MarsRoverExtendedFuncionalityTest #test02logsPositionForSingleLogger stamp: 'LK 10/30/2023 14:31:12'!
ERROR!
!MarsRoverFun methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 14:34:44' prior: 50711378!
initializeFor: aProxy

	proxy := OrderedCollection new.
	proxy add: aProxy.
	proxy do: [:proxt | proxt addSubscriber: self].
	! !

!testRun: #MarsRoverExtendedFuncionalityTest #test02logsPositionForSingleLogger stamp: 'LK 10/30/2023 14:35:32'!
ERROR!

!testRun: #MarsRoverExtendedFuncionalityTest #test02logsPositionForSingleLogger stamp: 'LK 10/30/2023 14:35:32'!
ERROR!
!MarsRover methodsFor: 'initialization' stamp: 'LK 10/30/2023 14:35:56' prior: 50710902!
initializeAt: aPosition heading: aHeadingType

	position := MarsRoverObservableVariable for: aPosition.
	head := MarsRoverObservableVariable for: (aHeadingType for: self).
	
	
	positionLogs := OrderedCollection new.
	directionLogs := OrderedCollection new.
	positionAndDirectionLogs := OrderedCollection new.! !

!testRun: #MarsRoverExtendedFuncionalityTest #test02logsPositionForSingleLogger stamp: 'LK 10/30/2023 14:35:59'!
ERROR!

!testRun: #MarsRoverExtendedFuncionalityTest #test02logsPositionForSingleLogger stamp: 'LK 10/30/2023 14:35:59'!
ERROR!
!MarsRover methodsFor: 'moving' stamp: 'LK 10/30/2023 14:37:02' prior: 50708693!
moveForward
	
	(head value) moveForward! !
!MarsRover methodsFor: 'moving' stamp: 'LK 10/30/2023 14:37:09' prior: 50708685!
moveBackward
	
	(head value) moveBackward! !

!testRun: #MarsRoverExtendedFuncionalityTest #test02logsPositionForSingleLogger stamp: 'LK 10/30/2023 14:37:13'!
ERROR!

!testRun: #MarsRoverExtendedFuncionalityTest #test02logsPositionForSingleLogger stamp: 'LK 10/30/2023 14:37:13'!
ERROR!

!testRun: #MarsRoverExtendedFuncionalityTest #test02logsPositionForSingleLogger stamp: 'LK 10/30/2023 14:37:53'!
ERROR!

!testRun: #MarsRoverExtendedFuncionalityTest #test02logsPositionForSingleLogger stamp: 'LK 10/30/2023 14:37:53'!
ERROR!
!MarsRoverObservableVariable methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 14:38:38' prior: 50711030!
updateContent: aClosure
	
	variable := aClosure.
	subscribers do: [:aSubscriber | aSubscriber update: variable].
	! !

!testRun: #MarsRoverExtendedFuncionalityTest #test02logsPositionForSingleLogger stamp: 'LK 10/30/2023 14:38:40'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test03logsMoreThanOnePositionForSingleLogger stamp: 'LK 10/30/2023 14:38:42'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test04logsPositionForMultipleLoggers stamp: 'LK 10/30/2023 14:38:43'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test05logsDirectionForSingleLogger stamp: 'LK 10/30/2023 14:38:45'!
ERROR!

!testRun: #MarsRoverExtendedFuncionalityTest #test05logsDirectionForSingleLogger stamp: 'LK 10/30/2023 14:38:45'!
ERROR!
!MarsRover methodsFor: 'heading' stamp: 'LK 10/30/2023 14:39:15' prior: 50708655!
rotateLeft
	
	(head value) rotateLeft! !
!MarsRover methodsFor: 'heading' stamp: 'LK 10/30/2023 14:39:21' prior: 50708659!
rotateRight
	
	(head value) rotateRight! !

!testRun: #MarsRoverExtendedFuncionalityTest #test04logsPositionForMultipleLoggers stamp: 'LK 10/30/2023 14:39:31'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test05logsDirectionForSingleLogger stamp: 'LK 10/30/2023 14:39:33'!
FAILURE!

!testRun: #MarsRoverExtendedFuncionalityTest #test05logsDirectionForSingleLogger stamp: 'LK 10/30/2023 14:39:33'!
FAILURE!
!MarsRoverHeading methodsFor: 'heading' stamp: 'LK 10/30/2023 14:49:56'!
direction
! !
!MarsRoverHeadingEast methodsFor: 'heading' stamp: 'LK 10/30/2023 14:50:07' overrides: 50711499!
direction
! !
!MarsRoverHeadingNorth methodsFor: 'heading' stamp: 'LK 10/30/2023 14:50:07' overrides: 50711499!
direction
! !
!MarsRoverHeadingSouth methodsFor: 'heading' stamp: 'LK 10/30/2023 14:50:07' overrides: 50711499!
direction
! !
!MarsRoverHeadingWest methodsFor: 'heading' stamp: 'LK 10/30/2023 14:50:07' overrides: 50711499!
direction
! !
!MarsRoverHeading methodsFor: 'heading' stamp: 'LK 10/30/2023 14:50:07' prior: 50711499!
direction

	self subclassResponsibility! !
!MarsRoverHeadingEast methodsFor: 'heading' stamp: 'LK 10/30/2023 14:50:28' prior: 50711503 overrides: 50711519!
direction

	^'East'! !
!MarsRoverHeadingNorth methodsFor: 'heading' stamp: 'LK 10/30/2023 14:50:34' prior: 50711507 overrides: 50711519!
direction

	^'North'! !
!MarsRoverHeadingSouth methodsFor: 'heading' stamp: 'LK 10/30/2023 14:50:40' prior: 50711511 overrides: 50711519!
direction

	^'South'! !
!MarsRoverHeadingWest methodsFor: 'heading' stamp: 'LK 10/30/2023 14:50:47' prior: 50711515 overrides: 50711519!
direction

	^'West'! !
!MarsRoverLogger methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 14:51:29'!
updatePosition: aPosition

	logs add: aPosition.! !
!MarsRoverLogger methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 14:51:55'!
updateDirection: aHeading

	logs add: aHeading direction.! !

!methodRemoval: MarsRoverLogger #update: stamp: 'LK 10/30/2023 14:52:03'!
update: aThing

	logs add: aThing.!

1@2 value!

!classRenamed: #MarsRoverFun as: #MarsRoverFunctionality stamp: 'LK 10/30/2023 14:59:32'!
Smalltalk renameClassNamed: #MarsRoverFun as: #MarsRoverFunctionality!

Object subclass: #MarsRoverFunctionality
	instanceVariableNames: 'proxies'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!

!classDefinition: #MarsRoverFunctionality category: 'MarsRover-WithHeading' stamp: 'LK 10/30/2023 15:01:19'!
Object subclass: #MarsRoverFunctionality
	instanceVariableNames: 'proxies'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!

Object subclass: #MarsRoverFunctionality
	instanceVariableNames: 'proxy'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!

!classDefinition: #MarsRoverFunctionality category: 'MarsRover-WithHeading' stamp: 'LK 10/30/2023 15:01:25'!
Object subclass: #MarsRoverFunctionality
	instanceVariableNames: 'proxy'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!

!classDefinition: #MarsRoverFunctionality category: 'MarsRover-WithHeading' stamp: 'LK 10/30/2023 15:01:32'!
Object subclass: #MarsRoverFunctionality
	instanceVariableNames: 'proxies'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!
!MarsRoverFunctionality methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 15:01:32' prior: 50711393!
initializeFor: aProxy

	proxies := OrderedCollection new.
	proxies add: aProxy.
	proxies do: [:proxt | proxt addSubscriber: self].
	! !
!MarsRoverFunctionality methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 15:01:32' prior: 50711281!
subscribeTo: aProxy

	proxies add: aProxy.
	aProxy addSubscriber: self.! !

!methodRemoval: MarsRover #addNewDirectionLogger stamp: 'LK 10/30/2023 15:03:19'!
addNewDirectionLogger

	directionLogs add: (MarsRoverLogger with: head)!

!methodRemoval: MarsRover #positionLoggerAt: stamp: 'LK 10/30/2023 15:03:23'!
positionLoggerAt: aNumber
	
	^(positionLogs at: aNumber) getLog.!

!methodRemoval: MarsRover #directionLoggerAt: stamp: 'LK 10/30/2023 15:03:25'!
directionLoggerAt: aNumber
	
	^(directionLogs at: aNumber) getLog.!

!methodRemoval: MarsRover #bothLoggerAt: stamp: 'LK 10/30/2023 15:03:26'!
bothLoggerAt: aNumber
	
	^(positionAndDirectionLogs at: aNumber) getLog.!

!methodRemoval: MarsRover #areLoggersEmpty stamp: 'LK 10/30/2023 15:03:27'!
areLoggersEmpty
	
	^ positionLogs isEmpty and: [directionLogs isEmpty and: [positionAndDirectionLogs isEmpty]].!

!classDefinition: #MarsRover category: 'MarsRover-WithHeading' stamp: 'LK 10/30/2023 15:03:56'!
Object subclass: #MarsRover
	instanceVariableNames: 'position head positionLogs directionLogs positionAndDirectionLogs positionObserver'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!
!MarsRover methodsFor: 'loggers' stamp: 'LK 10/30/2023 15:03:54'!
addPositionObserver: aClosure

	positionObserver add: aClosure! !

!methodRemoval: MarsRover #addNewPositionAndDirectionLogger stamp: 'LK 10/30/2023 15:04:04'!
addNewPositionAndDirectionLogger

	positionAndDirectionLogs add: (MarsRoverLogger with: head with: position)!

!methodRemoval: MarsRover #addNewPositionLogger stamp: 'LK 10/30/2023 15:04:05'!
addNewPositionLogger

	positionLogs add: (MarsRoverLogger with: position).!

!classDefinition: #MarsRover category: 'MarsRover-WithHeading' stamp: 'LK 10/30/2023 15:04:22'!
Object subclass: #MarsRover
	instanceVariableNames: 'position head positionLogs directionLogs positionAndDirectionLogs positionObserver directionObserver'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!
!MarsRover methodsFor: 'loggers' stamp: 'LK 10/30/2023 15:04:21'!
addDirectionObserver: aClosure

	directionObserver add: aClosure! !

Object subclass: #MarsRover
	instanceVariableNames: 'position head positionObserver directionObserver'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!

!classDefinition: #MarsRover category: 'MarsRover-WithHeading' stamp: 'LK 10/30/2023 15:04:30'!
Object subclass: #MarsRover
	instanceVariableNames: 'position head positionObserver directionObserver'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!
!MarsRoverHeading methodsFor: 'heading' stamp: 'LK 10/30/2023 15:08:46' overrides: 16902254!
value

	self subclassResponsibility! !

!methodRemoval: MarsRoverHeading #direction stamp: 'LK 10/30/2023 15:08:46'!
direction

	self subclassResponsibility!
!MarsRoverHeadingEast methodsFor: 'heading' stamp: 'LK 10/30/2023 15:09:00' overrides: 50711690!
value

	^'East'! !

!methodRemoval: MarsRoverHeadingEast #direction stamp: 'LK 10/30/2023 15:09:00'!
direction

	^'East'!
!MarsRoverHeadingNorth methodsFor: 'heading' stamp: 'LK 10/30/2023 15:09:11' overrides: 50711690!
value

	^'North'! !

!methodRemoval: MarsRoverHeadingNorth #direction stamp: 'LK 10/30/2023 15:09:11'!
direction

	^'North'!
!MarsRoverHeadingSouth methodsFor: 'heading' stamp: 'LK 10/30/2023 15:09:25' overrides: 50711690!
value

	^'South'! !

!methodRemoval: MarsRoverHeadingSouth #direction stamp: 'LK 10/30/2023 15:09:25'!
direction

	^'South'!
!MarsRoverHeadingWest methodsFor: 'heading' stamp: 'LK 10/30/2023 15:09:35' overrides: 50711690!
value

	^'West'! !

!methodRemoval: MarsRoverHeadingWest #direction stamp: 'LK 10/30/2023 15:09:35'!
direction

	^'West'!

!methodRemoval: MarsRoverLogger #updatePosition: stamp: 'LK 10/30/2023 15:09:46'!
updatePosition: aPosition

	logs add: aPosition.!
!MarsRoverLogger methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 15:10:02' overrides: 16903929!
update: aThing

	logs add: aThing value.! !

!classDefinition: #MarsRover category: 'MarsRover-WithHeading' stamp: 'LK 10/30/2023 15:11:29'!
Object subclass: #MarsRover
	instanceVariableNames: 'position head positionObserver directionObserver directionLogs'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!
!MarsRover methodsFor: 'loggers' stamp: 'LK 10/30/2023 15:11:27'!
addNewDirectionLogger

	directionLogs add: (MarsRoverLogger with: head)! !

!classDefinition: #MarsRover category: 'MarsRover-WithHeading' stamp: 'LK 10/30/2023 15:11:39'!
Object subclass: #MarsRover
	instanceVariableNames: 'position head positionObserver directionObserver directionLogs positionAndDirectionLogs'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!
!MarsRover methodsFor: 'loggers' stamp: 'LK 10/30/2023 15:11:36'!
addNewPositionAndDirectionLogger

	positionAndDirectionLogs add: (MarsRoverLogger with: head with: position)! !

!classDefinition: #MarsRover category: 'MarsRover-WithHeading' stamp: 'LK 10/30/2023 15:11:46'!
Object subclass: #MarsRover
	instanceVariableNames: 'position head positionObserver directionObserver directionLogs positionAndDirectionLogs positionLogs'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!
!MarsRover methodsFor: 'loggers' stamp: 'LK 10/30/2023 15:11:44'!
addNewPositionLogger

	positionLogs add: (MarsRoverLogger with: position).! !
!MarsRover methodsFor: 'loggers' stamp: 'LK 10/30/2023 15:11:51'!
areLoggersEmpty
	
	^ positionLogs isEmpty and: [directionLogs isEmpty and: [positionAndDirectionLogs isEmpty]].! !
!MarsRover methodsFor: 'loggers' stamp: 'LK 10/30/2023 15:11:56'!
bothLoggerAt: aNumber
	
	^(positionAndDirectionLogs at: aNumber) getLog.! !
!MarsRover methodsFor: 'loggers' stamp: 'LK 10/30/2023 15:12:01' prior: 50711786!
bothLoggerAt: aNumber
	
	^(positionAndDirectionLogs at: aNumber) getLog.! !
!MarsRover methodsFor: 'loggers' stamp: 'LK 10/30/2023 15:12:07'!
directionLoggerAt: aNumber
	
	^(directionLogs at: aNumber) getLog.! !
!MarsRover methodsFor: 'loggers' stamp: 'LK 10/30/2023 15:12:14'!
positionLoggerAt: aNumber
	
	^(positionLogs at: aNumber) getLog.! !

!methodRemoval: MarsRover #addDirectionObserver: stamp: 'LK 10/30/2023 15:12:22'!
addDirectionObserver: aClosure

	directionObserver add: aClosure!

!methodRemoval: MarsRover #addPositionObserver: stamp: 'LK 10/30/2023 15:12:26'!
addPositionObserver: aClosure

	positionObserver add: aClosure!

!testRun: #MarsRoverExtendedFuncionalityTest #test01logsAreEmptyAtStart stamp: 'LK 10/30/2023 15:12:38'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test02logsPositionForSingleLogger stamp: 'LK 10/30/2023 15:12:38'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test03logsMoreThanOnePositionForSingleLogger stamp: 'LK 10/30/2023 15:12:38'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test04logsPositionForMultipleLoggers stamp: 'LK 10/30/2023 15:12:38'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test05logsDirectionForSingleLogger stamp: 'LK 10/30/2023 15:12:38'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test06logsMoreThanOneDirectionForSingleLogger stamp: 'LK 10/30/2023 15:12:38'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test07logsDirectionForMultipleLoggers stamp: 'LK 10/30/2023 15:12:38'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test08logsBothDirectionAndPositionForSingleLogger stamp: 'LK 10/30/2023 15:12:38'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test09logsBothDirectionAndPositionForMultipleLoggers stamp: 'LK 10/30/2023 15:12:38'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test10logsDifferentTypeOfLoggersAtOnce stamp: 'LK 10/30/2023 15:12:38'!
PASSED!
!MarsRoverWindow methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 15:15:26' overrides: 16903929!
update: aThing

	! !
!MarsRoverWindow methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 15:15:32'!
updateDirection: aDirection

	! !

!classDefinition: #MarsRoverWindow category: 'MarsRover-WithHeading' stamp: 'LK 10/30/2023 15:15:51'!
MarsRoverFunctionality subclass: #MarsRoverWindow
	instanceVariableNames: 'heading'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!
!MarsRoverWindow methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 15:15:50'!
heading
	^heading! !

!classDefinition: #MarsRoverWindow category: 'MarsRover-WithHeading' stamp: 'LK 10/30/2023 15:15:58'!
MarsRoverFunctionality subclass: #MarsRoverWindow
	instanceVariableNames: 'heading position'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!
!MarsRoverWindow methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 15:15:58'!
position
	^position! !
!MarsRoverWindow methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 15:16:19' overrides: 16920235!
initialize
	position:=''.
	heading:=''! !

!methodRemoval: MarsRoverWindow #heading stamp: 'LK 10/30/2023 15:16:23'!
heading
	^heading!

!methodRemoval: MarsRoverWindow #initialize stamp: 'LK 10/30/2023 15:16:23'!
initialize
	position:=''.
	heading:=''!

!methodRemoval: MarsRoverWindow #position stamp: 'LK 10/30/2023 15:16:23'!
position
	^position!

!methodRemoval: MarsRoverWindow #show stamp: 'LK 10/30/2023 15:16:23'!
show!

!methodRemoval: MarsRoverWindow #update: stamp: 'LK 10/30/2023 15:16:23'!
update: aThing

	!

!methodRemoval: MarsRoverWindow #updateDirection: stamp: 'LK 10/30/2023 15:16:23'!
updateDirection: aDirection

	!
!MarsRoverWindow methodsFor: 'no messages' stamp: 'LK 10/30/2023 15:16:34' overrides: 16920235!
initialize
	position:=''.
	heading:=''! !
!MarsRoverWindow methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 15:16:39'!
heading
	^heading! !
!MarsRoverWindow methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 15:16:43'!
position
	^position! !
!MarsRoverWindow methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 15:17:01' prior: 50711912 overrides: 16920235!
initialize
	heading:=''! !
!MarsRoverWindow methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 15:17:16'!
updatePosition: aPosition

	position := aPosition! !
!MarsRoverWindow methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 15:17:23'!
updateDirection: aDirection! !
!MarsRoverWindow methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 15:17:50' prior: 50711934!
updateDirection: aDirection
	
	heading:= 'Pointing to', aDirection value.
! !

!testRun: #MarsRoverExtendedFuncionalityTest #test01logsAreEmptyAtStart stamp: 'LK 10/30/2023 15:18:14'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test01logsAreEmptyAtStart stamp: 'LK 10/30/2023 15:18:16'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test02logsPositionForSingleLogger stamp: 'LK 10/30/2023 15:18:16'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test03logsMoreThanOnePositionForSingleLogger stamp: 'LK 10/30/2023 15:18:16'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test04logsPositionForMultipleLoggers stamp: 'LK 10/30/2023 15:18:16'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test05logsDirectionForSingleLogger stamp: 'LK 10/30/2023 15:18:16'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test06logsMoreThanOneDirectionForSingleLogger stamp: 'LK 10/30/2023 15:18:16'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test07logsDirectionForMultipleLoggers stamp: 'LK 10/30/2023 15:18:16'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test08logsBothDirectionAndPositionForSingleLogger stamp: 'LK 10/30/2023 15:18:16'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test09logsBothDirectionAndPositionForMultipleLoggers stamp: 'LK 10/30/2023 15:18:16'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test10logsDifferentTypeOfLoggersAtOnce stamp: 'LK 10/30/2023 15:18:16'!
PASSED!

!methodRemoval: MarsRoverLogger #updateDirection: stamp: 'LK 10/30/2023 15:18:30'!
updateDirection: aHeading

	logs add: aHeading direction.!
!MarsRoverObservableVariable methodsFor: 'as yet unclassified' stamp: 'LK 10/30/2023 15:21:32' prior: 50711453!
updateContent: aNewValue
	
	variable := aNewValue.
	subscribers do: [:aSubscriber | aSubscriber update: variable].
	! !

!classRemoval: #MarsRoverWindow stamp: 'LK 10/30/2023 15:22:20'!
MarsRoverFunctionality subclass: #MarsRoverWindow
	instanceVariableNames: 'heading position'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MarsRover-WithHeading'!

!testRun: #MarsRoverExtendedFuncionalityTest #test01logsAreEmptyAtStart stamp: 'LK 10/30/2023 15:22:40'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test02logsPositionForSingleLogger stamp: 'LK 10/30/2023 15:22:40'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test03logsMoreThanOnePositionForSingleLogger stamp: 'LK 10/30/2023 15:22:40'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test04logsPositionForMultipleLoggers stamp: 'LK 10/30/2023 15:22:40'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test05logsDirectionForSingleLogger stamp: 'LK 10/30/2023 15:22:40'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test06logsMoreThanOneDirectionForSingleLogger stamp: 'LK 10/30/2023 15:22:40'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test07logsDirectionForMultipleLoggers stamp: 'LK 10/30/2023 15:22:40'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test08logsBothDirectionAndPositionForSingleLogger stamp: 'LK 10/30/2023 15:22:40'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test09logsBothDirectionAndPositionForMultipleLoggers stamp: 'LK 10/30/2023 15:22:40'!
PASSED!

!testRun: #MarsRoverExtendedFuncionalityTest #test10logsDifferentTypeOfLoggersAtOnce stamp: 'LK 10/30/2023 15:22:40'!
PASSED!

----QUIT----(30 October 2023 15:22:52) CuisUniversity-5981.image priorSource: 12129669!

----STARTUP---- (2 November 2023 13:04:18) as C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\CuisUniversity-5981.image!


----End fileIn of C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\TusLibros.st----!

!testRun: #CartTest #test01cartStartsEmpty stamp: 'LK 11/2/2023 13:05:45'!
PASSED!

!testRun: #CartTest #test02cartWithOneBookSizeIsOne stamp: 'LK 11/2/2023 13:05:47'!
PASSED!

!testRun: #CartTest #test03cartWithTwoIdenticalBooksSizeIsTwo stamp: 'LK 11/2/2023 13:05:48'!
PASSED!

!testRun: #CartTest #test04cartWithTwoBooksSizeIsSumOfQuantities stamp: 'LK 11/2/2023 13:05:49'!
PASSED!

!testRun: #CartTest #test05cartWithTwoIdenticalBooksSizeIsSomeOfQuantities stamp: 'LK 11/2/2023 13:05:51'!
PASSED!

!testRun: #CartTest #test06cartWithTwoBooksKnowsItsContents stamp: 'LK 11/2/2023 13:05:52'!
PASSED!

!testRun: #CartTest #test07itemQuantityShouldBeGreaterThanZero stamp: 'LK 11/2/2023 13:05:54'!
FAILURE!

!testRun: #CartTest #test07itemQuantityShouldBeGreaterThanZero stamp: 'LK 11/2/2023 13:05:54'!
FAILURE!

!testRun: #CartTest #test08itemShouldBeAvailable stamp: 'LK 11/2/2023 13:05:56'!
FAILURE!

!testRun: #CartTest #test08itemShouldBeAvailable stamp: 'LK 11/2/2023 13:05:56'!
FAILURE!

!testRun: #CartTest #test08itemShouldBeAvailable stamp: 'LK 11/2/2023 13:07:09'!
FAILURE!
!CartTest methodsFor: 'tests' stamp: 'LK 11/2/2023 13:12:42' prior: 50712143!
test07itemQuantityShouldBeGreaterThanZero
	|isbn quantity availableItems cart|
	cart := Cart new.
	isbn := 1414893.
	quantity := 0.
	availableItems := OrderedCollection with: isbn.
	cart availability: availableItems.
	self should: [cart addToCartItem: isbn amount: quantity]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [:anError | 
				self assert: (anError messageText = 					Cart)].
			
! !
!Cart methodsFor: 'as yet unclassified' stamp: 'LK 11/2/2023 13:13:23'!
errorNonPositiveAmountOfItems

	^ 'TheAmountOfItemsHasToBePositive'! !
!Cart methodsFor: 'as yet unclassified' stamp: 'LK 11/2/2023 13:13:23' prior: 50712217!
requireAmountGreaterThanZero: anAmount
	(anAmount > 0) ifFalse: [self error: self errorNonPositiveAmountOfItems]! !
!Cart methodsFor: 'as yet unclassified' stamp: 'LK 11/2/2023 13:13:41' prior: 50712282!
errorNonPositiveAmountOfItems

	^ 'The Amount Of Items Has To Be Positive'! !
!Cart methodsFor: 'as yet unclassified' stamp: 'LK 11/2/2023 13:14:02'!
errorNonAvailableItem

	^ 'ThisItemIsNotAvailable'! !
!Cart methodsFor: 'as yet unclassified' stamp: 'LK 11/2/2023 13:14:02' prior: 50712223!
requireItemIsAvailable: isbn
	(itemsAvailable includes: isbn) ifFalse: [self error: self errorNonAvailableItem]! !
!CartTest methodsFor: 'tests' stamp: 'LK 11/2/2023 13:14:45' prior: 50712266!
test07itemQuantityShouldBeGreaterThanZero
	|isbn quantity availableItems cart|
	cart := Cart new.
	isbn := 1414893.
	quantity := 0.
	availableItems := OrderedCollection with: isbn.
	cart availability: availableItems.
	self should: [cart addToCartItem: isbn amount: quantity]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [:anError | 
				self assert: (anError messageText = 					Cart errorNonPositiveAmountOfItems)].
			
! !

!testRun: #CartTest #test07itemQuantityShouldBeGreaterThanZero stamp: 'LK 11/2/2023 13:14:52'!
ERROR!
!Cart methodsFor: 'as yet unclassified' stamp: 'LK 11/2/2023 13:15:10' prior: 50712299!
errorNonAvailableItem

	^ 'This Item Is Not Available'! !
!Cart methodsFor: 'as yet unclassified' stamp: 'LK 11/2/2023 13:15:53'!
nonAvailableItemError

	^ 'This Item Is Not Available'! !
!Cart methodsFor: 'as yet unclassified' stamp: 'LK 11/2/2023 13:15:53' prior: 50712304!
requireItemIsAvailable: isbn
	(itemsAvailable includes: isbn) ifFalse: [self error: self nonAvailableItemError]! !

!methodRemoval: Cart #errorNonAvailableItem stamp: 'LK 11/2/2023 13:15:53'!
errorNonAvailableItem

	^ 'This Item Is Not Available'!
!Cart methodsFor: 'as yet unclassified' stamp: 'LK 11/2/2023 13:16:05'!
nonPositiveAmountOfItemsError

	^ 'The Amount Of Items Has To Be Positive'! !
!Cart methodsFor: 'as yet unclassified' stamp: 'LK 11/2/2023 13:16:06' prior: 50712287!
requireAmountGreaterThanZero: anAmount
	(anAmount > 0) ifFalse: [self error: self nonPositiveAmountOfItemsError]! !

!methodRemoval: Cart #errorNonPositiveAmountOfItems stamp: 'LK 11/2/2023 13:16:06'!
errorNonPositiveAmountOfItems

	^ 'The Amount Of Items Has To Be Positive'!
!CartTest methodsFor: 'tests' stamp: 'LK 11/2/2023 13:16:24' prior: 50712311!
test07itemQuantityShouldBeGreaterThanZero
	|isbn quantity availableItems cart|
	cart := Cart new.
	isbn := 1414893.
	quantity := 0.
	availableItems := OrderedCollection with: isbn.
	cart availability: availableItems.
	self should: [cart addToCartItem: isbn amount: quantity]
		raise: Error
		withExceptionDo: [:anError | 
				self assert: (anError messageText = 					Cart nonPositiveAmountOfItemsError)].
			
! !
!CartTest methodsFor: 'tests' stamp: 'LK 11/2/2023 13:16:45' prior: 50712158!
test08itemShouldBeAvailable

	|isbn quantity availableItems cart|
	cart := Cart new.
	isbn := 5473533.
	quantity := 1.
	availableItems := OrderedCollection with: 1232112 with: 1232134 with: 7675477.
	cart availability: availableItems .
	
	self should: [cart addToCartItem: isbn amount: quantity]
		raise: Error
		withExceptionDo: [:anError | 
				self assert: anError messageText = Cart nonAvailableItemError]! !
!CartTest methodsFor: 'tests' stamp: 'LK 11/2/2023 13:59:24' prior: 50712370!
test07itemQuantityShouldBeGreaterThanZero
	|isbn quantity availableItems cart|
	cart := Cart new.
	isbn := 1414893.
	quantity := 0.
	availableItems := OrderedCollection with: isbn.
	cart availability: availableItems.
	self should: [cart addToCartItem: isbn amount: quantity]		raise: Error		withExceptionDo: [:anError | self assert: anError messageText = 					'bsd'].
			
! !
!Cart methodsFor: 'as yet unclassified' stamp: 'LK 11/2/2023 13:59:55' prior: 50712358!
requireAmountGreaterThanZero: anAmount
	(anAmount > 0) ifFalse: [self error: 'bsd']! !

!testRun: #CartTest #test07itemQuantityShouldBeGreaterThanZero stamp: 'LK 11/2/2023 14:00:02'!
PASSED!
!Cart methodsFor: 'as yet unclassified' stamp: 'LK 11/2/2023 14:00:38' prior: 50712417!
requireAmountGreaterThanZero: anAmount
	(anAmount > 0) ifFalse: [self error: 'Amount should be greater than zero']! !
!CartTest methodsFor: 'tests' stamp: 'LK 11/2/2023 14:00:47' prior: 50712402!
test07itemQuantityShouldBeGreaterThanZero
	|isbn quantity availableItems cart|
	cart := Cart new.
	isbn := 1414893.
	quantity := 0.
	availableItems := OrderedCollection with: isbn.
	cart availability: availableItems.
	self should: [cart addToCartItem: isbn amount: quantity]		raise: Error		withExceptionDo: [:anError | self assert: anError messageText = 					'Amount should be greater than zero'].
			
! !

!testRun: #CartTest #test07itemQuantityShouldBeGreaterThanZero stamp: 'LK 11/2/2023 14:00:49'!
PASSED!

!testRun: #CartTest #test01cartStartsEmpty stamp: 'LK 11/2/2023 14:00:49'!
PASSED!

!testRun: #CartTest #test02cartWithOneBookSizeIsOne stamp: 'LK 11/2/2023 14:00:49'!
PASSED!

!testRun: #CartTest #test03cartWithTwoIdenticalBooksSizeIsTwo stamp: 'LK 11/2/2023 14:00:49'!
PASSED!

!testRun: #CartTest #test04cartWithTwoBooksSizeIsSumOfQuantities stamp: 'LK 11/2/2023 14:00:49'!
PASSED!

!testRun: #CartTest #test05cartWithTwoIdenticalBooksSizeIsSomeOfQuantities stamp: 'LK 11/2/2023 14:00:50'!
PASSED!

!testRun: #CartTest #test06cartWithTwoBooksKnowsItsContents stamp: 'LK 11/2/2023 14:00:50'!
PASSED!

!testRun: #CartTest #test07itemQuantityShouldBeGreaterThanZero stamp: 'LK 11/2/2023 14:00:50'!
PASSED!

!testRun: #CartTest #test08itemShouldBeAvailable stamp: 'LK 11/2/2023 14:00:50'!
ERROR!

!testRun: #CartTest #test08itemShouldBeAvailable stamp: 'LK 11/2/2023 14:00:50'!
ERROR!

!testRun: #CartTest #test07itemQuantityShouldBeGreaterThanZero stamp: 'LK 11/2/2023 14:01:13'!
PASSED!
!CartTest methodsFor: 'tests' stamp: 'LK 11/2/2023 14:01:29' prior: 50712386!
test08itemShouldBeAvailable

	|isbn quantity availableItems cart|
	cart := Cart new.
	isbn := 5473533.
	quantity := 1.
	availableItems := OrderedCollection with: 1232112 with: 1232134 with: 7675477.
	cart availability: availableItems .
	
	self should: [cart addToCartItem: isbn amount: quantity]
		raise: Error
		withExceptionDo: [:anError | 
				self assert: anError messageText = 'Item is not available']! !
!Cart methodsFor: 'as yet unclassified' stamp: 'LK 11/2/2023 14:01:50' prior: 50712336!
nonAvailableItemError

	^ 'Item is not available'! !

!testRun: #CartTest #test08itemShouldBeAvailable stamp: 'LK 11/2/2023 14:01:52'!
PASSED!

!testRun: #CartTest #test01cartStartsEmpty stamp: 'LK 11/2/2023 14:01:52'!
PASSED!

!testRun: #CartTest #test02cartWithOneBookSizeIsOne stamp: 'LK 11/2/2023 14:01:52'!
PASSED!

!testRun: #CartTest #test03cartWithTwoIdenticalBooksSizeIsTwo stamp: 'LK 11/2/2023 14:01:52'!
PASSED!

!testRun: #CartTest #test04cartWithTwoBooksSizeIsSumOfQuantities stamp: 'LK 11/2/2023 14:01:52'!
PASSED!

!testRun: #CartTest #test05cartWithTwoIdenticalBooksSizeIsSomeOfQuantities stamp: 'LK 11/2/2023 14:01:52'!
PASSED!

!testRun: #CartTest #test06cartWithTwoBooksKnowsItsContents stamp: 'LK 11/2/2023 14:01:52'!
PASSED!

!testRun: #CartTest #test07itemQuantityShouldBeGreaterThanZero stamp: 'LK 11/2/2023 14:01:52'!
PASSED!

!testRun: #CartTest #test08itemShouldBeAvailable stamp: 'LK 11/2/2023 14:01:52'!
PASSED!
!Cart methodsFor: 'as yet unclassified' stamp: 'LK 11/2/2023 14:02:46' prior: 50712352!
nonPositiveAmountOfItemsError

	^ 'Amount should be greater than zero'! !
!Cart methodsFor: 'as yet unclassified' stamp: 'LK 11/2/2023 14:02:57' prior: 50712426!
requireAmountGreaterThanZero: anAmount
	(anAmount > 0) ifFalse: [self error: self nonAvailableItemError]! !

!testRun: #CartTest #test01cartStartsEmpty stamp: 'LK 11/2/2023 14:02:59'!
PASSED!

!testRun: #CartTest #test02cartWithOneBookSizeIsOne stamp: 'LK 11/2/2023 14:02:59'!
PASSED!

!testRun: #CartTest #test03cartWithTwoIdenticalBooksSizeIsTwo stamp: 'LK 11/2/2023 14:02:59'!
PASSED!

!testRun: #CartTest #test04cartWithTwoBooksSizeIsSumOfQuantities stamp: 'LK 11/2/2023 14:02:59'!
PASSED!

!testRun: #CartTest #test05cartWithTwoIdenticalBooksSizeIsSomeOfQuantities stamp: 'LK 11/2/2023 14:02:59'!
PASSED!

!testRun: #CartTest #test06cartWithTwoBooksKnowsItsContents stamp: 'LK 11/2/2023 14:02:59'!
PASSED!

!testRun: #CartTest #test07itemQuantityShouldBeGreaterThanZero stamp: 'LK 11/2/2023 14:02:59'!
FAILURE!

!testRun: #CartTest #test08itemShouldBeAvailable stamp: 'LK 11/2/2023 14:02:59'!
PASSED!

!testRun: #CartTest #test07itemQuantityShouldBeGreaterThanZero stamp: 'LK 11/2/2023 14:02:59'!
FAILURE!

!testRun: #CartTest #test07itemQuantityShouldBeGreaterThanZero stamp: 'LK 11/2/2023 14:03:02'!
FAILURE!

!testRun: #CartTest #test07itemQuantityShouldBeGreaterThanZero stamp: 'LK 11/2/2023 14:03:02'!
FAILURE!

!testRun: #CartTest #test08itemShouldBeAvailable stamp: 'LK 11/2/2023 14:03:05'!
PASSED!
!Cart methodsFor: 'as yet unclassified' stamp: 'LK 11/2/2023 14:03:33' prior: 50712538!
requireAmountGreaterThanZero: anAmount
	(anAmount > 0) ifFalse: [self error: self nonPositiveAmountOfItemsError]! !

!testRun: #CartTest #test08itemShouldBeAvailable stamp: 'LK 11/2/2023 14:03:35'!
PASSED!

!testRun: #CartTest #test07itemQuantityShouldBeGreaterThanZero stamp: 'LK 11/2/2023 14:03:36'!
PASSED!

!testRun: #CartTest #test01cartStartsEmpty stamp: 'LK 11/2/2023 14:03:37'!
PASSED!

!testRun: #CartTest #test02cartWithOneBookSizeIsOne stamp: 'LK 11/2/2023 14:03:37'!
PASSED!

!testRun: #CartTest #test03cartWithTwoIdenticalBooksSizeIsTwo stamp: 'LK 11/2/2023 14:03:37'!
PASSED!

!testRun: #CartTest #test04cartWithTwoBooksSizeIsSumOfQuantities stamp: 'LK 11/2/2023 14:03:37'!
PASSED!

!testRun: #CartTest #test05cartWithTwoIdenticalBooksSizeIsSomeOfQuantities stamp: 'LK 11/2/2023 14:03:38'!
PASSED!

!testRun: #CartTest #test06cartWithTwoBooksKnowsItsContents stamp: 'LK 11/2/2023 14:03:38'!
PASSED!

!testRun: #CartTest #test07itemQuantityShouldBeGreaterThanZero stamp: 'LK 11/2/2023 14:03:38'!
PASSED!

!testRun: #CartTest #test08itemShouldBeAvailable stamp: 'LK 11/2/2023 14:03:38'!
PASSED!
!Cart class methodsFor: 'no messages' stamp: 'LK 11/2/2023 14:06:24'!
nonAvailableItemError

	^ 'Item is not available'! !
!Cart class methodsFor: 'as yet unclassified' stamp: 'LK 11/2/2023 14:06:39'!
nonPositiveAmountOfItemsError

	^ 'Amount should be greater than zero'! !

!methodRemoval: Cart #nonPositiveAmountOfItemsError stamp: 'LK 11/2/2023 14:06:47'!
nonPositiveAmountOfItemsError

	^ 'Amount should be greater than zero'!

!methodRemoval: Cart #nonAvailableItemError stamp: 'LK 11/2/2023 14:06:49'!
nonAvailableItemError

	^ 'Item is not available'!

!testRun: #CartTest #test08itemShouldBeAvailable stamp: 'LK 11/2/2023 14:06:54'!
FAILURE!

!testRun: #CartTest #test07itemQuantityShouldBeGreaterThanZero stamp: 'LK 11/2/2023 14:06:58'!
FAILURE!
!CartTest methodsFor: 'tests' stamp: 'LK 11/2/2023 14:07:09' prior: 50712433!
test07itemQuantityShouldBeGreaterThanZero
	|isbn quantity availableItems cart|
	cart := Cart new.
	isbn := 1414893.
	quantity := 0.
	availableItems := OrderedCollection with: isbn.
	cart availability: availableItems.
	self should: [cart addToCartItem: isbn amount: quantity]		raise: Error		withExceptionDo: [:anError | self assert: anError messageText = 			Cart].
			
! !
!CartTest methodsFor: 'tests' stamp: 'LK 11/2/2023 14:07:26' prior: 50712483!
test08itemShouldBeAvailable

	|isbn quantity availableItems cart|
	cart := Cart new.
	isbn := 5473533.
	quantity := 1.
	availableItems := OrderedCollection with: 1232112 with: 1232134 with: 7675477.
	cart availability: availableItems .
	
	self should: [cart addToCartItem: isbn amount: quantity]
		raise: Error
		withExceptionDo: [:anError | 
				self assert: anError messageText = Cart nonAvailableItemError ]! !
!CartTest methodsFor: 'tests' stamp: 'LK 11/2/2023 14:07:27' prior: 50712659!
test08itemShouldBeAvailable

	|isbn quantity availableItems cart|
	cart := Cart new.
	isbn := 5473533.
	quantity := 1.
	availableItems := OrderedCollection with: 1232112 with: 1232134 with: 7675477.
	cart availability: availableItems .
	
	self should: [cart addToCartItem: isbn amount: quantity]
		raise: Error
		withExceptionDo: [:anError | 
				self assert: anError messageText = Cart nonAvailableItemError]! !

!testRun: #CartTest #test08itemShouldBeAvailable stamp: 'LK 11/2/2023 14:07:27'!
FAILURE!
!CartTest methodsFor: 'tests' stamp: 'LK 11/2/2023 14:00:47' prior: 50712644!
test07itemQuantityShouldBeGreaterThanZero
	|isbn quantity availableItems cart|
	cart := Cart new.
	isbn := 1414893.
	quantity := 0.
	availableItems := OrderedCollection with: isbn.
	cart availability: availableItems.
	self should: [cart addToCartItem: isbn amount: quantity]		raise: Error		withExceptionDo: [:anError | self assert: anError messageText = 					'Amount should be greater than zero'].
			
! !
!CartTest methodsFor: 'tests' stamp: 'LK 11/2/2023 14:07:26' prior: 50712675!
test08itemShouldBeAvailable

	|isbn quantity availableItems cart|
	cart := Cart new.
	isbn := 5473533.
	quantity := 1.
	availableItems := OrderedCollection with: 1232112 with: 1232134 with: 7675477.
	cart availability: availableItems .
	
	self should: [cart addToCartItem: isbn amount: quantity]
		raise: Error
		withExceptionDo: [:anError | 
				self assert: anError messageText = Cart nonAvailableItemError ]! !
!CartTest methodsFor: 'tests' stamp: 'LK 11/2/2023 14:01:29' prior: 50712710!
test08itemShouldBeAvailable

	|isbn quantity availableItems cart|
	cart := Cart new.
	isbn := 5473533.
	quantity := 1.
	availableItems := OrderedCollection with: 1232112 with: 1232134 with: 7675477.
	cart availability: availableItems .
	
	self should: [cart addToCartItem: isbn amount: quantity]
		raise: Error
		withExceptionDo: [:anError | 
				self assert: anError messageText = 'Item is not available']! !
!Cart methodsFor: 'error handling' stamp: 'LK 11/2/2023 14:08:21'!
nonPositiveAmountOfItemsError

	^ 'Amount should be greater than zero'! !
!Cart methodsFor: 'error handling' stamp: 'LK 11/2/2023 14:08:39'!
nonAvailableItemError

	^ 'Item is not available'! !

!methodRemoval: Cart class #nonAvailableItemError stamp: 'LK 11/2/2023 14:08:46'!
nonAvailableItemError

	^ 'Item is not available'!

!methodRemoval: Cart class #nonPositiveAmountOfItemsError stamp: 'LK 11/2/2023 14:08:47'!
nonPositiveAmountOfItemsError

	^ 'Amount should be greater than zero'!

!testRun: #CartTest #test08itemShouldBeAvailable stamp: 'LK 11/2/2023 14:08:50'!
PASSED!

!testRun: #CartTest #test01cartStartsEmpty stamp: 'LK 11/2/2023 14:08:52'!
PASSED!

!testRun: #CartTest #test02cartWithOneBookSizeIsOne stamp: 'LK 11/2/2023 14:08:52'!
PASSED!

!testRun: #CartTest #test03cartWithTwoIdenticalBooksSizeIsTwo stamp: 'LK 11/2/2023 14:08:52'!
PASSED!

!testRun: #CartTest #test04cartWithTwoBooksSizeIsSumOfQuantities stamp: 'LK 11/2/2023 14:08:52'!
PASSED!

!testRun: #CartTest #test05cartWithTwoIdenticalBooksSizeIsSomeOfQuantities stamp: 'LK 11/2/2023 14:08:52'!
PASSED!

!testRun: #CartTest #test06cartWithTwoBooksKnowsItsContents stamp: 'LK 11/2/2023 14:08:52'!
PASSED!

!testRun: #CartTest #test07itemQuantityShouldBeGreaterThanZero stamp: 'LK 11/2/2023 14:08:52'!
PASSED!

!testRun: #CartTest #test08itemShouldBeAvailable stamp: 'LK 11/2/2023 14:08:52'!
PASSED!

----QUIT----(2 November 2023 14:10:48) CuisUniversity-5981.image priorSource: 12172715!

----STARTUP---- (2 November 2023 17:51:23) as C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\CuisUniversity-5981.image!


----QUIT----(2 November 2023 17:52:40) CuisUniversity-5981.image priorSource: 12196404!

----STARTUP---- (2 November 2023 18:26:01) as C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\CuisUniversity-5981.image!


----End fileIn of C:\Users\lucas\OneDrive\Desktop\TusLibros.st----!

!classRemoval: #Cart stamp: 'LK 11/2/2023 18:26:38'!
Object subclass: #Cart
	instanceVariableNames: 'catalog items'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classRemoval: #CartTest stamp: 'LK 11/2/2023 18:26:39'!
TestCase subclass: #CartTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

----End fileIn of C:\Users\lucas\OneDrive\Desktop\TusLibros.st----!

!classRemoval: #Cart stamp: 'LK 11/2/2023 18:27:47'!
Object subclass: #Cart
	instanceVariableNames: 'catalog items'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classRemoval: #CartTest stamp: 'LK 11/2/2023 18:27:48'!
TestCase subclass: #CartTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

----End fileIn of C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\repo\isw1\09-TusLibros\Iteracion1\TusLibros.st----!

TestCase subclass: #CashierTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #CashierTest category: 'TusLibros' stamp: 'LK 11/2/2023 18:32:23'!
TestCase subclass: #CashierTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!CashierTest methodsFor: 'nil' stamp: 'LK 11/2/2023 18:32:41'!
test01

	|cart |
	
	cart := Cart new.! !

!classRemoval: #CashierTest stamp: 'LK 11/2/2023 18:32:57'!
TestCase subclass: #CashierTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!CartTest methodsFor: 'tests' stamp: 'LK 11/2/2023 18:40:23' prior: 50713291!
test08itemShouldBeAvailable

	|isbn quantity availableItems cart|
	cart := Cart new.
	isbn := 5473533.
	quantity := 1.
	availableItems := OrderedCollection with: 1232112 with: 1232134 with: 7675477.
	cart availability: availableItems .
	
	self should: [cart addToCartItem: isbn amount: quantity]
		raise: Error
		withExceptionDo: [:anError | 
				self assert: anError messageText = cart nonAvailableItemError]! !

!testRun: #CartTest #test08itemShouldBeAvailable stamp: 'LK 11/2/2023 18:40:24'!
PASSED!

!testRun: #CartTest #test01cartStartsEmpty stamp: 'LK 11/2/2023 18:40:24'!
PASSED!

!testRun: #CartTest #test02cartWithOneBookSizeIsOne stamp: 'LK 11/2/2023 18:40:24'!
PASSED!

!testRun: #CartTest #test03cartWithTwoIdenticalBooksSizeIsTwo stamp: 'LK 11/2/2023 18:40:24'!
PASSED!

!testRun: #CartTest #test04cartWithTwoBooksSizeIsSumOfQuantities stamp: 'LK 11/2/2023 18:40:24'!
PASSED!

!testRun: #CartTest #test05cartWithTwoIdenticalBooksSizeIsSomeOfQuantities stamp: 'LK 11/2/2023 18:40:24'!
PASSED!

!testRun: #CartTest #test06cartWithTwoBooksKnowsItsContents stamp: 'LK 11/2/2023 18:40:24'!
PASSED!

!testRun: #CartTest #test07itemQuantityShouldBeGreaterThanZero stamp: 'LK 11/2/2023 18:40:24'!
PASSED!

!testRun: #CartTest #test08itemShouldBeAvailable stamp: 'LK 11/2/2023 18:40:24'!
PASSED!
!CartTest methodsFor: 'tests' stamp: 'LK 11/2/2023 18:40:37' prior: 50713276!
test07itemQuantityShouldBeGreaterThanZero
	|isbn quantity availableItems cart|
	cart := Cart new.
	isbn := 1414893.
	quantity := 0.
	availableItems := OrderedCollection with: isbn.
	cart availability: availableItems.
	self should: [cart addToCartItem: isbn amount: quantity]		raise: Error		withExceptionDo: [:anError | self assert: anError messageText = 		cart nonPositiveAmountOfItemsError].
			
! !

!testRun: #CartTest #test07itemQuantityShouldBeGreaterThanZero stamp: 'LK 11/2/2023 18:40:38'!
PASSED!

!testRun: #CartTest #test01cartStartsEmpty stamp: 'LK 11/2/2023 18:40:38'!
PASSED!

!testRun: #CartTest #test02cartWithOneBookSizeIsOne stamp: 'LK 11/2/2023 18:40:38'!
PASSED!

!testRun: #CartTest #test03cartWithTwoIdenticalBooksSizeIsTwo stamp: 'LK 11/2/2023 18:40:38'!
PASSED!

!testRun: #CartTest #test04cartWithTwoBooksSizeIsSumOfQuantities stamp: 'LK 11/2/2023 18:40:38'!
PASSED!

!testRun: #CartTest #test05cartWithTwoIdenticalBooksSizeIsSomeOfQuantities stamp: 'LK 11/2/2023 18:40:39'!
PASSED!

!testRun: #CartTest #test06cartWithTwoBooksKnowsItsContents stamp: 'LK 11/2/2023 18:40:39'!
PASSED!

!testRun: #CartTest #test07itemQuantityShouldBeGreaterThanZero stamp: 'LK 11/2/2023 18:40:39'!
PASSED!

!testRun: #CartTest #test08itemShouldBeAvailable stamp: 'LK 11/2/2023 18:40:39'!
PASSED!

----End fileIn of C:\Users\lucas\OneDrive\Desktop\TusLibros.st----!

!classRemoval: #Cart stamp: 'LK 11/2/2023 18:43:13'!
Object subclass: #Cart
	instanceVariableNames: 'catalog items'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classRemoval: #CartTest stamp: 'LK 11/2/2023 18:43:13'!
TestCase subclass: #CartTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

----End fileIn of C:\Users\lucas\OneDrive\Desktop\TusLibros.st----!

TestCase subclass: #CashierTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #CashierTest category: 'TusLibros' stamp: 'LK 11/2/2023 18:43:40'!
TestCase subclass: #CashierTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!CashierTest methodsFor: 'no messages' stamp: 'LK 11/2/2023 18:43:53'!
createCart
	
	^Cart acceptingItemsOf: self defaultCatalog! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'LK 11/2/2023 18:44:04'!
defaultCatalog
	
	^ Array with: self itemSellByTheStore! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'LK 11/2/2023 18:44:15'!
itemSellByTheStore
	
	^ 'validBook'! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'LK 11/2/2023 18:44:39'!
test01

	|aCashier aCart|
	
	aCart := self createCart.! !

!classDefinition: #Cashier category: 'TusLibros' stamp: 'LK 11/2/2023 18:45:59'!
Object subclass: #Cashier
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!CashierTest methodsFor: 'as yet unclassified' stamp: 'LK 11/2/2023 18:45:50' prior: 50713882!
test01

	|aCashier aCart|
	
	aCart := self createCart.
	aCashier := Cashier new.
	
	self 
		should: [aCashier checkout: aCart]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
				self assert: anError messageText = aCashier invalidCartErrorMessage.]! !

!testRun: #CashierTest #test01 stamp: 'LK 11/2/2023 18:46:30'!
ERROR!
!Cashier methodsFor: 'operations' stamp: 'LK 11/2/2023 18:46:43'!
checkout: aCart 
	self shouldBeImplemented.! !
!Cashier methodsFor: 'operations' stamp: 'LK 11/2/2023 18:47:07' prior: 50713907!
checkout: aCart 
	
	self error: self invalidCartErrorMessage! !

!testRun: #CashierTest #test01 stamp: 'LK 11/2/2023 18:47:13'!
ERROR!
!Cashier methodsFor: 'error' stamp: 'LK 11/2/2023 18:47:24'!
invalidCartErrorMessage
	self shouldBeImplemented.! !
!Cashier methodsFor: 'error' stamp: 'LK 11/2/2023 18:47:39' prior: 50713919!
invalidCartErrorMessage
	
	^'Cart should have at least one item'.! !

!testRun: #CashierTest #test01 stamp: 'LK 11/2/2023 18:47:42'!
PASSED!
!CashierTest methodsFor: 'as yet unclassified' stamp: 'LK 11/2/2023 18:47:50'!
test02

	|aCashier aCart|
	
	aCart := self createCart.
	aCashier := Cashier new.
	
	self 
		should: [aCashier checkout: aCart]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
				self assert: anError messageText = aCashier invalidCartErrorMessage.]! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'LK 11/2/2023 18:48:55' prior: 50713931!
test02

	|aCashier aCart|
	
	aCart := self createCart.
	aCart add: self itemSellByTheStore.
	
	aCashier := Cashier new.
! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'LK 11/2/2023 18:49:29' prior: 50713894!
test01

	|cashier aCart|
	
	aCart := self createCart.
	cashier := Cashier new.
	
	self 
		should: [cashier checkout: aCart]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
				self assert: anError messageText = cashier invalidCartErrorMessage.]! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'LK 11/2/2023 18:49:35' prior: 50713950!
test01

	|cashier cart|
	
	cart := self createCart.
	cashier := Cashier new.
	
	self 
		should: [cashier checkout: cart]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
				self assert: anError messageText = cashier invalidCartErrorMessage.]! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'LK 11/2/2023 18:49:42' prior: 50713943!
test02

	|cashier aCart|
	
	aCart := self createCart.
	aCart add: self itemSellByTheStore.
	
	cashier := Cashier new.
! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'LK 11/2/2023 18:49:48' prior: 50713974!
test02

	|cashier cart|
	
	cart := self createCart.
	cart add: self itemSellByTheStore.
	
	cashier := Cashier new.
! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'LK 11/2/2023 18:50:36' prior: 50713981!
test02

	|cashier cart expectedValue|
	
	cart := self createCart.
	cart add: self itemSellByTheStore.
	cashier := Cashier new.
	expectedValue := 10.
	
	self assert: (expectedValue = cashier checkout: cart)
! !

!testRun: #CashierTest #test02 stamp: 'LK 11/2/2023 18:50:43'!
ERROR!
!Cashier methodsFor: 'operations' stamp: 'LK 11/2/2023 18:52:07' prior: 50713912!
checkout: aCart 
	
	(aCart isEmpty) ifTrue: [self error: self invalidCartErrorMessage].! !
!Cashier methodsFor: 'operations' stamp: 'LK 11/2/2023 18:52:19' prior: 50714000!
checkout: aCart 
	
	|books|
	
	(aCart isEmpty) ifTrue: [self error: self invalidCartErrorMessage].
	
	! !
!Cart methodsFor: 'testing' stamp: 'LK 11/2/2023 18:52:47'!
items
	
	^items copy! !
!Cashier methodsFor: 'operations' stamp: 'LK 11/2/2023 18:53:46' prior: 50714006!
checkout: aCart 
	
	
	
	(aCart isEmpty) ifTrue: [self error: self invalidCartErrorMessage].
	
	^10! !

!testRun: #CashierTest #test02 stamp: 'LK 11/2/2023 18:53:51'!
ERROR!

!testRun: #CashierTest #test02 stamp: 'LK 11/2/2023 18:53:51'!
ERROR!
!CashierTest methodsFor: 'as yet unclassified' stamp: 'LK 11/2/2023 18:54:00' prior: 50713988!
test02

	|cashier cart expectedValue|
	
	cart := self createCart.
	cart add: self itemSellByTheStore.
	cashier := Cashier new.
	expectedValue := 10.
	
	self assert: (expectedValue = (cashier checkout: cart))
! !

!testRun: #CashierTest #test02 stamp: 'LK 11/2/2023 18:54:02'!
PASSED!

!testRun: #CashierTest #test01 stamp: 'LK 11/2/2023 18:54:02'!
PASSED!

!testRun: #CashierTest #test02 stamp: 'LK 11/2/2023 18:54:02'!
PASSED!
!Cashier methodsFor: 'operations' stamp: 'LK 11/2/2023 18:55:41' prior: 50714016!
checkout: aCart
	
	(aCart isEmpty) ifTrue: [self error: self invalidCartErrorMessage].
	
	^10! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'LK 11/2/2023 18:56:07'!
test03

	|cashier cart expectedValue|
	
	cart := self createCart.
	cart add: self itemSellByTheStore.
	cart add: self itemSellByTheStore.
	cashier := Cashier new.
	expectedValue := 20.
	
	self assert: (expectedValue = (cashier checkout: cart))
! !

Object subclass: #Cashier
	instanceVariableNames: 'priceCatalog'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #Cashier category: 'TusLibros' stamp: 'LK 11/2/2023 18:59:09'!
Object subclass: #Cashier
	instanceVariableNames: 'priceCatalog'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!Cashier methodsFor: 'error' stamp: 'LK 11/2/2023 18:59:58'!
initializeWithPriceCatalog: aPriceCatalog

	priceCatalog := aPriceCatalog.! !
!Cashier class methodsFor: 'nil' stamp: 'LK 11/2/2023 19:01:01'!
withPriceCatalog: aPriceCatalog

	^self new initializeWithPriceCatalog: aPriceCatalog! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'LK 11/2/2023 19:01:15'!
defaultPriceCatalog! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'LK 11/2/2023 19:01:29' prior: 50714081!
defaultPriceCatalog
	
	^Dictionary! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'LK 11/2/2023 19:01:31' prior: 50714085!
defaultPriceCatalog
	
	^Dictionary new! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'LK 11/2/2023 19:02:21' prior: 50714090!
defaultPriceCatalog
	
	|aDictionary|
	
	aDictionary := Dictionary new.
	
	aDictionary add: 'd'->10.! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'LK 11/2/2023 19:02:34' prior: 50714095!
defaultPriceCatalog
	
	|aDictionary|
	
	aDictionary := Dictionary new.
	
	aDictionary add: 'validBook' ->10.! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'LK 11/2/2023 19:02:54' prior: 50713962!
test01

	|cashier cart|
	
	cart := self createCart.
	cashier := Cashier withPriceCatalog: self defaultPriceCatalog.
	
	self 
		should: [cashier checkout: cart]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
				self assert: anError messageText = cashier invalidCartErrorMessage.]! !

!testRun: #CashierTest #test01 stamp: 'LK 11/2/2023 19:02:55'!
PASSED!

!testRun: #CashierTest #test01 stamp: 'LK 11/2/2023 19:02:55'!
PASSED!

!testRun: #CashierTest #test02 stamp: 'LK 11/2/2023 19:02:55'!
PASSED!

!testRun: #CashierTest #test03 stamp: 'LK 11/2/2023 19:02:55'!
FAILURE!

!testRun: #CashierTest #test03 stamp: 'LK 11/2/2023 19:02:55'!
FAILURE!

!testRun: #CashierTest #test01 stamp: 'LK 11/2/2023 19:03:02'!
PASSED!

!testRun: #CashierTest #test02 stamp: 'LK 11/2/2023 19:03:04'!
PASSED!
!Cashier methodsFor: 'operations' stamp: 'LK 11/2/2023 19:05:07' prior: 50714043!
checkout: aCart
	
	|books|
	
	(aCart isEmpty) ifTrue: [self error: self invalidCartErrorMessage].
	
	books := aCart items.
	
	^books sum: [:a | priceCatalog keyAtValue: a ifAbsent: []].! !

!testRun: #CashierTest #test02 stamp: 'LK 11/2/2023 19:05:16'!
ERROR!

!testRun: #CashierTest #test02 stamp: 'LK 11/2/2023 19:05:16'!
ERROR!
!CashierTest methodsFor: 'as yet unclassified' stamp: 'LK 11/2/2023 19:05:36' prior: 50714102!
defaultPriceCatalog
	
	|aDictionary|
	
	aDictionary := Dictionary new.
	
	aDictionary add: 'validBook' ->10.
	
	^aDictionary ! !

!testRun: #CashierTest #test01 stamp: 'LK 11/2/2023 19:05:38'!
PASSED!

!testRun: #CashierTest #test02 stamp: 'LK 11/2/2023 19:05:39'!
ERROR!

!testRun: #CashierTest #test02 stamp: 'LK 11/2/2023 19:05:39'!
ERROR!
!CashierTest methodsFor: 'as yet unclassified' stamp: 'LK 11/2/2023 19:06:12' prior: 50714027!
test02

	|cashier cart expectedValue|
	
	cart := self createCart.
	cart add: self itemSellByTheStore.
	cashier := Cashier withPriceCatalog: self defaultPriceCatalog.
	expectedValue := 10.
	
	self assert: (expectedValue = (cashier checkout: cart))
! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'LK 11/2/2023 19:06:18' prior: 50714049!
test03

	|cashier cart expectedValue|
	
	cart := self createCart.
	cart add: self itemSellByTheStore.
	cart add: self itemSellByTheStore.
	cashier := Cashier withPriceCatalog: self defaultPriceCatalog.
	expectedValue := 20.
	
	self assert: (expectedValue = (cashier checkout: cart))
! !

!testRun: #CashierTest #test02 stamp: 'LK 11/2/2023 19:06:22'!
FAILURE!

!testRun: #CashierTest #test02 stamp: 'LK 11/2/2023 19:07:50'!
FAILURE!

!testRun: #CashierTest #test02 stamp: 'LK 11/2/2023 19:07:50'!
FAILURE!
!Cashier methodsFor: 'operations' stamp: 'LK 11/2/2023 19:08:21' prior: 50714137!
checkout: aCart
	
	|books|
	
	(aCart isEmpty) ifTrue: [self error: self invalidCartErrorMessage].
	
	books := aCart items.
	
	^books sum: [:a | priceCatalog keyAtValue: a ifAbsent: [0]].! !

!testRun: #CashierTest #test02 stamp: 'LK 11/2/2023 19:09:38'!
FAILURE!

!testRun: #CashierTest #test03 stamp: 'LK 11/2/2023 19:10:57'!
FAILURE!
!CashierTest methodsFor: 'as yet unclassified' stamp: 'LK 11/2/2023 19:11:14' prior: 50714176!
test03

	|cashier cart expectedValue|
	
	cart := self createCart.
	cart add: self itemSellByTheStore.
	cart add: self itemSellByTheStore. 
	cashier := Cashier withPriceCatalog: self defaultPriceCatalog.
	expectedValue := 20.
	
	self assert: (expectedValue = (cashier checkout: cart))
! !

cashier checkout: cart!

^books sum: [:a | priceCatalog keyAtValue: a ifAbsent: [0]].!
!Cashier methodsFor: 'operations' stamp: 'LK 11/2/2023 19:12:35' prior: 50714195!
checkout: aCart
	
	|books|
	
	(aCart isEmpty) ifTrue: [self error: self invalidCartErrorMessage].
	
	books := aCart items.
	
	^books sum: [:a | priceCatalog at: a ifAbsent: [0]].! !


	^books sum: [:a | priceCatalog at: a ifAbsent: [0]].!

!testRun: #CashierTest #test03 stamp: 'LK 11/2/2023 19:12:48'!
PASSED!
!CashierTest methodsFor: 'as yet unclassified' stamp: 'LK 11/2/2023 19:13:41' prior: 50714209!
test03

	|cashier cart expectedValue|
	
	cart := self createCart.
	cart add: self itemSellByTheStore.
	cart add: self itemSellByTheStore. 
	cashier := Cashier withPriceCatalog: self defaultPriceCatalog.
	expectedValue := 20.
	
	self assert: (expectedValue = (cashier checkout: cart))
! !

!testRun: #CashierTest #test02 stamp: 'LK 11/2/2023 19:13:43'!
PASSED!
!Cashier methodsFor: 'operations' stamp: 'LK 11/2/2023 19:14:56' prior: 50714224!
checkout: aCart
	
	|books|
	
	(aCart isEmpty) ifTrue: [self error: self invalidCartErrorMessage].
	
	books := aCart items.
	
	^books sum: [:a | priceCatalog at: a].! !

!testRun: #CashierTest #test01 stamp: 'LK 11/2/2023 19:14:59'!
PASSED!

!testRun: #CashierTest #test02 stamp: 'LK 11/2/2023 19:14:59'!
PASSED!

!testRun: #CashierTest #test03 stamp: 'LK 11/2/2023 19:14:59'!
PASSED!
!CashierTest methodsFor: 'testing' stamp: 'LK 11/2/2023 19:19:57'!
test04

	|cashier cart expectedValue|
	
	cart := self createCart.
	cart add: self itemSellByTheStore.
	cart add: self itemSellByTheStore. 
	cashier := Cashier withPriceCatalog: self defaultPriceCatalog.
	expectedValue := 20.
	
	self assert: (expectedValue = (cashier checkout: cart))
! !
!Cashier methodsFor: 'operations' stamp: 'LK 11/2/2023 19:20:51'!
checkout: aCart with: aCreditCard 
	
	|books|
	
	(aCart isEmpty) ifTrue: [self error: self invalidCartErrorMessage].
	
	books := aCart items.
	
	^books sum: [:a | priceCatalog at: a].! !

!methodRemoval: Cashier #checkout: stamp: 'LK 11/2/2023 19:20:51'!
checkout: aCart
	
	|books|
	
	(aCart isEmpty) ifTrue: [self error: self invalidCartErrorMessage].
	
	books := aCart items.
	
	^books sum: [:a | priceCatalog at: a].!
!CashierTest methodsFor: 'support' stamp: 'LK 11/2/2023 19:21:25'!
defaultCreditCard! !
!CashierTest methodsFor: 'testing' stamp: 'LK 11/2/2023 19:21:41' prior: 50714109!
test01

	|cashier cart|
	
	cart := self createCart.
	cashier := Cashier withPriceCatalog: self defaultPriceCatalog.
	
	self 
		should: [cashier checkout: cart with: self defaultCreditCard ]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
				self assert: anError messageText = cashier invalidCartErrorMessage.]! !
!CashierTest methodsFor: 'testing' stamp: 'LK 11/2/2023 19:21:44' prior: 50714298!
test01

	|cashier cart|
	
	cart := self createCart.
	cashier := Cashier withPriceCatalog: self defaultPriceCatalog.
	
	self 
		should: [cashier checkout: cart with: self defaultCreditCard]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
				self assert: anError messageText = cashier invalidCartErrorMessage.]! !
!CashierTest methodsFor: 'testing' stamp: 'LK 11/2/2023 19:22:01' prior: 50714165!
test02

	|cashier cart expectedValue|
	
	cart := self createCart.
	cart add: self itemSellByTheStore.
	cashier := Cashier withPriceCatalog: self defaultPriceCatalog.
	expectedValue := 10.
	
	self assert: (expectedValue = (cashier checkout: cart with: self defaultCreditCard))
! !

!testRun: #CashierTest #test01 stamp: 'LK 11/2/2023 19:22:05'!
PASSED!

!testRun: #CashierTest #test02 stamp: 'LK 11/2/2023 19:22:07'!
PASSED!
!CashierTest methodsFor: 'testing' stamp: 'LK 11/2/2023 19:22:20' prior: 50714237!
test03

	|cashier cart expectedValue|
	
	cart := self createCart.
	cart add: self itemSellByTheStore.
	cart add: self itemSellByTheStore. 
	cashier := Cashier withPriceCatalog: self defaultPriceCatalog.
	expectedValue := 20.
	
	self assert: (expectedValue = (cashier checkout: cart with: self defaultCreditCard))
! !
!CashierTest methodsFor: 'testing' stamp: 'LK 11/2/2023 19:22:33' prior: 50714266!
test04

	|cashier cart expectedValue|
	
	cart := self createCart.
	cart add: self itemSellByTheStore.
	cart add: self itemSellByTheStore. 
	cashier := Cashier withPriceCatalog: self defaultPriceCatalog.
	expectedValue := 20.
	
	self assert: (expectedValue = (cashier checkout: cart with: self defaultCreditCard))
! !
!Cashier methodsFor: 'operations' stamp: 'LK 11/2/2023 19:23:26' prior: 50714278!
checkout: aCart with: aCreditCard 
	
	|books totalAmount|
	
	(aCart isEmpty) ifTrue: [self error: self invalidCartErrorMessage].
	
	books := aCart items.
	
	^books sum: [:a | priceCatalog at: a].! !
!Cashier methodsFor: 'operations' stamp: 'LK 11/2/2023 19:24:08' prior: 50714368!
checkout: aCart with: aCreditCard 
	
	|books totalAmount|
	
	(aCart isEmpty) ifTrue: [self error: self invalidCartErrorMessage].
	
	books := aCart items.
	
	totalAmount := books sum: [:a | priceCatalog at: a].
	
	self debit: totalAmount from: aCreditCard.
	
	^totalAmount.
	
	! !

!testRun: #CashierTest #test01 stamp: 'LK 11/2/2023 19:24:33'!
PASSED!

!testRun: #CashierTest #test02 stamp: 'LK 11/2/2023 19:24:36'!
ERROR!

!testRun: #CashierTest #test02 stamp: 'LK 11/2/2023 19:24:36'!
ERROR!
!Cashier methodsFor: 'operations' stamp: 'LK 11/2/2023 19:24:43'!
debit: totalAmount from: aCreditCard 
	self shouldBeImplemented.! !
!Cashier methodsFor: 'operations' stamp: 'LK 11/2/2023 19:24:45' prior: 50714395!
debit: totalAmount from: aCreditCard 
	! !

!testRun: #CashierTest #test01 stamp: 'LK 11/2/2023 19:24:50'!
PASSED!

!testRun: #CashierTest #test02 stamp: 'LK 11/2/2023 19:24:50'!
PASSED!

!testRun: #CashierTest #test03 stamp: 'LK 11/2/2023 19:24:50'!
PASSED!

!testRun: #CashierTest #test04 stamp: 'LK 11/2/2023 19:24:50'!
PASSED!
!CashierTest methodsFor: 'support' stamp: 'LK 11/2/2023 19:26:57'!
expiredCreditCard! !

Object subclass: #CreditCard
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #CreditCard category: 'TusLibros' stamp: 'LK 11/2/2023 19:49:16'!
Object subclass: #CreditCard
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!CreditCard methodsFor: 'nil' stamp: 'LK 11/2/2023 19:49:27' overrides: 16920235!
initialize! !

Object subclass: #CreditCard
	instanceVariableNames: 'expirationDate number cardOwner'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #CreditCard category: 'TusLibros' stamp: 'LK 11/2/2023 19:50:41'!
Object subclass: #CreditCard
	instanceVariableNames: 'expirationDate number cardOwner'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!CreditCard methodsFor: 'as yet unclassified' stamp: 'LK 11/2/2023 19:52:43'!
initializeCard: aNumber fromOwner: aNameOfOwner withExpDate: aMonthOfYear! !
!CreditCard methodsFor: 'as yet unclassified' stamp: 'LK 11/2/2023 19:54:18' prior: 50714443!
initializeCard: aNumber fromOwner: aNameOfOwner withExpDate: aMonthOfYear

	expirationDate := aMonthOfYear.
	number := aNumber! !

!classDefinition: #CreditCard category: 'TusLibros' stamp: 'LK 11/2/2023 19:54:28'!
Object subclass: #CreditCard
	instanceVariableNames: 'expirationDate cardNumber cardOwner'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!CreditCard methodsFor: 'as yet unclassified' stamp: 'LK 11/2/2023 19:54:28' prior: 50714449!
initializeCard: aNumber fromOwner: aNameOfOwner withExpDate: aMonthOfYear

	expirationDate := aMonthOfYear.
	cardNumber := aNumber! !

!methodRemoval: CreditCard #initialize stamp: 'LK 11/2/2023 19:54:32'!
initialize!
!CreditCard methodsFor: 'as yet unclassified' stamp: 'LK 11/2/2023 19:54:50' prior: 50714464!
initializeCard: aNumber fromOwner: aNameOfOwner withExpDate: aMonthOfYear

	expirationDate := aMonthOfYear.
	cardNumber := aNumber.
	! !
!CreditCard methodsFor: 'as yet unclassified' stamp: 'LK 11/2/2023 19:55:07' prior: 50714474!
initializeCard: aNumber fromOwner: aNameOfOwner withExpDate: aMonthOfYear

	expirationDate := aMonthOfYear.
	cardNumber := aNumber.
	cardOwner := aNameOfOwner.! !
!CreditCard class methodsFor: 'no messages' stamp: 'LK 11/2/2023 19:56:02'!
withNumber: aNumber fromOwner: aNameOfOwner withExpDate: aMonthOfYear

	^self new initializeCard: aNumber fromOwner: aNameOfOwner withExpDate: aMonthOfYear! !
!CreditCard methodsFor: 'as yet unclassified' stamp: 'LK 11/2/2023 20:47:53'!
isExpired! !

TestCase subclass: #CreditCardTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #CreditCardTest category: 'TusLibros' stamp: 'LK 11/2/2023 21:26:21'!
TestCase subclass: #CreditCardTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!CreditCardTest methodsFor: 'no messages' stamp: 'LK 11/2/2023 21:26:43'!
test01! !
!CreditCard class methodsFor: 'as yet unclassified' stamp: 'LK 11/2/2023 21:28:51' prior: 50714490!
withNumber: aNumber fromOwner: aNameOfOwner withExpDate: aMonthOfYear


	^self new initializeCard: aNumber fromOwner: aNameOfOwner withExpDate: aMonthOfYear! !
!CreditCardTest methodsFor: 'as yet unclassified' stamp: 'LK 11/2/2023 21:31:42' prior: 50714512!
test01

	|invalidName idCreditCard expiryDate|
	
	invalidName := ''.
	idCreditCard := '1234567890123456'.
	expiryDate := GregorianMonthOfYear current.
	
	
	
	! !
!CreditCardTest methodsFor: 'as yet unclassified' stamp: 'LK 11/2/2023 21:33:55' prior: 50714525!
test01

	|invalidName idCreditCard expiryDate|
	
	invalidName := ''.
	idCreditCard := '1234567890123456'.
	expiryDate := GregorianMonthOfYear current.
	
	self
		should: [CreditCard withNumber: idCreditCard fromOwner: invalidName withExpDate: expiryDate]
		raise: Error
		withExceptionDo: [:anError | 
				self assert: anError messageText = CreditCard invalidNameErrorDescription]	
	
	
	! !

!testRun: #CreditCardTest #test01 stamp: 'LK 11/2/2023 21:33:58'!
FAILURE!
!CreditCard class methodsFor: 'as yet unclassified' stamp: 'LK 11/2/2023 21:34:57' prior: 50714516!
withNumber: aNumber fromOwner: aNameOfOwner withExpDate: aMonthOfYear


	self validateOwnerName: aNameOfOwner.
	
	^self new initializeCard: aNumber fromOwner: aNameOfOwner withExpDate: aMonthOfYear! !
!CreditCard class methodsFor: 'as yet unclassified' stamp: 'LK 11/2/2023 21:35:30'!
validateOwnerName: aName

	(aName = '') ifTrue: [self error: self]! !
!CreditCard class methodsFor: 'as yet unclassified' stamp: 'LK 11/2/2023 21:35:52' prior: 50714561!
validateOwnerName: aName

	(aName = '') ifTrue: [self error: self invalidNameErrorDescription]! !
!CreditCard class methodsFor: 'as yet unclassified' stamp: 'LK 11/2/2023 21:36:13'!
invalidNameErrorDescription

	^'Owner name cant be empty'! !

!testRun: #CreditCardTest #test01 stamp: 'LK 11/2/2023 21:36:22'!
PASSED!
!CreditCardTest methodsFor: 'as yet unclassified' stamp: 'LK 11/2/2023 21:37:11'!
test02

	|cardName invalidIdCard expiryDate|
	
	cardName := 'Carlos'.
	invalidIdCard := '3'.
	expiryDate := GregorianMonthOfYear current.
	
	self
		should: [CreditCard withNumber: invalidIdCard fromOwner: cardName withExpDate: expiryDate]
		raise: Error
		withExceptionDo: [:anError | 
				self assert: anError messageText = CreditCard invalidNameErrorDescription]	
	
	
	! !
!CreditCardTest methodsFor: 'as yet unclassified' stamp: 'LK 11/2/2023 21:37:33' prior: 50714580!
test02

	|cardName invalidIdCard expiryDate|
	
	cardName := 'Carlos'.
	invalidIdCard := '3'.
	expiryDate := GregorianMonthOfYear current.
	
	self
		should: [CreditCard withNumber: invalidIdCard fromOwner: cardName withExpDate: expiryDate]
		raise: Error
		withExceptionDo: [:anError | 
				self assert: anError messageText = CreditCard invalidIdCardNumberDescription]	
	
	
	! !
!CreditCard class methodsFor: 'as yet unclassified' stamp: 'LK 11/2/2023 21:37:58'!
invalidIdCardNumberDescription

	^'Card Number must be 16 digits'! !
!CreditCard class methodsFor: 'as yet unclassified' stamp: 'LK 11/2/2023 21:38:57'!
validateCardNumber: anIDCard

	(anIDCard size = 16) ifFalse: [self error: self invalidIdCardNumberDescription]! !
!CreditCard class methodsFor: 'as yet unclassified' stamp: 'LK 11/2/2023 21:39:12' prior: 50714552!
withNumber: aNumber fromOwner: aNameOfOwner withExpDate: aMonthOfYear


	self validateOwnerName: aNameOfOwner.
	self validateCardNumber: aNumber.
	
	^self new initializeCard: aNumber fromOwner: aNameOfOwner withExpDate: aMonthOfYear! !
!CreditCard class methodsFor: 'as yet unclassified' stamp: 'LK 11/2/2023 21:39:19' prior: 50714622!
withNumber: anIDCard fromOwner: aNameOfOwner withExpDate: aMonthOfYear


	self validateOwnerName: aNameOfOwner.
	self validateCardNumber: anIDCard.
	
	^self new initializeCard: anIDCard fromOwner: aNameOfOwner withExpDate: aMonthOfYear! !

!testRun: #CreditCardTest #test02 stamp: 'LK 11/2/2023 21:39:28'!
PASSED!
!CreditCardTest methodsFor: 'as yet unclassified' stamp: 'LK 11/2/2023 21:39:42'!
test03

	|cardName invalidIdCard expiryDate|
	
	cardName := 'Carlos'.
	invalidIdCard := '1234567890123456'.
	expiryDate := GregorianMonthOfYear current.
	
	self
		should: [CreditCard withNumber: invalidIdCard fromOwner: cardName withExpDate: expiryDate]
		raise: Error
		withExceptionDo: [:anError | 
				self assert: anError messageText = CreditCard invalidIdCardNumberDescription]	
	
	
	! !
!CreditCardTest methodsFor: 'as yet unclassified' stamp: 'LK 11/2/2023 21:41:08' prior: 50714646!
test03

	|cardName invalidIdCard expiryDate|
	
	cardName := 'Carlos'.
	invalidIdCard := '1234567890123456'.
	expiryDate := 'AAAAAAAAAAAAAAAAAAAA'.
	
	self
		should: [CreditCard withNumber: invalidIdCard fromOwner: cardName withExpDate: expiryDate]
		raise: Error
		withExceptionDo: [:anError | 
				self assert: anError messageText = CreditCard invalidIdCardNumberDescription]	
	
	
	! !
!CreditCardTest methodsFor: 'as yet unclassified' stamp: 'LK 11/2/2023 21:41:31' prior: 50714662!
test03

	|cardName idCreditCard expiryDate|
	
	cardName := 'Carlos'.
	idCreditCard := '1234567890123456'.
	expiryDate := 'AAAAAAAAAAAAAAAAAAAA'.
	
	self
		should: [CreditCard withNumber: idCreditCard fromOwner: cardName withExpDate: expiryDate]
		raise: Error
		withExceptionDo: [:anError | 
				self assert: anError messageText = CreditCard invalidIdCardNumberDescription]	
	
	
	! !
!CreditCardTest methodsFor: 'as yet unclassified' stamp: 'LK 11/2/2023 21:41:44' prior: 50714678!
test03

	|cardName idCreditCard expiryDate|
	
	cardName := 'Carlos'.
	idCreditCard := '1234567890123456'.
	expiryDate := 'AAAAAAAAAAAAAAAAAAAA'.
	
	self
		should: [CreditCard withNumber: idCreditCard fromOwner: cardName withExpDate: expiryDate]
		raise: Error
		withExceptionDo: [:anError | 
				self assert: anError messageText = CreditCard invalidExpiryDate]	
	
	
	! !
!CreditCard class methodsFor: 'as yet unclassified' stamp: 'LK 11/2/2023 21:42:11'!
invalidExpiryDate

	^'Expiry date must be date and month'.! !
!CreditCard class methodsFor: 'as yet unclassified' stamp: 'LK 11/2/2023 21:42:26'!
validateExpiryDate: aDate! !
!CreditCard class methodsFor: 'as yet unclassified' stamp: 'LK 11/2/2023 21:42:38' prior: 50714633!
withNumber: anIDCard fromOwner: aNameOfOwner withExpDate: aMonthOfYear


	self validateOwnerName: aNameOfOwner.
	self validateCardNumber: anIDCard.
	self validateExpiryDate: aMonthOfYear.
	
	^self new initializeCard: anIDCard fromOwner: aNameOfOwner withExpDate: aMonthOfYear! !
!CreditCard class methodsFor: 'as yet unclassified' stamp: 'LK 11/2/2023 21:48:50' prior: 50714714!
validateExpiryDate: aDate

	(aDate isKindOf: GregorianMonthOfYear) ifFalse: [self error: self invalidNameErrorDescription]. ! !

!testRun: #CreditCardTest #test03 stamp: 'LK 11/2/2023 21:48:56'!
FAILURE!
!CreditCardTest methodsFor: 'as yet unclassified' stamp: 'LK 11/2/2023 21:49:20' prior: 50714694!
test03

	|cardName idCreditCard expiryDate|
	
	cardName := 'Carlos'.
	idCreditCard := '1234567890123456'.
	expiryDate := 'AAAAAAAAAAAAAAAAAAAA'.
	
	self
		should: [CreditCard withNumber: idCreditCard fromOwner: cardName withExpDate: expiryDate]
		raise: Error
		withExceptionDo: [:anError | 
				self assert: anError messageText = CreditCard invalidExpiryDate]	
	
	
	! !

!testRun: #CreditCardTest #test03 stamp: 'LK 11/2/2023 21:49:20'!
FAILURE!

!testRun: #CreditCardTest #test03 stamp: 'LK 11/2/2023 21:49:48'!
FAILURE!

!testRun: #CreditCardTest #test01 stamp: 'LK 11/2/2023 21:50:08'!
PASSED!

!testRun: #CreditCardTest #test02 stamp: 'LK 11/2/2023 21:50:08'!
PASSED!

!testRun: #CreditCardTest #test03 stamp: 'LK 11/2/2023 21:50:08'!
FAILURE!

!testRun: #CreditCardTest #test03 stamp: 'LK 11/2/2023 21:50:08'!
FAILURE!

self assert: anError messageText = CreditCard invalidExpiryDate!

self assert: anError messageText = CreditCard invalidExpiryDate!

----QUIT----(2 November 2023 21:50:31) CuisUniversity-5981.image priorSource: 12196624!

----STARTUP---- (3 November 2023 02:29:20) as C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\CuisUniversity-5981.image!

!CreditCardTest methodsFor: 'as yet unclassified' stamp: 'LK 11/3/2023 02:30:33'!
test04

	|cardName idCreditCard expiryDate cc|
	
	cardName := 'Carlos'.
	idCreditCard := '1234567890123456'.
	expiryDate := GregorianMonthOfYear current.
	cc := CreditCard withNumber: idCreditCard fromOwner: cardName withExpDate: expiryDate.
	
	
	
	
	
	! !
!CreditCardTest methodsFor: 'as yet unclassified' stamp: 'LK 11/3/2023 02:30:57' prior: 50714781!
test04

	|cardName idCreditCard expiryDate cc|
	
	cardName := 'Carlos'.
	idCreditCard := '1234567890123456'.
	expiryDate := GregorianMonthOfYear current.
	cc := CreditCard withNumber: idCreditCard fromOwner: cardName withExpDate: expiryDate.
	
	self assert: (cc isExpired = false)

	
	
	
	! !

!testRun: #CreditCardTest #test04 stamp: 'LK 11/3/2023 02:31:03'!
FAILURE!
!CreditCard methodsFor: 'as yet unclassified' stamp: 'LK 11/3/2023 02:31:15' prior: 50714498!
isExpired

	^false! !

!testRun: #CreditCardTest #test04 stamp: 'LK 11/3/2023 02:31:18'!
PASSED!
!CreditCard methodsFor: 'as yet unclassified' stamp: 'LK 11/3/2023 02:32:27'!
isExpiredAsToday: aCurrentMonthOfYear

	^false! !

!methodRemoval: CreditCard #isExpired stamp: 'LK 11/3/2023 02:32:40'!
isExpired

	^false!
!CreditCardTest methodsFor: 'as yet unclassified' stamp: 'LK 11/3/2023 02:33:03' prior: 50714793!
test04

	|cardName idCreditCard expiryDate cc|
	
	cardName := 'Carlos'.
	idCreditCard := '1234567890123456'.
	expiryDate := GregorianMonthOfYear current.
	cc := CreditCard withNumber: idCreditCard fromOwner: cardName withExpDate: expiryDate.
	
	self assert: (cc isExpiredAsToday: GregorianMonthOfYear current = false)

	
	
	
	! !

!testRun: #CreditCardTest #test04 stamp: 'LK 11/3/2023 02:33:04'!
FAILURE!
!CreditCardTest methodsFor: 'as yet unclassified' stamp: 'LK 11/3/2023 02:33:20' prior: 50714822!
test04

	|cardName idCreditCard expiryDate cc|
	
	cardName := 'Carlos'.
	idCreditCard := '1234567890123456'.
	expiryDate := GregorianMonthOfYear current.
	cc := CreditCard withNumber: idCreditCard fromOwner: cardName withExpDate: expiryDate.
	
	self assert: ((cc isExpiredAsToday: GregorianMonthOfYear current) = false)

	
	
	
	! !

!testRun: #CreditCardTest #test04 stamp: 'LK 11/3/2023 02:33:20'!
PASSED!

!testRun: #CreditCardTest #test01 stamp: 'LK 11/3/2023 02:33:21'!
PASSED!

!testRun: #CreditCardTest #test02 stamp: 'LK 11/3/2023 02:33:21'!
PASSED!

!testRun: #CreditCardTest #test03 stamp: 'LK 11/3/2023 02:33:21'!
FAILURE!

!testRun: #CreditCardTest #test04 stamp: 'LK 11/3/2023 02:33:21'!
PASSED!

!testRun: #CreditCardTest #test03 stamp: 'LK 11/3/2023 02:33:21'!
FAILURE!

!testRun: #CreditCardTest #test03 stamp: 'LK 11/3/2023 02:33:44'!
FAILURE!

!testRun: #CreditCardTest #test04 stamp: 'LK 11/3/2023 02:34:14'!
PASSED!
!CreditCardTest methodsFor: 'as yet unclassified' stamp: 'LK 11/3/2023 02:34:28' prior: 50714838!
test04

	|cardName idCreditCard expiryDate cc|
	
	cardName := 'Carlos'.
	idCreditCard := '1234567890123456'.
	expiryDate := GregorianMonthOfYear current.
	cc := CreditCard withNumber: idCreditCard fromOwner: cardName withExpDate: expiryDate.
	
	self assert: (cc isExpiredAsToday: GregorianMonthOfYear current = false)

	
	
	
	! !

!testRun: #CreditCardTest #test04 stamp: 'LK 11/3/2023 02:34:29'!
FAILURE!

!testRun: #CreditCardTest #test04 stamp: 'LK 11/3/2023 02:34:37'!
FAILURE!

!testRun: #CreditCardTest #test04 stamp: 'LK 11/3/2023 02:34:37'!
FAILURE!

!testRun: #CreditCardTest #test04 stamp: 'LK 11/3/2023 02:34:43'!
FAILURE!

!testRun: #CreditCardTest #test04 stamp: 'LK 11/3/2023 02:34:43'!
FAILURE!
!CreditCardTest methodsFor: 'as yet unclassified' stamp: 'LK 11/3/2023 02:34:54' prior: 50714871!
test04

	|cardName idCreditCard expiryDate cc|
	
	cardName := 'Carlos'.
	idCreditCard := '1234567890123456'.
	expiryDate := GregorianMonthOfYear current.
	cc := CreditCard withNumber: idCreditCard fromOwner: cardName withExpDate: expiryDate.
	
	self assert: ((cc isExpiredAsToday: GregorianMonthOfYear current) = false)

	
	
	
	! !

!testRun: #CreditCardTest #test04 stamp: 'LK 11/3/2023 02:34:55'!
PASSED!

!testRun: #CreditCardTest #test01 stamp: 'LK 11/3/2023 02:34:55'!
PASSED!

!testRun: #CreditCardTest #test02 stamp: 'LK 11/3/2023 02:34:55'!
PASSED!

!testRun: #CreditCardTest #test03 stamp: 'LK 11/3/2023 02:34:55'!
FAILURE!

!testRun: #CreditCardTest #test04 stamp: 'LK 11/3/2023 02:34:55'!
PASSED!

!testRun: #CreditCardTest #test03 stamp: 'LK 11/3/2023 02:34:55'!
FAILURE!
!CreditCardTest methodsFor: 'as yet unclassified' stamp: 'LK 11/3/2023 02:35:43' prior: 50714741!
test03

	|cardName idCreditCard expiryDate|
	
	cardName := 'Carlos'.
	idCreditCard := '1234567890123456'.
	expiryDate := 'AAAAAA'.
	
	self
		should: [CreditCard withNumber: idCreditCard fromOwner: cardName withExpDate: expiryDate]
		raise: Error
		withExceptionDo: [:anError | 
				self assert: anError messageText = CreditCard invalidExpiryDate]	
	
	
	! !

!testRun: #CreditCardTest #test03 stamp: 'LK 11/3/2023 02:35:45'!
FAILURE!
!CreditCardTest methodsFor: 'as yet unclassified' stamp: 'LK 11/3/2023 02:37:24' prior: 50714925!
test03

	|cardName idCreditCard expiryDate|
	
	cardName := 'Carlos'.
	idCreditCard := '1234567890123456'.
	expiryDate := 'AAAAAA'.
	
	self
		should: [CreditCard withNumber: idCreditCard fromOwner: cardName withExpDate: expiryDate]
		raise: Error
		withExceptionDo: [:anError | 
				self assert: (anError messageText = CreditCard invalidExpiryDate)]	
	
	
	! !

!testRun: #CreditCardTest #test03 stamp: 'LK 11/3/2023 02:37:25'!
FAILURE!
!CreditCard class methodsFor: 'as yet unclassified' stamp: 'LK 11/3/2023 02:39:59' prior: 50714731!
validateExpiryDate: aDate

	(aDate isKindOf: GregorianMonthOfYear) ifFalse: [self error: self invalidExpiryDate]. ! !

!testRun: #CreditCardTest #test01 stamp: 'LK 11/3/2023 02:40:13'!
PASSED!

!testRun: #CreditCardTest #test02 stamp: 'LK 11/3/2023 02:40:13'!
PASSED!

!testRun: #CreditCardTest #test03 stamp: 'LK 11/3/2023 02:40:13'!
PASSED!

!testRun: #CreditCardTest #test04 stamp: 'LK 11/3/2023 02:40:13'!
PASSED!
!CreditCardTest methodsFor: 'as yet unclassified' stamp: 'LK 11/3/2023 02:41:28' prior: 50714897!
test04

	|cardName idCreditCard expiryDate cc|
	
	cardName := 'Carlos'.
	idCreditCard := '1234567890123456'.
	expiryDate := GregorianMonthOfYear yearNumber: 2018 monthNumber: 12.
	cc := CreditCard withNumber: idCreditCard fromOwner: cardName withExpDate: expiryDate.
	
	self assert: ((cc isExpiredAsToday: GregorianMonthOfYear current) = true)

	
	
	
	! !

!testRun: #CreditCardTest #test04 stamp: 'LK 11/3/2023 02:41:29'!
FAILURE!
!CreditCardTest methodsFor: 'as yet unclassified' stamp: 'LK 11/3/2023 02:34:54' prior: 50714976!
test04

	|cardName idCreditCard expiryDate cc|
	
	cardName := 'Carlos'.
	idCreditCard := '1234567890123456'.
	expiryDate := GregorianMonthOfYear current.
	cc := CreditCard withNumber: idCreditCard fromOwner: cardName withExpDate: expiryDate.
	
	self assert: ((cc isExpiredAsToday: GregorianMonthOfYear current) = false)

	
	
	
	! !
!CreditCardTest methodsFor: 'as yet unclassified' stamp: 'LK 11/3/2023 02:34:28' prior: 50714993!
test04

	|cardName idCreditCard expiryDate cc|
	
	cardName := 'Carlos'.
	idCreditCard := '1234567890123456'.
	expiryDate := GregorianMonthOfYear current.
	cc := CreditCard withNumber: idCreditCard fromOwner: cardName withExpDate: expiryDate.
	
	self assert: (cc isExpiredAsToday: GregorianMonthOfYear current = false)

	
	
	
	! !
!CreditCardTest methodsFor: 'as yet unclassified' stamp: 'LK 11/3/2023 02:42:21' prior: 50715007!
test04

	|cardName idCreditCard expiryDate cc|
	
	cardName := 'Carlos'.
	idCreditCard := '1234567890123456'.
	expiryDate := GregorianMonthOfYear current.
	cc := CreditCard withNumber: idCreditCard fromOwner: cardName withExpDate: expiryDate.
	
	self assert: ((cc isExpiredAsToday: GregorianMonthOfYear current) = true)

	
	
	
	! !
!CreditCardTest methodsFor: 'as yet unclassified' stamp: 'LK 11/3/2023 02:42:41'!
test05

	|cardName idCreditCard expiryDate cc|
	
	cardName := 'Carlos'.
	idCreditCard := '1234567890123456'.
	expiryDate := GregorianMonthOfYear yearNumber: 2018 monthNumber: 12.
	cc := CreditCard withNumber: idCreditCard fromOwner: cardName withExpDate: expiryDate.
	
	self assert: ((cc isExpiredAsToday: GregorianMonthOfYear current) = false)

	
	
	
	! !
!CreditCardTest methodsFor: 'as yet unclassified' stamp: 'LK 11/3/2023 02:42:46' prior: 50715021!
test04

	|cardName idCreditCard expiryDate cc|
	
	cardName := 'Carlos'.
	idCreditCard := '1234567890123456'.
	expiryDate := GregorianMonthOfYear current.
	cc := CreditCard withNumber: idCreditCard fromOwner: cardName withExpDate: expiryDate.
	
	self assert: ((cc isExpiredAsToday: GregorianMonthOfYear current) = false)

	
	
	
	! !

!testRun: #CreditCardTest #test04 stamp: 'LK 11/3/2023 02:42:47'!
PASSED!

!testRun: #CreditCardTest #test01 stamp: 'LK 11/3/2023 02:42:47'!
PASSED!

!testRun: #CreditCardTest #test02 stamp: 'LK 11/3/2023 02:42:47'!
PASSED!

!testRun: #CreditCardTest #test03 stamp: 'LK 11/3/2023 02:42:47'!
PASSED!

!testRun: #CreditCardTest #test04 stamp: 'LK 11/3/2023 02:42:47'!
PASSED!

!testRun: #CreditCardTest #test05 stamp: 'LK 11/3/2023 02:42:47'!
PASSED!
!CreditCardTest methodsFor: 'as yet unclassified' stamp: 'LK 11/3/2023 02:42:54' prior: 50715034!
test05

	|cardName idCreditCard expiryDate cc|
	
	cardName := 'Carlos'.
	idCreditCard := '1234567890123456'.
	expiryDate := GregorianMonthOfYear yearNumber: 2018 monthNumber: 12.
	cc := CreditCard withNumber: idCreditCard fromOwner: cardName withExpDate: expiryDate.
	
	self assert: ((cc isExpiredAsToday: GregorianMonthOfYear current) = true)

	
	
	
	! !
!CreditCard methodsFor: 'as yet unclassified' stamp: 'LK 11/3/2023 02:46:25' prior: 50714814!
isExpiredAsToday: aCurrentMonthOfYear

	^((aCurrentMonthOfYear < expirationDate) or: [expirationDate = aCurrentMonthOfYear]) ! !

!testRun: #CreditCardTest #test05 stamp: 'LK 11/3/2023 02:46:29'!
FAILURE!

!testRun: #CreditCardTest #test05 stamp: 'LK 11/3/2023 02:46:29'!
FAILURE!

!testRun: #CreditCardTest #test04 stamp: 'LK 11/3/2023 02:46:38'!
FAILURE!

!testRun: #CreditCardTest #test04 stamp: 'LK 11/3/2023 02:46:38'!
FAILURE!

ds := GregorianMonthOfYear yearNumber: 2018 monthNumber: 12.!

today := GregorianMonthOfYear current.!

ds < today!

today < ds!

today = ds!
!CreditCard methodsFor: 'as yet unclassified' stamp: 'LK 11/3/2023 02:49:16' prior: 50715092!
isExpiredAsToday: aCurrentMonthOfYear

	^(((aCurrentMonthOfYear < expirationDate) or: [expirationDate = aCurrentMonthOfYear]) not) ! !

!testRun: #CreditCardTest #test04 stamp: 'LK 11/3/2023 02:49:20'!
PASSED!

!testRun: #CreditCardTest #test05 stamp: 'LK 11/3/2023 02:49:23'!
PASSED!
!CreditCard methodsFor: 'as yet unclassified' stamp: 'LK 11/3/2023 02:50:14' prior: 50715113!
isExpiredAsToday: aCurrentMonthOfYear

	((aCurrentMonthOfYear < expirationDate) or: [expirationDate = aCurrentMonthOfYear]) ifFalse: [^true] ifTrue: [^false].! !

!testRun: #CreditCardTest #test01 stamp: 'LK 11/3/2023 02:50:18'!
PASSED!

!testRun: #CreditCardTest #test02 stamp: 'LK 11/3/2023 02:50:18'!
PASSED!

!testRun: #CreditCardTest #test03 stamp: 'LK 11/3/2023 02:50:18'!
PASSED!

!testRun: #CreditCardTest #test04 stamp: 'LK 11/3/2023 02:50:18'!
PASSED!

!testRun: #CreditCardTest #test05 stamp: 'LK 11/3/2023 02:50:18'!
PASSED!
!CreditCard methodsFor: 'as yet unclassified' stamp: 'LK 11/3/2023 02:51:05' prior: 50715125!
isExpiredAsToday: aCurrentMonthOfYear

	((aCurrentMonthOfYear > expirationDate) or: [(expirationDate = aCurrentMonthOfYear) not]) 
	
	"ifFalse: [^true] ifTrue: [^false]."! !

!testRun: #CreditCardTest #test01 stamp: 'LK 11/3/2023 02:51:06'!
PASSED!

!testRun: #CreditCardTest #test02 stamp: 'LK 11/3/2023 02:51:06'!
PASSED!

!testRun: #CreditCardTest #test03 stamp: 'LK 11/3/2023 02:51:06'!
PASSED!

!testRun: #CreditCardTest #test04 stamp: 'LK 11/3/2023 02:51:06'!
FAILURE!

!testRun: #CreditCardTest #test05 stamp: 'LK 11/3/2023 02:51:06'!
FAILURE!
!CreditCard methodsFor: 'as yet unclassified' stamp: 'LK 11/3/2023 02:51:28' prior: 50715145!
isExpiredAsToday: aCurrentMonthOfYear

	((aCurrentMonthOfYear > expirationDate) or: [(expirationDate = aCurrentMonthOfYear)]) 
	
	"ifFalse: [^true] ifTrue: [^false]."! !

!testRun: #CreditCardTest #test01 stamp: 'LK 11/3/2023 02:51:29'!
PASSED!

!testRun: #CreditCardTest #test02 stamp: 'LK 11/3/2023 02:51:29'!
PASSED!

!testRun: #CreditCardTest #test03 stamp: 'LK 11/3/2023 02:51:29'!
PASSED!

!testRun: #CreditCardTest #test04 stamp: 'LK 11/3/2023 02:51:29'!
FAILURE!

!testRun: #CreditCardTest #test05 stamp: 'LK 11/3/2023 02:51:29'!
FAILURE!
!CreditCard methodsFor: 'as yet unclassified' stamp: 'LK 11/3/2023 02:50:14' prior: 50715166!
isExpiredAsToday: aCurrentMonthOfYear

	((aCurrentMonthOfYear < expirationDate) or: [expirationDate = aCurrentMonthOfYear]) ifFalse: [^true] ifTrue: [^false].! !

!testRun: #CreditCardTest #test01 stamp: 'LK 11/3/2023 02:51:50'!
PASSED!

!testRun: #CreditCardTest #test02 stamp: 'LK 11/3/2023 02:51:51'!
PASSED!

!testRun: #CreditCardTest #test03 stamp: 'LK 11/3/2023 02:51:51'!
PASSED!

!testRun: #CreditCardTest #test04 stamp: 'LK 11/3/2023 02:51:51'!
PASSED!

!testRun: #CreditCardTest #test05 stamp: 'LK 11/3/2023 02:51:51'!
PASSED!
!CreditCard methodsFor: 'as yet unclassified' stamp: 'LK 11/3/2023 02:52:08' prior: 50715187!
isExpiredAsToday: aCurrentMonthOfYear

	"se puede mejorar la logica"
	
	((aCurrentMonthOfYear < expirationDate) or: [expirationDate = aCurrentMonthOfYear]) ifFalse: [^true] ifTrue: [^false].! !
!CartTest methodsFor: 'support' stamp: 'LK 11/3/2023 02:54:43'!
defaultPriceCatalog
	
	|aDictionary|
	
	aDictionary := Dictionary new.
	
	aDictionary add: 'validBook' ->10.
	
	^aDictionary ! !
!CartTest methodsFor: 'support' stamp: 'LK 11/3/2023 02:55:04' prior: 50715216!
defaultPriceCatalog
	
	|aDictionary|
	
	aDictionary := Dictionary new.
	
	aDictionary add: self itemSellByTheStore ->10.
	
	^aDictionary ! !

!methodRemoval: CartTest #defaultCatalog stamp: 'LK 11/3/2023 02:55:13'!
defaultCatalog
	
	^ Array with: self itemSellByTheStore!
!CartTest methodsFor: 'support' stamp: 'LK 11/3/2023 02:55:29'!
defaultCatalog
	
	|aDictionary|
	
	aDictionary := Dictionary new.
	
	aDictionary add: self itemSellByTheStore ->10.
	
	^aDictionary ! !

!methodRemoval: CartTest #defaultPriceCatalog stamp: 'LK 11/3/2023 02:55:29'!
defaultPriceCatalog
	
	|aDictionary|
	
	aDictionary := Dictionary new.
	
	aDictionary add: self itemSellByTheStore ->10.
	
	^aDictionary !
!Cart methodsFor: 'assertions' stamp: 'LK 11/3/2023 02:56:17' prior: 50713801!
assertIsValidItem: anItem

	(catalog keys includes: anItem) ifFalse: [ self error: self invalidItemErrorMessage ]! !

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'LK 11/3/2023 02:56:54'!
PASSED!

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'LK 11/3/2023 02:56:58'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'LK 11/3/2023 02:56:58'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'LK 11/3/2023 02:56:58'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'LK 11/3/2023 02:56:58'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'LK 11/3/2023 02:56:59'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'LK 11/3/2023 02:56:59'!
PASSED!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'LK 11/3/2023 02:56:59'!
PASSED!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'LK 11/3/2023 02:56:59'!
PASSED!

!methodRemoval: CashierTest #defaultCatalog stamp: 'LK 11/3/2023 02:57:17'!
defaultCatalog
	
	^ Array with: self itemSellByTheStore!
!CashierTest methodsFor: 'support' stamp: 'LK 11/3/2023 02:57:39'!
defaultCatalog
	
	|aDictionary|
	
	aDictionary := Dictionary new.
	
	aDictionary add: 'validBook' ->10.
	
	^aDictionary ! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'LK 11/3/2023 02:57:39' prior: 50714312!
test01

	|cashier cart|
	
	cart := self createCart.
	cashier := Cashier withPriceCatalog: self defaultCatalog.
	
	self 
		should: [cashier checkout: cart with: self defaultCreditCard]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
				self assert: anError messageText = cashier invalidCartErrorMessage.]! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'LK 11/3/2023 02:57:40' prior: 50714355!
test04

	|cashier cart expectedValue|
	
	cart := self createCart.
	cart add: self itemSellByTheStore.
	cart add: self itemSellByTheStore. 
	cashier := Cashier withPriceCatalog: self defaultCatalog.
	expectedValue := 20.
	
	self assert: (expectedValue = (cashier checkout: cart with: self defaultCreditCard))
! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'LK 11/3/2023 02:57:40' prior: 50714342!
test03

	|cashier cart expectedValue|
	
	cart := self createCart.
	cart add: self itemSellByTheStore.
	cart add: self itemSellByTheStore. 
	cashier := Cashier withPriceCatalog: self defaultCatalog.
	expectedValue := 20.
	
	self assert: (expectedValue = (cashier checkout: cart with: self defaultCreditCard))
! !
!CashierTest methodsFor: 'as yet unclassified' stamp: 'LK 11/3/2023 02:57:40' prior: 50714326!
test02

	|cashier cart expectedValue|
	
	cart := self createCart.
	cart add: self itemSellByTheStore.
	cashier := Cashier withPriceCatalog: self defaultCatalog.
	expectedValue := 10.
	
	self assert: (expectedValue = (cashier checkout: cart with: self defaultCreditCard))
! !

!methodRemoval: CashierTest #defaultPriceCatalog stamp: 'LK 11/3/2023 02:57:40'!
defaultPriceCatalog
	
	|aDictionary|
	
	aDictionary := Dictionary new.
	
	aDictionary add: 'validBook' ->10.
	
	^aDictionary !

!testRun: #CashierTest #test01 stamp: 'LK 11/3/2023 02:57:43'!
PASSED!

!testRun: #CashierTest #test02 stamp: 'LK 11/3/2023 02:57:43'!
PASSED!

!testRun: #CashierTest #test03 stamp: 'LK 11/3/2023 02:57:43'!
PASSED!

!testRun: #CashierTest #test04 stamp: 'LK 11/3/2023 02:57:43'!
PASSED!

Object subclass: #Cashier
	instanceVariableNames: 'cart creditCard todaysDate priceCatalog'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #Cashier category: 'TusLibros' stamp: 'LK 11/3/2023 02:58:55'!
Object subclass: #Cashier
	instanceVariableNames: 'cart creditCard todaysDate priceCatalog'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!Cashier class methodsFor: 'as yet unclassified' stamp: 'LK 11/3/2023 03:00:57'!
for: aCart from: aCreditCard andTodayIs: aMonthOfYear

	^self new initializeFor: aCart from: aCreditCard andTodayIs: aMonthOfYear ! !

!methodRemoval: Cashier class #withPriceCatalog: stamp: 'LK 11/3/2023 03:01:05'!
withPriceCatalog: aPriceCatalog

	^self new initializeWithPriceCatalog: aPriceCatalog!
!Cashier methodsFor: 'initialization' stamp: 'LK 11/3/2023 03:02:00'!
initializeFor: aCart from: aCreditCard andTodayIs: aMonthOfYear

	cart := aCart.
	creditCard := aCreditCard.
	todaysDate := aMonthOfYear.! !

!methodRemoval: Cashier #initializeWithPriceCatalog: stamp: 'LK 11/3/2023 03:02:08'!
initializeWithPriceCatalog: aPriceCatalog

	priceCatalog := aPriceCatalog.!
!Cashier class methodsFor: 'as yet unclassified' stamp: 'LK 11/3/2023 03:02:33' prior: 50715374!
for: aCart from: aCreditCard andTodayIs: aMonthOfYear

	(aCart isEmpty) ifTrue: [self error: self invalidCartErrorMessage].

	^self new initializeFor: aCart from: aCreditCard andTodayIs: aMonthOfYear ! !
!Cashier class methodsFor: 'as yet unclassified' stamp: 'LK 11/3/2023 03:02:48'!
invalidCartErrorMessage! !

!methodRemoval: Cashier #invalidCartErrorMessage stamp: 'LK 11/3/2023 03:03:10'!
invalidCartErrorMessage
	
	^'Cart should have at least one item'.!
!Cashier class methodsFor: 'as yet unclassified' stamp: 'LK 11/3/2023 03:03:16' prior: 50715408!
invalidCartErrorMessage

	^'Cart should have at least one item'.! !
!Cashier class methodsFor: 'as yet unclassified' stamp: 'LK 11/3/2023 03:04:03' prior: 50715399!
for: aCart from: aCreditCard andTodayIs: aMonthOfYear

	(aCart isEmpty) ifTrue: [self error: self invalidCartErrorMessage].
	
	(aCreditCard isExpired) ifTrue: [self error: self expiredCCErrorMessage].

	^self new initializeFor: aCart from: aCreditCard andTodayIs: aMonthOfYear ! !
!Cashier class methodsFor: 'as yet unclassified' stamp: 'LK 11/3/2023 03:04:17'!
expiredCCErrorMessage

	^'This credit card is expired.'! !
!Cashier methodsFor: 'operations' stamp: 'LK 11/3/2023 03:06:14' prior: 50714377!
checkout: aCart with: aCreditCard 
	
	|totalAmount|
	
	totalAmount := aCart valueOfCart.
	
	self debit: totalAmount from: aCreditCard.
	
	^totalAmount.
	
	! !
!Cart methodsFor: 'queries' stamp: 'LK 11/3/2023 03:06:39'!
valueOfCart

	^ items sum: [:a | catalog at: a]! !
!CashierTest methodsFor: 'testing' stamp: 'LK 11/3/2023 03:08:38' prior: 50715294!
test01

	|cashier cart|
	
	cart := self createCart.
	cashier := Cashier for: cart from: self defaultCreditCard andTodayIs: self today.
	
	self 
		should: [cashier checkout: cart with: self defaultCreditCard]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
				self assert: anError messageText = cashier invalidCartErrorMessage.]! !
!CashierTest methodsFor: 'support' stamp: 'LK 11/3/2023 03:09:05'!
today

	^GregorianMonthOfYear current! !

!methodRemoval: CashierTest #itemSellByTheStore stamp: 'LK 11/3/2023 03:09:29'!
itemSellByTheStore
	
	^ 'validBook'!
!CashierTest methodsFor: 'testing' stamp: 'LK 11/3/2023 03:10:24' prior: 50715452!
test01

	|cart|
	
	cart := self createCart.
	
	self 
		should: [Cashier for: cart from: self defaultCreditCard andTodayIs: self today.]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
				self assert: anError messageText = Cashier invalidCartErrorMessage.]! !

!testRun: #CashierTest #test01 stamp: 'LK 11/3/2023 03:10:25'!
PASSED!

!testRun: #CashierTest #test01 stamp: 'LK 11/3/2023 03:10:25'!
PASSED!

!testRun: #CashierTest #test02 stamp: 'LK 11/3/2023 03:10:25'!
ERROR!

!testRun: #CashierTest #test03 stamp: 'LK 11/3/2023 03:10:25'!
ERROR!

!testRun: #CashierTest #test04 stamp: 'LK 11/3/2023 03:10:25'!
ERROR!
!CashierTest methodsFor: 'support' stamp: 'LK 11/3/2023 03:11:10'!
itemSellByTheStore
	
	^ 'validBook'! !
!CashierTest methodsFor: 'testing' stamp: 'LK 11/3/2023 03:11:32' prior: 50715334!
test02

	|cashier cart expectedValue|
	
	cart := self createCart.
	cart add: self itemSellByTheStore.
	cashier := Cashier for: cart from: self defaultCreditCard andTodayIs: self today.
	expectedValue := 10.
	
	self assert: (expectedValue = (cashier checkout: cart with: self defaultCreditCard))
! !
!CashierTest methodsFor: 'testing' stamp: 'LK 11/3/2023 03:11:47' prior: 50715501!
test02

	|cashier cart expectedValue|
	
	cart := self createCart.
	cart add: self itemSellByTheStore.
	cashier := Cashier for: cart from: self defaultCreditCard andTodayIs: self today.
	expectedValue := 10.
	
	self assert: (expectedValue = (cashier checkout:nil))
! !
!Cashier methodsFor: 'operations' stamp: 'LK 11/3/2023 03:12:11'!
checkout
	
	|totalAmount|
	
	totalAmount := cart valueOfCart.
	
	self debit: totalAmount from: creditCard .
	
	^totalAmount.
	
	! !

!methodRemoval: Cashier #checkout:with: stamp: 'LK 11/3/2023 03:12:15'!
checkout: aCart with: aCreditCard 
	
	|totalAmount|
	
	totalAmount := aCart valueOfCart.
	
	self debit: totalAmount from: aCreditCard.
	
	^totalAmount.
	
	!
!CashierTest methodsFor: 'testing' stamp: 'LK 11/3/2023 03:12:22' prior: 50715513!
test02

	|cashier cart expectedValue|
	
	cart := self createCart.
	cart add: self itemSellByTheStore.
	cashier := Cashier for: cart from: self defaultCreditCard andTodayIs: self today.
	expectedValue := 10.
	
	self assert: (expectedValue = (cashier checkout))
! !

!testRun: #CashierTest #test02 stamp: 'LK 11/3/2023 03:12:23'!
ERROR!

!testRun: #CashierTest #test02 stamp: 'LK 11/3/2023 03:12:37'!
ERROR!
!CashierTest methodsFor: 'support' stamp: 'LK 11/3/2023 03:13:59' prior: 50714294!
defaultCreditCard

	^CreditCard withNumber: '1234567890123456' fromOwner: 'Carlos' withExpDate: GregorianMonthOfYear current.! !

!testRun: #CashierTest #test02 stamp: 'LK 11/3/2023 03:14:04'!
ERROR!

!testRun: #CashierTest #test02 stamp: 'LK 11/3/2023 03:14:04'!
ERROR!
!CashierTest methodsFor: 'support' stamp: 'LK 11/3/2023 03:14:23' prior: 50715554!
defaultCreditCard

	^(CreditCard withNumber: '1234567890123456' fromOwner: 'Carlos' withExpDate: GregorianMonthOfYear current)! !

!testRun: #CashierTest #test02 stamp: 'LK 11/3/2023 03:14:27'!
ERROR!

!testRun: #CashierTest #test02 stamp: 'LK 11/3/2023 03:14:27'!
ERROR!

aCreditCard!
!Cashier class methodsFor: 'as yet unclassified' stamp: 'LK 11/3/2023 03:15:22' prior: 50715423!
for: aCart from: aCreditCard andTodayIs: aMonthOfYear

	(aCart isEmpty) ifTrue: [self error: self invalidCartErrorMessage].
	
	(aCreditCard isExpiredAsToday: aMonthOfYear) ifTrue: [self error: self expiredCCErrorMessage].

	^self new initializeFor: aCart from: aCreditCard andTodayIs: aMonthOfYear ! !

!testRun: #CashierTest #test02 stamp: 'LK 11/3/2023 03:15:28'!
PASSED!
!CashierTest methodsFor: 'testing' stamp: 'LK 11/3/2023 03:16:02' prior: 50715321!
test03

	|cashier cart expectedValue|
	
	cart := self createCart.
	cart add: self itemSellByTheStore.
	cart add: self itemSellByTheStore. 
	cashier := Cashier for: cart from: self defaultCreditCard andTodayIs: self today.
	expectedValue := 20.
	
	self assert: (expectedValue = (cashier checkout))
! !

!testRun: #CashierTest #test03 stamp: 'LK 11/3/2023 03:16:02'!
PASSED!

!testRun: #CashierTest #test01 stamp: 'LK 11/3/2023 03:16:02'!
PASSED!

!testRun: #CashierTest #test02 stamp: 'LK 11/3/2023 03:16:02'!
PASSED!

!testRun: #CashierTest #test03 stamp: 'LK 11/3/2023 03:16:02'!
PASSED!

!testRun: #CashierTest #test04 stamp: 'LK 11/3/2023 03:16:02'!
ERROR!

!testRun: #CashierTest #test04 stamp: 'LK 11/3/2023 03:16:02'!
ERROR!

!testRun: #CashierTest #test03 stamp: 'LK 11/3/2023 03:16:11'!
PASSED!
!CashierTest methodsFor: 'testing' stamp: 'LK 11/3/2023 03:16:25' prior: 50715308!
test04

	|cashier cart expectedValue|
	
	cart := self createCart.
	cart add: self itemSellByTheStore.
	cart add: self itemSellByTheStore. 
	cashier := Cashier for: cart from: self defaultCreditCard andTodayIs: self today.
	expectedValue := 20.
	
	self assert: (expectedValue = (cashier checkout))
! !
!CashierTest methodsFor: 'testing' stamp: 'LK 11/3/2023 03:17:01' prior: 50715621!
test04

	|cashier cart expectedValue|
	
	cart := self createCart.
	cart add: self itemSellByTheStore.
	cart add: self itemSellByTheStore. 
	cashier := Cashier for: cart from: self expiredCreditCard andTodayIs: self today.
	expectedValue := 20.
	
	self assert: (expectedValue = (cashier checkout))
! !
!CashierTest methodsFor: 'testing' stamp: 'LK 11/3/2023 03:17:29' prior: 50715633!
test04

	|cashier cart |
	
	cart := self createCart.
	cart add: self itemSellByTheStore.
	cart add: self itemSellByTheStore. 
	cashier := Cashier for: cart from: self expiredCreditCard andTodayIs: self today.
	
	self 
		should: [cashier checkout]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
				self assert: anError messageText = cashier invalidCartErrorMessage.]
! !
!CashierTest methodsFor: 'testing' stamp: 'LK 11/3/2023 03:18:31' prior: 50715645!
test04

	|cart |
	
	cart := self createCart.
	cart add: self itemSellByTheStore.
	
	self 
		should: [Cashier for: cart from: self expiredCreditCard andTodayIs: self today.]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
				self assert: anError messageText = Cashier expiredCCErrorMessage.]
! !
!CashierTest methodsFor: 'testing' stamp: 'LK 11/3/2023 03:18:41' prior: 50715660!
test04

	| cart |
	
	cart := self createCart.
	cart add: self itemSellByTheStore.
	
	self 
		should: [Cashier for: cart from: self expiredCreditCard andTodayIs: self today.]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
				self assert: anError messageText = Cashier expiredCCErrorMessage.]
! !
!CashierTest methodsFor: 'support' stamp: 'LK 11/3/2023 03:19:27' prior: 50714413!
expiredCreditCard

	^(CreditCard withNumber: '1234567890123456' fromOwner: 'Carlos' withExpDate: (GregorianMonthOfYear yearNumber: 2019 monthNumber: 11))! !

!testRun: #CashierTest #test04 stamp: 'LK 11/3/2023 03:19:31'!
PASSED!

!testRun: #CashierTest #test01 stamp: 'LK 11/3/2023 03:19:34'!
PASSED!

!testRun: #CashierTest #test02 stamp: 'LK 11/3/2023 03:19:34'!
PASSED!

!testRun: #CashierTest #test03 stamp: 'LK 11/3/2023 03:19:35'!
PASSED!

!testRun: #CashierTest #test04 stamp: 'LK 11/3/2023 03:19:35'!
PASSED!
!CashierTest methodsFor: 'testing' stamp: 'LK 11/3/2023 03:19:44'!
test02d

	| cart |
	
	cart := self createCart.
	cart add: self itemSellByTheStore.
	
	self 
		should: [Cashier for: cart from: self expiredCreditCard andTodayIs: self today.]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
				self assert: anError messageText = Cashier expiredCCErrorMessage.]
! !

!methodRemoval: CashierTest #test04 stamp: 'LK 11/3/2023 03:19:44'!
test04

	| cart |
	
	cart := self createCart.
	cart add: self itemSellByTheStore.
	
	self 
		should: [Cashier for: cart from: self expiredCreditCard andTodayIs: self today.]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
				self assert: anError messageText = Cashier expiredCCErrorMessage.]
!
!CashierTest methodsFor: 'testing' stamp: 'LK 11/3/2023 03:19:54'!
test03d

	|cashier cart expectedValue|
	
	cart := self createCart.
	cart add: self itemSellByTheStore.
	cashier := Cashier for: cart from: self defaultCreditCard andTodayIs: self today.
	expectedValue := 10.
	
	self assert: (expectedValue = (cashier checkout))
! !

!methodRemoval: CashierTest #test02 stamp: 'LK 11/3/2023 03:19:55'!
test02

	|cashier cart expectedValue|
	
	cart := self createCart.
	cart add: self itemSellByTheStore.
	cashier := Cashier for: cart from: self defaultCreditCard andTodayIs: self today.
	expectedValue := 10.
	
	self assert: (expectedValue = (cashier checkout))
!
!CashierTest methodsFor: 'testing' stamp: 'LK 11/3/2023 03:20:00'!
test04

	|cashier cart expectedValue|
	
	cart := self createCart.
	cart add: self itemSellByTheStore.
	cart add: self itemSellByTheStore. 
	cashier := Cashier for: cart from: self defaultCreditCard andTodayIs: self today.
	expectedValue := 20.
	
	self assert: (expectedValue = (cashier checkout))
! !

!methodRemoval: CashierTest #test03 stamp: 'LK 11/3/2023 03:20:00'!
test03

	|cashier cart expectedValue|
	
	cart := self createCart.
	cart add: self itemSellByTheStore.
	cart add: self itemSellByTheStore. 
	cashier := Cashier for: cart from: self defaultCreditCard andTodayIs: self today.
	expectedValue := 20.
	
	self assert: (expectedValue = (cashier checkout))
!

----QUIT----(3 November 2023 03:20:22) CuisUniversity-5981.image priorSource: 12259932!

----STARTUP---- (6 November 2023 00:28:47) as C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\CuisUniversity-5981.image!

!CartTest methodsFor: 'tests' stamp: 'LK 11/6/2023 00:31:00'!
test09CartCalculatesCorrectPricesForItems! !
!CartTest methodsFor: 'tests' stamp: 'LK 11/6/2023 00:31:16' prior: 50715781!
test09CartCalculatesCorrectPricesForItems

	|cart|
	
	cart := self createCart.! !
!CartTest methodsFor: 'tests' stamp: 'LK 11/6/2023 00:32:00' prior: 50715785!
test09CartCalculatesCorrectPricesForItems

	|cart|
	
	cart := self createCart.
	
	cart add: self itemSellByTheStore withOcurrences: 2.
	
	self assert: (cart = 20)! !
!CartTest methodsFor: 'tests' stamp: 'LK 11/6/2023 00:32:08' prior: 50715790!
test09CartCalculatesCorrectPricesForItems

	|cart|
	
	cart := self createCart.
	
	cart add: self itemSellByTheStore withOcurrences: 2.
	
	self assert: (cart valueOfCart = 20)! !

!testRun: #CartTest #test09CartCalculatesCorrectPricesForItems stamp: 'LK 11/6/2023 00:32:09'!
PASSED!

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'LK 11/6/2023 00:32:09'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'LK 11/6/2023 00:32:09'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'LK 11/6/2023 00:32:09'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'LK 11/6/2023 00:32:09'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'LK 11/6/2023 00:32:09'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'LK 11/6/2023 00:32:09'!
PASSED!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'LK 11/6/2023 00:32:09'!
PASSED!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'LK 11/6/2023 00:32:09'!
PASSED!

!testRun: #CartTest #test09CartCalculatesCorrectPricesForItems stamp: 'LK 11/6/2023 00:32:09'!
PASSED!
!CartTest methodsFor: 'tests' stamp: 'LK 11/6/2023 00:34:30'!
test09CartCalculatesCorrectPricesForOneItem

	|cart|
	
	cart := self createCart.
	
	cart add: self itemSellByTheStore withOcurrences: 2.
	
	self assert: (cart valueOfCart = 20)! !
!CartTest methodsFor: 'tests' stamp: 'LK 11/6/2023 00:34:43'!
test10CartCalculatesCorrectPricesForManyItems

	|cart|
	
	cart := self createCart.
	
	cart add: self itemSellByTheStore withOcurrences: 2.
	
	self assert: (cart valueOfCart = 20)! !

!methodRemoval: CartTest #test09CartCalculatesCorrectPricesForItems stamp: 'LK 11/6/2023 00:34:43'!
test09CartCalculatesCorrectPricesForItems

	|cart|
	
	cart := self createCart.
	
	cart add: self itemSellByTheStore withOcurrences: 2.
	
	self assert: (cart valueOfCart = 20)!
!CartTest methodsFor: 'tests' stamp: 'LK 11/6/2023 00:34:50' prior: 50715846!
test10CartCalculatesCorrectPricesForManyItems

	|cart|
	
	cart := self createCart.
	
	cart add: self itemSellByTheStore withOcurrences: 2.
	cart add: self itemSellByTheStore withOcurrences: 2.
	
	self assert: (cart valueOfCart = 40)! !

!testRun: #CartTest #test10CartCalculatesCorrectPricesForManyItems stamp: 'LK 11/6/2023 00:34:51'!
PASSED!
!CartTest methodsFor: 'tests' stamp: 'LK 11/6/2023 00:35:07' prior: 50715838!
test09CartCalculatesCorrectPricesForOneItem

	|cart|
	
	cart := self createCart.
	
	cart add: self itemSellByTheStore.
	
	self assert: (cart valueOfCart = 10)! !

!testRun: #CartTest #test09CartCalculatesCorrectPricesForOneItem stamp: 'LK 11/6/2023 00:35:08'!
PASSED!

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'LK 11/6/2023 00:35:08'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'LK 11/6/2023 00:35:08'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'LK 11/6/2023 00:35:08'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'LK 11/6/2023 00:35:08'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'LK 11/6/2023 00:35:08'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'LK 11/6/2023 00:35:08'!
PASSED!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'LK 11/6/2023 00:35:08'!
PASSED!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'LK 11/6/2023 00:35:08'!
PASSED!

!testRun: #CartTest #test09CartCalculatesCorrectPricesForOneItem stamp: 'LK 11/6/2023 00:35:08'!
PASSED!

!testRun: #CartTest #test10CartCalculatesCorrectPricesForManyItems stamp: 'LK 11/6/2023 00:35:08'!
PASSED!
!CreditCardTest methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 00:40:45'!
test01cantInitialize

	|invalidName idCreditCard expiryDate|
	
	invalidName := ''.
	idCreditCard := '1234567890123456'.
	expiryDate := GregorianMonthOfYear current.
	
	self
		should: [CreditCard withNumber: idCreditCard fromOwner: invalidName withExpDate: expiryDate]
		raise: Error
		withExceptionDo: [:anError | 
				self assert: anError messageText = CreditCard invalidNameErrorDescription]	
	
	
	! !

!methodRemoval: CreditCardTest #test01 stamp: 'LK 11/6/2023 00:40:45'!
test01

	|invalidName idCreditCard expiryDate|
	
	invalidName := ''.
	idCreditCard := '1234567890123456'.
	expiryDate := GregorianMonthOfYear current.
	
	self
		should: [CreditCard withNumber: idCreditCard fromOwner: invalidName withExpDate: expiryDate]
		raise: Error
		withExceptionDo: [:anError | 
				self assert: anError messageText = CreditCard invalidNameErrorDescription]	
	
	
	!
!CreditCardTest methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 00:41:21'!
test01cannotUseEmptyNameForCreditCard

	|invalidName idCreditCard expiryDate|
	
	invalidName := ''.
	idCreditCard := '1234567890123456'.
	expiryDate := GregorianMonthOfYear current.
	
	self
		should: [CreditCard withNumber: idCreditCard fromOwner: invalidName withExpDate: expiryDate]
		raise: Error
		withExceptionDo: [:anError | 
				self assert: anError messageText = CreditCard invalidNameErrorDescription]	
	
	
	! !

!methodRemoval: CreditCardTest #test01cantInitialize stamp: 'LK 11/6/2023 00:41:21'!
test01cantInitialize

	|invalidName idCreditCard expiryDate|
	
	invalidName := ''.
	idCreditCard := '1234567890123456'.
	expiryDate := GregorianMonthOfYear current.
	
	self
		should: [CreditCard withNumber: idCreditCard fromOwner: invalidName withExpDate: expiryDate]
		raise: Error
		withExceptionDo: [:anError | 
				self assert: anError messageText = CreditCard invalidNameErrorDescription]	
	
	
	!
!CreditCardTest methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 00:41:47'!
test02shouldBe16DigitsCreditCardID

	|cardName invalidIdCard expiryDate|
	
	cardName := 'Carlos'.
	invalidIdCard := '3'.
	expiryDate := GregorianMonthOfYear current.
	
	self
		should: [CreditCard withNumber: invalidIdCard fromOwner: cardName withExpDate: expiryDate]
		raise: Error
		withExceptionDo: [:anError | 
				self assert: anError messageText = CreditCard invalidIdCardNumberDescription]	
	
	
	! !

!methodRemoval: CreditCardTest #test02 stamp: 'LK 11/6/2023 00:41:47'!
test02

	|cardName invalidIdCard expiryDate|
	
	cardName := 'Carlos'.
	invalidIdCard := '3'.
	expiryDate := GregorianMonthOfYear current.
	
	self
		should: [CreditCard withNumber: invalidIdCard fromOwner: cardName withExpDate: expiryDate]
		raise: Error
		withExceptionDo: [:anError | 
				self assert: anError messageText = CreditCard invalidIdCardNumberDescription]	
	
	
	!
!CreditCardTest methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 00:42:05'!
test03shouldUseValidFormatExpiryDate

	|cardName idCreditCard expiryDate|
	
	cardName := 'Carlos'.
	idCreditCard := '1234567890123456'.
	expiryDate := 'AAAAAA'.
	
	self
		should: [CreditCard withNumber: idCreditCard fromOwner: cardName withExpDate: expiryDate]
		raise: Error
		withExceptionDo: [:anError | 
				self assert: (anError messageText = CreditCard invalidExpiryDate)]	
	
	
	! !

!methodRemoval: CreditCardTest #test03 stamp: 'LK 11/6/2023 00:42:05'!
test03

	|cardName idCreditCard expiryDate|
	
	cardName := 'Carlos'.
	idCreditCard := '1234567890123456'.
	expiryDate := 'AAAAAA'.
	
	self
		should: [CreditCard withNumber: idCreditCard fromOwner: cardName withExpDate: expiryDate]
		raise: Error
		withExceptionDo: [:anError | 
				self assert: (anError messageText = CreditCard invalidExpiryDate)]	
	
	
	!
!CreditCardTest methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 00:42:31'!
test04currentMonthOfYearShouldBeValidDate

	|cardName idCreditCard expiryDate cc|
	
	cardName := 'Carlos'.
	idCreditCard := '1234567890123456'.
	expiryDate := GregorianMonthOfYear current.
	cc := CreditCard withNumber: idCreditCard fromOwner: cardName withExpDate: expiryDate.
	
	self assert: ((cc isExpiredAsToday: GregorianMonthOfYear current) = false)

	
	
	
	! !

!methodRemoval: CreditCardTest #test04 stamp: 'LK 11/6/2023 00:42:31'!
test04

	|cardName idCreditCard expiryDate cc|
	
	cardName := 'Carlos'.
	idCreditCard := '1234567890123456'.
	expiryDate := GregorianMonthOfYear current.
	cc := CreditCard withNumber: idCreditCard fromOwner: cardName withExpDate: expiryDate.
	
	self assert: ((cc isExpiredAsToday: GregorianMonthOfYear current) = false)

	
	
	
	!
!CreditCardTest methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 00:43:16'!
test05shouldBeExpiredIfExpiryDateHasPassed

	|cardName idCreditCard expiryDate cc|
	
	cardName := 'Carlos'.
	idCreditCard := '1234567890123456'.
	expiryDate := GregorianMonthOfYear yearNumber: 2018 monthNumber: 12.
	cc := CreditCard withNumber: idCreditCard fromOwner: cardName withExpDate: expiryDate.
	
	self assert: ((cc isExpiredAsToday: GregorianMonthOfYear current) = true)

	
	
	
	! !

!methodRemoval: CreditCardTest #test05 stamp: 'LK 11/6/2023 00:43:16'!
test05

	|cardName idCreditCard expiryDate cc|
	
	cardName := 'Carlos'.
	idCreditCard := '1234567890123456'.
	expiryDate := GregorianMonthOfYear yearNumber: 2018 monthNumber: 12.
	cc := CreditCard withNumber: idCreditCard fromOwner: cardName withExpDate: expiryDate.
	
	self assert: ((cc isExpiredAsToday: GregorianMonthOfYear current) = true)

	
	
	
	!
!CashierTest methodsFor: 'testing' stamp: 'LK 11/6/2023 00:43:52'!
test01cannotMakeCashierWithEmptyCart

	|cart|
	
	cart := self createCart.
	
	self 
		should: [Cashier for: cart from: self defaultCreditCard andTodayIs: self today.]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
				self assert: anError messageText = Cashier invalidCartErrorMessage.]! !

!methodRemoval: CashierTest #test01 stamp: 'LK 11/6/2023 00:43:52'!
test01

	|cart|
	
	cart := self createCart.
	
	self 
		should: [Cashier for: cart from: self defaultCreditCard andTodayIs: self today.]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
				self assert: anError messageText = Cashier invalidCartErrorMessage.]!
!CashierTest methodsFor: 'testing' stamp: 'LK 11/6/2023 00:44:31'!
test02CannotUseExpiredCreditCardForCashier

	| cart |
	
	cart := self createCart.
	cart add: self itemSellByTheStore.
	
	self 
		should: [Cashier for: cart from: self expiredCreditCard andTodayIs: self today.]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
				self assert: anError messageText = Cashier expiredCCErrorMessage.]
! !

!methodRemoval: CashierTest #test02d stamp: 'LK 11/6/2023 00:44:31'!
test02d

	| cart |
	
	cart := self createCart.
	cart add: self itemSellByTheStore.
	
	self 
		should: [Cashier for: cart from: self expiredCreditCard andTodayIs: self today.]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
				self assert: anError messageText = Cashier expiredCCErrorMessage.]
!
!CashierTest methodsFor: 'testing' stamp: 'LK 11/6/2023 00:44:35'!
test02cannotUseExpiredCreditCardForCashier

	| cart |
	
	cart := self createCart.
	cart add: self itemSellByTheStore.
	
	self 
		should: [Cashier for: cart from: self expiredCreditCard andTodayIs: self today.]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
				self assert: anError messageText = Cashier expiredCCErrorMessage.]
! !

!methodRemoval: CashierTest #test02CannotUseExpiredCreditCardForCashier stamp: 'LK 11/6/2023 00:44:35'!
test02CannotUseExpiredCreditCardForCashier

	| cart |
	
	cart := self createCart.
	cart add: self itemSellByTheStore.
	
	self 
		should: [Cashier for: cart from: self expiredCreditCard andTodayIs: self today.]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
				self assert: anError messageText = Cashier expiredCCErrorMessage.]
!

!methodRemoval: CashierTest #test03d stamp: 'LK 11/6/2023 00:44:42'!
test03d

	|cashier cart expectedValue|
	
	cart := self createCart.
	cart add: self itemSellByTheStore.
	cashier := Cashier for: cart from: self defaultCreditCard andTodayIs: self today.
	expectedValue := 10.
	
	self assert: (expectedValue = (cashier checkout))
!

!methodRemoval: CashierTest #test04 stamp: 'LK 11/6/2023 00:44:43'!
test04

	|cashier cart expectedValue|
	
	cart := self createCart.
	cart add: self itemSellByTheStore.
	cart add: self itemSellByTheStore. 
	cashier := Cashier for: cart from: self defaultCreditCard andTodayIs: self today.
	expectedValue := 20.
	
	self assert: (expectedValue = (cashier checkout))
!
!CashierTest methodsFor: 'testing' stamp: 'LK 11/6/2023 00:47:12'!
test03cannotUsePastDateForCashier

	| cart pastDate|
	
	cart := self createCart.
	cart add: self itemSellByTheStore.
	pastDate := GregorianMonthOfYear yearNumber: 2012 monthNumber: 2.
	
	self 
		should: [Cashier for: cart from: self defaultCreditCard andTodayIs: pastDate.]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
				self assert: anError messageText = Cashier expiredCCErrorMessage.]
! !
!Cashier class methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 00:48:32' prior: 50715578!
for: aCart from: aCreditCard andTodayIs: aMonthOfYear

	(aCart isEmpty) ifTrue: [self error: self invalidCartErrorMessage].
	
	(aCreditCard isExpiredAsToday: aMonthOfYear) ifTrue: [self error: self expiredCCErrorMessage].
	
	(aMonthOfYear = GregorianMonthOfYear current) ifFalse: [self error: self notValidTodayDateMessage].

	^self new initializeFor: aCart from: aCreditCard andTodayIs: aMonthOfYear ! !
!Cashier class methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 00:48:51'!
notValidTodayDateMessage

	^'Given date is not correct!!!!'! !
!CashierTest methodsFor: 'testing' stamp: 'LK 11/6/2023 00:49:03' prior: 50716194!
test03cannotUsePastDateForCashier

	| cart pastDate|
	
	cart := self createCart.
	cart add: self itemSellByTheStore.
	pastDate := GregorianMonthOfYear yearNumber: 2012 monthNumber: 2.
	
	self 
		should: [Cashier for: cart from: self defaultCreditCard andTodayIs: pastDate.]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
				self assert: anError messageText = Cashier notValidTodayDateMessage.]
! !

!testRun: #CashierTest #test03cannotUsePastDateForCashier stamp: 'LK 11/6/2023 00:49:04'!
PASSED!

!testRun: #CashierTest #test01cannotMakeCashierWithEmptyCart stamp: 'LK 11/6/2023 00:49:04'!
PASSED!

!testRun: #CashierTest #test02cannotUseExpiredCreditCardForCashier stamp: 'LK 11/6/2023 00:49:04'!
PASSED!

!testRun: #CashierTest #test03cannotUsePastDateForCashier stamp: 'LK 11/6/2023 00:49:04'!
PASSED!

TestCase subclass: #MPTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #MPTest category: 'TusLibros' stamp: 'LK 11/6/2023 00:49:39'!
TestCase subclass: #MPTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

----QUIT----(6 November 2023 00:54:40) CuisUniversity-5981.image priorSource: 12291964!

----STARTUP---- (6 November 2023 14:27:12) as C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\CuisUniversity-5981.image!


!classRenamed: #MPTest as: #MerchantProcessorTest stamp: 'LK 11/6/2023 14:27:28'!
Smalltalk renameClassNamed: #MPTest as: #MerchantProcessorTest!
!MerchantProcessorTest methodsFor: 'nil' stamp: 'LK 11/6/2023 14:27:48'!
test01
! !

!classDefinition: #MerchantProcessor category: 'TusLibros' stamp: 'LK 11/6/2023 14:28:49'!
Object subclass: #MerchantProcessor
	instanceVariableNames: 'stolenCards'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!MerchantProcessorTest class methodsFor: 'nil' stamp: 'LK 11/6/2023 14:28:35'!
test01

	|mp|
	
	mp := MerchantProcessor new.
	
	! !
!MerchantProcessor class methodsFor: 'no messages' stamp: 'LK 11/6/2023 14:29:24'!
for: aCollectionOfStolenCards

	^self new initializeFor: aCollectionOfStolenCards.! !
!MerchantProcessor methodsFor: 'no messages' stamp: 'LK 11/6/2023 14:29:46'!
initializeFor: aCollectionOfStolenCards

	stolenCards := aCollectionOfStolenCards.! !
!MerchantProcessor methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 14:30:03'!
addStolenCard: aCreditCard

	stolenCards add: aCreditCard! !

!classDefinition: #Cashier category: 'TusLibros' stamp: 'LK 11/6/2023 14:53:56'!
Object subclass: #Cashier
	instanceVariableNames: 'cart creditCard todaysDate priceCatalog mp'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!Cashier methodsFor: 'operations' stamp: 'LK 11/6/2023 14:53:53' prior: 50715524!
checkout
	
	|totalAmount|
	
	totalAmount := cart valueOfCart.
	
	mp debit: totalAmount from: creditCard .
	
	^totalAmount.
	
	! !

!methodRemoval: Cashier #debit:from: stamp: 'LK 11/6/2023 14:54:02'!
debit: totalAmount from: aCreditCard 
	!
!MerchantProcessor methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 14:56:06'!
debit: anAmount from: aCreditCard! !
!Cashier methodsFor: 'initialization' stamp: 'LK 11/6/2023 14:56:57'!
initializeFor: aCart from: aCreditCard andTodayIs: aMonthOfYear withMP: aMerchantProcessor 

	cart := aCart.
	creditCard := aCreditCard.
	todaysDate := aMonthOfYear.! !
!Cashier class methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 14:56:57' prior: 50716211!
for: aCart from: aCreditCard andTodayIs: aMonthOfYear

	(aCart isEmpty) ifTrue: [self error: self invalidCartErrorMessage].
	
	(aCreditCard isExpiredAsToday: aMonthOfYear) ifTrue: [self error: self expiredCCErrorMessage].
	
	(aMonthOfYear = GregorianMonthOfYear current) ifFalse: [self error: self notValidTodayDateMessage].

	^self new initializeFor: aCart from: aCreditCard andTodayIs: aMonthOfYear withMP: mp ! !

!methodRemoval: Cashier #initializeFor:from:andTodayIs: stamp: 'LK 11/6/2023 14:56:57'!
initializeFor: aCart from: aCreditCard andTodayIs: aMonthOfYear

	cart := aCart.
	creditCard := aCreditCard.
	todaysDate := aMonthOfYear.!
!Cashier methodsFor: 'initialization' stamp: 'LK 11/6/2023 14:57:09' prior: 50716338!
initializeFor: aCart from: aCreditCard andTodayIs: aMonthOfYear withMP: aMerchantProcessor 

	cart := aCart.
	creditCard := aCreditCard.
	todaysDate := aMonthOfYear.
	mp := aMerchantProcessor.! !

!classDefinition: #CreditCard category: 'TusLibros' stamp: 'LK 11/6/2023 14:58:52'!
Object subclass: #CreditCard
	instanceVariableNames: 'expirationDate cardNumber cardOwner limit'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!CreditCard methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 14:58:50'!
addLimit: aLimitAmount

	limit := aLimitAmount ! !
!MerchantProcessorTest class methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 15:00:42' prior: 50716293!
test01

	|mp stolenCreditCards creditCard|
	
	creditCard := CreditCard new.
	stolenCreditCards := OrderedCollection new.
	stolenCreditCards add: creditCard.
	
	mp := MerchantProcessor for: stolenCreditCards.
	
	! !
!MerchantProcessorTest class methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 15:00:58' prior: 50716393!
test01

	|mp stolenCreditCards creditCard|
	
	creditCard := CreditCard new.
	stolenCreditCards := OrderedCollection new.
	stolenCreditCards add: creditCard.
	
	mp := MerchantProcessor for: stolenCreditCards.
	
	mp debit: 100 from: stolenCreditCards.
	
	
	! !
!MerchantProcessorTest class methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 15:01:25' prior: 50716404!
test01

	|mp stolenCreditCards creditCard|
	
	creditCard := CreditCard new.
	stolenCreditCards := OrderedCollection new.
	stolenCreditCards add: creditCard.
	
	mp := MerchantProcessor for: stolenCreditCards.
	
	mp debit: 100 from: stolenCreditCards.
	
	
	
	! !
!MerchantProcessorTest methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 15:01:34' prior: 50716282!
test01

	|mp stolenCreditCards creditCard|
	
	creditCard := CreditCard new.
	stolenCreditCards := OrderedCollection new.
	stolenCreditCards add: creditCard.
	
	mp := MerchantProcessor for: stolenCreditCards.
	
	mp debit: 100 from: stolenCreditCards.
	
	
	
	! !

!methodRemoval: MerchantProcessorTest class #test01 stamp: 'LK 11/6/2023 15:01:36'!
test01

	|mp stolenCreditCards creditCard|
	
	creditCard := CreditCard new.
	stolenCreditCards := OrderedCollection new.
	stolenCreditCards add: creditCard.
	
	mp := MerchantProcessor for: stolenCreditCards.
	
	mp debit: 100 from: stolenCreditCards.
	
	
	
	!
!MerchantProcessorTest methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 15:03:06' prior: 50716428!
test01

	|mp stolenCreditCards creditCard|
	
	creditCard := CreditCard withNumber: '1234567890123567' fromOwner: 'Pepe' withExpDate: GregorianMonthOfYear current.
	stolenCreditCards := OrderedCollection new.
	stolenCreditCards add: creditCard.
	
	mp := MerchantProcessor for: stolenCreditCards.
	
	
	self
		should: [mp debit: 100 from: stolenCreditCards]
		raise: Error
		withExceptionDo: [:anError | 
				self assert: anError messageText = MerchantProcessor stolenCardErrorDescription]	
	
	
	
	
	! !
!MerchantProcessorTest methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 15:03:26'!
validCreditCard

	^CreditCard withNumber: '1234567890123567' fromOwner: 'Pepe' withExpDate: GregorianMonthOfYear current! !
!MerchantProcessorTest methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 15:03:35' prior: 50716451!
test01

	|mp stolenCreditCards creditCard|
	
	creditCard := self validCreditCard .
	stolenCreditCards := OrderedCollection new.
	stolenCreditCards add: creditCard.
	
	mp := MerchantProcessor for: stolenCreditCards.
	
	
	self
		should: [mp debit: 100 from: stolenCreditCards]
		raise: Error
		withExceptionDo: [:anError | 
				self assert: anError messageText = MerchantProcessor stolenCardErrorDescription]	
	
	
	
	
	! !

!testRun: #MerchantProcessorTest #test01 stamp: 'LK 11/6/2023 15:03:43'!
FAILURE!

!testRun: #MerchantProcessorTest #test01 stamp: 'LK 11/6/2023 15:03:43'!
FAILURE!
!MerchantProcessor methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 15:04:02'!
stolenCardErrorDescription! !
!MerchantProcessor methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 15:04:35' prior: 50716334!
debit: anAmount from: aCreditCard

	(stolenCards includes: aCreditCard) ifTrue: [self error: self stolenCardErrorDescription]! !
!MerchantProcessor methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 15:05:01' prior: 50716499!
stolenCardErrorDescription

	^'This credit card was stolen!!'! !

!testRun: #MerchantProcessorTest #test01 stamp: 'LK 11/6/2023 15:05:03'!
FAILURE!

!testRun: #MerchantProcessorTest #test01 stamp: 'LK 11/6/2023 15:05:04'!
FAILURE!

self validCreditCard!

!testRun: #MerchantProcessorTest #test01 stamp: 'LK 11/6/2023 15:05:17'!
FAILURE!
!MerchantProcessorTest methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 15:05:43' prior: 50716478!
test01

	|mp stolenCreditCards creditCard|
	
	creditCard := self validCreditCard .
	stolenCreditCards := OrderedCollection new.
	stolenCreditCards add: creditCard.
	
	mp := MerchantProcessor for: stolenCreditCards.
	
	
	self
		should: [mp debit: 100 from: stolenCreditCards]
		raise: Error
		withExceptionDo: [:anError | 
				self assert: anError messageText = mp stolenCardErrorDescription]	
	
	
	
	
	! !

!testRun: #MerchantProcessorTest #test01 stamp: 'LK 11/6/2023 15:05:43'!
FAILURE!

!testRun: #MerchantProcessorTest #test01 stamp: 'LK 11/6/2023 15:05:48'!
FAILURE!
!MerchantProcessorTest methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 15:05:54' prior: 50716526!
test01

	|mp stolenCreditCards creditCard|
	
	creditCard := self validCreditCard .
	stolenCreditCards := OrderedCollection new.
	stolenCreditCards add: creditCard.
	
	mp := MerchantProcessor for: stolenCreditCards.
	
	self
		should: [mp debit: 100 from: stolenCreditCards]
		raise: Error
		withExceptionDo: [:anError | 
				self assert: anError messageText = mp stolenCardErrorDescription]	
	
	
	
	
	! !
!MerchantProcessorTest methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 15:06:01' prior: 50716548!
test01

	|mp stolenCreditCards creditCard|
	
	creditCard := self validCreditCard .
	stolenCreditCards := OrderedCollection new.
	stolenCreditCards add: creditCard.
	
	mp := MerchantProcessor for: stolenCreditCards.
	
	self
		should: [mp debit: 100 from: creditCard]
		raise: Error
		withExceptionDo: [:anError | 
				self assert: anError messageText = mp stolenCardErrorDescription]	
	
	
	
	
	! !

!testRun: #MerchantProcessorTest #test01 stamp: 'LK 11/6/2023 15:06:02'!
PASSED!

!testRun: #MerchantProcessorTest #test01 stamp: 'LK 11/6/2023 15:06:02'!
PASSED!
!MerchantProcessorTest methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 15:06:59' prior: 50716564!
test01

	|mp stolenCreditCards creditCard|
	
	creditCard := self validCreditCard.
	creditCard addLimit: 30.
	stolenCreditCards := OrderedCollection new.
	
	mp := MerchantProcessor for: stolenCreditCards.
	
	self
		should: [mp debit: 100 from: creditCard]
		raise: Error
		withExceptionDo: [:anError | 
				self assert: anError messageText = mp declinedCreditCardErrorDescription]	
	
	
	
	
	! !
!MerchantProcessor methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 15:07:21'!
declinedCreditCardErrorDescription

	^'Your card has been declined.'! !
!CreditCard methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 15:07:37'!
limit

	^limit! !
!MerchantProcessor methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 15:08:13' prior: 50716504!
debit: anAmount from: aCreditCard

	(stolenCards includes: aCreditCard) ifTrue: [self error: self stolenCardErrorDescription].
	
	(aCreditCard limit < anAmount) ifTrue: [self error: self declinedCreditCardErrorDescription].! !
!MerchantProcessorTest methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 15:08:29'!
test02

	|mp stolenCreditCards creditCard|
	
	creditCard := self validCreditCard.
	creditCard addLimit: 30.
	stolenCreditCards := OrderedCollection new.
	
	mp := MerchantProcessor for: stolenCreditCards.
	
	self
		should: [mp debit: 100 from: creditCard]
		raise: Error
		withExceptionDo: [:anError | 
				self assert: anError messageText = mp declinedCreditCardErrorDescription]	
	
	
	
	
	! !
!MerchantProcessorTest methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 15:06:01' prior: 50716585!
test01

	|mp stolenCreditCards creditCard|
	
	creditCard := self validCreditCard .
	stolenCreditCards := OrderedCollection new.
	stolenCreditCards add: creditCard.
	
	mp := MerchantProcessor for: stolenCreditCards.
	
	self
		should: [mp debit: 100 from: creditCard]
		raise: Error
		withExceptionDo: [:anError | 
				self assert: anError messageText = mp stolenCardErrorDescription]	
	
	
	
	
	! !

!testRun: #MerchantProcessorTest #test01 stamp: 'LK 11/6/2023 15:08:41'!
PASSED!

!testRun: #MerchantProcessorTest #test01 stamp: 'LK 11/6/2023 15:08:41'!
PASSED!

!testRun: #MerchantProcessorTest #test02 stamp: 'LK 11/6/2023 15:08:41'!
PASSED!
!MerchantProcessorTest methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 15:09:22'!
test03

	|mp stolenCreditCards creditCard|
	
	creditCard := self validCreditCard.
	creditCard addLimit: 150.
	stolenCreditCards := OrderedCollection new.
	
	mp := MerchantProcessor for: stolenCreditCards.
	
	self assert: (mp debit: 100 from: creditCard = '123')
	
	
	
	
	! !
!MerchantProcessor methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 15:09:38' prior: 50716609!
debit: anAmount from: aCreditCard

	(stolenCards includes: aCreditCard) ifTrue: [self error: self stolenCardErrorDescription].
	
	(aCreditCard limit < anAmount) ifTrue: [self error: self declinedCreditCardErrorDescription].
	
	^'123'! !
!MerchantProcessor methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 15:09:54' prior: 50716670!
debit: anAmount from: aCreditCard

	| transactionId |
	(stolenCards includes: aCreditCard) ifTrue: [self error: self stolenCardErrorDescription].
	
	(aCreditCard limit < anAmount) ifTrue: [self error: self declinedCreditCardErrorDescription].
	
	transactionId := '123'.
	
	^transactionId! !
!MerchantProcessor methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 15:09:58' prior: 50716681!
debit: anAmount from: aCreditCard

	| transactionId |
	
	(stolenCards includes: aCreditCard) ifTrue: [self error: self stolenCardErrorDescription].
	
	(aCreditCard limit < anAmount) ifTrue: [self error: self declinedCreditCardErrorDescription].
	
	transactionId := '123'.
	
	^transactionId! !

!testRun: #MerchantProcessorTest #test03 stamp: 'LK 11/6/2023 15:10:03'!
ERROR!
!MerchantProcessorTest methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 15:10:14' prior: 50716658!
test03

	|mp stolenCreditCards creditCard|
	
	creditCard := self validCreditCard.
	creditCard addLimit: 150.
	stolenCreditCards := OrderedCollection new.
	
	mp := MerchantProcessor for: stolenCreditCards.
	
	self assert: (mp debit: 100 from: creditCard) = '123'
	
	
	
	
	! !

!testRun: #MerchantProcessorTest #test03 stamp: 'LK 11/6/2023 15:10:15'!
PASSED!

!testRun: #MerchantProcessorTest #test01 stamp: 'LK 11/6/2023 15:10:15'!
PASSED!

!testRun: #MerchantProcessorTest #test02 stamp: 'LK 11/6/2023 15:10:15'!
PASSED!

!testRun: #MerchantProcessorTest #test03 stamp: 'LK 11/6/2023 15:10:15'!
PASSED!
!MerchantProcessorTest methodsFor: 'testing' stamp: 'LK 11/6/2023 15:11:33'!
test01shouldRaiseStolenCardError

	|mp stolenCreditCards creditCard|
	
	creditCard := self validCreditCard .
	stolenCreditCards := OrderedCollection new.
	stolenCreditCards add: creditCard.
	
	mp := MerchantProcessor for: stolenCreditCards.
	
	self
		should: [mp debit: 100 from: creditCard]
		raise: Error
		withExceptionDo: [:anError | 
				self assert: anError messageText = mp stolenCardErrorDescription]	
	
	
	
	
	! !

!methodRemoval: MerchantProcessorTest #test01 stamp: 'LK 11/6/2023 15:11:33'!
test01

	|mp stolenCreditCards creditCard|
	
	creditCard := self validCreditCard .
	stolenCreditCards := OrderedCollection new.
	stolenCreditCards add: creditCard.
	
	mp := MerchantProcessor for: stolenCreditCards.
	
	self
		should: [mp debit: 100 from: creditCard]
		raise: Error
		withExceptionDo: [:anError | 
				self assert: anError messageText = mp stolenCardErrorDescription]	
	
	
	
	
	!
!MerchantProcessorTest methodsFor: 'testing' stamp: 'LK 11/6/2023 15:11:44'!
test02shouldRaiseInsuficientFundsError

	|mp stolenCreditCards creditCard|
	
	creditCard := self validCreditCard.
	creditCard addLimit: 30.
	stolenCreditCards := OrderedCollection new.
	
	mp := MerchantProcessor for: stolenCreditCards.
	
	self
		should: [mp debit: 100 from: creditCard]
		raise: Error
		withExceptionDo: [:anError | 
				self assert: anError messageText = mp declinedCreditCardErrorDescription]	
	
	
	
	
	! !

!methodRemoval: MerchantProcessorTest #test02 stamp: 'LK 11/6/2023 15:11:44'!
test02

	|mp stolenCreditCards creditCard|
	
	creditCard := self validCreditCard.
	creditCard addLimit: 30.
	stolenCreditCards := OrderedCollection new.
	
	mp := MerchantProcessor for: stolenCreditCards.
	
	self
		should: [mp debit: 100 from: creditCard]
		raise: Error
		withExceptionDo: [:anError | 
				self assert: anError messageText = mp declinedCreditCardErrorDescription]	
	
	
	
	
	!
!MerchantProcessorTest methodsFor: 'testing' stamp: 'LK 11/6/2023 15:12:01'!
test03shouldGiveTransactionID

	|mp stolenCreditCards creditCard|
	
	creditCard := self validCreditCard.
	creditCard addLimit: 150.
	stolenCreditCards := OrderedCollection new.
	
	mp := MerchantProcessor for: stolenCreditCards.
	
	self assert: (mp debit: 100 from: creditCard) = '123'
	
	
	
	
	! !

!methodRemoval: MerchantProcessorTest #test03 stamp: 'LK 11/6/2023 15:12:01'!
test03

	|mp stolenCreditCards creditCard|
	
	creditCard := self validCreditCard.
	creditCard addLimit: 150.
	stolenCreditCards := OrderedCollection new.
	
	mp := MerchantProcessor for: stolenCreditCards.
	
	self assert: (mp debit: 100 from: creditCard) = '123'
	
	
	
	
	!

!testRun: #CreditCardTest #test05shouldBeExpiredIfExpiryDateHasPassed stamp: 'LK 11/6/2023 15:13:15'!
PASSED!

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'LK 11/6/2023 15:13:22'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'LK 11/6/2023 15:13:22'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'LK 11/6/2023 15:13:22'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'LK 11/6/2023 15:13:22'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'LK 11/6/2023 15:13:22'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'LK 11/6/2023 15:13:22'!
PASSED!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'LK 11/6/2023 15:13:22'!
PASSED!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'LK 11/6/2023 15:13:23'!
PASSED!

!testRun: #CartTest #test09CartCalculatesCorrectPricesForOneItem stamp: 'LK 11/6/2023 15:13:23'!
PASSED!

!testRun: #CartTest #test10CartCalculatesCorrectPricesForManyItems stamp: 'LK 11/6/2023 15:13:23'!
PASSED!

!testRun: #CashierTest #test01cannotMakeCashierWithEmptyCart stamp: 'LK 11/6/2023 15:13:23'!
PASSED!

!testRun: #CashierTest #test02cannotUseExpiredCreditCardForCashier stamp: 'LK 11/6/2023 15:13:23'!
PASSED!

!testRun: #CashierTest #test03cannotUsePastDateForCashier stamp: 'LK 11/6/2023 15:13:23'!
PASSED!

!testRun: #CreditCardTest #test01cannotUseEmptyNameForCreditCard stamp: 'LK 11/6/2023 15:13:23'!
PASSED!

!testRun: #CreditCardTest #test02shouldBe16DigitsCreditCardID stamp: 'LK 11/6/2023 15:13:23'!
PASSED!

!testRun: #CreditCardTest #test03shouldUseValidFormatExpiryDate stamp: 'LK 11/6/2023 15:13:23'!
PASSED!

!testRun: #CreditCardTest #test04currentMonthOfYearShouldBeValidDate stamp: 'LK 11/6/2023 15:13:23'!
PASSED!

!testRun: #CreditCardTest #test05shouldBeExpiredIfExpiryDateHasPassed stamp: 'LK 11/6/2023 15:13:23'!
PASSED!

!testRun: #MerchantProcessorTest #test01shouldRaiseStolenCardError stamp: 'LK 11/6/2023 15:13:23'!
PASSED!

!testRun: #MerchantProcessorTest #test02shouldRaiseInsuficientFundsError stamp: 'LK 11/6/2023 15:13:23'!
PASSED!

!testRun: #MerchantProcessorTest #test03shouldGiveTransactionID stamp: 'LK 11/6/2023 15:13:23'!
PASSED!

!testRun: #CashierTest #test01cannotMakeCashierWithEmptyCart stamp: 'LK 11/6/2023 15:13:40'!
PASSED!

!testRun: #CashierTest #test02cannotUseExpiredCreditCardForCashier stamp: 'LK 11/6/2023 15:13:42'!
PASSED!

Object subclass: #Cashier
	instanceVariableNames: 'cart creditCard todaysDate priceCatalog mp transactionId'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #Cashier category: 'TusLibros' stamp: 'LK 11/6/2023 15:15:08'!
Object subclass: #Cashier
	instanceVariableNames: 'cart creditCard todaysDate priceCatalog mp transactionId'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!Cashier methodsFor: 'operations' stamp: 'LK 11/6/2023 15:15:17' prior: 50716323!
checkout
	
	|totalAmount|
	
	totalAmount := cart valueOfCart.
	
	transactionId := mp debit: totalAmount from: creditCard .
	
	^totalAmount.
	
	! !
!Cashier methodsFor: 'operations' stamp: 'LK 11/6/2023 15:15:30'!
getTransactionId

	^transactionId.! !
!CreditCardTest methodsFor: 'testing' stamp: 'LK 11/6/2023 15:17:09'!
test06shouldStoreLimit

	|cardName idCreditCard expiryDate cc|
	
	cardName := 'Carlos'.
	idCreditCard := '1234567890123456'.
	expiryDate := GregorianMonthOfYear yearNumber: 2018 monthNumber: 12.
	cc := CreditCard withNumber: idCreditCard fromOwner: cardName withExpDate: expiryDate.
	
	self assert: ((cc isExpiredAsToday: GregorianMonthOfYear current) = true)

	
	
	
	! !
!CreditCardTest methodsFor: 'testing' stamp: 'LK 11/6/2023 15:17:17' prior: 50716920!
test06shouldStoreLimit

	|cardName idCreditCard expiryDate cc|
	
	cardName := 'Carlos'.
	idCreditCard := '1234567890123456'.
	expiryDate := GregorianMonthOfYear current.
	cc := CreditCard withNumber: idCreditCard fromOwner: cardName withExpDate: expiryDate.
	
	self assert: ((cc isExpiredAsToday: GregorianMonthOfYear current) = true)

	
	
	
	! !
!CreditCardTest methodsFor: 'testing' stamp: 'LK 11/6/2023 15:18:19' prior: 50716935!
test06shouldStoreLimit

	|cardName idCreditCard expiryDate cc|
	
	cardName := 'Carlos'.
	idCreditCard := '1234567890123456'.
	expiryDate := GregorianMonthOfYear current.
	cc := CreditCard withNumber: idCreditCard fromOwner: cardName withExpDate: expiryDate.
	
	cc addLimit: 30.
	
	self assert: (cc limit) = 30

	
	
	
	! !

!testRun: #CreditCardTest #test06shouldStoreLimit stamp: 'LK 11/6/2023 15:18:20'!
PASSED!

!testRun: #CreditCardTest #test01cannotUseEmptyNameForCreditCard stamp: 'LK 11/6/2023 15:18:20'!
PASSED!

!testRun: #CreditCardTest #test02shouldBe16DigitsCreditCardID stamp: 'LK 11/6/2023 15:18:20'!
PASSED!

!testRun: #CreditCardTest #test03shouldUseValidFormatExpiryDate stamp: 'LK 11/6/2023 15:18:20'!
PASSED!

!testRun: #CreditCardTest #test04currentMonthOfYearShouldBeValidDate stamp: 'LK 11/6/2023 15:18:20'!
PASSED!

!testRun: #CreditCardTest #test05shouldBeExpiredIfExpiryDateHasPassed stamp: 'LK 11/6/2023 15:18:20'!
PASSED!

!testRun: #CreditCardTest #test06shouldStoreLimit stamp: 'LK 11/6/2023 15:18:20'!
PASSED!
!CreditCard methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 15:18:43' prior: 50715207!
isExpiredAsToday: aCurrentMonthOfYear

	"se puede mejorar la logica, menor o igual"
	
	((aCurrentMonthOfYear < expirationDate) or: [expirationDate = aCurrentMonthOfYear]) ifFalse: [^true] ifTrue: [^false].! !
!CashierTest methodsFor: 'testing' stamp: 'LK 11/6/2023 15:20:12' prior: 50716232!
test03cannotUsePastDateForCashier

	| cart pastDate|
	
	cart := self createCart.
	cart add: self itemSellByTheStore.
	pastDate := GregorianMonthOfYear current previous: (TimeUnits month with: 1).
	
	self 
		should: [Cashier for: cart from: self defaultCreditCard andTodayIs: pastDate.]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
				self assert: anError messageText = Cashier notValidTodayDateMessage.]
! !

!testRun: #CashierTest #test03cannotUsePastDateForCashier stamp: 'LK 11/6/2023 15:20:13'!
PASSED!

!testRun: #CashierTest #test01cannotMakeCashierWithEmptyCart stamp: 'LK 11/6/2023 15:20:13'!
PASSED!

!testRun: #CashierTest #test02cannotUseExpiredCreditCardForCashier stamp: 'LK 11/6/2023 15:20:13'!
PASSED!

!testRun: #CashierTest #test03cannotUsePastDateForCashier stamp: 'LK 11/6/2023 15:20:13'!
PASSED!
!CreditCardTest methodsFor: 'testing' stamp: 'LK 11/6/2023 15:20:39' prior: 50716067!
test05shouldBeExpiredIfExpiryDateHasPassed

	|cardName idCreditCard expiryDate cc|
	
	cardName := 'Carlos'.
	idCreditCard := '1234567890123456'.
	expiryDate := GregorianMonthOfYear current previous: (TimeUnits month with: 1)..
	cc := CreditCard withNumber: idCreditCard fromOwner: cardName withExpDate: expiryDate.
	
	self assert: ((cc isExpiredAsToday: GregorianMonthOfYear current) = true)

	
	
	
	! !
!CreditCardTest methodsFor: 'testing' stamp: 'LK 11/6/2023 15:20:40' prior: 50717024!
test05shouldBeExpiredIfExpiryDateHasPassed

	|cardName idCreditCard expiryDate cc|
	
	cardName := 'Carlos'.
	idCreditCard := '1234567890123456'.
	expiryDate := GregorianMonthOfYear current previous: (TimeUnits month with: 1).
	cc := CreditCard withNumber: idCreditCard fromOwner: cardName withExpDate: expiryDate.
	
	self assert: ((cc isExpiredAsToday: GregorianMonthOfYear current) = true)

	
	
	
	! !

!testRun: #CreditCardTest #test05shouldBeExpiredIfExpiryDateHasPassed stamp: 'LK 11/6/2023 15:20:41'!
PASSED!

!testRun: #CreditCardTest #test01cannotUseEmptyNameForCreditCard stamp: 'LK 11/6/2023 15:20:41'!
PASSED!

!testRun: #CreditCardTest #test02shouldBe16DigitsCreditCardID stamp: 'LK 11/6/2023 15:20:41'!
PASSED!

!testRun: #CreditCardTest #test03shouldUseValidFormatExpiryDate stamp: 'LK 11/6/2023 15:20:41'!
PASSED!

!testRun: #CreditCardTest #test04currentMonthOfYearShouldBeValidDate stamp: 'LK 11/6/2023 15:20:41'!
PASSED!

!testRun: #CreditCardTest #test05shouldBeExpiredIfExpiryDateHasPassed stamp: 'LK 11/6/2023 15:20:41'!
PASSED!

!testRun: #CreditCardTest #test06shouldStoreLimit stamp: 'LK 11/6/2023 15:20:41'!
PASSED!

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'LK 11/6/2023 15:21:40'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'LK 11/6/2023 15:21:40'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'LK 11/6/2023 15:21:40'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'LK 11/6/2023 15:21:40'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'LK 11/6/2023 15:21:40'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'LK 11/6/2023 15:21:40'!
PASSED!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'LK 11/6/2023 15:21:40'!
PASSED!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'LK 11/6/2023 15:21:40'!
PASSED!

!testRun: #CartTest #test09CartCalculatesCorrectPricesForOneItem stamp: 'LK 11/6/2023 15:21:40'!
PASSED!

!testRun: #CartTest #test10CartCalculatesCorrectPricesForManyItems stamp: 'LK 11/6/2023 15:21:40'!
PASSED!

!testRun: #CashierTest #test01cannotMakeCashierWithEmptyCart stamp: 'LK 11/6/2023 15:21:40'!
PASSED!

!testRun: #CashierTest #test02cannotUseExpiredCreditCardForCashier stamp: 'LK 11/6/2023 15:21:40'!
PASSED!

!testRun: #CashierTest #test03cannotUsePastDateForCashier stamp: 'LK 11/6/2023 15:21:40'!
PASSED!

!testRun: #CreditCardTest #test01cannotUseEmptyNameForCreditCard stamp: 'LK 11/6/2023 15:21:40'!
PASSED!

!testRun: #CreditCardTest #test02shouldBe16DigitsCreditCardID stamp: 'LK 11/6/2023 15:21:40'!
PASSED!

!testRun: #CreditCardTest #test03shouldUseValidFormatExpiryDate stamp: 'LK 11/6/2023 15:21:40'!
PASSED!

!testRun: #CreditCardTest #test04currentMonthOfYearShouldBeValidDate stamp: 'LK 11/6/2023 15:21:40'!
PASSED!

!testRun: #CreditCardTest #test05shouldBeExpiredIfExpiryDateHasPassed stamp: 'LK 11/6/2023 15:21:40'!
PASSED!

!testRun: #CreditCardTest #test06shouldStoreLimit stamp: 'LK 11/6/2023 15:21:40'!
PASSED!

!testRun: #MerchantProcessorTest #test01shouldRaiseStolenCardError stamp: 'LK 11/6/2023 15:21:40'!
PASSED!

!testRun: #MerchantProcessorTest #test02shouldRaiseInsuficientFundsError stamp: 'LK 11/6/2023 15:21:40'!
PASSED!

!testRun: #MerchantProcessorTest #test03shouldGiveTransactionID stamp: 'LK 11/6/2023 15:21:40'!
PASSED!

----QUIT----(6 November 2023 15:22:19) CuisUniversity-5981.image priorSource: 12307847!

----STARTUP---- (6 November 2023 15:28:24) as C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\CuisUniversity-5981.image!

!MerchantProcessorTest methodsFor: 'testing' stamp: 'LK 11/6/2023 15:29:16' prior: 50716762!
test02shouldRaiseInsuficientFundsError

	|mp creditCard|
	
	creditCard := self validCreditCard.
	creditCard addLimit: 30.
	
	mp := MerchantProcessor for: OrderedCollection new.
	
	self
		should: [mp debit: 100 from: creditCard]
		raise: Error
		withExceptionDo: [:anError | 
				self assert: anError messageText = mp declinedCreditCardErrorDescription]	
	
	
	
	
	! !
!MerchantProcessorTest methodsFor: 'testing' stamp: 'LK 11/6/2023 15:29:26' prior: 50716793!
test03shouldGiveTransactionID

	|mp creditCard|
	
	creditCard := self validCreditCard.
	creditCard addLimit: 150.
	
	mp := MerchantProcessor for: OrderedCollection new.
	
	self assert: (mp debit: 100 from: creditCard) = '123'
	
	
	
	
	! !
!CashierTest methodsFor: 'testing' stamp: 'LK 11/6/2023 15:29:58' prior: 50716095!
test01cannotMakeCashierWithEmptyCart

	|cart mp|
	
	cart := self createCart.
	mp := MerchantProcessor for: OrderedCollection new.
	
	self 
		should: [Cashier for: cart from: self defaultCreditCard andTodayIs: self today withMP: mp.]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
				self assert: anError messageText = Cashier invalidCartErrorMessage.]! !
!CashierTest methodsFor: 'testing' stamp: 'LK 11/6/2023 15:30:13' prior: 50716144!
test02cannotUseExpiredCreditCardForCashier

	| cart mp |
	
	cart := self createCart.
	cart add: self itemSellByTheStore.
	mp := MerchantProcessor for: OrderedCollection new.
	self 
		should: [Cashier for: cart from: self expiredCreditCard andTodayIs: self today withMP: mp]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
				self assert: anError messageText = Cashier expiredCCErrorMessage.]
! !
!CashierTest methodsFor: 'testing' stamp: 'LK 11/6/2023 15:30:40' prior: 50716995!
test03cannotUsePastDateForCashier

	| cart pastDate mp|
	
	cart := self createCart.
	cart add: self itemSellByTheStore.
	pastDate := GregorianMonthOfYear current previous: (TimeUnits month with: 1).
	mp := MerchantProcessor for: OrderedCollection new.
	
	self 
		should: [Cashier for: cart from: self defaultCreditCard andTodayIs: pastDate withMP: mp.]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
				self assert: anError messageText = Cashier notValidTodayDateMessage.]
! !
!Cashier class methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 15:30:56'!
for: aCart from: aCreditCard andTodayIs: aMonthOfYear withMP: mp

	(aCart isEmpty) ifTrue: [self error: self invalidCartErrorMessage].
	
	(aCreditCard isExpiredAsToday: aMonthOfYear) ifTrue: [self error: self expiredCCErrorMessage].
	
	(aMonthOfYear = GregorianMonthOfYear current) ifFalse: [self error: self notValidTodayDateMessage].

	^self new initializeFor: aCart from: aCreditCard andTodayIs: aMonthOfYear withMP: mp ! !

!testRun: #CashierTest #test01cannotMakeCashierWithEmptyCart stamp: 'LK 11/6/2023 15:30:57'!
PASSED!

!testRun: #CashierTest #test02cannotUseExpiredCreditCardForCashier stamp: 'LK 11/6/2023 15:30:57'!
PASSED!

!testRun: #CashierTest #test03cannotUsePastDateForCashier stamp: 'LK 11/6/2023 15:30:57'!
PASSED!

!testRun: #CashierTest #test01cannotMakeCashierWithEmptyCart stamp: 'LK 11/6/2023 15:31:00'!
PASSED!

!testRun: #CashierTest #test02cannotUseExpiredCreditCardForCashier stamp: 'LK 11/6/2023 15:31:00'!
PASSED!

!testRun: #CashierTest #test03cannotUsePastDateForCashier stamp: 'LK 11/6/2023 15:31:00'!
PASSED!

!methodRemoval: Cashier class #for:from:andTodayIs: stamp: 'LK 11/6/2023 15:31:07'!
for: aCart from: aCreditCard andTodayIs: aMonthOfYear

	(aCart isEmpty) ifTrue: [self error: self invalidCartErrorMessage].
	
	(aCreditCard isExpiredAsToday: aMonthOfYear) ifTrue: [self error: self expiredCCErrorMessage].
	
	(aMonthOfYear = GregorianMonthOfYear current) ifFalse: [self error: self notValidTodayDateMessage].

	^self new initializeFor: aCart from: aCreditCard andTodayIs: aMonthOfYear withMP: mp !
!Cashier class methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 15:31:18' prior: 50717233!
for: aCart from: aCreditCard andTodayIs: aMonthOfYear withMP: aMerchantProcessor

	(aCart isEmpty) ifTrue: [self error: self invalidCartErrorMessage].
	
	(aCreditCard isExpiredAsToday: aMonthOfYear) ifTrue: [self error: self expiredCCErrorMessage].
	
	(aMonthOfYear = GregorianMonthOfYear current) ifFalse: [self error: self notValidTodayDateMessage].

	^self new initializeFor: aCart from: aCreditCard andTodayIs: aMonthOfYear withMP: aMerchantProcessor ! !

!testRun: #CashierTest #test01cannotMakeCashierWithEmptyCart stamp: 'LK 11/6/2023 15:31:22'!
PASSED!

!testRun: #CashierTest #test02cannotUseExpiredCreditCardForCashier stamp: 'LK 11/6/2023 15:31:22'!
PASSED!

!testRun: #CashierTest #test03cannotUsePastDateForCashier stamp: 'LK 11/6/2023 15:31:22'!
PASSED!

----QUIT----(6 November 2023 15:31:55) CuisUniversity-5981.image priorSource: 12335970!

----STARTUP---- (6 November 2023 19:42:40) as C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\CuisUniversity-5981.image!


----End fileIn of C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\TusLibros.st----!

!classRemoval: #MerchantProcessor stamp: 'LK 11/6/2023 19:44:14'!
Object subclass: #MerchantProcessor
	instanceVariableNames: 'stolenCards'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classRemoval: #CreditCard stamp: 'LK 11/6/2023 19:44:15'!
Object subclass: #CreditCard
	instanceVariableNames: 'expirationDate cardNumber cardOwner limit'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classRemoval: #Cashier stamp: 'LK 11/6/2023 19:44:15'!
Object subclass: #Cashier
	instanceVariableNames: 'cart creditCard todaysDate priceCatalog mp transactionId'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classRemoval: #Cart stamp: 'LK 11/6/2023 19:44:15'!
Object subclass: #Cart
	instanceVariableNames: 'catalog items'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classRemoval: #MerchantProcessorTest stamp: 'LK 11/6/2023 19:44:16'!
TestCase subclass: #MerchantProcessorTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classRemoval: #CreditCardTest stamp: 'LK 11/6/2023 19:44:16'!
TestCase subclass: #CreditCardTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classRemoval: #CashierTest stamp: 'LK 11/6/2023 19:44:16'!
TestCase subclass: #CashierTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classRemoval: #CartTest stamp: 'LK 11/6/2023 19:44:17'!
TestCase subclass: #CartTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

----End fileIn of C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\TusLibros-33.st----!

TestCase subclass: #RestAPITest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #RestAPITest category: 'TusLibros' stamp: 'LK 11/6/2023 19:51:16'!
TestCase subclass: #RestAPITest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!RestAPITest methodsFor: 'no messages' stamp: 'LK 11/6/2023 19:51:22'!
test01! !

!classRenamed: #RestAPITest as: #XXXTest stamp: 'LK 11/6/2023 19:59:44'!
Smalltalk renameClassNamed: #RestAPITest as: #XXXTest!

!classDefinition: #InputInterface category: 'TusLibros' stamp: 'LK 11/6/2023 20:02:19'!
Object subclass: #InputInterface
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!XXXTest methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 20:02:12' prior: 50718679!
test01

	|user interfaceBehavior|
	
	user := InputInterface new.
	
	interfaceBehavior := [:a | self error: InputInterface invalidLoginCredentialsErrorMessage]
	
	self
		should: [user createCart]
		raise: Error 
		withExceptionDo: [:anError |
			self assert messageText = InputInterface invalidLoginCredentialsErrorMessage.]
		
		! !
!XXXTest methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 20:03:44' prior: 50718694!
test01

	|user interfaceBehavior|
	
	user := InputInterface new.
	
	interfaceBehavior := [:a | self error: InputInterface invalidLoginCredentialsErrorMessage].
	
	self
		should: [user createCart]
		raise: Error 
		withExceptionDo: [:anError |
			self assert: anError messageText = InputInterface invalidLoginCredentialsErrorMessage.]
		
		! !
!InputInterface class methodsFor: 'no messages' stamp: 'LK 11/6/2023 20:06:22'!
invalidLoginCredentialsErrorMessage

	^'Your login info is invalid'! !

!classRenamed: #XXXTest as: #InputInterfaceTest stamp: 'LK 11/6/2023 20:06:37'!
Smalltalk renameClassNamed: #XXXTest as: #InputInterfaceTest!
!InputInterfaceTest methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 20:07:44' prior: 50718708!
test01

	|user ab|
	
	user := InputInterface new.
	
	ab := [:a | self error: InputInterface invalidLoginCredentialsErrorMessage].
	
	self
		should: [user createCart]
		raise: Error 
		withExceptionDo: [:anError |
			self assert: anError messageText = InputInterface invalidLoginCredentialsErrorMessage.]
		
		! !

TestCase subclass: #InputInterfaceTest
	instanceVariableNames: 'inputBehavior'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #InputInterfaceTest category: 'TusLibros' stamp: 'LK 11/6/2023 20:07:56'!
TestCase subclass: #InputInterfaceTest
	instanceVariableNames: 'inputBehavior'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!InputInterfaceTest methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 20:08:28' prior: 50718732!
test01

	|inputInterface|
	
	inputInterface := InputInterface new.
	
	inputBehavior := [:a | self error: InputInterface invalidLoginCredentialsErrorMessage].
	
	self
		should: [inputInterface createCart]
		raise: Error 
		withExceptionDo: [:anError |
			self assert: anError messageText = InputInterface invalidLoginCredentialsErrorMessage.]
		
		! !
!InputInterface methodsFor: 'no messages' stamp: 'LK 11/6/2023 20:08:42'!
createCart! !
!InputInterfaceTest methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 20:09:48' prior: 50718758!
test01

	|inputInterface|
	
	inputInterface := InputInterface new.
	
	inputBehavior := [:aUser :aPassword | self error: InputInterface invalidLoginCredentialsErrorMessage].
	
	self
		should: [inputInterface createCart]
		raise: Error 
		withExceptionDo: [:anError |
			self assert: anError messageText = InputInterface invalidLoginCredentialsErrorMessage.]
		
		! !

!classDefinition: #InputInterfaceTest category: 'TusLibros' stamp: 'LK 11/6/2023 20:10:32'!
TestCase subclass: #InputInterfaceTest
	instanceVariableNames: 'inputBehavior testObjectsFactory'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!InputInterfaceTest methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 20:10:27' overrides: 16961394!
setUp

	testObjectsFactory := StoreTestObjectsFactory new.
	inputBehavior := [ :anAmount :aCreditCard | ]! !
!InputInterfaceTest methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 20:11:45'!
inputFrom: aUser and: aPassword 

	^inputBehavior value: aUser value: aPassword ! !
!InputInterfaceTest methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 20:13:49' prior: 50718776!
test01

	|inputInterface|
	
	inputInterface := InputInterface withUser: 'a' withPassword: 'b' through: self.
	
	inputBehavior := [:aUser :aPassword | self error: InputInterface invalidLoginCredentialsErrorMessage].
	
	self
		should: [inputInterface createCart]
		raise: Error 
		withExceptionDo: [:anError |
			self assert: anError messageText = InputInterface invalidLoginCredentialsErrorMessage.]
		
		! !

Object subclass: #InputInterface
	instanceVariableNames: 'user password'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #InputInterface category: 'TusLibros' stamp: 'LK 11/6/2023 20:15:49'!
Object subclass: #InputInterface
	instanceVariableNames: 'user password'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

Object subclass: #InputInterface
	instanceVariableNames: 'user password database'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #InputInterface category: 'TusLibros' stamp: 'LK 11/6/2023 20:16:02'!
Object subclass: #InputInterface
	instanceVariableNames: 'user password database'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!InputInterface class methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 20:17:06'!
withUser: aUser withPassword: aPassword through: aDatabase

	^self new initializeFor: aUser withPassword: aPassword through: aDatabase.! !
!InputInterface methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 20:17:37'!
initializeFor: aUser withPassword: aPassword through: aDatabase

	user := aUser.
	password := aPassword.
	
	database := aDatabase! !
!InputInterface methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 20:17:39' prior: 50718859!
initializeFor: aUser withPassword: aPassword through: aDatabase

	user := aUser.
	password := aPassword.	
	database := aDatabase! !
!InputInterface methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 20:18:26' prior: 50718772!
createCart

	database inputFrom: user and: password! !

!testRun: #InputInterfaceTest #test01 stamp: 'LK 11/6/2023 20:18:33'!
PASSED!
!StoreTestObjectsFactory methodsFor: 'date' stamp: 'LK 11/6/2023 20:18:55'!
validUser

	^'ValidUser'! !
!StoreTestObjectsFactory methodsFor: 'database' stamp: 'LK 11/6/2023 20:19:20'!
validPassword

	^'validPassword'! !
!StoreTestObjectsFactory methodsFor: 'database' stamp: 'LK 11/6/2023 20:19:33'!
invalidPassword

	^'sd'! !
!StoreTestObjectsFactory methodsFor: 'database' stamp: 'LK 11/6/2023 20:19:39'!
invalidUser

	^'sdsd'! !
!InputInterfaceTest methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 20:20:23' prior: 50718812!
test01

	|inputInterface|
	
	inputInterface := InputInterface withUser: testObjectsFactory invalidUser withPassword: testObjectsFactory invalidPassword through: self.
	
	inputBehavior := [:aUser :aPassword | self error: InputInterface invalidLoginCredentialsErrorMessage].
	
	self
		should: [inputInterface createCart]
		raise: Error 
		withExceptionDo: [:anError |
			self assert: anError messageText = InputInterface invalidLoginCredentialsErrorMessage.]
		
		! !

!testRun: #InputInterfaceTest #test01 stamp: 'LK 11/6/2023 20:20:24'!
PASSED!

!testRun: #InputInterfaceTest #test01 stamp: 'LK 11/6/2023 20:20:24'!
PASSED!
!InputInterfaceTest methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 20:22:51'!
test02! !
!InputInterfaceTest methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 20:29:32' prior: 50718898!
test01

	|inputInterface|
	
	inputInterface := InputInterface withUser: testObjectsFactory invalidUser withPassword: testObjectsFactory invalidPassword through: self.
	
	inputBehavior := [:aUser :aPassword | self error: InputInterface invalidLoginCredentialsErrorMessage].
	
	self
		should: [inputInterface createCart]
		raise: Error 
		withExceptionDo: [:anError |
			self assert: anError messageText = InputInterface invalidLoginCredentialsErrorMessage.]
		
		! !

!classDefinition: #InputInterface category: 'TusLibros' stamp: 'LK 11/6/2023 20:31:06'!
Object subclass: #InputInterface
	instanceVariableNames: 'user password authenticator'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!InputInterface methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 20:31:06' prior: 50718875!
createCart

	authenticator inputFrom: user and: password! !
!InputInterface methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 20:31:06' prior: 50718867!
initializeFor: aUser withPassword: aPassword through: aDatabase

	user := aUser.
	password := aPassword.	
	authenticator := aDatabase! !
!InputInterface methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 20:31:15' prior: 50718956!
initializeFor: aUser withPassword: aPassword through: anAuthenticator

	user := aUser.
	password := aPassword.	
	authenticator := anAuthenticator! !
!InputInterfaceTest methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 20:33:37' prior: 50718921!
test02

	|inputInterface|
	
	inputInterface := InputInterface withUser: testObjectsFactory validUser withPassword: testObjectsFactory validPassword through: self.
	
	"inputBehavior := [:aUser :aPassword | self error: InputInterface invalidLoginCredentialsErrorMessage]."
	
	self
		should: [inputInterface createCart]
		raise: Error 
		withExceptionDo: [:anError |
			self assert: anError messageText = InputInterface invalidLoginCredentialsErrorMessage.]
		
		! !
!InputInterfaceTest methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 20:34:56' prior: 50718972!
test02

	|inputInterface cartID|
	
	inputInterface := InputInterface withUser: testObjectsFactory validUser withPassword: testObjectsFactory validPassword through: self.
	
	"inputBehavior := [:aUser :aPassword | self error: InputInterface invalidLoginCredentialsErrorMessage]."
	
	cartID := inputInterface createCart.
	
	self assert: (inputInterface listCartWithID: cartID) = OrderedCollection new.! !
!InputInterfaceTest methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 20:35:17' prior: 50718990!
test02

	|inputInterface cartID|
	
	inputInterface := InputInterface withUser: testObjectsFactory validUser withPassword: testObjectsFactory validPassword through: self.
	
	"inputBehavior := [:aUser :aPassword | self error: InputInterface invalidLoginCredentialsErrorMessage]."
	
	cartID := inputInterface createCart.
	
	self assert: (inputInterface listCartWithID: cartID) = OrderedCollection new.! !
!InputInterface methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 20:35:29'!
listCartWithID: cartID

	^OrderedCollection new.! !
!InputInterface methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 20:35:34' prior: 50718951!
createCart

	authenticator inputFrom: user and: password
	
	^13! !

!testRun: #InputInterfaceTest #test01 stamp: 'LK 11/6/2023 20:35:37'!
FAILURE!

!testRun: #InputInterfaceTest #test02 stamp: 'LK 11/6/2023 20:35:37'!
ERROR!

!testRun: #InputInterfaceTest #test02 stamp: 'LK 11/6/2023 20:35:43'!
ERROR!

!testRun: #InputInterfaceTest #test02 stamp: 'LK 11/6/2023 20:37:40'!
ERROR!
!InputInterface methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 20:37:52' prior: 50719027!
createCart

	authenticator inputFrom: user and: password.
	
	^13! !

!testRun: #InputInterfaceTest #test02 stamp: 'LK 11/6/2023 20:37:55'!
PASSED!
!InputInterface methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 20:49:37'!
createCart: aUser

	authenticator inputFrom: user and: password.
	
	^13! !

!methodRemoval: InputInterface #createCart stamp: 'LK 11/6/2023 20:49:37'!
createCart

	authenticator inputFrom: user and: password.
	
	^13!
!InputInterface methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 20:49:55'!
createCartwithUser: aUser

	authenticator inputFrom: user and: password.
	
	^13! !

!methodRemoval: InputInterface #createCart: stamp: 'LK 11/6/2023 20:49:55'!
createCart: aUser

	authenticator inputFrom: user and: password.
	
	^13!
!InputInterface methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 20:50:17'!
createCartwithUser: aUser usingPassword: aPassword 

	authenticator inputFrom: user and: password.
	
	^13! !

!methodRemoval: InputInterface #createCartwithUser: stamp: 'LK 11/6/2023 20:50:17'!
createCartwithUser: aUser

	authenticator inputFrom: user and: password.
	
	^13!
!InputInterface methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 20:50:33' prior: 50718964!
initializeFor: aUser withPassword: aPassword through: anAuthenticator

	authenticator := anAuthenticator! !

Object subclass: #InputInterface
	instanceVariableNames: 'authenticator'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #InputInterface category: 'TusLibros' stamp: 'LK 11/6/2023 20:50:41'!
Object subclass: #InputInterface
	instanceVariableNames: 'authenticator'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!InputInterface methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 20:50:59' prior: 50719070!
createCartwithUser: aUser usingPassword: aPassword 

	authenticator inputFrom: aUser and: aPassword.
	
	^13! !
!InputInterface class methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 20:51:47'!
with: aDatabase

	^self new initializeFor: aDatabase.! !
!InputInterface methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 20:52:07'!
initializeFor: aDatabase

! !
!InputInterface methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 20:52:25' prior: 50719113!
initializeFor: anAuthenticator

	authenticator := anAuthenticator.

! !

!methodRemoval: InputInterface #initializeFor:withPassword:through: stamp: 'LK 11/6/2023 20:52:27'!
initializeFor: aUser withPassword: aPassword through: anAuthenticator

	authenticator := anAuthenticator!
!InputInterface class methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 20:52:41' prior: 50719108!
with: anAuthenticator

	^self new initializeFor: anAuthenticator.! !

!methodRemoval: InputInterface class #withUser:withPassword:through: stamp: 'LK 11/6/2023 20:52:44'!
withUser: aUser withPassword: aPassword through: aDatabase

	^self new initializeFor: aUser withPassword: aPassword through: aDatabase.!
!InputInterfaceTest methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 20:53:44' prior: 50718925!
test01

	|inputInterface|
	
	inputInterface := InputInterface with: self.
	
	inputBehavior := [:aUser :aPassword | self error: InputInterface invalidLoginCredentialsErrorMessage].
	
	self
		should: [inputInterface createCartwithUser: testObjectsFactory invalidUser usingPassword: testObjectsFactory invalidPassword]
		raise: Error 
		withExceptionDo: [:anError |
			self assert: anError messageText = InputInterface invalidLoginCredentialsErrorMessage.]
		
		! !

!testRun: #InputInterfaceTest #test01 stamp: 'LK 11/6/2023 20:53:45'!
PASSED!

!testRun: #InputInterfaceTest #test01 stamp: 'LK 11/6/2023 20:53:45'!
PASSED!

!testRun: #InputInterfaceTest #test02 stamp: 'LK 11/6/2023 20:53:45'!
ERROR!

!testRun: #InputInterfaceTest #test02 stamp: 'LK 11/6/2023 20:53:45'!
ERROR!
!InputInterfaceTest methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 20:55:04' prior: 50719142!
test01

	|inputInterface|
	
	inputInterface := InputInterface with: self.
	
	inputBehavior := [:aUser :aPassword | self error: InputInterface invalidLoginCredentialsErrorMessage].
	
	self
		should: [inputInterface createCartwithUser: (testObjectsFactory invalidUser) usingPassword: (testObjectsFactory invalidPassword)]
		raise: Error 
		withExceptionDo: [:anError |
			self assert: anError messageText = InputInterface invalidLoginCredentialsErrorMessage.]
		
		! !

!testRun: #InputInterfaceTest #test01 stamp: 'LK 11/6/2023 20:55:05'!
PASSED!

!testRun: #InputInterfaceTest #test01 stamp: 'LK 11/6/2023 20:55:05'!
PASSED!

!testRun: #InputInterfaceTest #test02 stamp: 'LK 11/6/2023 20:55:05'!
ERROR!

!testRun: #InputInterfaceTest #test02 stamp: 'LK 11/6/2023 20:55:05'!
ERROR!
!InputInterfaceTest methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 20:55:40' prior: 50719006!
test02

	|inputInterface cartID|
	
	inputInterface := InputInterface with: self.
	
	"inputBehavior := [:aUser :aPassword | self error: InputInterface invalidLoginCredentialsErrorMessage]."
	
	cartID := inputInterface createCartwithUser: testObjectsFactory validUser usingPassword: testObjectsFactory validPassword.
	
	self assert: (inputInterface listCartWithID: cartID) = OrderedCollection new.! !

!testRun: #InputInterfaceTest #test02 stamp: 'LK 11/6/2023 20:55:40'!
PASSED!

!testRun: #InputInterfaceTest #test01 stamp: 'LK 11/6/2023 20:55:40'!
PASSED!

!testRun: #InputInterfaceTest #test02 stamp: 'LK 11/6/2023 20:55:40'!
PASSED!
!InputInterfaceTest methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 20:55:52' prior: 50719198!
test02

	|inputInterface cartID|
	
	inputInterface := InputInterface with: self.
	
	cartID := inputInterface createCartwithUser: testObjectsFactory validUser usingPassword: testObjectsFactory validPassword.
	
	self assert: (inputInterface listCartWithID: cartID) = OrderedCollection new.! !
!InputInterface methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 20:57:09'!
addToCart: aCartId amount: aBookQuantity of: bookISBN

! !
!InputInterface methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 20:58:17' prior: 50719234!
addToCart: aCartId amount: aBookQuantity of: bookISBN




! !
!InputInterfaceTest methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 20:59:51' prior: 50719222!
test02

	|inputInterface cartID|
	
	inputInterface := InputInterface with: self.
	
	cartID := inputInterface createCartwithUser: testObjectsFactory validUser usingPassword: testObjectsFactory validPassword.
	
	self shouldnt: [inputInterface listCartWithID: cartID] 
	raise: Error! !

!testRun: #InputInterfaceTest #test02 stamp: 'LK 11/6/2023 20:59:52'!
PASSED!

!testRun: #InputInterfaceTest #test01 stamp: 'LK 11/6/2023 20:59:52'!
PASSED!

!testRun: #InputInterfaceTest #test02 stamp: 'LK 11/6/2023 20:59:52'!
PASSED!
!InputInterfaceTest methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 21:03:20'!
test03

	|inputInterface cartID|
	
	inputInterface := InputInterface with: self.
	
	cartID := inputInterface createCartwithUser: testObjectsFactory validUser usingPassword: testObjectsFactory validPassword.
	
	inputInterface addToCart:  cartID amount: 1 of: 23424.
	
	! !
!InputInterfaceTest methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 21:04:50' prior: 50719264!
test03

	|inputInterface cartID|
	
	inputInterface := InputInterface with: self.
	
	cartID := inputInterface createCartwithUser: testObjectsFactory validUser usingPassword: testObjectsFactory validPassword.
	
	inputInterface addToCart:  cartID amount: 1 of: 23424.
	
	self assert: (inputInterface listCartWithID: cartID) = (OrderedCollection with: 23424)! !

----QUIT----(6 November 2023 21:11:02) CuisUniversity-5981.image priorSource: 12341151!

----STARTUP---- (6 November 2023 21:36:12) as C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\CuisUniversity-5981.image!


Object subclass: #InputInterface
	instanceVariableNames: 'authenticator cartsOfUsers'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #InputInterface category: 'TusLibros' stamp: 'LK 11/6/2023 21:37:22'!
Object subclass: #InputInterface
	instanceVariableNames: 'authenticator cartsOfUsers'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!InputInterfaceTest methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 21:43:20' prior: 50719170!
test01

	|inputInterface|
	
	inputInterface := InputInterface with: self.
	
	inputBehavior := [:aUser :aPassword | self error: InputInterface invalidLoginCredentialsErrorMessage].
	
	self
		should: [inputInterface createCartwithUser: testObjectsFactory invalidUser usingPassword: testObjectsFactory invalidPassword]
		raise: Error 
		withExceptionDo: [:anError |
			self assert: anError messageText = InputInterface invalidLoginCredentialsErrorMessage.]
		
		! !
!InputInterfaceTest methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 21:43:24' prior: 50719310!
test01

	|inputInterface|
	
	inputInterface := InputInterface with: self.
	
	inputBehavior := [:aUser :aPassword | self error: InputInterface invalidLoginCredentialsErrorMessage].
	
	self
		should: [inputInterface createCartwithUser: testObjectsFactory validUser usingPassword: testObjectsFactory invalidPassword]
		raise: Error 
		withExceptionDo: [:anError |
			self assert: anError messageText = InputInterface invalidLoginCredentialsErrorMessage.]
		
		! !
!InputInterfaceTest methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 21:43:28'!
test01b

	|inputInterface|
	
	inputInterface := InputInterface with: self.
	
	inputBehavior := [:aUser :aPassword | self error: InputInterface invalidLoginCredentialsErrorMessage].
	
	self
		should: [inputInterface createCartwithUser: testObjectsFactory validUser usingPassword: testObjectsFactory invalidPassword]
		raise: Error 
		withExceptionDo: [:anError |
			self assert: anError messageText = InputInterface invalidLoginCredentialsErrorMessage.]
		
		! !

!methodRemoval: InputInterfaceTest #test01b stamp: 'LK 11/6/2023 21:43:51'!
test01b

	|inputInterface|
	
	inputInterface := InputInterface with: self.
	
	inputBehavior := [:aUser :aPassword | self error: InputInterface invalidLoginCredentialsErrorMessage].
	
	self
		should: [inputInterface createCartwithUser: testObjectsFactory validUser usingPassword: testObjectsFactory invalidPassword]
		raise: Error 
		withExceptionDo: [:anError |
			self assert: anError messageText = InputInterface invalidLoginCredentialsErrorMessage.]
		
		!
!InputInterfaceTest methodsFor: 'as yet unclassified' stamp: 'LK 11/6/2023 21:43:58' prior: 50719328!
test01

	|inputInterface|
	
	inputInterface := InputInterface with: self.
	
	inputBehavior := [:aUser :aPassword | self error: InputInterface invalidLoginCredentialsErrorMessage].
	
	self
		should: [inputInterface createCartwithUser: testObjectsFactory invalidUser usingPassword: testObjectsFactory invalidPassword]
		raise: Error 
		withExceptionDo: [:anError |
			self assert: anError messageText = InputInterface invalidLoginCredentialsErrorMessage.]
		
		! !

----QUIT----(6 November 2023 21:53:29) CuisUniversity-5981.image priorSource: 12404453!

----STARTUP---- (9 November 2023 12:31:42) as C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\CuisUniversity-5981.image!

!InputInterfaceTest methodsFor: 'as yet unclassified' stamp: 'LK 11/9/2023 13:24:22'!
test01cannotCreateCardWithInvalidCredentials

	|inputInterface|
	
	inputInterface := InputInterface with: self.
	
	inputBehavior := [:aUser :aPassword | self error: InputInterface invalidLoginCredentialsErrorMessage].
	
	self
		should: [inputInterface createCartwithUser: testObjectsFactory invalidUser usingPassword: testObjectsFactory invalidPassword]
		raise: Error 
		withExceptionDo: [:anError |
			self assert: anError messageText = InputInterface invalidLoginCredentialsErrorMessage.]
		
		! !

!methodRemoval: InputInterfaceTest #test01 stamp: 'LK 11/9/2023 13:24:22'!
test01

	|inputInterface|
	
	inputInterface := InputInterface with: self.
	
	inputBehavior := [:aUser :aPassword | self error: InputInterface invalidLoginCredentialsErrorMessage].
	
	self
		should: [inputInterface createCartwithUser: testObjectsFactory invalidUser usingPassword: testObjectsFactory invalidPassword]
		raise: Error 
		withExceptionDo: [:anError |
			self assert: anError messageText = InputInterface invalidLoginCredentialsErrorMessage.]
		
		!
!InputInterfaceTest methodsFor: 'as yet unclassified' stamp: 'LK 11/9/2023 13:24:41'!
test02canCreateCartForValidUser

	|inputInterface cartID|
	
	inputInterface := InputInterface with: self.
	
	cartID := inputInterface createCartwithUser: testObjectsFactory validUser usingPassword: testObjectsFactory validPassword.
	
	self shouldnt: [inputInterface listCartWithID: cartID] 
	raise: Error! !

!methodRemoval: InputInterfaceTest #test02 stamp: 'LK 11/9/2023 13:24:41'!
test02

	|inputInterface cartID|
	
	inputInterface := InputInterface with: self.
	
	cartID := inputInterface createCartwithUser: testObjectsFactory validUser usingPassword: testObjectsFactory validPassword.
	
	self shouldnt: [inputInterface listCartWithID: cartID] 
	raise: Error!
!InputInterface methodsFor: 'as yet unclassified' stamp: 'LK 11/9/2023 13:25:14' prior: 50719117!
initializeFor: anAuthenticator

	authenticator := anAuthenticator.
	
	cartsOfUsers := Dictionary new.

! !
!InputInterface methodsFor: 'as yet unclassified' stamp: 'LK 11/9/2023 13:26:04' prior: 50719022!
listCartWithID: cartID

	|list|
	list := ''.
	^list.! !
!InputInterfaceTest methodsFor: 'as yet unclassified' stamp: 'LK 11/9/2023 13:28:24' prior: 50719276!
test03

	|inputInterface cartID|
	
	inputInterface := InputInterface with: self.
	
	inputInterface addToCart:  testObjectsFactory invalidCartID amount: 1 of: 23424.
	
	self assert: (inputInterface listCartWithID: cartID) = (OrderedCollection with: 23424)! !
!InputInterfaceTest methodsFor: 'as yet unclassified' stamp: 'LK 11/9/2023 13:30:17' prior: 50719478!
test03

	|inputInterface |
	
	inputInterface := InputInterface with: self.
	
	self should: [inputInterface addToCart:  testObjectsFactory invalidCartID amount: 1 of: 23424.]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText = inputInterface AddItemToInvalidCartIDErrorDescription].
	! !
!InputInterfaceTest methodsFor: 'as yet unclassified' stamp: 'LK 11/9/2023 13:30:21' prior: 50719490!
test03

	|inputInterface|
	
	inputInterface := InputInterface with: self.
	
	self should: [inputInterface addToCart:  testObjectsFactory invalidCartID amount: 1 of: 23424.]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText = inputInterface AddItemToInvalidCartIDErrorDescription].
	! !
!InputInterface methodsFor: 'as yet unclassified' stamp: 'LK 11/9/2023 13:31:12'!
addToCart: aCartId withAmount: aBookQuantity of: bookISBN




! !
!InputInterfaceTest methodsFor: 'as yet unclassified' stamp: 'LK 11/9/2023 13:31:12' prior: 50719504!
test03

	|inputInterface|
	
	inputInterface := InputInterface with: self.
	
	self should: [inputInterface addToCart:  testObjectsFactory invalidCartID withAmount: 1 of: 23424.]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText = inputInterface AddItemToInvalidCartIDErrorDescription].
	! !

!methodRemoval: InputInterface #addToCart:amount:of: stamp: 'LK 11/9/2023 13:31:12'!
addToCart: aCartId amount: aBookQuantity of: bookISBN




!
!StoreTestObjectsFactory methodsFor: 'database' stamp: 'LK 11/9/2023 13:31:33'!
invalidCartID

	^'nononononono'! !
!InputInterfaceTest methodsFor: 'as yet unclassified' stamp: 'LK 11/9/2023 13:32:14'!
test03cannotAddValidItemWithInvalidCartID

	|inputInterface|
	
	inputInterface := InputInterface with: self.
	
	self should: [inputInterface addToCart:  testObjectsFactory invalidCartID withAmount: 1 of: 23424.]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText = inputInterface AddItemToInvalidCartIDErrorDescription].
	! !

!methodRemoval: InputInterfaceTest #test03 stamp: 'LK 11/9/2023 13:32:14'!
test03

	|inputInterface|
	
	inputInterface := InputInterface with: self.
	
	self should: [inputInterface addToCart:  testObjectsFactory invalidCartID withAmount: 1 of: 23424.]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText = inputInterface AddItemToInvalidCartIDErrorDescription].
	!
!InputInterfaceTest methodsFor: 'as yet unclassified' stamp: 'LK 11/9/2023 13:40:55' prior: 50719545!
test03cannotAddValidItemWithInvalidCartID

	|inputInterface|
	
	inputInterface := InputInterface with: self.
	
	self should: [inputInterface addToCart:  testObjectsFactory invalidCartID withAmount: 1 of: 23424.]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText = InputInterface InvalidCartIDErrorDescription].
	! !
!InputInterface class methodsFor: 'as yet unclassified' stamp: 'LK 11/9/2023 13:41:03'!
InvalidCartIDErrorDescription! !
!InputInterface class methodsFor: 'as yet unclassified' stamp: 'LK 11/9/2023 13:41:14' prior: 50718722!
invalidLoginCredentialsErrorMessage

	^'Your login credentials are invalid'! !
!InputInterface class methodsFor: 'as yet unclassified' stamp: 'LK 11/9/2023 13:41:34' prior: 50719586!
InvalidCartIDErrorDescription

	^'The Cart ID given is invalid'! !

!testRun: #InputInterfaceTest #test03cannotAddValidItemWithInvalidCartID stamp: 'LK 11/9/2023 13:41:40'!
FAILURE!
!InputInterface methodsFor: 'as yet unclassified' stamp: 'LK 11/9/2023 13:42:24' prior: 50719517!
addToCart: aCartId withAmount: aBookQuantity of: bookISBN

	(self validateCartID: aCartId)




! !
!InputInterface methodsFor: 'as yet unclassified' stamp: 'LK 11/9/2023 13:44:24'!
validateCardID: aCartId

	((cartsOfUsers keys) includes: aCartId) ifFalse: [self error: InputInterface ]! !
!InputInterface methodsFor: 'as yet unclassified' stamp: 'LK 11/9/2023 13:44:40' prior: 50719612!
validateCardID: aCartId

	((cartsOfUsers keys) includes: aCartId) ifFalse: [self error: InputInterface InvalidCartIDErrorDescription].! !

!testRun: #InputInterfaceTest #test03cannotAddValidItemWithInvalidCartID stamp: 'LK 11/9/2023 13:44:49'!
FAILURE!
!InputInterface methodsFor: 'as yet unclassified' stamp: 'LK 11/9/2023 13:45:15' prior: 50719606!
addToCart: aCartId withAmount: aBookQuantity of: bookISBN

	(self validateCardID: aCartId)




! !

!testRun: #InputInterfaceTest #test03cannotAddValidItemWithInvalidCartID stamp: 'LK 11/9/2023 13:45:17'!
PASSED!

!classDefinition: #InputInterface category: 'TusLibros' stamp: 'LK 11/9/2023 13:47:24'!
Object subclass: #InputInterface
	instanceVariableNames: 'authenticator cartsOfUsers catalog'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!InputInterface methodsFor: 'as yet unclassified' stamp: 'LK 11/9/2023 13:47:20' prior: 50719101!
createCartwithUser: aUser usingPassword: aPassword 
	
	|cartID| 
	authenticator inputFrom: aUser and: aPassword.
	
	cartID := self generateNewCartID.
	cartsOfUsers at: cartID put: (Cart acceptingItemsOf: catalog)
	
	^13! !
!InputInterface methodsFor: 'as yet unclassified' stamp: 'LK 11/9/2023 13:47:37' prior: 50719648!
createCartwithUser: aUser usingPassword: aPassword 
	
	|cartID| 
	authenticator inputFrom: aUser and: aPassword.
	
	cartID := self generateNewCartID.
	cartsOfUsers at: cartID put: (Cart acceptingItemsOf: catalog)
	
	^cartID! !
!InputInterface methodsFor: 'as yet unclassified' stamp: 'LK 11/9/2023 13:48:48'!
generateNewCartID

	^ (100000 atRandom)! !

!testRun: #InputInterfaceTest #test03cannotAddValidItemWithInvalidCartID stamp: 'LK 11/9/2023 13:49:06'!
PASSED!

!testRun: #InputInterfaceTest #test01cannotCreateCardWithInvalidCredentials stamp: 'LK 11/9/2023 13:49:06'!
PASSED!

!testRun: #InputInterfaceTest #test02canCreateCartForValidUser stamp: 'LK 11/9/2023 13:49:06'!
ERROR!

!testRun: #InputInterfaceTest #test03cannotAddValidItemWithInvalidCartID stamp: 'LK 11/9/2023 13:49:06'!
PASSED!

!testRun: #InputInterfaceTest #test02canCreateCartForValidUser stamp: 'LK 11/9/2023 13:49:06'!
ERROR!

!testRun: #InputInterfaceTest #test03cannotAddValidItemWithInvalidCartID stamp: 'LK 11/9/2023 13:49:14'!
PASSED!

!testRun: #InputInterfaceTest #test02canCreateCartForValidUser stamp: 'LK 11/9/2023 13:49:15'!
ERROR!

!testRun: #InputInterfaceTest #test02canCreateCartForValidUser stamp: 'LK 11/9/2023 13:49:15'!
ERROR!

!testRun: #InputInterfaceTest #test01cannotCreateCardWithInvalidCredentials stamp: 'LK 11/9/2023 13:49:32'!
PASSED!
!InputInterfaceTest methodsFor: 'as yet unclassified' stamp: 'LK 11/9/2023 13:49:54' prior: 50719442!
test02canCreateCartForValidUser

	|inputInterface cartID|
	
	inputInterface := InputInterface with: self.
	
	cartID := inputInterface createCartwithUser: testObjectsFactory validUser usingPassword: testObjectsFactory validPassword.
	
	self shouldnt: [inputInterface listCartWithID: cartID] 
		raise: Error! !

!testRun: #InputInterfaceTest #test02canCreateCartForValidUser stamp: 'LK 11/9/2023 13:49:59'!
ERROR!
!InputInterface methodsFor: 'as yet unclassified' stamp: 'LK 11/9/2023 13:50:18' prior: 50719659!
createCartwithUser: aUser usingPassword: aPassword 
	
	|cartID| 
	authenticator inputFrom: aUser and: aPassword.
	
	cartID := self generateNewCartID.
	cartsOfUsers at: cartID put: (Cart acceptingItemsOf: catalog).
	
	^cartID! !

!testRun: #InputInterfaceTest #test01cannotCreateCardWithInvalidCredentials stamp: 'LK 11/9/2023 13:50:21'!
PASSED!

!testRun: #InputInterfaceTest #test02canCreateCartForValidUser stamp: 'LK 11/9/2023 13:50:21'!
PASSED!

!testRun: #InputInterfaceTest #test03cannotAddValidItemWithInvalidCartID stamp: 'LK 11/9/2023 13:50:21'!
PASSED!
!InputInterfaceTest methodsFor: 'testing' stamp: 'LK 11/9/2023 13:51:14'!
test04canAddValidItemWithValidCartID! !
!InputInterfaceTest methodsFor: 'testing' stamp: 'LK 11/9/2023 13:51:34' prior: 50719741!
test04canAddValidItemWithValidCartID

	|inputInterface cartID|
	
	inputInterface := InputInterface with: self.
	
	cartID := inputInterface createCartwithUser: testObjectsFactory validUser usingPassword: testObjectsFactory validPassword.! !
!InputInterfaceTest methodsFor: 'testing' stamp: 'LK 11/9/2023 13:52:12' prior: 50719746!
test04canAddValidItemWithValidCartID

	|inputInterface cartID|
	
	inputInterface := InputInterface with: self.
	
	cartID := inputInterface createCartwithUser: testObjectsFactory validUser usingPassword: testObjectsFactory validPassword.
	
	inputInterface addToCart:  testObjectsFactory invalidCartID withAmount: 1 of: testObjectsFactory itemSellByTheStore.! !
!InputInterfaceTest methodsFor: 'testing' stamp: 'LK 11/9/2023 13:52:21' prior: 50719757!
test04canAddValidItemWithValidCartID

	|inputInterface cartID|
	
	inputInterface := InputInterface with: self.
	
	cartID := inputInterface createCartwithUser: testObjectsFactory validUser usingPassword: testObjectsFactory validPassword.
	
	inputInterface addToCart:  cartID withAmount: 1 of: testObjectsFactory itemSellByTheStore.! !
!InputInterfaceTest methodsFor: 'testing' stamp: 'LK 11/9/2023 13:52:55' prior: 50719772!
test04canAddValidItemWithValidCartID

	|inputInterface cartID|
	
	inputInterface := InputInterface with: self.
	
	cartID := inputInterface createCartwithUser: testObjectsFactory validUser usingPassword: testObjectsFactory validPassword.
	
	inputInterface addToCart:  cartID withAmount: 1 of: testObjectsFactory itemSellByTheStore.
	
	self assert: ' ISBN: validBook | Quantity: 3 |' equals: (inputInterface listCart: cartID)! !
!InputInterfaceTest methodsFor: 'testing' stamp: 'LK 11/9/2023 13:53:06' prior: 50719786!
test04canAddValidItemWithValidCartID

	|inputInterface cartID|
	
	inputInterface := InputInterface with: self.
	
	cartID := inputInterface createCartwithUser: testObjectsFactory validUser usingPassword: testObjectsFactory validPassword.
	
	inputInterface addToCart:  cartID withAmount: 1 of: testObjectsFactory itemSellByTheStore.
	
	self assert: ' ISBN: validBook | Quantity: 3 |' equals: (inputInterface listCartWithID: cartID)! !
!InputInterface methodsFor: 'as yet unclassified' stamp: 'LK 11/9/2023 13:57:37' prior: 50719466!
initializeFor: anAuthenticator

	authenticator := anAuthenticator.
	
	cartsOfUsers := Dictionary new.
	
	catalog := 1.
! !
!InputInterface methodsFor: 'as yet unclassified' stamp: 'LK 11/9/2023 13:58:43' prior: 50719820!
initializeFor: anAuthenticator

	authenticator := anAuthenticator.
	
	cartsOfUsers := Dictionary new.
	
	catalog := Dictionary new
		at: 'validBook' put: 10;
		yourself.
! !
!InputInterfaceTest methodsFor: 'testing' stamp: 'LK 11/9/2023 13:59:54' prior: 50719803!
test04canAddValidItemWithValidCartID

	|inputInterface cartID|
	
	inputInterface := InputInterface with: self.
	
	cartID := inputInterface createCartwithUser: testObjectsFactory validUser usingPassword: testObjectsFactory validPassword.
	
	inputInterface addToCart:  cartID withAmount: 10 of: testObjectsFactory itemSellByTheStore.
	
	self assert: '| ISBN: validBook | Quantity: 10 |' equals: (inputInterface listCartWithID: cartID)! !

!testRun: #InputInterfaceTest #test04canAddValidItemWithValidCartID stamp: 'LK 11/9/2023 13:59:56'!
FAILURE!
!InputInterfaceTest methodsFor: 'testing' stamp: 'LK 11/9/2023 14:00:05' prior: 50719836!
test04canAddValidItemWithValidCartID

	|inputInterface cartID|
	
	inputInterface := InputInterface with: self.
	
	cartID := inputInterface createCartwithUser: testObjectsFactory validUser usingPassword: testObjectsFactory validPassword.
	
	inputInterface addToCart:  cartID withAmount: 10 of: testObjectsFactory itemSellByTheStore.
	
	self assert: '| ISBN: validBook | Quantity: 10 |' = (inputInterface listCartWithID: cartID)! !

!testRun: #InputInterfaceTest #test04canAddValidItemWithValidCartID stamp: 'LK 11/9/2023 14:00:06'!
FAILURE!
!InputInterface methodsFor: 'as yet unclassified' stamp: 'LK 11/9/2023 14:02:22' prior: 50719473!
listCartWithID: cartID

	|list|
	list := '|'.
	^list.! !
!InputInterface methodsFor: 'as yet unclassified' stamp: 'LK 11/9/2023 14:05:43' prior: 50719876!
listCartWithID: cartID

	|list|
	list := '|'.
	
	cartsOfUsers keysAndValuesDo: [:aKey :aValue | 
			list := list, ' ISBN: ', aKey, ' | Quantity: ', aValue asString, ' |']. 
	^list.
	! !

!testRun: #InputInterfaceTest #test04canAddValidItemWithValidCartID stamp: 'LK 11/9/2023 14:05:45'!
ERROR!

!testRun: #InputInterfaceTest #test04canAddValidItemWithValidCartID stamp: 'LK 11/9/2023 14:05:45'!
ERROR!
!InputInterface methodsFor: 'as yet unclassified' stamp: 'LK 11/9/2023 14:06:01' prior: 50719881!
listCartWithID: cartID

	|list|
	list := '|'.
	
	cartsOfUsers keysAndValuesDo: [:aKey :aValue | 
			list := list, ' ISBN: ', aKey, ' | Quantity: ', (aValue asString) , ' |']. 
	^list.
	! !

!testRun: #InputInterfaceTest #test04canAddValidItemWithValidCartID stamp: 'LK 11/9/2023 14:06:04'!
ERROR!

!testRun: #InputInterfaceTest #test04canAddValidItemWithValidCartID stamp: 'LK 11/9/2023 14:06:04'!
ERROR!
!InputInterface methodsFor: 'as yet unclassified' stamp: 'LK 11/9/2023 14:06:33' prior: 50719897!
listCartWithID: cartID

	|list|
	list := '|'.
	
	cartsOfUsers keysAndValuesDo: [:aKey :aValue | 
			list := list, ' ISBN: ', (aKey asString), ' | Quantity: ', (aValue asString) , ' |']. 
	^list.
	! !

!testRun: #InputInterfaceTest #test04canAddValidItemWithValidCartID stamp: 'LK 11/9/2023 14:06:35'!
FAILURE!

!testRun: #InputInterfaceTest #test04canAddValidItemWithValidCartID stamp: 'LK 11/9/2023 14:06:35'!
FAILURE!
!InputInterfaceTest methodsFor: 'testing' stamp: 'LK 11/9/2023 14:06:42' prior: 50719856!
test04canAddValidItemWithValidCartID

	|inputInterface cartID|
	
	inputInterface := InputInterface with: self.
	
	cartID := inputInterface createCartwithUser: testObjectsFactory validUser usingPassword: testObjectsFactory validPassword.
	
	inputInterface addToCart:  cartID withAmount: 10 of: testObjectsFactory itemSellByTheStore.
	
	self assert: '| ISBN: validBook | Quantity: 10 |' equals: (inputInterface listCartWithID: cartID)! !

!testRun: #InputInterfaceTest #test04canAddValidItemWithValidCartID stamp: 'LK 11/9/2023 14:06:43'!
FAILURE!

!testRun: #InputInterfaceTest #test04canAddValidItemWithValidCartID stamp: 'LK 11/9/2023 14:06:43'!
FAILURE!
!InputInterface methodsFor: 'as yet unclassified' stamp: 'LK 11/9/2023 14:09:10' prior: 50719630!
addToCart: aCartId withAmount: aBookQuantity of: bookISBN

	(self validateCardID: aCartId).
	
	(cartsOfUsers at: aCartId).




! !
!InputInterface methodsFor: 'as yet unclassified' stamp: 'LK 11/9/2023 14:09:41' prior: 50719953!
addToCart: aCartId withAmount: aBookQuantity of: bookISBN

	(self validateCardID: aCartId).
	
	(cartsOfUsers at: aCartId) add: aBookQuantity of: bookISBN.
! !

!testRun: #InputInterfaceTest #test04canAddValidItemWithValidCartID stamp: 'LK 11/9/2023 14:09:43'!
FAILURE!

!testRun: #InputInterfaceTest #test04canAddValidItemWithValidCartID stamp: 'LK 11/9/2023 14:09:43'!
FAILURE!
!InputInterface methodsFor: 'as yet unclassified' stamp: 'LK 11/9/2023 14:13:06' prior: 50719913!
listCartWithID: cartID

	|list cart|
	list := '|'.
	
	cart := cartsOfUsers at: cartID.
	
	
	^list.
	! !
!InputInterface methodsFor: 'as yet unclassified' stamp: 'LK 11/9/2023 14:16:30' prior: 50719976!
listCartWithID: cartID

	|list cart|
	list := '|'.
	
	cart := cartsOfUsers at: cartID.
	
	(catalog keys) do: [:aBook | (cart occurrencesOf: aBook > 0) ifTrue:[
				list := list, ' ISBN: ', aBook, ' | Quantity: ', (cart occurrencesOf: aBook) asString]
		]	
	^list.
	! !
!InputInterfaceTest methodsFor: 'testing' stamp: 'LK 11/9/2023 14:16:59' prior: 50719929!
test04canAddValidItemWithValidCartID

	|inputInterface cartID|
	
	inputInterface := InputInterface with: self.
	
	cartID := inputInterface createCartwithUser: testObjectsFactory validUser usingPassword: testObjectsFactory validPassword.
	
	inputInterface addToCart:  cartID withAmount: 10 of: testObjectsFactory itemSellByTheStore.
	
	self assert: '| ISBN: validBook | Quantity: 10 |' equals: (inputInterface listCartWithID: cartID)! !
!InputInterface methodsFor: 'as yet unclassified' stamp: 'LK 11/9/2023 14:17:10' prior: 50719983!
listCartWithID: cartID

	|list cart|
	list := '|'.
	
	cart := cartsOfUsers at: cartID.
	
	(catalog keys) do: [:aBook | (cart occurrencesOf: aBook > 0) ifTrue:[
				list := list, '| ISBN: ', aBook, ' | Quantity: ', (cart occurrencesOf: aBook) asString]
		]	
	^list.
	! !
!InputInterface methodsFor: 'as yet unclassified' stamp: 'LK 11/9/2023 14:17:21' prior: 50720012!
listCartWithID: cartID

	|list cart|
	list := '|'.
	
	cart := cartsOfUsers at: cartID.
	
	(catalog keys) do: [:aBook | (cart occurrencesOf: aBook > 0) ifTrue:[
				list := list, '| ISBN: ', aBook, ' | Quantity: ', (cart occurrencesOf: aBook) asString, ' |']
		]	
	^list.
	! !

!testRun: #InputInterfaceTest #test04canAddValidItemWithValidCartID stamp: 'LK 11/9/2023 14:17:23'!
ERROR!

!testRun: #InputInterfaceTest #test04canAddValidItemWithValidCartID stamp: 'LK 11/9/2023 14:17:23'!
ERROR!
!InputInterface methodsFor: 'as yet unclassified' stamp: 'LK 11/9/2023 14:17:37' prior: 50720024!
listCartWithID: cartID

	|list cart|
	list := '|'.
	
	cart := cartsOfUsers at: cartID.
	
	(catalog keys) do: [:aBook | (cart occurrencesOf: aBook > 0) ifTrue:[
				list := list, '| ISBN: ', aBook, ' | Quantity: ', (cart occurrencesOf: aBook) asString, ' |']
		].
	^list.
	! !

!testRun: #InputInterfaceTest #test04canAddValidItemWithValidCartID stamp: 'LK 11/9/2023 14:17:38'!
ERROR!

!testRun: #InputInterfaceTest #test04canAddValidItemWithValidCartID stamp: 'LK 11/9/2023 14:17:38'!
ERROR!
!InputInterface methodsFor: 'as yet unclassified' stamp: 'LK 11/9/2023 14:18:13' prior: 50720043!
listCartWithID: cartID

	|list cart|
	list := '|'.
	
	cart := cartsOfUsers at: cartID.
	
	(catalog keys) do: [:aBook | ((cart occurrencesOf: aBook) > 0) ifTrue:[
				list := list, '| ISBN: ', aBook, ' | Quantity: ', (cart occurrencesOf: aBook) asString, ' |']
		].
	^list.
	! !

!testRun: #InputInterfaceTest #test04canAddValidItemWithValidCartID stamp: 'LK 11/9/2023 14:18:15'!
FAILURE!

!testRun: #InputInterfaceTest #test04canAddValidItemWithValidCartID stamp: 'LK 11/9/2023 14:18:15'!
FAILURE!

!testRun: #InputInterfaceTest #test04canAddValidItemWithValidCartID stamp: 'LK 11/9/2023 14:18:25'!
FAILURE!

!testRun: #InputInterfaceTest #test04canAddValidItemWithValidCartID stamp: 'LK 11/9/2023 14:18:26'!
FAILURE!
!InputInterface methodsFor: 'as yet unclassified' stamp: 'LK 11/9/2023 14:18:40' prior: 50720062!
listCartWithID: cartID

	|list cart|
	list := '|'.
	
	cart := cartsOfUsers at: cartID.
	
	(catalog keys) do: [:aBook | ((cart occurrencesOf: aBook) > 0) ifTrue:[
				list := list, ' ISBN: ', aBook, ' | Quantity: ', (cart occurrencesOf: aBook) asString, ' |']
		].
	^list.
	! !

!testRun: #InputInterfaceTest #test04canAddValidItemWithValidCartID stamp: 'LK 11/9/2023 14:18:41'!
PASSED!
!InputInterfaceTest methodsFor: 'testing' stamp: 'LK 11/9/2023 14:20:36' prior: 50719995!
test04canAddValidItemWithValidCartID

	|inputInterface cartID|
	
	inputInterface := InputInterface with: self.
	
	cartID := inputInterface createCartwithUser: testObjectsFactory validUser usingPassword: testObjectsFactory validPassword.
	
	inputInterface addToCart:  cartID withAmount: 10 of: testObjectsFactory itemSellByTheStore.
	
	self assert: '| ISBN: validBook | Quantity: 10 |' equals: (inputInterface listCartWithID: cartID)! !
!InputInterfaceTest methodsFor: 'testing' stamp: 'LK 11/9/2023 14:23:08' prior: 50720103!
test04canAddValidItemWithValidCartID

	|inputInterface cartID|
	
	inputInterface := InputInterface with: self.
	
	cartID := inputInterface createCartwithUser: testObjectsFactory validUser usingPassword: testObjectsFactory validPassword.
	
	self shouldnt: [inputInterface addToCart:  cartID withAmount: 10 of: testObjectsFactory itemSellByTheStore.]
		raise: Error.
	
	self assert: '| ISBN: validBook | Quantity: 10 |' equals: (inputInterface listCartWithID: cartID)! !
!InputInterfaceTest methodsFor: 'testing' stamp: 'LK 11/9/2023 14:25:22'!
test05cannotAddValidItemToInvalidCartID

	|inputInterface |
	
	inputInterface := InputInterface with: self.
	
	inputInterface createCartwithUser: testObjectsFactory validUser usingPassword: testObjectsFactory validPassword.
	
	self should: [inputInterface addToCart: testObjectsFactory invalidCartID withAmount: 10 of: testObjectsFactory itemSellByTheStore.]
	raise: Error
	withExceptionDo: [:anError | anError messageText = InputInterface InvalidCartIDErrorDescription].
	
	
	self assert: '| ISBN: validBook | Quantity: 10 |' equals: (inputInterface listCartWithID: 1)! !

!testRun: #InputInterfaceTest #test05cannotAddValidItemToInvalidCartID stamp: 'LK 11/9/2023 14:25:25'!
ERROR!
!InputInterfaceTest methodsFor: 'testing' stamp: 'LK 11/9/2023 14:28:47'!
test05canListItemsOfValidCart

	|inputInterface |
	
	inputInterface := InputInterface with: self.
	
	inputInterface createCartwithUser: testObjectsFactory validUser usingPassword: testObjectsFactory validPassword.
	
	self should: [inputInterface addToCart: testObjectsFactory invalidCartID withAmount: 10 of: testObjectsFactory itemSellByTheStore.]
	raise: Error
	withExceptionDo: [:anError | anError messageText = InputInterface InvalidCartIDErrorDescription].
	
	
	self assert: '| ISBN: validBook | Quantity: 10 |' equals: (inputInterface listCartWithID: 1)! !
!InputInterfaceTest methodsFor: 'testing' stamp: 'LK 11/9/2023 14:29:27' prior: 50720161!
test05canListItemsOfValidCart

	|inputInterface cartID|
	
	inputInterface := InputInterface with: self.
	
	cartID := inputInterface createCartwithUser: testObjectsFactory validUser usingPassword: testObjectsFactory validPassword.
	
	inputInterface addToCart: cartID withAmount: 10 of: testObjectsFactory itemSellByTheStore.
	
	
	self assert: '| ISBN: validBook | Quantity: 10 |' equals: (inputInterface listCartWithID: cartID)! !

!testRun: #InputInterfaceTest #test05canListItemsOfValidCart stamp: 'LK 11/9/2023 14:29:27'!
PASSED!

!testRun: #InputInterfaceTest #test01cannotCreateCardWithInvalidCredentials stamp: 'LK 11/9/2023 14:29:27'!
PASSED!

!testRun: #InputInterfaceTest #test02canCreateCartForValidUser stamp: 'LK 11/9/2023 14:29:27'!
PASSED!

!testRun: #InputInterfaceTest #test03cannotAddValidItemWithInvalidCartID stamp: 'LK 11/9/2023 14:29:27'!
PASSED!

!testRun: #InputInterfaceTest #test04canAddValidItemWithValidCartID stamp: 'LK 11/9/2023 14:29:27'!
PASSED!

!testRun: #InputInterfaceTest #test05canListItemsOfValidCart stamp: 'LK 11/9/2023 14:29:27'!
PASSED!

!testRun: #InputInterfaceTest #test05cannotAddValidItemToInvalidCartID stamp: 'LK 11/9/2023 14:29:27'!
ERROR!

!testRun: #InputInterfaceTest #test05cannotAddValidItemToInvalidCartID stamp: 'LK 11/9/2023 14:29:27'!
ERROR!

!methodRemoval: InputInterfaceTest #test05cannotAddValidItemToInvalidCartID stamp: 'LK 11/9/2023 14:29:40'!
test05cannotAddValidItemToInvalidCartID

	|inputInterface |
	
	inputInterface := InputInterface with: self.
	
	inputInterface createCartwithUser: testObjectsFactory validUser usingPassword: testObjectsFactory validPassword.
	
	self should: [inputInterface addToCart: testObjectsFactory invalidCartID withAmount: 10 of: testObjectsFactory itemSellByTheStore.]
	raise: Error
	withExceptionDo: [:anError | anError messageText = InputInterface InvalidCartIDErrorDescription].
	
	
	self assert: '| ISBN: validBook | Quantity: 10 |' equals: (inputInterface listCartWithID: 1)!
!InputInterfaceTest methodsFor: 'testing' stamp: 'LK 11/9/2023 14:30:02' prior: 50720182!
test05canListItemsOfValidCart

	|inputInterface cartID|
	
	inputInterface := InputInterface with: self.
	
	cartID := inputInterface createCartwithUser: testObjectsFactory validUser usingPassword: testObjectsFactory validPassword.
	
	inputInterface addToCart: cartID withAmount: 10 of: testObjectsFactory itemSellByTheStore.
	
	self assert: '| ISBN: validBook | Quantity: 10 |' equals: (inputInterface listCartWithID: cartID)! !

!testRun: #InputInterfaceTest #test05canListItemsOfValidCart stamp: 'LK 11/9/2023 14:30:02'!
PASSED!

!testRun: #InputInterfaceTest #test01cannotCreateCardWithInvalidCredentials stamp: 'LK 11/9/2023 14:30:03'!
PASSED!

!testRun: #InputInterfaceTest #test02canCreateCartForValidUser stamp: 'LK 11/9/2023 14:30:03'!
PASSED!

!testRun: #InputInterfaceTest #test03cannotAddValidItemWithInvalidCartID stamp: 'LK 11/9/2023 14:30:03'!
PASSED!

!testRun: #InputInterfaceTest #test04canAddValidItemWithValidCartID stamp: 'LK 11/9/2023 14:30:03'!
PASSED!

!testRun: #InputInterfaceTest #test05canListItemsOfValidCart stamp: 'LK 11/9/2023 14:30:03'!
PASSED!

!testRun: #InputInterfaceTest #test05canListItemsOfValidCart stamp: 'LK 11/9/2023 14:30:05'!
PASSED!

!testRun: #InputInterfaceTest #test01cannotCreateCardWithInvalidCredentials stamp: 'LK 11/9/2023 14:30:05'!
PASSED!

!testRun: #InputInterfaceTest #test02canCreateCartForValidUser stamp: 'LK 11/9/2023 14:30:05'!
PASSED!

!testRun: #InputInterfaceTest #test03cannotAddValidItemWithInvalidCartID stamp: 'LK 11/9/2023 14:30:05'!
PASSED!

!testRun: #InputInterfaceTest #test04canAddValidItemWithValidCartID stamp: 'LK 11/9/2023 14:30:05'!
PASSED!

!testRun: #InputInterfaceTest #test05canListItemsOfValidCart stamp: 'LK 11/9/2023 14:30:05'!
PASSED!
!InputInterfaceTest methodsFor: 'testing' stamp: 'LK 11/9/2023 14:30:18'!
test06cannotListItemsOfInalidCart

	|inputInterface cartID|
	
	inputInterface := InputInterface with: self.
	
	cartID := inputInterface createCartwithUser: testObjectsFactory validUser usingPassword: testObjectsFactory validPassword.
	
	inputInterface addToCart: cartID withAmount: 10 of: testObjectsFactory itemSellByTheStore.
	
	self assert: '| ISBN: validBook | Quantity: 10 |' equals: (inputInterface listCartWithID: cartID)! !
!InputInterfaceTest methodsFor: 'testing' stamp: 'LK 11/9/2023 14:30:28' prior: 50720120!
test04canAddValidItemWithValidCartID

	|inputInterface cartID|
	
	inputInterface := InputInterface with: self.
	
	cartID := inputInterface createCartwithUser: testObjectsFactory validUser usingPassword: testObjectsFactory validPassword.
	
	self shouldnt: [inputInterface addToCart:  cartID withAmount: 10 of: testObjectsFactory itemSellByTheStore.]
		raise: Error.
	! !
!InputInterfaceTest methodsFor: 'testing' stamp: 'LK 11/9/2023 14:31:28' prior: 50720304!
test06cannotListItemsOfInalidCart

	|inputInterface |
	
	inputInterface := InputInterface with: self.
	
	inputInterface createCartwithUser: testObjectsFactory validUser usingPassword: testObjectsFactory validPassword.
	
	self should: [inputInterface listCartWithID: testObjectsFactory invalidCartID]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText = InputInterface InvalidCartIDErrorDescription].! !

!testRun: #InputInterfaceTest #test06cannotListItemsOfInalidCart stamp: 'LK 11/9/2023 14:31:32'!
FAILURE!
!InputInterface methodsFor: 'as yet unclassified' stamp: 'LK 11/9/2023 14:31:57' prior: 50720088!
listCartWithID: cartID

	|list cart|
	(self validateCardID: cartID).
	
	list := '|'.
	
	cart := cartsOfUsers at: cartID.
	
	(catalog keys) do: [:aBook | ((cart occurrencesOf: aBook) > 0) ifTrue:[
				list := list, ' ISBN: ', aBook, ' | Quantity: ', (cart occurrencesOf: aBook) asString, ' |']
		].
	^list.
	! !
!InputInterface methodsFor: 'as yet unclassified' stamp: 'LK 11/9/2023 14:31:59' prior: 50720356!
listCartWithID: cartID

	|list cart|
	
	(self validateCardID: cartID).
	
	list := '|'.
	
	cart := cartsOfUsers at: cartID.
	
	(catalog keys) do: [:aBook | ((cart occurrencesOf: aBook) > 0) ifTrue:[
				list := list, ' ISBN: ', aBook, ' | Quantity: ', (cart occurrencesOf: aBook) asString, ' |']
		].
	^list.
	! !

!testRun: #InputInterfaceTest #test06cannotListItemsOfInalidCart stamp: 'LK 11/9/2023 14:32:02'!
PASSED!
!InputInterfaceTest methodsFor: 'testing' stamp: 'LK 11/9/2023 14:32:15'!
test06canCheckoutCart

	|inputInterface |
	
	inputInterface := InputInterface with: self.
	
	inputInterface createCartwithUser: testObjectsFactory validUser usingPassword: testObjectsFactory validPassword.
	
	self should: [inputInterface listCartWithID: testObjectsFactory invalidCartID]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText = InputInterface InvalidCartIDErrorDescription].! !
!InputInterfaceTest methodsFor: 'testing' stamp: 'LK 11/9/2023 14:33:39'!
test07canCheckoutCart

	|inputInterface |
	
	inputInterface := InputInterface with: self.
	
	inputInterface createCartwithUser: testObjectsFactory validUser usingPassword: testObjectsFactory validPassword.
	
	self should: [inputInterface listCartWithID: testObjectsFactory invalidCartID]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText = InputInterface InvalidCartIDErrorDescription].! !

!methodRemoval: InputInterfaceTest #test06canCheckoutCart stamp: 'LK 11/9/2023 14:33:40'!
test06canCheckoutCart

	|inputInterface |
	
	inputInterface := InputInterface with: self.
	
	inputInterface createCartwithUser: testObjectsFactory validUser usingPassword: testObjectsFactory validPassword.
	
	self should: [inputInterface listCartWithID: testObjectsFactory invalidCartID]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText = InputInterface InvalidCartIDErrorDescription].!
!InputInterface methodsFor: 'as yet unclassified' stamp: 'LK 11/9/2023 14:35:04'!
checkout
! !
!InputInterface methodsFor: 'as yet unclassified' stamp: 'LK 11/9/2023 14:47:51'!
checkoutFor: aCartId usingCreditCardFrom: anOwner numbered: aCreditCardNumber withExpiryDate: aMonthOfYear
! !
!InputInterface methodsFor: 'as yet unclassified' stamp: 'LK 11/9/2023 14:48:08' prior: 50720436!
checkoutFor: aCartId usingCreditCardFrom: anOwner numbered: aCreditCardNumber withExpiryDate: aMonthOfYear

	(self validateCardID: aCartId).! !
!InputInterfaceTest methodsFor: 'testing' stamp: 'LK 11/9/2023 14:48:24'!
test07cannotCheckoutCartWithInvalidCartID

	|inputInterface |
	
	inputInterface := InputInterface with: self.
	
	inputInterface createCartwithUser: testObjectsFactory validUser usingPassword: testObjectsFactory validPassword.
	
	self should: [inputInterface listCartWithID: testObjectsFactory invalidCartID]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText = InputInterface InvalidCartIDErrorDescription].! !

!methodRemoval: InputInterfaceTest #test07canCheckoutCart stamp: 'LK 11/9/2023 14:48:24'!
test07canCheckoutCart

	|inputInterface |
	
	inputInterface := InputInterface with: self.
	
	inputInterface createCartwithUser: testObjectsFactory validUser usingPassword: testObjectsFactory validPassword.
	
	self should: [inputInterface listCartWithID: testObjectsFactory invalidCartID]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText = InputInterface InvalidCartIDErrorDescription].!
!InputInterfaceTest methodsFor: 'testing' stamp: 'LK 11/9/2023 14:49:15' prior: 50720450!
test07cannotCheckoutCartWithInvalidCartID

	|inputInterface |
	
	inputInterface := InputInterface with: self.
	
	inputInterface createCartwithUser: testObjectsFactory validUser usingPassword: testObjectsFactory validPassword.
	
	self should: [inputInterface checkoutFor: testObjectsFactory invalidCartID numbered: '33' withExpiryDate: 'ds' ]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText = InputInterface InvalidCartIDErrorDescription].! !
!InputInterfaceTest methodsFor: 'testing' stamp: 'LK 11/9/2023 14:50:16' prior: 50720483!
test07cannotCheckoutCartWithInvalidCartID

	|inputInterface |
	
	inputInterface := InputInterface with: self.
	
	inputInterface createCartwithUser: testObjectsFactory validUser usingPassword: testObjectsFactory validPassword.
	
	self should: [inputInterface checkoutFor: testObjectsFactory invalidCartID usingCreditCardFrom: 'pepe' numbered: '33' withExpiryDate: 'ds']
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText = InputInterface InvalidCartIDErrorDescription].! !

!testRun: #InputInterfaceTest #test07cannotCheckoutCartWithInvalidCartID stamp: 'LK 11/9/2023 14:50:16'!
PASSED!

!testRun: #InputInterfaceTest #test01cannotCreateCardWithInvalidCredentials stamp: 'LK 11/9/2023 14:50:16'!
PASSED!

!testRun: #InputInterfaceTest #test02canCreateCartForValidUser stamp: 'LK 11/9/2023 14:50:16'!
PASSED!

!testRun: #InputInterfaceTest #test03cannotAddValidItemWithInvalidCartID stamp: 'LK 11/9/2023 14:50:16'!
PASSED!

!testRun: #InputInterfaceTest #test04canAddValidItemWithValidCartID stamp: 'LK 11/9/2023 14:50:16'!
PASSED!

!testRun: #InputInterfaceTest #test05canListItemsOfValidCart stamp: 'LK 11/9/2023 14:50:16'!
PASSED!

!testRun: #InputInterfaceTest #test06cannotListItemsOfInalidCart stamp: 'LK 11/9/2023 14:50:16'!
PASSED!

!testRun: #InputInterfaceTest #test07cannotCheckoutCartWithInvalidCartID stamp: 'LK 11/9/2023 14:50:16'!
PASSED!
!InputInterfaceTest methodsFor: 'testing' stamp: 'LK 11/9/2023 14:50:57' prior: 50720501!
test07cannotCheckoutCartWithInvalidCartID

	|inputInterface |
	
	inputInterface := InputInterface with: self.
	
	inputInterface createCartwithUser: testObjectsFactory validUser usingPassword: testObjectsFactory validPassword.
	
	self should: [inputInterface checkoutFor: testObjectsFactory invalidCartID usingCreditCardFrom: 'Pepe' numbered: '332138791237023' withExpiryDate: GregorianMonthOfYear current]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText = InputInterface InvalidCartIDErrorDescription].! !

!testRun: #InputInterfaceTest #test07cannotCheckoutCartWithInvalidCartID stamp: 'LK 11/9/2023 14:50:59'!
PASSED!

!testRun: #InputInterfaceTest #test01cannotCreateCardWithInvalidCredentials stamp: 'LK 11/9/2023 14:50:59'!
PASSED!

!testRun: #InputInterfaceTest #test02canCreateCartForValidUser stamp: 'LK 11/9/2023 14:50:59'!
PASSED!

!testRun: #InputInterfaceTest #test03cannotAddValidItemWithInvalidCartID stamp: 'LK 11/9/2023 14:50:59'!
PASSED!

!testRun: #InputInterfaceTest #test04canAddValidItemWithValidCartID stamp: 'LK 11/9/2023 14:50:59'!
PASSED!

!testRun: #InputInterfaceTest #test05canListItemsOfValidCart stamp: 'LK 11/9/2023 14:50:59'!
PASSED!

!testRun: #InputInterfaceTest #test06cannotListItemsOfInalidCart stamp: 'LK 11/9/2023 14:50:59'!
PASSED!

!testRun: #InputInterfaceTest #test07cannotCheckoutCartWithInvalidCartID stamp: 'LK 11/9/2023 14:50:59'!
PASSED!
!InputInterfaceTest methodsFor: 'testing' stamp: 'LK 11/9/2023 14:55:09'!
test08cannotCheckoutCartWithInvalidCartID

	|inputInterface |
	
	inputInterface := InputInterface with: self.
	
	inputInterface createCartwithUser: testObjectsFactory validUser usingPassword: testObjectsFactory validPassword.
	
	self should: [inputInterface checkoutFor: testObjectsFactory invalidCartID usingCreditCardFrom: 'Pepe' numbered: '332138791237023' withExpiryDate: GregorianMonthOfYear current]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText = InputInterface InvalidCartIDErrorDescription].! !
!InputInterfaceTest methodsFor: 'testing' stamp: 'LK 11/9/2023 14:57:41' prior: 50720595!
test08cannotCheckoutCartWithInvalidCartID

	|inputInterface |
	
	inputInterface := InputInterface with: self.
	
	inputInterface createCartwithUser: testObjectsFactory validUser usingPassword: testObjectsFactory validPassword.! !

!methodRemoval: InputInterface #checkout stamp: 'LK 11/9/2023 14:57:55'!
checkout
!

!classDefinition: #InputInterface category: 'TusLibros' stamp: 'LK 11/9/2023 15:00:21'!
Object subclass: #InputInterface
	instanceVariableNames: 'authenticator cartsOfUsers catalog mp'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classDefinition: #InputInterface category: 'TusLibros' stamp: 'LK 11/9/2023 15:00:23'!
Object subclass: #InputInterface
	instanceVariableNames: 'authenticator cartsOfUsers catalog mp salesBook'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!
!InputInterface methodsFor: 'as yet unclassified' stamp: 'LK 11/9/2023 15:00:18' prior: 50720443!
checkoutFor: aCartId usingCreditCardFrom: anOwner numbered: aCreditCardNumber withExpiryDate: aMonthOfYear

	|cart|
	
	(self validateCardID: aCartId).
	
	cart := cartsOfUsers at: aCartId.
	
	Cashier 
		toCheckout: cart 
		charging: (CreditCard expiringOn: aMonthOfYear)
		throught: mp
		on: self today
		registeringOn: salesBook.! !
!InputInterface methodsFor: 'as yet unclassified' stamp: 'LK 11/9/2023 15:03:30' prior: 50720645!
checkoutFor: aCartId usingCreditCardFrom: anOwner numbered: aCreditCardNumber withExpiryDate: aMonthOfYear

	|cart|
	
	(self validateCardID: aCartId).
	
	cart := cartsOfUsers at: aCartId.
	
	Cashier 
		toCheckout: cart 
		charging: (CreditCard expiringOn: aMonthOfYear)
		throught: mp
		on: self time
		registeringOn: salesBook.! !
!InputInterface methodsFor: 'as yet unclassified' stamp: 'LK 11/9/2023 15:03:35'!
time! !
!InputInterfaceTest methodsFor: 'testing' stamp: 'LK 11/9/2023 15:04:59'!
test08canCheckout

	|inputInterface |
	
	inputInterface := InputInterface with: self.
	
	inputInterface createCartwithUser: testObjectsFactory validUser usingPassword: testObjectsFactory validPassword.! !

!methodRemoval: InputInterfaceTest #test08cannotCheckoutCartWithInvalidCartID stamp: 'LK 11/9/2023 15:05:00'!
test08cannotCheckoutCartWithInvalidCartID

	|inputInterface |
	
	inputInterface := InputInterface with: self.
	
	inputInterface createCartwithUser: testObjectsFactory validUser usingPassword: testObjectsFactory validPassword.!
!InputInterfaceTest methodsFor: 'testing' stamp: 'LK 11/9/2023 15:34:09' prior: 50720675!
test08canCheckout

	|inputInterface cartID|
	
	inputInterface := InputInterface with: self.
	
	cartID := inputInterface createCartwithUser: testObjectsFactory validUser usingPassword: testObjectsFactory validPassword.
	! !
!InputInterfaceTest methodsFor: 'testing' stamp: 'LK 11/9/2023 15:34:52' prior: 50720695!
test08canCheckout

	|inputInterface cartID|
	
	inputInterface := InputInterface with: self.
	
	cartID := inputInterface createCartwithUser: testObjectsFactory validUser usingPassword: testObjectsFactory validPassword.
	
	inputInterface addToCart: cartID withAmount: 10 of: testObjectsFactory itemSellByTheStore.
	
	! !
!InputInterface methodsFor: 'as yet unclassified' stamp: 'LK 11/9/2023 15:35:57' prior: 50719827!
initializeFor: anAuthenticator

	authenticator := anAuthenticator.
	
	cartsOfUsers := Dictionary new.
	
	salesBook := Dictionary new.
	
	catalog := Dictionary new
		at: 'validBook' put: 10;
		yourself.
! !
!InputInterface methodsFor: 'as yet unclassified' stamp: 'LK 11/9/2023 15:36:35'!
initializeFor: anAuthenticator andMP: merchantProcessor 

	authenticator := anAuthenticator.
	
	cartsOfUsers := Dictionary new.
	
	salesBook := Dictionary new.
	
	catalog := Dictionary new
		at: 'validBook' put: 10;
		yourself.
! !
!InputInterface class methodsFor: 'as yet unclassified' stamp: 'LK 11/9/2023 15:36:35' prior: 50719129!
with: anAuthenticator

	^self new initializeFor: anAuthenticator andMP: aMerchantProcessor.! !

!methodRemoval: InputInterface #initializeFor: stamp: 'LK 11/9/2023 15:36:35'!
initializeFor: anAuthenticator

	authenticator := anAuthenticator.
	
	cartsOfUsers := Dictionary new.
	
	salesBook := Dictionary new.
	
	catalog := Dictionary new
		at: 'validBook' put: 10;
		yourself.
!
!InputInterface methodsFor: 'as yet unclassified' stamp: 'LK 11/9/2023 15:36:46' prior: 50720728!
initializeFor: anAuthenticator andMP: merchantProcessor 

	authenticator := anAuthenticator.
	
	mp := merchantProcessor.
	
	cartsOfUsers := Dictionary new.
	
	salesBook := Dictionary new.
	
	catalog := Dictionary new
		at: 'validBook' put: 10;
		yourself.
! !

!testRun: #InputInterfaceTest #test01cannotCreateCardWithInvalidCredentials stamp: 'LK 11/9/2023 15:36:53'!
PASSED!

!testRun: #InputInterfaceTest #test02canCreateCartForValidUser stamp: 'LK 11/9/2023 15:36:53'!
PASSED!

!testRun: #InputInterfaceTest #test03cannotAddValidItemWithInvalidCartID stamp: 'LK 11/9/2023 15:36:53'!
PASSED!

!testRun: #InputInterfaceTest #test04canAddValidItemWithValidCartID stamp: 'LK 11/9/2023 15:36:53'!
PASSED!

!testRun: #InputInterfaceTest #test05canListItemsOfValidCart stamp: 'LK 11/9/2023 15:36:53'!
PASSED!

!testRun: #InputInterfaceTest #test06cannotListItemsOfInalidCart stamp: 'LK 11/9/2023 15:36:53'!
PASSED!

!testRun: #InputInterfaceTest #test07cannotCheckoutCartWithInvalidCartID stamp: 'LK 11/9/2023 15:36:53'!
PASSED!

!testRun: #InputInterfaceTest #test08canCheckout stamp: 'LK 11/9/2023 15:36:53'!
PASSED!
!InputInterface class methodsFor: 'as yet unclassified' stamp: 'LK 11/9/2023 15:37:51'!
with: anAuthenticator andMP: merchantProcessor 

	^self new initializeFor: anAuthenticator andMP: aMerchantProcessor.! !
!InputInterfaceTest methodsFor: 'as yet unclassified' stamp: 'LK 11/9/2023 15:37:51' prior: 50720247!
test05canListItemsOfValidCart

	|inputInterface cartID|
	
	inputInterface := InputInterface with: self andMP: aMerchanProcessor.
	
	cartID := inputInterface createCartwithUser: testObjectsFactory validUser usingPassword: testObjectsFactory validPassword.
	
	inputInterface addToCart: cartID withAmount: 10 of: testObjectsFactory itemSellByTheStore.
	
	self assert: '| ISBN: validBook | Quantity: 10 |' equals: (inputInterface listCartWithID: cartID)! !
!InputInterfaceTest methodsFor: 'as yet unclassified' stamp: 'LK 11/9/2023 15:37:51' prior: 50719705!
test02canCreateCartForValidUser

	|inputInterface cartID|
	
	inputInterface := InputInterface with: self andMP: aMerchanProcessor.
	
	cartID := inputInterface createCartwithUser: testObjectsFactory validUser usingPassword: testObjectsFactory validPassword.
	
	self shouldnt: [inputInterface listCartWithID: cartID] 
		raise: Error! !
!InputInterfaceTest methodsFor: 'as yet unclassified' stamp: 'LK 11/9/2023 15:37:51' prior: 50719406!
test01cannotCreateCardWithInvalidCredentials

	|inputInterface|
	
	inputInterface := InputInterface with: self andMP: aMerchanProcessor.
	
	inputBehavior := [:aUser :aPassword | self error: InputInterface invalidLoginCredentialsErrorMessage].
	
	self
		should: [inputInterface createCartwithUser: testObjectsFactory invalidUser usingPassword: testObjectsFactory invalidPassword]
		raise: Error 
		withExceptionDo: [:anError |
			self assert: anError messageText = InputInterface invalidLoginCredentialsErrorMessage.]
		
		! !
!InputInterfaceTest methodsFor: 'as yet unclassified' stamp: 'LK 11/9/2023 15:37:51' prior: 50720336!
test06cannotListItemsOfInalidCart

	|inputInterface |
	
	inputInterface := InputInterface with: self andMP: aMerchanProcessor.
	
	inputInterface createCartwithUser: testObjectsFactory validUser usingPassword: testObjectsFactory validPassword.
	
	self should: [inputInterface listCartWithID: testObjectsFactory invalidCartID]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText = InputInterface InvalidCartIDErrorDescription].! !
!InputInterfaceTest methodsFor: 'as yet unclassified' stamp: 'LK 11/9/2023 15:37:51' prior: 50719572!
test03cannotAddValidItemWithInvalidCartID

	|inputInterface|
	
	inputInterface := InputInterface with: self andMP: aMerchanProcessor.
	
	self should: [inputInterface addToCart:  testObjectsFactory invalidCartID withAmount: 1 of: 23424.]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText = InputInterface InvalidCartIDErrorDescription].
	! !
!InputInterfaceTest methodsFor: 'as yet unclassified' stamp: 'LK 11/9/2023 15:37:51' prior: 50720705!
test08canCheckout

	|inputInterface cartID|
	
	inputInterface := InputInterface with: self andMP: aMerchanProcessor.
	
	cartID := inputInterface createCartwithUser: testObjectsFactory validUser usingPassword: testObjectsFactory validPassword.
	
	inputInterface addToCart: cartID withAmount: 10 of: testObjectsFactory itemSellByTheStore.
	
	! !
!InputInterfaceTest methodsFor: 'as yet unclassified' stamp: 'LK 11/9/2023 15:37:51' prior: 50720548!
test07cannotCheckoutCartWithInvalidCartID

	|inputInterface |
	
	inputInterface := InputInterface with: self andMP: aMerchanProcessor.
	
	inputInterface createCartwithUser: testObjectsFactory validUser usingPassword: testObjectsFactory validPassword.
	
	self should: [inputInterface checkoutFor: testObjectsFactory invalidCartID usingCreditCardFrom: 'Pepe' numbered: '332138791237023' withExpiryDate: GregorianMonthOfYear current]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText = InputInterface InvalidCartIDErrorDescription].! !
!InputInterfaceTest methodsFor: 'as yet unclassified' stamp: 'LK 11/9/2023 15:37:51' prior: 50720321!
test04canAddValidItemWithValidCartID

	|inputInterface cartID|
	
	inputInterface := InputInterface with: self andMP: aMerchanProcessor.
	
	cartID := inputInterface createCartwithUser: testObjectsFactory validUser usingPassword: testObjectsFactory validPassword.
	
	self shouldnt: [inputInterface addToCart:  cartID withAmount: 10 of: testObjectsFactory itemSellByTheStore.]
		raise: Error.
	! !

!methodRemoval: InputInterface class #with: stamp: 'LK 11/9/2023 15:37:51'!
with: anAuthenticator

	^self new initializeFor: anAuthenticator andMP: aMerchantProcessor.!
!InputInterface class methodsFor: 'as yet unclassified' stamp: 'LK 11/9/2023 15:38:11' prior: 50720792!
with: anAuthenticator andMP: aMerchantProcessor 

	^self new initializeFor: anAuthenticator andMP: aMerchantProcessor.! !

!testRun: #InputInterfaceTest #test01cannotCreateCardWithInvalidCredentials stamp: 'LK 11/9/2023 15:38:21'!
PASSED!

!testRun: #InputInterfaceTest #test02canCreateCartForValidUser stamp: 'LK 11/9/2023 15:38:21'!
PASSED!

!testRun: #InputInterfaceTest #test03cannotAddValidItemWithInvalidCartID stamp: 'LK 11/9/2023 15:38:21'!
PASSED!

!testRun: #InputInterfaceTest #test04canAddValidItemWithValidCartID stamp: 'LK 11/9/2023 15:38:21'!
PASSED!

!testRun: #InputInterfaceTest #test05canListItemsOfValidCart stamp: 'LK 11/9/2023 15:38:21'!
PASSED!

!testRun: #InputInterfaceTest #test06cannotListItemsOfInalidCart stamp: 'LK 11/9/2023 15:38:21'!
PASSED!

!testRun: #InputInterfaceTest #test07cannotCheckoutCartWithInvalidCartID stamp: 'LK 11/9/2023 15:38:21'!
PASSED!

!testRun: #InputInterfaceTest #test08canCheckout stamp: 'LK 11/9/2023 15:38:21'!
PASSED!

!testRun: #InputInterfaceTest #test01cannotCreateCardWithInvalidCredentials stamp: 'LK 11/9/2023 15:39:13'!
PASSED!

!testRun: #InputInterfaceTest #test01cannotCreateCardWithInvalidCredentials stamp: 'LK 11/9/2023 15:39:14'!
PASSED!

!testRun: #InputInterfaceTest #test02canCreateCartForValidUser stamp: 'LK 11/9/2023 15:39:14'!
PASSED!

!testRun: #InputInterfaceTest #test03cannotAddValidItemWithInvalidCartID stamp: 'LK 11/9/2023 15:39:14'!
PASSED!

!testRun: #InputInterfaceTest #test04canAddValidItemWithValidCartID stamp: 'LK 11/9/2023 15:39:14'!
PASSED!

!testRun: #InputInterfaceTest #test05canListItemsOfValidCart stamp: 'LK 11/9/2023 15:39:14'!
PASSED!

!testRun: #InputInterfaceTest #test06cannotListItemsOfInalidCart stamp: 'LK 11/9/2023 15:39:14'!
PASSED!

!testRun: #InputInterfaceTest #test07cannotCheckoutCartWithInvalidCartID stamp: 'LK 11/9/2023 15:39:14'!
PASSED!

!testRun: #InputInterfaceTest #test08canCheckout stamp: 'LK 11/9/2023 15:39:14'!
PASSED!
!InputInterfaceTest methodsFor: 'testing' stamp: 'LK 11/9/2023 15:39:28' prior: 50720831!
test01cannotCreateCardWithInvalidCredentials

	|inputInterface|
	
	inputInterface := InputInterface with: self andMP: self.
	
	inputBehavior := [:aUser :aPassword | self error: InputInterface invalidLoginCredentialsErrorMessage].
	
	self
		should: [inputInterface createCartwithUser: testObjectsFactory invalidUser usingPassword: testObjectsFactory invalidPassword]
		raise: Error 
		withExceptionDo: [:anError |
			self assert: anError messageText = InputInterface invalidLoginCredentialsErrorMessage.]
		
		! !
!InputInterfaceTest methodsFor: 'testing' stamp: 'LK 11/9/2023 15:39:31' prior: 50720817!
test02canCreateCartForValidUser

	|inputInterface cartID|
	
	inputInterface := InputInterface with: self andMP: self.
	
	cartID := inputInterface createCartwithUser: testObjectsFactory validUser usingPassword: testObjectsFactory validPassword.
	
	self shouldnt: [inputInterface listCartWithID: cartID] 
		raise: Error! !
!InputInterfaceTest methodsFor: 'testing' stamp: 'LK 11/9/2023 15:39:37' prior: 50720869!
test03cannotAddValidItemWithInvalidCartID

	|inputInterface|
	
	inputInterface := InputInterface with: self andMP: self.
	
	self should: [inputInterface addToCart:  testObjectsFactory invalidCartID withAmount: 1 of: 23424.]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText = InputInterface InvalidCartIDErrorDescription].
	! !
!InputInterfaceTest methodsFor: 'testing' stamp: 'LK 11/9/2023 15:39:39' prior: 50720919!
test04canAddValidItemWithValidCartID

	|inputInterface cartID|
	
	inputInterface := InputInterface with: self andMP: self.
	
	cartID := inputInterface createCartwithUser: testObjectsFactory validUser usingPassword: testObjectsFactory validPassword.
	
	self shouldnt: [inputInterface addToCart:  cartID withAmount: 10 of: testObjectsFactory itemSellByTheStore.]
		raise: Error.
	! !
!InputInterfaceTest methodsFor: 'testing' stamp: 'LK 11/9/2023 15:39:42' prior: 50720799!
test05canListItemsOfValidCart

	|inputInterface cartID|
	
	inputInterface := InputInterface with: self andMP: self.
	
	cartID := inputInterface createCartwithUser: testObjectsFactory validUser usingPassword: testObjectsFactory validPassword.
	
	inputInterface addToCart: cartID withAmount: 10 of: testObjectsFactory itemSellByTheStore.
	
	self assert: '| ISBN: validBook | Quantity: 10 |' equals: (inputInterface listCartWithID: cartID)! !
!InputInterfaceTest methodsFor: 'testing' stamp: 'LK 11/9/2023 15:39:44' prior: 50720851!
test06cannotListItemsOfInalidCart

	|inputInterface |
	
	inputInterface := InputInterface with: self andMP: self.
	
	inputInterface createCartwithUser: testObjectsFactory validUser usingPassword: testObjectsFactory validPassword.
	
	self should: [inputInterface listCartWithID: testObjectsFactory invalidCartID]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText = InputInterface InvalidCartIDErrorDescription].! !
!InputInterfaceTest methodsFor: 'testing' stamp: 'LK 11/9/2023 15:39:46' prior: 50720898!
test07cannotCheckoutCartWithInvalidCartID

	|inputInterface |
	
	inputInterface := InputInterface with: self andMP: self.
	
	inputInterface createCartwithUser: testObjectsFactory validUser usingPassword: testObjectsFactory validPassword.
	
	self should: [inputInterface checkoutFor: testObjectsFactory invalidCartID usingCreditCardFrom: 'Pepe' numbered: '332138791237023' withExpiryDate: GregorianMonthOfYear current]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText = InputInterface InvalidCartIDErrorDescription].! !
!InputInterfaceTest methodsFor: 'testing' stamp: 'LK 11/9/2023 15:39:48' prior: 50720884!
test08canCheckout

	|inputInterface cartID|
	
	inputInterface := InputInterface with: self andMP: self.
	
	cartID := inputInterface createCartwithUser: testObjectsFactory validUser usingPassword: testObjectsFactory validPassword.
	
	inputInterface addToCart: cartID withAmount: 10 of: testObjectsFactory itemSellByTheStore.
	
	! !

!testRun: #InputInterfaceTest #test01cannotCreateCardWithInvalidCredentials stamp: 'LK 11/9/2023 15:40:34'!
PASSED!

!testRun: #InputInterfaceTest #test02canCreateCartForValidUser stamp: 'LK 11/9/2023 15:40:34'!
PASSED!

!testRun: #InputInterfaceTest #test03cannotAddValidItemWithInvalidCartID stamp: 'LK 11/9/2023 15:40:34'!
PASSED!

!testRun: #InputInterfaceTest #test04canAddValidItemWithValidCartID stamp: 'LK 11/9/2023 15:40:34'!
PASSED!

!testRun: #InputInterfaceTest #test05canListItemsOfValidCart stamp: 'LK 11/9/2023 15:40:34'!
PASSED!

!testRun: #InputInterfaceTest #test06cannotListItemsOfInalidCart stamp: 'LK 11/9/2023 15:40:34'!
PASSED!

!testRun: #InputInterfaceTest #test07cannotCheckoutCartWithInvalidCartID stamp: 'LK 11/9/2023 15:40:34'!
PASSED!

!testRun: #InputInterfaceTest #test08canCheckout stamp: 'LK 11/9/2023 15:40:34'!
PASSED!
!InputInterface methodsFor: 'as yet unclassified' stamp: 'LK 11/9/2023 15:41:11' prior: 50720659!
checkoutFor: aCartId usingCreditCardFrom: anOwner numbered: aCreditCardNumber withExpiryDate: aMonthOfYear

	|cart cashier|
	
	(self validateCardID: aCartId).
	
	cart := cartsOfUsers at: aCartId.
	
	cashier := Cashier 
		toCheckout: cart 
		charging: (CreditCard expiringOn: aMonthOfYear)
		throught: mp
		on: self time
		registeringOn: salesBook.
		
	cashier checkout.! !
!InputInterface methodsFor: 'as yet unclassified' stamp: 'LK 11/9/2023 15:41:30' prior: 50721162!
checkoutFor: aCartId usingCreditCardFrom: anOwner numbered: aCreditCardNumber withExpiryDate: aMonthOfYear

	|cart cashier|
	
	(self validateCardID: aCartId).
	
	cart := cartsOfUsers at: aCartId.
	
	cashier := Cashier 
		toCheckout: cart 
		charging: (CreditCard expiringOn: aMonthOfYear)
		throught: mp
		on: self time
		registeringOn: salesBook.
		
	cashier checkOut.! !
!InputInterfaceTest methodsFor: 'setup' stamp: 'LK 11/9/2023 15:41:42'!
debit: anAmount from: aCreditCard ! !
!InputInterfaceTest methodsFor: 'testing' stamp: 'LK 11/9/2023 15:42:51' prior: 50721121!
test08canCheckout

	|inputInterface cartID total|
	
	inputInterface := InputInterface with: self andMP: self.
	
	cartID := inputInterface createCartwithUser: testObjectsFactory validUser usingPassword: testObjectsFactory validPassword.
	
	inputInterface addToCart: cartID withAmount: 10 of: testObjectsFactory itemSellByTheStore.
	
	total := inputInterface checkoutFor: cartID usingCreditCardFrom: 'Juan' numbered: '1234567890123456' withExpiryDate: GregorianMonthOfYear current .
	
	self assert: total = 10.
	
	! !

!testRun: #InputInterfaceTest #test08canCheckout stamp: 'LK 11/9/2023 15:42:52'!
ERROR!
!StoreTestObjectsFactory methodsFor: 'items' stamp: 'LK 11/9/2023 15:45:48'!
nonExpiringMonth
	^(Month month: today monthIndex year: today yearNumber + 1)! !
!InputInterfaceTest methodsFor: 'testing' stamp: 'LK 11/9/2023 15:46:02' prior: 50721195!
test08canCheckout

	|inputInterface cartID total|
	
	inputInterface := InputInterface with: self andMP: self.
	
	cartID := inputInterface createCartwithUser: testObjectsFactory validUser usingPassword: testObjectsFactory validPassword.
	
	inputInterface addToCart: cartID withAmount: 10 of: testObjectsFactory itemSellByTheStore.
	
	total := inputInterface checkoutFor: cartID usingCreditCardFrom: 'Juan' numbered: '1234567890123456' withExpiryDate: testObjectsFactory nonExpiringMonth .
	
	self assert: total = 10.
	
	! !

!testRun: #InputInterfaceTest #test08canCheckout stamp: 'LK 11/9/2023 15:46:03'!
ERROR!

----QUIT----(9 November 2023 15:46:26) CuisUniversity-5981.image priorSource: 12407918!

----STARTUP---- (9 November 2023 15:47:02) as C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\CuisUniversity-5981.image!


----QUIT----(9 November 2023 15:47:20) CuisUniversity-5981.image priorSource: 12467011!

----STARTUP---- (13 November 2023 12:22:58) as C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\CuisUniversity-5981.image!


!classRemoval: #StoreTestObjectsFactory stamp: 'LK 11/13/2023 12:23:36'!
Object subclass: #StoreTestObjectsFactory
	instanceVariableNames: 'today'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classRemoval: #Sale stamp: 'LK 11/13/2023 12:23:36'!
Object subclass: #Sale
	instanceVariableNames: 'total'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classRemoval: #InputInterface stamp: 'LK 11/13/2023 12:23:36'!
Object subclass: #InputInterface
	instanceVariableNames: 'authenticator cartsOfUsers catalog mp salesBook'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classRemoval: #CreditCard stamp: 'LK 11/13/2023 12:23:37'!
Object subclass: #CreditCard
	instanceVariableNames: 'expiration'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classRemoval: #Cashier stamp: 'LK 11/13/2023 12:23:37'!
Object subclass: #Cashier
	instanceVariableNames: 'cart salesBook merchantProcessor creditCard total'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classRemoval: #Cart stamp: 'LK 11/13/2023 12:23:37'!
Object subclass: #Cart
	instanceVariableNames: 'catalog items'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classRemoval: #InputInterfaceTest stamp: 'LK 11/13/2023 12:23:37'!
TestCase subclass: #InputInterfaceTest
	instanceVariableNames: 'inputBehavior testObjectsFactory'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classRemoval: #CashierTest stamp: 'LK 11/13/2023 12:23:37'!
TestCase subclass: #CashierTest
	instanceVariableNames: 'testObjectsFactory debitBehavior'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

!classRemoval: #CartTest stamp: 'LK 11/13/2023 12:23:38'!
TestCase subclass: #CartTest
	instanceVariableNames: 'testObjectsFactory'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TusLibros'!

----End fileIn of C:\Users\lucas\OneDrive\Desktop\TusLibros-Model Ejercicio it4.st----!

----End fileIn of C:\Users\lucas\OneDrive\Desktop\TusLibrosREST Ejercicio it4.st----!

----End fileIn of C:\Users\lucas\OneDrive\Desktop\TusLibros-Tests Ejercicio it4.st----!

----End fileIn of C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\Packages\System\Collections-CompactArrays.pck.st----!

----End fileIn of C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\Packages\Features\Compression.pck.st----!

----End fileIn of C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\Packages\Features\Sound.pck.st----!

----End fileIn of C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\Packages\Features\Cryptography-DigitalSignatures.pck.st----!

----End fileIn of C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\Packages\Features\Identities-UUID.pck.st----!

----End fileIn of C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\Packages\System\Network-Kernel.pck.st----!

----End fileIn of C:\Users\lucas\OneDrive\Desktop\WebClient.pck.st----!

WebClient new!
!TusLibrosSystemFacade methodsFor: 'private' stamp: 'LK 11/13/2023 12:43:04' prior: 50722136!
bookPerformance: anItem

	| bookPerformance totalMoney totalSales semaphore|

	bookPerformance := Dictionary new.
	
	semaphore := Semaphore new.
	
	[totalSales := self totalSalesOf: anItem.
	totalMoney := self totalMoneyRaisedBy: anItem.
	semaphore signal] fork.
	
	semaphore wait.
	
	bookPerformance at: 'quantity' put: totalSales.
	bookPerformance at: 'total' put: totalMoney.
	bookPerformance at: 'summary' put: anItem,' was selled ',totalSales asString, ' times and raised a total amount of money equal to: ', totalMoney asString.
	
	^bookPerformance
	

! !
!TusLibrosSystemFacade methodsFor: 'private' stamp: 'LK 11/13/2023 12:43:38' prior: 50722177!
storePerformance

	| totalMoney totalSales performance semaphore|
	
	performance := Dictionary new.
	
	semaphore := Semaphore new.
	
	[totalSales := self totalSales.
	totalMoney := self totalMoneyRaised.
	semaphore signal.] fork.

	semaphore wait.
	
	performance at: 'quantity' put: totalSales.
	performance at: 'total' put: totalMoney.
	performance at: 'summary' put: 'The store selled a total of ',totalSales asString, ' books and raised a total amount of money equal to: ', totalMoney asString.
	
	^performance
	

! !

!testRun: #TusLibrosSystemFacadeTest #test20BookPerformanceShouldNotTakeTooLong stamp: 'LK 11/13/2023 12:43:49'!
FAILURE!

!testRun: #TusLibrosSystemFacadeTest #test20BookPerformanceShouldNotTakeTooLong stamp: 'LK 11/13/2023 12:43:51'!
FAILURE!

!testRun: #TusLibrosSystemFacadeTest #test21StorePerformanceShouldNotTakeTooLong stamp: 'LK 11/13/2023 12:44:00'!
FAILURE!

!testRun: #TusLibrosSystemFacadeTest #test21StorePerformanceShouldNotTakeTooLong stamp: 'LK 11/13/2023 12:44:02'!
FAILURE!
!TusLibrosSystemFacade methodsFor: 'private' stamp: 'LK 11/13/2023 12:44:40' prior: 50760860!
bookPerformance: anItem

	| bookPerformance totalMoney totalSales semaphore|

	bookPerformance := Dictionary new.
	
	semaphore := Semaphore new.
	
	[totalSales := self totalSalesOf: anItem. semaphore signal] fork.
	[totalMoney := self totalMoneyRaisedBy: anItem. semaphore signal] fork.
	
	semaphore wait.
	semaphore wait.
	
	bookPerformance at: 'quantity' put: totalSales.
	bookPerformance at: 'total' put: totalMoney.
	bookPerformance at: 'summary' put: anItem,' was selled ',totalSales asString, ' times and raised a total amount of money equal to: ', totalMoney asString.
	
	^bookPerformance
	

! !
!TusLibrosSystemFacade methodsFor: 'private' stamp: 'LK 11/13/2023 12:45:32' prior: 50760881!
storePerformance

	| totalMoney totalSales performance semaphore|
	
	performance := Dictionary new.
	
	semaphore := Semaphore new.
	
	[totalSales := self totalSales. semaphore signal] fork.
	[totalMoney := self totalMoneyRaised. semaphore signal] fork.

	semaphore wait. semaphore wait.
	
	performance at: 'quantity' put: totalSales.
	performance at: 'total' put: totalMoney.
	performance at: 'summary' put: 'The store selled a total of ',totalSales asString, ' books and raised a total amount of money equal to: ', totalMoney asString.
	
	^performance
	

! !

!testRun: #TusLibrosSystemFacadeTest #test01CanCreateCartWithValidUserAndPassword stamp: 'LK 11/13/2023 12:45:37'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test02CanNotCreateCartWithInvalidUser stamp: 'LK 11/13/2023 12:45:37'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test03CanNotCreateCartWithInvalidPassword stamp: 'LK 11/13/2023 12:45:37'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test04CanAddItemsToACreatedCart stamp: 'LK 11/13/2023 12:45:37'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test05CanNotAddItemToNotCreatedCart stamp: 'LK 11/13/2023 12:45:37'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test06CanNotAddItemNotSellByTheStore stamp: 'LK 11/13/2023 12:45:37'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test08CanNotListCartOfInvalidCartId stamp: 'LK 11/13/2023 12:45:37'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test09ListCartReturnsTheRightNumberOfItems stamp: 'LK 11/13/2023 12:45:37'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test10CheckOutReturnsTransactionIdAndImpactsCustomerPurchases stamp: 'LK 11/13/2023 12:45:37'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test10_1_CanNotCheckoutAnAlreadyCheckedOutCart stamp: 'LK 11/13/2023 12:45:37'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test11CanNotCheckoutANotCreatedCart stamp: 'LK 11/13/2023 12:45:37'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test12CanNotCheckoutAnEmptyCart stamp: 'LK 11/13/2023 12:45:37'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test13CanNotCheckoutWithAnExpiredCreditCard stamp: 'LK 11/13/2023 12:45:37'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test14ListPurchasesIncludesBoughtItems stamp: 'LK 11/13/2023 12:45:37'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test15CanNotListPurchasesOfInvalidCustomer stamp: 'LK 11/13/2023 12:45:37'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test16CanNotListPurchasesOfValidCustomerWithInvalidPassword stamp: 'LK 11/13/2023 12:45:37'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test17CanNotAddToCartWhenSessionIsExpired stamp: 'LK 11/13/2023 12:45:37'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test18CanNotListCartWhenSessionIsExpired stamp: 'LK 11/13/2023 12:45:37'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test19CanNotCheckOutCartWhenSessionIsExpired stamp: 'LK 11/13/2023 12:45:37'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test20BookPerformanceShouldNotTakeTooLong stamp: 'LK 11/13/2023 12:45:38'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test21StorePerformanceShouldNotTakeTooLong stamp: 'LK 11/13/2023 12:45:39'!
PASSED!
!TusLibrosSystemFacade methodsFor: 'private' stamp: 'LK 11/13/2023 13:25:00'!
forkAndDo: aBlockToExecute with: aSemaphore

	[aBlockToExecute value. aSemaphore signal] fork.

! !
!TusLibrosSystemFacade methodsFor: 'private' stamp: 'LK 11/13/2023 13:28:32' prior: 50760916!
bookPerformance: anItem

	| bookPerformance totalMoney totalSales semaphore|

	bookPerformance := Dictionary new.
	
	semaphore := Semaphore new.
	
	self forkAndDo: [totalSales := self totalSalesOf: anItem] with: semaphore.
	self forkAndDo: [totalMoney := self totalMoneyRaisedBy: anItem] with: semaphore.
	
	semaphore wait.
	semaphore wait.
	
	bookPerformance at: 'quantity' put: totalSales.
	bookPerformance at: 'total' put: totalMoney.
	bookPerformance at: 'summary' put: anItem,' was selled ',totalSales asString, ' times and raised a total amount of money equal to: ', totalMoney asString.
	
	^bookPerformance
	

! !

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'LK 11/13/2023 13:28:33'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'LK 11/13/2023 13:28:33'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'LK 11/13/2023 13:28:33'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'LK 11/13/2023 13:28:33'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'LK 11/13/2023 13:28:33'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'LK 11/13/2023 13:28:33'!
PASSED!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'LK 11/13/2023 13:28:33'!
PASSED!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'LK 11/13/2023 13:28:33'!
PASSED!

!testRun: #CashierTest #test01CanNotCheckoutAnEmptyCart stamp: 'LK 11/13/2023 13:28:33'!
PASSED!

!testRun: #CashierTest #test02CalculatedTotalIsCorrect stamp: 'LK 11/13/2023 13:28:33'!
PASSED!

!testRun: #CashierTest #test03CanNotCheckoutWithAnExpiredCreditCart stamp: 'LK 11/13/2023 13:28:33'!
PASSED!

!testRun: #CashierTest #test04CheckoutRegistersASale stamp: 'LK 11/13/2023 13:28:33'!
PASSED!

!testRun: #CashierTest #test05CashierChargesCreditCardUsingMerchantProcessor stamp: 'LK 11/13/2023 13:28:33'!
PASSED!

!testRun: #CashierTest #test06CashierDoesNotSaleWhenTheCreditCardHasNoCredit stamp: 'LK 11/13/2023 13:28:33'!
PASSED!

!testRun: #CreditCardTest #test01CreditCardNumberWithLessThan16DigitsIsNotValid stamp: 'LK 11/13/2023 13:28:33'!
PASSED!

!testRun: #CreditCardTest #test02CreditCardNumberWithMoreThan16DigitsIsNotValid stamp: 'LK 11/13/2023 13:28:33'!
PASSED!

!testRun: #CreditCardTest #test03CreditCardNumberShouldBeDigitsOnly stamp: 'LK 11/13/2023 13:28:33'!
PASSED!

!testRun: #CreditCardTest #test04NameCanNotBeEmpty stamp: 'LK 11/13/2023 13:28:33'!
PASSED!

!testRun: #CreditCardTest #test05IsExpiredOnNextExpirationMonth stamp: 'LK 11/13/2023 13:28:33'!
PASSED!

!testRun: #CreditCardTest #test06IsNotExpiredOnExpirationMonth stamp: 'LK 11/13/2023 13:28:33'!
PASSED!

!testRun: #CreditCardTest #test07CanGetCreditCardInfoFromIt stamp: 'LK 11/13/2023 13:28:33'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test01CanCreateCartWithValidUserAndPassword stamp: 'LK 11/13/2023 13:28:33'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test02CanNotCreateCartWithInvalidUser stamp: 'LK 11/13/2023 13:28:33'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test03CanNotCreateCartWithInvalidPassword stamp: 'LK 11/13/2023 13:28:33'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test04CanAddItemsToACreatedCart stamp: 'LK 11/13/2023 13:28:33'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test05CanNotAddItemToNotCreatedCart stamp: 'LK 11/13/2023 13:28:33'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test06CanNotAddItemNotSellByTheStore stamp: 'LK 11/13/2023 13:28:33'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test08CanNotListCartOfInvalidCartId stamp: 'LK 11/13/2023 13:28:33'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test09ListCartReturnsTheRightNumberOfItems stamp: 'LK 11/13/2023 13:28:33'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test10CheckOutReturnsTransactionIdAndImpactsCustomerPurchases stamp: 'LK 11/13/2023 13:28:33'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test10_1_CanNotCheckoutAnAlreadyCheckedOutCart stamp: 'LK 11/13/2023 13:28:33'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test11CanNotCheckoutANotCreatedCart stamp: 'LK 11/13/2023 13:28:33'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test12CanNotCheckoutAnEmptyCart stamp: 'LK 11/13/2023 13:28:33'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test13CanNotCheckoutWithAnExpiredCreditCard stamp: 'LK 11/13/2023 13:28:33'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test14ListPurchasesIncludesBoughtItems stamp: 'LK 11/13/2023 13:28:33'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test15CanNotListPurchasesOfInvalidCustomer stamp: 'LK 11/13/2023 13:28:33'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test16CanNotListPurchasesOfValidCustomerWithInvalidPassword stamp: 'LK 11/13/2023 13:28:33'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test17CanNotAddToCartWhenSessionIsExpired stamp: 'LK 11/13/2023 13:28:33'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test18CanNotListCartWhenSessionIsExpired stamp: 'LK 11/13/2023 13:28:33'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test19CanNotCheckOutCartWhenSessionIsExpired stamp: 'LK 11/13/2023 13:28:33'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test20BookPerformanceShouldNotTakeTooLong stamp: 'LK 11/13/2023 13:28:34'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test21StorePerformanceShouldNotTakeTooLong stamp: 'LK 11/13/2023 13:28:35'!
PASSED!
!TusLibrosSystemFacade methodsFor: 'private' stamp: 'LK 11/13/2023 13:29:12' prior: 50760938!
storePerformance

	| totalMoney totalSales performance semaphore|
	
	performance := Dictionary new.
	
	semaphore := Semaphore new.
	
	self forkAndDo: [totalSales := self totalSales] with: semaphore.
	self forkAndDo: [totalMoney := self totalMoneyRaised] with: semaphore.

	semaphore wait. semaphore wait.
	
	performance at: 'quantity' put: totalSales.
	performance at: 'total' put: totalMoney.
	performance at: 'summary' put: 'The store selled a total of ',totalSales asString, ' books and raised a total amount of money equal to: ', totalMoney asString.
	
	^performance
	

! !

!testRun: #TusLibrosSystemFacadeTest #test01CanCreateCartWithValidUserAndPassword stamp: 'LK 11/13/2023 13:29:27'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test02CanNotCreateCartWithInvalidUser stamp: 'LK 11/13/2023 13:29:28'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test03CanNotCreateCartWithInvalidPassword stamp: 'LK 11/13/2023 13:29:28'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test04CanAddItemsToACreatedCart stamp: 'LK 11/13/2023 13:29:28'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test05CanNotAddItemToNotCreatedCart stamp: 'LK 11/13/2023 13:29:28'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test06CanNotAddItemNotSellByTheStore stamp: 'LK 11/13/2023 13:29:28'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test08CanNotListCartOfInvalidCartId stamp: 'LK 11/13/2023 13:29:28'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test09ListCartReturnsTheRightNumberOfItems stamp: 'LK 11/13/2023 13:29:28'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test10CheckOutReturnsTransactionIdAndImpactsCustomerPurchases stamp: 'LK 11/13/2023 13:29:28'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test10_1_CanNotCheckoutAnAlreadyCheckedOutCart stamp: 'LK 11/13/2023 13:29:28'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test11CanNotCheckoutANotCreatedCart stamp: 'LK 11/13/2023 13:29:28'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test12CanNotCheckoutAnEmptyCart stamp: 'LK 11/13/2023 13:29:28'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test13CanNotCheckoutWithAnExpiredCreditCard stamp: 'LK 11/13/2023 13:29:28'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test14ListPurchasesIncludesBoughtItems stamp: 'LK 11/13/2023 13:29:28'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test15CanNotListPurchasesOfInvalidCustomer stamp: 'LK 11/13/2023 13:29:28'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test16CanNotListPurchasesOfValidCustomerWithInvalidPassword stamp: 'LK 11/13/2023 13:29:28'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test17CanNotAddToCartWhenSessionIsExpired stamp: 'LK 11/13/2023 13:29:28'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test18CanNotListCartWhenSessionIsExpired stamp: 'LK 11/13/2023 13:29:28'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test19CanNotCheckOutCartWhenSessionIsExpired stamp: 'LK 11/13/2023 13:29:28'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test20BookPerformanceShouldNotTakeTooLong stamp: 'LK 11/13/2023 13:29:29'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test21StorePerformanceShouldNotTakeTooLong stamp: 'LK 11/13/2023 13:29:30'!
PASSED!

TusLibrosServerRestInterface installForDefaultSystem.!

TusLibrosClientTestWindow open!
!TusLibrosServerRestInterface methodsFor: 'request' stamp: 'LK 11/13/2023 13:58:25' prior: 50722757!
answer: aBlock to: aRequest 

	| response semaphore |
	
	semaphore := Semaphore new.
	
	
	
	[[response := aBlock value. semaphore signal] fork. semaphore wait.
	aRequest send200Response: (WebUtils jsonEncode: (response))]
		on: Error
		do: [ :anError | aRequest send400Response: anError messageText ]! !
!TusLibrosServerRestInterface methodsFor: 'request' stamp: 'LK 11/13/2023 13:58:27' prior: 50761323!
answer: aBlock to: aRequest 

	| response semaphore |
	
	semaphore := Semaphore new.
	
	[[response := aBlock value. semaphore signal] fork. semaphore wait.
	aRequest send200Response: (WebUtils jsonEncode: (response))]
		on: Error
		do: [ :anError | aRequest send400Response: anError messageText ]! !

WebClient reset!

WebServer reset!

TusLibrosServerRestInterface installForDefaultSystem.!

TusLibrosClientTestWindow open!
!TusLibrosServerRestInterface methodsFor: 'request' stamp: 'LK 11/13/2023 14:14:00' prior: 50761336!
answer: aBlock to: aRequest 

	| response |

	
	[[response := aBlock value.] fork.
	aRequest send200Response: (WebUtils jsonEncode: (response))]
		on: Error
		do: [ :anError | aRequest send400Response: anError messageText ]! !
!TusLibrosServerRestInterface methodsFor: 'request' stamp: 'LK 11/13/2023 14:14:27' prior: 50761353!
answer: aBlock to: aRequest 

	| response |

	
	[response := aBlock value.
	aRequest send200Response: (WebUtils jsonEncode: (response))]
		on: Error
		do: [ :anError | aRequest send400Response: anError messageText ]! !

WebServer reset!

TusLibrosServerRestInterface installForDefaultSystem.!

TusLibrosClientTestWindow open!

----QUIT----(13 November 2023 15:30:53) CuisUniversity-5981.image priorSource: 12467231!

----STARTUP---- (13 November 2023 19:41:47) as C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\CuisUniversity-5981.image!


----End fileIn of C:\Users\lucas\OneDrive\Desktop\CustomerImporter.st----!

!testRun: #ImportTest #test01Import stamp: 'LK 11/13/2023 19:42:53'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'LK 11/13/2023 19:42:54'!
PASSED!

----QUIT----(13 November 2023 19:45:36) CuisUniversity-5981.image priorSource: 13751237!

----STARTUP---- (14 November 2023 00:38:05) as C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\CuisUniversity-5981.image!


!classRemoval: #DataBaseSession stamp: 'LK 11/14/2023 00:38:51'!
Object subclass: #DataBaseSession
	instanceVariableNames: 'configuration tables id'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!classRemoval: #Customer stamp: 'LK 11/14/2023 00:38:51'!
Object subclass: #Customer
	instanceVariableNames: 'id firstName lastName identificationType identificationNumber addresses'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!classRemoval: #Address stamp: 'LK 11/14/2023 00:38:51'!
Object subclass: #Address
	instanceVariableNames: 'id streetName streetNumber town zipCode province'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!classRemoval: #ImportTest stamp: 'LK 11/14/2023 00:38:52'!
TestCase subclass: #ImportTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

----End fileIn of C:\Users\lucas\OneDrive\Desktop\CustomerImporter (1).st----!

----QUIT----(14 November 2023 00:46:40) CuisUniversity-5981.image priorSource: 13760264!

----STARTUP---- (16 November 2023 00:15:53) as C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\CuisUniversity-5981.image!


TestCase subclass: #ImportTest
	instanceVariableNames: 'session inputFile'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!classDefinition: #ImportTest category: 'CustomerImporter' stamp: 'LK 11/16/2023 00:18:04'!
TestCase subclass: #ImportTest
	instanceVariableNames: 'session inputFile'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'LK 11/16/2023 00:18:18' prior: 50761753!
test01Import

	|numberOfCustomers customer customers addresses|

	self importCustomersWithStream: inputFile.
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	self assert: numberOfCustomers equals: 2.
	
	customers := session
				select: [:aCustomer | aCustomer identificationType = 'D' 
					and: [aCustomer identificationNumber = '22333444']] ofType: Customer.
		
	self assert: customers size equals: 1.
	customer := customers anyOne.
	self assert: customer firstName equals: 'Pepe'.
	self assert: customer lastName equals: 'Sanchez'.
	self assert: customer identificationType equals: 'D'.
	self assert: customer identificationNumber equals: '22333444'.
	
	addresses := customer addresses.
	
	self assert: addresses size equals: 2.
	
	customers := session
				select: [:aCustomer | aCustomer identificationType = 'C' 
					and: [aCustomer identificationNumber = '23-25666777-9']] ofType: Customer.
				
	self assert: customers size equals: 1.
	customer := customers anyOne.
	self assert: customer firstName equals: 'Juan'.
	self assert: customer lastName equals: 'Perez'.
	self assert: customer identificationType equals: 'C'.
	self assert: customer identificationNumber equals: '23-25666777-9'.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'LK 11/16/2023 00:18:29' prior: 50761742 overrides: 16961394!
setUp

	inputFile := (UniFileStream new open: 'input.txt' forWrite: false).
	session := DataBaseSession for: (Array with: Address with: Customer).
	session beginTransaction! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'LK 11/16/2023 00:18:38' prior: 50761795!
test02Import

	|customer customers addresses address |

	self importCustomersWithStream: inputFile.
	
	customers := session
				select: [:aCustomer | aCustomer identificationType = 'D' 
					and: [aCustomer identificationNumber = '22333444']] ofType: Customer.
		
	customer := customers anyOne.
	addresses := customer addresses.
	
	self assert: addresses size equals: 2.
	
	address := addresses select: [:anAddress | anAddress streetName = 'Maipu'].
	address := address first.
	
	self assert: (address streetName) equals: 'Maipu'.
	self assert: address streetNumber equals: 888.
	self assert: address town equals: 'Florida'.
	self assert: address zipCode equals: 1122.
	self assert: address province equals: 'Buenos Aires'.
	
	address := addresses select: [:anAddress | anAddress streetName = 'San Martin'].
	address := address first.
	
	self assert: (address streetName) equals: 'San Martin'.
	self assert: address streetNumber equals: 3322.
	self assert: address town equals: 'Olivos'.
	self assert: address zipCode equals: 1636.
	self assert: address province equals: 'BsAs'.
	
	customers := session
				select: [:aCustomer | aCustomer identificationType = 'C' 
					and: [aCustomer identificationNumber = '23-25666777-9']] ofType: Customer.
				
	customer := customers anyOne.
	addresses := customer addresses.
	
	address := addresses select: [:anAddress | anAddress streetName = 'Alem'].
	address := address first.
	
	self assert: (address streetName) equals: 'Alem'.
	self assert: address streetNumber equals: 1122.
	self assert: address town equals: 'CABA'.
	self assert: address zipCode equals: 1001.
	self assert: address province equals: 'CABA'.				
				
	
	
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'LK 11/16/2023 00:19:44' prior: 50762129!
test02Import

	|singleCustomer customers addresses address |

	self importCustomersWithStream: inputFile.
	
	customers := session
				select: [:aCustomer | aCustomer identificationType = 'D' 
					and: [aCustomer identificationNumber = '22333444']] ofType: Customer.
		
	singleCustomer := customers anyOne.
	addresses := singleCustomer addresses.
	
	self assert: addresses size equals: 2.
	
	address := addresses select: [:anAddress | anAddress streetName = 'Maipu'].
	address := address first.
	
	self assert: (address streetName) equals: 'Maipu'.
	self assert: address streetNumber equals: 888.
	self assert: address town equals: 'Florida'.
	self assert: address zipCode equals: 1122.
	self assert: address province equals: 'Buenos Aires'.
	
	address := addresses select: [:anAddress | anAddress streetName = 'San Martin'].
	address := address first.
	
	self assert: (address streetName) equals: 'San Martin'.
	self assert: address streetNumber equals: 3322.
	self assert: address town equals: 'Olivos'.
	self assert: address zipCode equals: 1636.
	self assert: address province equals: 'BsAs'.
	
	customers := session
				select: [:aCustomer | aCustomer identificationType = 'C' 
					and: [aCustomer identificationNumber = '23-25666777-9']] ofType: Customer.
				
	singleCustomer := customers anyOne.
	addresses := singleCustomer addresses.
	
	address := addresses select: [:anAddress | anAddress streetName = 'Alem'].
	address := address first.
	
	self assert: (address streetName) equals: 'Alem'.
	self assert: address streetNumber equals: 1122.
	self assert: address town equals: 'CABA'.
	self assert: address zipCode equals: 1001.
	self assert: address province equals: 'CABA'.				
				
	
	
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'LK 11/16/2023 00:19:53' prior: 50762185!
test02Import

	|singleCustomer customers customerAddresses address |

	self importCustomersWithStream: inputFile.
	
	customers := session
				select: [:aCustomer | aCustomer identificationType = 'D' 
					and: [aCustomer identificationNumber = '22333444']] ofType: Customer.
		
	singleCustomer := customers anyOne.
	customerAddresses := singleCustomer addresses.
	
	self assert: customerAddresses size equals: 2.
	
	address := customerAddresses select: [:anAddress | anAddress streetName = 'Maipu'].
	address := address first.
	
	self assert: (address streetName) equals: 'Maipu'.
	self assert: address streetNumber equals: 888.
	self assert: address town equals: 'Florida'.
	self assert: address zipCode equals: 1122.
	self assert: address province equals: 'Buenos Aires'.
	
	address := customerAddresses select: [:anAddress | anAddress streetName = 'San Martin'].
	address := address first.
	
	self assert: (address streetName) equals: 'San Martin'.
	self assert: address streetNumber equals: 3322.
	self assert: address town equals: 'Olivos'.
	self assert: address zipCode equals: 1636.
	self assert: address province equals: 'BsAs'.
	
	customers := session
				select: [:aCustomer | aCustomer identificationType = 'C' 
					and: [aCustomer identificationNumber = '23-25666777-9']] ofType: Customer.
				
	singleCustomer := customers anyOne.
	customerAddresses := singleCustomer addresses.
	
	address := customerAddresses select: [:anAddress | anAddress streetName = 'Alem'].
	address := address first.
	
	self assert: (address streetName) equals: 'Alem'.
	self assert: address streetNumber equals: 1122.
	self assert: address town equals: 'CABA'.
	self assert: address zipCode equals: 1001.
	self assert: address province equals: 'CABA'.				
				
	
	
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'LK 11/16/2023 00:20:03' prior: 50762242!
test02Import

	|singleCustomer selectedCustomers customerAddresses address |

	self importCustomersWithStream: inputFile.
	
	selectedCustomers := session
				select: [:aCustomer | aCustomer identificationType = 'D' 
					and: [aCustomer identificationNumber = '22333444']] ofType: Customer.
		
	singleCustomer := selectedCustomers anyOne.
	customerAddresses := singleCustomer addresses.
	
	self assert: customerAddresses size equals: 2.
	
	address := customerAddresses select: [:anAddress | anAddress streetName = 'Maipu'].
	address := address first.
	
	self assert: (address streetName) equals: 'Maipu'.
	self assert: address streetNumber equals: 888.
	self assert: address town equals: 'Florida'.
	self assert: address zipCode equals: 1122.
	self assert: address province equals: 'Buenos Aires'.
	
	address := customerAddresses select: [:anAddress | anAddress streetName = 'San Martin'].
	address := address first.
	
	self assert: (address streetName) equals: 'San Martin'.
	self assert: address streetNumber equals: 3322.
	self assert: address town equals: 'Olivos'.
	self assert: address zipCode equals: 1636.
	self assert: address province equals: 'BsAs'.
	
	selectedCustomers := session
				select: [:aCustomer | aCustomer identificationType = 'C' 
					and: [aCustomer identificationNumber = '23-25666777-9']] ofType: Customer.
				
	singleCustomer := selectedCustomers anyOne.
	customerAddresses := singleCustomer addresses.
	
	address := customerAddresses select: [:anAddress | anAddress streetName = 'Alem'].
	address := address first.
	
	self assert: (address streetName) equals: 'Alem'.
	self assert: address streetNumber equals: 1122.
	self assert: address town equals: 'CABA'.
	self assert: address zipCode equals: 1001.
	self assert: address province equals: 'CABA'.				
				
	
	
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'LK 11/16/2023 00:20:18' prior: 50762300!
test02Import

	|singleCustomer selectedCustomers customerAddresses singleAddress |

	self importCustomersWithStream: inputFile.
	
	selectedCustomers := session
				select: [:aCustomer | aCustomer identificationType = 'D' 
					and: [aCustomer identificationNumber = '22333444']] ofType: Customer.
		
	singleCustomer := selectedCustomers anyOne.
	customerAddresses := singleCustomer addresses.
	
	self assert: customerAddresses size equals: 2.
	
	singleAddress := customerAddresses select: [:anAddress | anAddress streetName = 'Maipu'].
	singleAddress := singleAddress first.
	
	self assert: (singleAddress streetName) equals: 'Maipu'.
	self assert: singleAddress streetNumber equals: 888.
	self assert: singleAddress town equals: 'Florida'.
	self assert: singleAddress zipCode equals: 1122.
	self assert: singleAddress province equals: 'Buenos Aires'.
	
	singleAddress := customerAddresses select: [:anAddress | anAddress streetName = 'San Martin'].
	singleAddress := singleAddress first.
	
	self assert: (singleAddress streetName) equals: 'San Martin'.
	self assert: singleAddress streetNumber equals: 3322.
	self assert: singleAddress town equals: 'Olivos'.
	self assert: singleAddress zipCode equals: 1636.
	self assert: singleAddress province equals: 'BsAs'.
	
	selectedCustomers := session
				select: [:aCustomer | aCustomer identificationType = 'C' 
					and: [aCustomer identificationNumber = '23-25666777-9']] ofType: Customer.
				
	singleCustomer := selectedCustomers anyOne.
	customerAddresses := singleCustomer addresses.
	
	singleAddress := customerAddresses select: [:anAddress | anAddress streetName = 'Alem'].
	singleAddress := singleAddress first.
	
	self assert: (singleAddress streetName) equals: 'Alem'.
	self assert: singleAddress streetNumber equals: 1122.
	self assert: singleAddress town equals: 'CABA'.
	self assert: singleAddress zipCode equals: 1001.
	self assert: singleAddress province equals: 'CABA'.				
				
	
	
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'LK 11/16/2023 00:20:25' prior: 50762360!
test02Import

	|selectedCustomers customerAddresses singleAddress singleCustomer|

	self importCustomersWithStream: inputFile.
	
	selectedCustomers := session
				select: [:aCustomer | aCustomer identificationType = 'D' 
					and: [aCustomer identificationNumber = '22333444']] ofType: Customer.
		
	singleCustomer := selectedCustomers anyOne.
	customerAddresses := singleCustomer addresses.
	
	self assert: customerAddresses size equals: 2.
	
	singleAddress := customerAddresses select: [:anAddress | anAddress streetName = 'Maipu'].
	singleAddress := singleAddress first.
	
	self assert: (singleAddress streetName) equals: 'Maipu'.
	self assert: singleAddress streetNumber equals: 888.
	self assert: singleAddress town equals: 'Florida'.
	self assert: singleAddress zipCode equals: 1122.
	self assert: singleAddress province equals: 'Buenos Aires'.
	
	singleAddress := customerAddresses select: [:anAddress | anAddress streetName = 'San Martin'].
	singleAddress := singleAddress first.
	
	self assert: (singleAddress streetName) equals: 'San Martin'.
	self assert: singleAddress streetNumber equals: 3322.
	self assert: singleAddress town equals: 'Olivos'.
	self assert: singleAddress zipCode equals: 1636.
	self assert: singleAddress province equals: 'BsAs'.
	
	selectedCustomers := session
				select: [:aCustomer | aCustomer identificationType = 'C' 
					and: [aCustomer identificationNumber = '23-25666777-9']] ofType: Customer.
				
	singleCustomer := selectedCustomers anyOne.
	customerAddresses := singleCustomer addresses.
	
	singleAddress := customerAddresses select: [:anAddress | anAddress streetName = 'Alem'].
	singleAddress := singleAddress first.
	
	self assert: (singleAddress streetName) equals: 'Alem'.
	self assert: singleAddress streetNumber equals: 1122.
	self assert: singleAddress town equals: 'CABA'.
	self assert: singleAddress zipCode equals: 1001.
	self assert: singleAddress province equals: 'CABA'.				
				
	
	
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'LK 11/16/2023 00:21:28'!
assertGivenCustomer: customer

	self assert: customer firstName equals: 'Pepe'.
	self assert: customer lastName equals: 'Sanchez'.
	self assert: customer identificationType equals: 'D'.
	self assert: customer identificationNumber equals: '22333444'! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'LK 11/16/2023 00:21:28' prior: 50762078!
test01Import

	|numberOfCustomers customer customers addresses|

	self importCustomersWithStream: inputFile.
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	self assert: numberOfCustomers equals: 2.
	
	customers := session
				select: [:aCustomer | aCustomer identificationType = 'D' 
					and: [aCustomer identificationNumber = '22333444']] ofType: Customer.
		
	self assert: customers size equals: 1.
	customer := customers anyOne.
	self assertGivenCustomer: customer.
	
	addresses := customer addresses.
	
	self assert: addresses size equals: 2.
	
	customers := session
				select: [:aCustomer | aCustomer identificationType = 'C' 
					and: [aCustomer identificationNumber = '23-25666777-9']] ofType: Customer.
				
	self assert: customers size equals: 1.
	customer := customers anyOne.
	self assert: customer firstName equals: 'Juan'.
	self assert: customer lastName equals: 'Perez'.
	self assert: customer identificationType equals: 'C'.
	self assert: customer identificationNumber equals: '23-25666777-9'.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'LK 11/16/2023 00:22:00'!
assertGivenCustomer: customer hasName: aName 

	self assert: customer firstName equals: 'Pepe'.
	self assert: customer lastName equals: 'Sanchez'.
	self assert: customer identificationType equals: 'D'.
	self assert: customer identificationNumber equals: '22333444'! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'LK 11/16/2023 00:22:00' prior: 50762499!
test01Import

	|numberOfCustomers customer customers addresses|

	self importCustomersWithStream: inputFile.
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	self assert: numberOfCustomers equals: 2.
	
	customers := session
				select: [:aCustomer | aCustomer identificationType = 'D' 
					and: [aCustomer identificationNumber = '22333444']] ofType: Customer.
		
	self assert: customers size equals: 1.
	customer := customers anyOne.
	self assertGivenCustomer: customer hasName: 'Pepe'.
	
	addresses := customer addresses.
	
	self assert: addresses size equals: 2.
	
	customers := session
				select: [:aCustomer | aCustomer identificationType = 'C' 
					and: [aCustomer identificationNumber = '23-25666777-9']] ofType: Customer.
				
	self assert: customers size equals: 1.
	customer := customers anyOne.
	self assert: customer firstName equals: 'Juan'.
	self assert: customer lastName equals: 'Perez'.
	self assert: customer identificationType equals: 'C'.
	self assert: customer identificationNumber equals: '23-25666777-9'.! !

!methodRemoval: ImportTest #assertGivenCustomer: stamp: 'LK 11/16/2023 00:22:00'!
assertGivenCustomer: customer

	self assert: customer firstName equals: 'Pepe'.
	self assert: customer lastName equals: 'Sanchez'.
	self assert: customer identificationType equals: 'D'.
	self assert: customer identificationNumber equals: '22333444'!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'LK 11/16/2023 00:22:00' prior: 50762534!
assertGivenCustomer: customer hasName: aName 

	self assert: customer firstName equals: aName.
	self assert: customer lastName equals: 'Sanchez'.
	self assert: customer identificationType equals: 'D'.
	self assert: customer identificationNumber equals: '22333444'! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'LK 11/16/2023 00:22:21'!
assertGivenCustomer: customer hasName: aName andLastName: aLastName  

	self assert: customer firstName equals: aName.
	self assert: customer lastName equals: 'Sanchez'.
	self assert: customer identificationType equals: 'D'.
	self assert: customer identificationNumber equals: '22333444'! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'LK 11/16/2023 00:22:21' prior: 50762546!
test01Import

	|numberOfCustomers customer customers addresses|

	self importCustomersWithStream: inputFile.
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	self assert: numberOfCustomers equals: 2.
	
	customers := session
				select: [:aCustomer | aCustomer identificationType = 'D' 
					and: [aCustomer identificationNumber = '22333444']] ofType: Customer.
		
	self assert: customers size equals: 1.
	customer := customers anyOne.
	self assertGivenCustomer: customer hasName: 'Pepe' andLastName: 'Sanchez'.
	
	addresses := customer addresses.
	
	self assert: addresses size equals: 2.
	
	customers := session
				select: [:aCustomer | aCustomer identificationType = 'C' 
					and: [aCustomer identificationNumber = '23-25666777-9']] ofType: Customer.
				
	self assert: customers size equals: 1.
	customer := customers anyOne.
	self assert: customer firstName equals: 'Juan'.
	self assert: customer lastName equals: 'Perez'.
	self assert: customer identificationType equals: 'C'.
	self assert: customer identificationNumber equals: '23-25666777-9'.! !

!methodRemoval: ImportTest #assertGivenCustomer:hasName: stamp: 'LK 11/16/2023 00:22:21'!
assertGivenCustomer: customer hasName: aName 

	self assert: customer firstName equals: aName.
	self assert: customer lastName equals: 'Sanchez'.
	self assert: customer identificationType equals: 'D'.
	self assert: customer identificationNumber equals: '22333444'!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'LK 11/16/2023 00:22:21' prior: 50762604!
assertGivenCustomer: customer hasName: aName andLastName: aLastName  

	self assert: customer firstName equals: aName.
	self assert: customer lastName equals: aLastName.
	self assert: customer identificationType equals: 'D'.
	self assert: customer identificationNumber equals: '22333444'! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'LK 11/16/2023 00:22:48'!
assertGivenCustomer: customer hasName: aName andLastName: aLastName withIDType: anIDType   

	self assert: customer firstName equals: aName.
	self assert: customer lastName equals: aLastName.
	self assert: customer identificationType equals: 'D'.
	self assert: customer identificationNumber equals: '22333444'! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'LK 11/16/2023 00:22:48' prior: 50762617!
test01Import

	|numberOfCustomers customer customers addresses|

	self importCustomersWithStream: inputFile.
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	self assert: numberOfCustomers equals: 2.
	
	customers := session
				select: [:aCustomer | aCustomer identificationType = 'D' 
					and: [aCustomer identificationNumber = '22333444']] ofType: Customer.
		
	self assert: customers size equals: 1.
	customer := customers anyOne.
	self assertGivenCustomer: customer hasName: 'Pepe' andLastName: 'Sanchez' withIDType: 'D'.
	
	addresses := customer addresses.
	
	self assert: addresses size equals: 2.
	
	customers := session
				select: [:aCustomer | aCustomer identificationType = 'C' 
					and: [aCustomer identificationNumber = '23-25666777-9']] ofType: Customer.
				
	self assert: customers size equals: 1.
	customer := customers anyOne.
	self assert: customer firstName equals: 'Juan'.
	self assert: customer lastName equals: 'Perez'.
	self assert: customer identificationType equals: 'C'.
	self assert: customer identificationNumber equals: '23-25666777-9'.! !

!methodRemoval: ImportTest #assertGivenCustomer:hasName:andLastName: stamp: 'LK 11/16/2023 00:22:48'!
assertGivenCustomer: customer hasName: aName andLastName: aLastName  

	self assert: customer firstName equals: aName.
	self assert: customer lastName equals: aLastName.
	self assert: customer identificationType equals: 'D'.
	self assert: customer identificationNumber equals: '22333444'!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'LK 11/16/2023 00:22:48' prior: 50762677!
assertGivenCustomer: customer hasName: aName andLastName: aLastName withIDType: anIDType   

	self assert: customer firstName equals: aName.
	self assert: customer lastName equals: aLastName.
	self assert: customer identificationType equals: anIDType.
	self assert: customer identificationNumber equals: '22333444'! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'LK 11/16/2023 00:23:13'!
assertGivenCustomer: customer hasName: aName andLastName: aLastName withIDType: anIDType andIdNumber: IdNumber    

	self assert: customer firstName equals: aName.
	self assert: customer lastName equals: aLastName.
	self assert: customer identificationType equals: anIDType.
	self assert: customer identificationNumber equals: '22333444'! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'LK 11/16/2023 00:23:14' prior: 50762690!
test01Import

	|numberOfCustomers customer customers addresses|

	self importCustomersWithStream: inputFile.
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	self assert: numberOfCustomers equals: 2.
	
	customers := session
				select: [:aCustomer | aCustomer identificationType = 'D' 
					and: [aCustomer identificationNumber = '22333444']] ofType: Customer.
		
	self assert: customers size equals: 1.
	customer := customers anyOne.
	self assertGivenCustomer: customer hasName: 'Pepe' andLastName: 'Sanchez' withIDType: 'D' andIdNumber: '22333444'.
	
	addresses := customer addresses.
	
	self assert: addresses size equals: 2.
	
	customers := session
				select: [:aCustomer | aCustomer identificationType = 'C' 
					and: [aCustomer identificationNumber = '23-25666777-9']] ofType: Customer.
				
	self assert: customers size equals: 1.
	customer := customers anyOne.
	self assert: customer firstName equals: 'Juan'.
	self assert: customer lastName equals: 'Perez'.
	self assert: customer identificationType equals: 'C'.
	self assert: customer identificationNumber equals: '23-25666777-9'.! !

!methodRemoval: ImportTest #assertGivenCustomer:hasName:andLastName:withIDType: stamp: 'LK 11/16/2023 00:23:14'!
assertGivenCustomer: customer hasName: aName andLastName: aLastName withIDType: anIDType   

	self assert: customer firstName equals: aName.
	self assert: customer lastName equals: aLastName.
	self assert: customer identificationType equals: anIDType.
	self assert: customer identificationNumber equals: '22333444'!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'LK 11/16/2023 00:23:14' prior: 50762753!
assertGivenCustomer: customer hasName: aName andLastName: aLastName withIDType: anIDType andIdNumber: IdNumber    

	self assert: customer firstName equals: aName.
	self assert: customer lastName equals: aLastName.
	self assert: customer identificationType equals: anIDType.
	self assert: customer identificationNumber equals: IdNumber! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'LK 11/16/2023 00:23:23'!
assertGivenCustomer: customer hasName: aName andLastName: aLastName withIdType: anIDType andIdNumber: IdNumber    

	self assert: customer firstName equals: aName.
	self assert: customer lastName equals: aLastName.
	self assert: customer identificationType equals: anIDType.
	self assert: customer identificationNumber equals: IdNumber! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'LK 11/16/2023 00:23:23' prior: 50762767!
test01Import

	|numberOfCustomers customer customers addresses|

	self importCustomersWithStream: inputFile.
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	self assert: numberOfCustomers equals: 2.
	
	customers := session
				select: [:aCustomer | aCustomer identificationType = 'D' 
					and: [aCustomer identificationNumber = '22333444']] ofType: Customer.
		
	self assert: customers size equals: 1.
	customer := customers anyOne.
	self assertGivenCustomer: customer hasName: 'Pepe' andLastName: 'Sanchez' withIdType: 'D' andIdNumber: '22333444'.
	
	addresses := customer addresses.
	
	self assert: addresses size equals: 2.
	
	customers := session
				select: [:aCustomer | aCustomer identificationType = 'C' 
					and: [aCustomer identificationNumber = '23-25666777-9']] ofType: Customer.
				
	self assert: customers size equals: 1.
	customer := customers anyOne.
	self assert: customer firstName equals: 'Juan'.
	self assert: customer lastName equals: 'Perez'.
	self assert: customer identificationType equals: 'C'.
	self assert: customer identificationNumber equals: '23-25666777-9'.! !

!methodRemoval: ImportTest #assertGivenCustomer:hasName:andLastName:withIDType:andIdNumber: stamp: 'LK 11/16/2023 00:23:23'!
assertGivenCustomer: customer hasName: aName andLastName: aLastName withIDType: anIDType andIdNumber: IdNumber    

	self assert: customer firstName equals: aName.
	self assert: customer lastName equals: aLastName.
	self assert: customer identificationType equals: anIDType.
	self assert: customer identificationNumber equals: IdNumber!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'LK 11/16/2023 00:23:39' prior: 50762847!
test01Import

	|numberOfCustomers customer customers addresses|

	self importCustomersWithStream: inputFile.
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	self assert: numberOfCustomers equals: 2.
	
	customers := session
				select: [:aCustomer | aCustomer identificationType = 'D' 
					and: [aCustomer identificationNumber = '22333444']] ofType: Customer.
		
	self assert: customers size equals: 1.
	customer := customers anyOne.
	
	self assertGivenCustomer: customer hasName: 'Pepe' andLastName: 'Sanchez' withIdType: 'D' andIdNumber: '22333444'.
	
	addresses := customer addresses.
	
	self assert: addresses size equals: 2.
	
	customers := session
				select: [:aCustomer | aCustomer identificationType = 'C' 
					and: [aCustomer identificationNumber = '23-25666777-9']] ofType: Customer.
				
	self assert: customers size equals: 1.
	customer := customers anyOne.
	self assert: customer firstName equals: 'Juan'.
	self assert: customer lastName equals: 'Perez'.
	self assert: customer identificationType equals: 'C'.
	self assert: customer identificationNumber equals: '23-25666777-9'.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'LK 11/16/2023 00:24:41' prior: 50762900!
test01Import

	|numberOfCustomers customer customers addresses|

	self importCustomersWithStream: inputFile.
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	self assert: numberOfCustomers equals: 2.
	
	customers := session
				select: [:aCustomer | aCustomer identificationType = 'D' 
					and: [aCustomer identificationNumber = '22333444']] ofType: Customer.
		
	self assert: customers size equals: 1.
	customer := customers anyOne.
	
	self assertGivenCustomer: customer hasName: 'Pepe' andLastName: 'Sanchez' withIdType: 'D' andIdNumber: '22333444'.
	
	addresses := customer addresses.
	
	self assert: addresses size equals: 2.
	
	customers := session
				select: [:aCustomer | aCustomer identificationType = 'C' 
					and: [aCustomer identificationNumber = '23-25666777-9']] ofType: Customer.
				
	self assert: customers size equals: 1.
	customer := customers anyOne.
	
	self assertGivenCustomer: customer hasName: 'Juan'andLastName: 'Perez'  withIdType: 'C' andIdNumber: '23-25666777-9'.! !

!testRun: #ImportTest #test01Import stamp: 'LK 11/16/2023 00:24:43'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'LK 11/16/2023 00:24:44'!
PASSED!

!testRun: #ImportTest #test02Import stamp: 'LK 11/16/2023 00:24:44'!
PASSED!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'LK 11/16/2023 00:26:51'!
assertGivenAddress: singleAddress

	self assert: (singleAddress streetName) equals: 'Maipu'.
	self assert: singleAddress streetNumber equals: 888.
	self assert: singleAddress town equals: 'Florida'.
	self assert: singleAddress zipCode equals: 1122.
	self assert: singleAddress province equals: 'Buenos Aires'! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'LK 11/16/2023 00:26:52' prior: 50762424!
test02Import

	|selectedCustomers customerAddresses singleAddress singleCustomer|

	self importCustomersWithStream: inputFile.
	
	selectedCustomers := session
				select: [:aCustomer | aCustomer identificationType = 'D' 
					and: [aCustomer identificationNumber = '22333444']] ofType: Customer.
		
	singleCustomer := selectedCustomers anyOne.
	customerAddresses := singleCustomer addresses.
	
	self assert: customerAddresses size equals: 2.
	
	singleAddress := customerAddresses select: [:anAddress | anAddress streetName = 'Maipu'].
	singleAddress := singleAddress first.
	
	self assertGivenAddress: singleAddress.
	
	singleAddress := customerAddresses select: [:anAddress | anAddress streetName = 'San Martin'].
	singleAddress := singleAddress first.
	
	self assert: (singleAddress streetName) equals: 'San Martin'.
	self assert: singleAddress streetNumber equals: 3322.
	self assert: singleAddress town equals: 'Olivos'.
	self assert: singleAddress zipCode equals: 1636.
	self assert: singleAddress province equals: 'BsAs'.
	
	selectedCustomers := session
				select: [:aCustomer | aCustomer identificationType = 'C' 
					and: [aCustomer identificationNumber = '23-25666777-9']] ofType: Customer.
				
	singleCustomer := selectedCustomers anyOne.
	customerAddresses := singleCustomer addresses.
	
	singleAddress := customerAddresses select: [:anAddress | anAddress streetName = 'Alem'].
	singleAddress := singleAddress first.
	
	self assert: (singleAddress streetName) equals: 'Alem'.
	self assert: singleAddress streetNumber equals: 1122.
	self assert: singleAddress town equals: 'CABA'.
	self assert: singleAddress zipCode equals: 1001.
	self assert: singleAddress province equals: 'CABA'.				
				
	
	
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'LK 11/16/2023 00:27:14'!
assertGivenAddress: singleAddress hasName: aStreetName 

	self assert: (singleAddress streetName) equals: 'Maipu'.
	self assert: singleAddress streetNumber equals: 888.
	self assert: singleAddress town equals: 'Florida'.
	self assert: singleAddress zipCode equals: 1122.
	self assert: singleAddress province equals: 'Buenos Aires'! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'LK 11/16/2023 00:27:14' prior: 50762993!
test02Import

	|selectedCustomers customerAddresses singleAddress singleCustomer|

	self importCustomersWithStream: inputFile.
	
	selectedCustomers := session
				select: [:aCustomer | aCustomer identificationType = 'D' 
					and: [aCustomer identificationNumber = '22333444']] ofType: Customer.
		
	singleCustomer := selectedCustomers anyOne.
	customerAddresses := singleCustomer addresses.
	
	self assert: customerAddresses size equals: 2.
	
	singleAddress := customerAddresses select: [:anAddress | anAddress streetName = 'Maipu'].
	singleAddress := singleAddress first.
	
	self assertGivenAddress: singleAddress hasName: 'Maipu'.
	
	singleAddress := customerAddresses select: [:anAddress | anAddress streetName = 'San Martin'].
	singleAddress := singleAddress first.
	
	self assert: (singleAddress streetName) equals: 'San Martin'.
	self assert: singleAddress streetNumber equals: 3322.
	self assert: singleAddress town equals: 'Olivos'.
	self assert: singleAddress zipCode equals: 1636.
	self assert: singleAddress province equals: 'BsAs'.
	
	selectedCustomers := session
				select: [:aCustomer | aCustomer identificationType = 'C' 
					and: [aCustomer identificationNumber = '23-25666777-9']] ofType: Customer.
				
	singleCustomer := selectedCustomers anyOne.
	customerAddresses := singleCustomer addresses.
	
	singleAddress := customerAddresses select: [:anAddress | anAddress streetName = 'Alem'].
	singleAddress := singleAddress first.
	
	self assert: (singleAddress streetName) equals: 'Alem'.
	self assert: singleAddress streetNumber equals: 1122.
	self assert: singleAddress town equals: 'CABA'.
	self assert: singleAddress zipCode equals: 1001.
	self assert: singleAddress province equals: 'CABA'.				
				
	
	
	! !

!methodRemoval: ImportTest #assertGivenAddress: stamp: 'LK 11/16/2023 00:27:14'!
assertGivenAddress: singleAddress

	self assert: (singleAddress streetName) equals: 'Maipu'.
	self assert: singleAddress streetNumber equals: 888.
	self assert: singleAddress town equals: 'Florida'.
	self assert: singleAddress zipCode equals: 1122.
	self assert: singleAddress province equals: 'Buenos Aires'!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'LK 11/16/2023 00:27:14' prior: 50763050!
assertGivenAddress: singleAddress hasName: aStreetName 

	self assert: (singleAddress streetName) equals: aStreetName.
	self assert: singleAddress streetNumber equals: 888.
	self assert: singleAddress town equals: 'Florida'.
	self assert: singleAddress zipCode equals: 1122.
	self assert: singleAddress province equals: 'Buenos Aires'! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'LK 11/16/2023 00:27:42'!
assertGivenAddress: singleAddress hasName: aStreetName withNumber: aStreetNumber  

	self assert: (singleAddress streetName) equals: aStreetName.
	self assert: singleAddress streetNumber equals: 888.
	self assert: singleAddress town equals: 'Florida'.
	self assert: singleAddress zipCode equals: 1122.
	self assert: singleAddress province equals: 'Buenos Aires'! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'LK 11/16/2023 00:27:42' prior: 50763064!
test02Import

	|selectedCustomers customerAddresses singleAddress singleCustomer|

	self importCustomersWithStream: inputFile.
	
	selectedCustomers := session
				select: [:aCustomer | aCustomer identificationType = 'D' 
					and: [aCustomer identificationNumber = '22333444']] ofType: Customer.
		
	singleCustomer := selectedCustomers anyOne.
	customerAddresses := singleCustomer addresses.
	
	self assert: customerAddresses size equals: 2.
	
	singleAddress := customerAddresses select: [:anAddress | anAddress streetName = 'Maipu'].
	singleAddress := singleAddress first.
	
	self assertGivenAddress: singleAddress hasName: 'Maipu' withNumber: 888.
	
	singleAddress := customerAddresses select: [:anAddress | anAddress streetName = 'San Martin'].
	singleAddress := singleAddress first.
	
	self assert: (singleAddress streetName) equals: 'San Martin'.
	self assert: singleAddress streetNumber equals: 3322.
	self assert: singleAddress town equals: 'Olivos'.
	self assert: singleAddress zipCode equals: 1636.
	self assert: singleAddress province equals: 'BsAs'.
	
	selectedCustomers := session
				select: [:aCustomer | aCustomer identificationType = 'C' 
					and: [aCustomer identificationNumber = '23-25666777-9']] ofType: Customer.
				
	singleCustomer := selectedCustomers anyOne.
	customerAddresses := singleCustomer addresses.
	
	singleAddress := customerAddresses select: [:anAddress | anAddress streetName = 'Alem'].
	singleAddress := singleAddress first.
	
	self assert: (singleAddress streetName) equals: 'Alem'.
	self assert: singleAddress streetNumber equals: 1122.
	self assert: singleAddress town equals: 'CABA'.
	self assert: singleAddress zipCode equals: 1001.
	self assert: singleAddress province equals: 'CABA'.				
				
	
	
	! !

!methodRemoval: ImportTest #assertGivenAddress:hasName: stamp: 'LK 11/16/2023 00:27:42'!
assertGivenAddress: singleAddress hasName: aStreetName 

	self assert: (singleAddress streetName) equals: aStreetName.
	self assert: singleAddress streetNumber equals: 888.
	self assert: singleAddress town equals: 'Florida'.
	self assert: singleAddress zipCode equals: 1122.
	self assert: singleAddress province equals: 'Buenos Aires'!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'LK 11/16/2023 00:27:42' prior: 50763148!
assertGivenAddress: singleAddress hasName: aStreetName withNumber: aStreetNumber  

	self assert: (singleAddress streetName) equals: aStreetName.
	self assert: singleAddress streetNumber equals: aStreetNumber.
	self assert: singleAddress town equals: 'Florida'.
	self assert: singleAddress zipCode equals: 1122.
	self assert: singleAddress province equals: 'Buenos Aires'! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'LK 11/16/2023 00:28:05'!
assertGivenAddress: singleAddress hasName: aStreetName withNumber: aStreetNumber inTown: aTown   

	self assert: (singleAddress streetName) equals: aStreetName.
	self assert: singleAddress streetNumber equals: aStreetNumber.
	self assert: singleAddress town equals: 'Florida'.
	self assert: singleAddress zipCode equals: 1122.
	self assert: singleAddress province equals: 'Buenos Aires'! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'LK 11/16/2023 00:28:05' prior: 50763163!
test02Import

	|selectedCustomers customerAddresses singleAddress singleCustomer|

	self importCustomersWithStream: inputFile.
	
	selectedCustomers := session
				select: [:aCustomer | aCustomer identificationType = 'D' 
					and: [aCustomer identificationNumber = '22333444']] ofType: Customer.
		
	singleCustomer := selectedCustomers anyOne.
	customerAddresses := singleCustomer addresses.
	
	self assert: customerAddresses size equals: 2.
	
	singleAddress := customerAddresses select: [:anAddress | anAddress streetName = 'Maipu'].
	singleAddress := singleAddress first.
	
	self assertGivenAddress: singleAddress hasName: 'Maipu' withNumber: 888 inTown: 'Florida'.
	
	singleAddress := customerAddresses select: [:anAddress | anAddress streetName = 'San Martin'].
	singleAddress := singleAddress first.
	
	self assert: (singleAddress streetName) equals: 'San Martin'.
	self assert: singleAddress streetNumber equals: 3322.
	self assert: singleAddress town equals: 'Olivos'.
	self assert: singleAddress zipCode equals: 1636.
	self assert: singleAddress province equals: 'BsAs'.
	
	selectedCustomers := session
				select: [:aCustomer | aCustomer identificationType = 'C' 
					and: [aCustomer identificationNumber = '23-25666777-9']] ofType: Customer.
				
	singleCustomer := selectedCustomers anyOne.
	customerAddresses := singleCustomer addresses.
	
	singleAddress := customerAddresses select: [:anAddress | anAddress streetName = 'Alem'].
	singleAddress := singleAddress first.
	
	self assert: (singleAddress streetName) equals: 'Alem'.
	self assert: singleAddress streetNumber equals: 1122.
	self assert: singleAddress town equals: 'CABA'.
	self assert: singleAddress zipCode equals: 1001.
	self assert: singleAddress province equals: 'CABA'.				
				
	
	
	! !

!methodRemoval: ImportTest #assertGivenAddress:hasName:withNumber: stamp: 'LK 11/16/2023 00:28:06'!
assertGivenAddress: singleAddress hasName: aStreetName withNumber: aStreetNumber  

	self assert: (singleAddress streetName) equals: aStreetName.
	self assert: singleAddress streetNumber equals: aStreetNumber.
	self assert: singleAddress town equals: 'Florida'.
	self assert: singleAddress zipCode equals: 1122.
	self assert: singleAddress province equals: 'Buenos Aires'!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'LK 11/16/2023 00:28:06' prior: 50763249!
assertGivenAddress: singleAddress hasName: aStreetName withNumber: aStreetNumber inTown: aTown   

	self assert: (singleAddress streetName) equals: aStreetName.
	self assert: singleAddress streetNumber equals: aStreetNumber.
	self assert: singleAddress town equals: aTown.
	self assert: singleAddress zipCode equals: 1122.
	self assert: singleAddress province equals: 'Buenos Aires'! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'LK 11/16/2023 00:28:19'!
assertGivenAddress: singleAddress hasName: aStreetName withNumber: aStreetNumber inTown: aTown withZipCode: aZipCode    

	self assert: (singleAddress streetName) equals: aStreetName.
	self assert: singleAddress streetNumber equals: aStreetNumber.
	self assert: singleAddress town equals: aTown.
	self assert: singleAddress zipCode equals: 1122.
	self assert: singleAddress province equals: 'Buenos Aires'! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'LK 11/16/2023 00:28:19' prior: 50763265!
test02Import

	|selectedCustomers customerAddresses singleAddress singleCustomer|

	self importCustomersWithStream: inputFile.
	
	selectedCustomers := session
				select: [:aCustomer | aCustomer identificationType = 'D' 
					and: [aCustomer identificationNumber = '22333444']] ofType: Customer.
		
	singleCustomer := selectedCustomers anyOne.
	customerAddresses := singleCustomer addresses.
	
	self assert: customerAddresses size equals: 2.
	
	singleAddress := customerAddresses select: [:anAddress | anAddress streetName = 'Maipu'].
	singleAddress := singleAddress first.
	
	self assertGivenAddress: singleAddress hasName: 'Maipu' withNumber: 888 inTown: 'Florida' withZipCode: 1122.
	
	singleAddress := customerAddresses select: [:anAddress | anAddress streetName = 'San Martin'].
	singleAddress := singleAddress first.
	
	self assert: (singleAddress streetName) equals: 'San Martin'.
	self assert: singleAddress streetNumber equals: 3322.
	self assert: singleAddress town equals: 'Olivos'.
	self assert: singleAddress zipCode equals: 1636.
	self assert: singleAddress province equals: 'BsAs'.
	
	selectedCustomers := session
				select: [:aCustomer | aCustomer identificationType = 'C' 
					and: [aCustomer identificationNumber = '23-25666777-9']] ofType: Customer.
				
	singleCustomer := selectedCustomers anyOne.
	customerAddresses := singleCustomer addresses.
	
	singleAddress := customerAddresses select: [:anAddress | anAddress streetName = 'Alem'].
	singleAddress := singleAddress first.
	
	self assert: (singleAddress streetName) equals: 'Alem'.
	self assert: singleAddress streetNumber equals: 1122.
	self assert: singleAddress town equals: 'CABA'.
	self assert: singleAddress zipCode equals: 1001.
	self assert: singleAddress province equals: 'CABA'.				
				
	
	
	! !

!methodRemoval: ImportTest #assertGivenAddress:hasName:withNumber:inTown: stamp: 'LK 11/16/2023 00:28:19'!
assertGivenAddress: singleAddress hasName: aStreetName withNumber: aStreetNumber inTown: aTown   

	self assert: (singleAddress streetName) equals: aStreetName.
	self assert: singleAddress streetNumber equals: aStreetNumber.
	self assert: singleAddress town equals: aTown.
	self assert: singleAddress zipCode equals: 1122.
	self assert: singleAddress province equals: 'Buenos Aires'!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'LK 11/16/2023 00:28:19' prior: 50763353!
assertGivenAddress: singleAddress hasName: aStreetName withNumber: aStreetNumber inTown: aTown withZipCode: aZipCode    

	self assert: (singleAddress streetName) equals: aStreetName.
	self assert: singleAddress streetNumber equals: aStreetNumber.
	self assert: singleAddress town equals: aTown.
	self assert: singleAddress zipCode equals: aZipCode.
	self assert: singleAddress province equals: 'Buenos Aires'! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'LK 11/16/2023 00:28:43'!
assertGivenAddress: singleAddress hasName: aStreetName withNumber: aStreetNumber inTown: aTown withZipCode: aZipCode withProvince: aProvince     

	self assert: (singleAddress streetName) equals: aStreetName.
	self assert: singleAddress streetNumber equals: aStreetNumber.
	self assert: singleAddress town equals: aTown.
	self assert: singleAddress zipCode equals: aZipCode.
	self assert: singleAddress province equals: 'Buenos Aires'! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'LK 11/16/2023 00:28:43' prior: 50763369!
test02Import

	|selectedCustomers customerAddresses singleAddress singleCustomer|

	self importCustomersWithStream: inputFile.
	
	selectedCustomers := session
				select: [:aCustomer | aCustomer identificationType = 'D' 
					and: [aCustomer identificationNumber = '22333444']] ofType: Customer.
		
	singleCustomer := selectedCustomers anyOne.
	customerAddresses := singleCustomer addresses.
	
	self assert: customerAddresses size equals: 2.
	
	singleAddress := customerAddresses select: [:anAddress | anAddress streetName = 'Maipu'].
	singleAddress := singleAddress first.
	
	self assertGivenAddress: singleAddress hasName: 'Maipu' withNumber: 888 inTown: 'Florida' withZipCode: 1122 withProvince: 'Buenos Aires'.
	
	singleAddress := customerAddresses select: [:anAddress | anAddress streetName = 'San Martin'].
	singleAddress := singleAddress first.
	
	self assert: (singleAddress streetName) equals: 'San Martin'.
	self assert: singleAddress streetNumber equals: 3322.
	self assert: singleAddress town equals: 'Olivos'.
	self assert: singleAddress zipCode equals: 1636.
	self assert: singleAddress province equals: 'BsAs'.
	
	selectedCustomers := session
				select: [:aCustomer | aCustomer identificationType = 'C' 
					and: [aCustomer identificationNumber = '23-25666777-9']] ofType: Customer.
				
	singleCustomer := selectedCustomers anyOne.
	customerAddresses := singleCustomer addresses.
	
	singleAddress := customerAddresses select: [:anAddress | anAddress streetName = 'Alem'].
	singleAddress := singleAddress first.
	
	self assert: (singleAddress streetName) equals: 'Alem'.
	self assert: singleAddress streetNumber equals: 1122.
	self assert: singleAddress town equals: 'CABA'.
	self assert: singleAddress zipCode equals: 1001.
	self assert: singleAddress province equals: 'CABA'.				
				
	
	
	! !

!methodRemoval: ImportTest #assertGivenAddress:hasName:withNumber:inTown:withZipCode: stamp: 'LK 11/16/2023 00:28:43'!
assertGivenAddress: singleAddress hasName: aStreetName withNumber: aStreetNumber inTown: aTown withZipCode: aZipCode    

	self assert: (singleAddress streetName) equals: aStreetName.
	self assert: singleAddress streetNumber equals: aStreetNumber.
	self assert: singleAddress town equals: aTown.
	self assert: singleAddress zipCode equals: aZipCode.
	self assert: singleAddress province equals: 'Buenos Aires'!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'LK 11/16/2023 00:28:43' prior: 50763460!
assertGivenAddress: singleAddress hasName: aStreetName withNumber: aStreetNumber inTown: aTown withZipCode: aZipCode withProvince: aProvince     

	self assert: (singleAddress streetName) equals: aStreetName.
	self assert: singleAddress streetNumber equals: aStreetNumber.
	self assert: singleAddress town equals: aTown.
	self assert: singleAddress zipCode equals: aZipCode.
	self assert: singleAddress province equals: aProvince! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'LK 11/16/2023 00:29:50' prior: 50762938!
test01Import

	|numberOfCustomers customer customers |

	self importCustomersWithStream: inputFile.
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	self assert: numberOfCustomers equals: 2.
	
	customers := session
				select: [:aCustomer | aCustomer identificationType = 'D' 
					and: [aCustomer identificationNumber = '22333444']] ofType: Customer.
		
	self assert: customers size equals: 1.
	customer := customers anyOne.
	
	self assertGivenCustomer: customer hasName: 'Pepe' andLastName: 'Sanchez' withIdType: 'D' andIdNumber: '22333444'.
	
	customers := session
				select: [:aCustomer | aCustomer identificationType = 'C' 
					and: [aCustomer identificationNumber = '23-25666777-9']] ofType: Customer.
				
	self assert: customers size equals: 1.
	customer := customers anyOne.
	
	self assertGivenCustomer: customer hasName: 'Juan'andLastName: 'Perez'  withIdType: 'C' andIdNumber: '23-25666777-9'.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'LK 11/16/2023 00:29:58' prior: 50763571!
test01Import

	|numberOfCustomers singleCustomer customers |

	self importCustomersWithStream: inputFile.
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	self assert: numberOfCustomers equals: 2.
	
	customers := session
				select: [:aCustomer | aCustomer identificationType = 'D' 
					and: [aCustomer identificationNumber = '22333444']] ofType: Customer.
		
	self assert: customers size equals: 1.
	singleCustomer := customers anyOne.
	
	self assertGivenCustomer: singleCustomer hasName: 'Pepe' andLastName: 'Sanchez' withIdType: 'D' andIdNumber: '22333444'.
	
	customers := session
				select: [:aCustomer | aCustomer identificationType = 'C' 
					and: [aCustomer identificationNumber = '23-25666777-9']] ofType: Customer.
				
	self assert: customers size equals: 1.
	singleCustomer := customers anyOne.
	
	self assertGivenCustomer: singleCustomer hasName: 'Juan'andLastName: 'Perez'  withIdType: 'C' andIdNumber: '23-25666777-9'.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'LK 11/16/2023 00:32:10' prior: 50763477!
test02Import

	|selectedCustomers customerAddresses singleAddress singleCustomer|

	self importCustomersWithStream: inputFile.
	
	selectedCustomers := session
				select: [:aCustomer | aCustomer identificationType = 'D' 
					and: [aCustomer identificationNumber = '22333444']] ofType: Customer.
		
	singleCustomer := selectedCustomers anyOne.
	customerAddresses := singleCustomer addresses.
	
	self assert: customerAddresses size equals: 2.
	
	singleAddress := customerAddresses select: [:anAddress | anAddress streetName = 'Maipu'].
	singleAddress := singleAddress first.
	
	self assertGivenAddress: singleAddress hasName: 'Maipu' withNumber: 888 inTown: 'Florida' withZipCode: 1122 withProvince: 'Buenos Aires'.
	
	singleAddress := customerAddresses select: [:anAddress | anAddress streetName = 'San Martin'].
	singleAddress := singleAddress first.
	
	self assertGivenAddress: singleAddress hasName: 'San Martin' withNumber: 3322 inTown: 'Olivos' withZipCode:  1636 withProvince:  'BsAs'.
	
	selectedCustomers := session
				select: [:aCustomer | aCustomer identificationType = 'C' 
					and: [aCustomer identificationNumber = '23-25666777-9']] ofType: Customer.
				
	singleCustomer := selectedCustomers anyOne.
	customerAddresses := singleCustomer addresses.
	
	singleAddress := customerAddresses select: [:anAddress | anAddress streetName = 'Alem'].
	singleAddress := singleAddress first.
	
	self assertGivenAddress: singleAddress hasName: 'Alem' withNumber: 1122 inTown: 'CABA' withZipCode: 1001 withProvince: 'CABA'.

	
	
	! !

!testRun: #ImportTest #test02Import stamp: 'LK 11/16/2023 00:32:11'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'LK 11/16/2023 00:32:12'!
PASSED!

!testRun: #ImportTest #test02Import stamp: 'LK 11/16/2023 00:32:13'!
PASSED!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'LK 11/16/2023 00:45:59'!
getPepeFromSession

	^ session
				select: [:aCustomer | aCustomer identificationType = 'D' 
					and: [aCustomer identificationNumber = '22333444']] ofType: Customer! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'LK 11/16/2023 00:45:59' prior: 50763636!
test02Import

	|selectedCustomers customerAddresses singleAddress singleCustomer|

	self importCustomersWithStream: inputFile.
	
	selectedCustomers := self getPepeFromSession.
		
	singleCustomer := selectedCustomers anyOne.
	customerAddresses := singleCustomer addresses.
	
	self assert: customerAddresses size equals: 2.
	
	singleAddress := customerAddresses select: [:anAddress | anAddress streetName = 'Maipu'].
	singleAddress := singleAddress first.
	
	self assertGivenAddress: singleAddress hasName: 'Maipu' withNumber: 888 inTown: 'Florida' withZipCode: 1122 withProvince: 'Buenos Aires'.
	
	singleAddress := customerAddresses select: [:anAddress | anAddress streetName = 'San Martin'].
	singleAddress := singleAddress first.
	
	self assertGivenAddress: singleAddress hasName: 'San Martin' withNumber: 3322 inTown: 'Olivos' withZipCode:  1636 withProvince:  'BsAs'.
	
	selectedCustomers := session
				select: [:aCustomer | aCustomer identificationType = 'C' 
					and: [aCustomer identificationNumber = '23-25666777-9']] ofType: Customer.
				
	singleCustomer := selectedCustomers anyOne.
	customerAddresses := singleCustomer addresses.
	
	singleAddress := customerAddresses select: [:anAddress | anAddress streetName = 'Alem'].
	singleAddress := singleAddress first.
	
	self assertGivenAddress: singleAddress hasName: 'Alem' withNumber: 1122 inTown: 'CABA' withZipCode: 1001 withProvince: 'CABA'.

	
	
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'LK 11/16/2023 00:45:59' prior: 50763603!
test01Import

	|numberOfCustomers singleCustomer customers |

	self importCustomersWithStream: inputFile.
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	self assert: numberOfCustomers equals: 2.
	
	customers := self getPepeFromSession.
		
	self assert: customers size equals: 1.
	singleCustomer := customers anyOne.
	
	self assertGivenCustomer: singleCustomer hasName: 'Pepe' andLastName: 'Sanchez' withIdType: 'D' andIdNumber: '22333444'.
	
	customers := session
				select: [:aCustomer | aCustomer identificationType = 'C' 
					and: [aCustomer identificationNumber = '23-25666777-9']] ofType: Customer.
				
	self assert: customers size equals: 1.
	singleCustomer := customers anyOne.
	
	self assertGivenCustomer: singleCustomer hasName: 'Juan'andLastName: 'Perez'  withIdType: 'C' andIdNumber: '23-25666777-9'.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'LK 11/16/2023 00:46:27' prior: 50763751!
test01Import

	|numberOfCustomers singleCustomer customers |

	self importCustomersWithStream: inputFile.
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	self assert: numberOfCustomers equals: 2.
	
	customers := self getPepeFromSession.	
	self assert: customers size equals: 1.
	singleCustomer := customers anyOne.
	
	self assertGivenCustomer: singleCustomer hasName: 'Pepe' andLastName: 'Sanchez' withIdType: 'D' andIdNumber: '22333444'.
	
	customers := session
				select: [:aCustomer | aCustomer identificationType = 'C' 
					and: [aCustomer identificationNumber = '23-25666777-9']] ofType: Customer.
				
	self assert: customers size equals: 1.
	singleCustomer := customers anyOne.
	
	self assertGivenCustomer: singleCustomer hasName: 'Juan'andLastName: 'Perez'  withIdType: 'C' andIdNumber: '23-25666777-9'.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'LK 11/16/2023 00:46:35'!
getJuanFromSession

	^ session
				select: [:aCustomer | aCustomer identificationType = 'C' 
					and: [aCustomer identificationNumber = '23-25666777-9']] ofType: Customer! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'LK 11/16/2023 00:46:35' prior: 50763703!
test02Import

	|selectedCustomers customerAddresses singleAddress singleCustomer|

	self importCustomersWithStream: inputFile.
	
	selectedCustomers := self getPepeFromSession.
		
	singleCustomer := selectedCustomers anyOne.
	customerAddresses := singleCustomer addresses.
	
	self assert: customerAddresses size equals: 2.
	
	singleAddress := customerAddresses select: [:anAddress | anAddress streetName = 'Maipu'].
	singleAddress := singleAddress first.
	
	self assertGivenAddress: singleAddress hasName: 'Maipu' withNumber: 888 inTown: 'Florida' withZipCode: 1122 withProvince: 'Buenos Aires'.
	
	singleAddress := customerAddresses select: [:anAddress | anAddress streetName = 'San Martin'].
	singleAddress := singleAddress first.
	
	self assertGivenAddress: singleAddress hasName: 'San Martin' withNumber: 3322 inTown: 'Olivos' withZipCode:  1636 withProvince:  'BsAs'.
	
	selectedCustomers := self getJuanFromSession.
				
	singleCustomer := selectedCustomers anyOne.
	customerAddresses := singleCustomer addresses.
	
	singleAddress := customerAddresses select: [:anAddress | anAddress streetName = 'Alem'].
	singleAddress := singleAddress first.
	
	self assertGivenAddress: singleAddress hasName: 'Alem' withNumber: 1122 inTown: 'CABA' withZipCode: 1001 withProvince: 'CABA'.

	
	
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'LK 11/16/2023 00:46:35' prior: 50763781!
test01Import

	|numberOfCustomers singleCustomer customers |

	self importCustomersWithStream: inputFile.
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	self assert: numberOfCustomers equals: 2.
	
	customers := self getPepeFromSession.	
	self assert: customers size equals: 1.
	singleCustomer := customers anyOne.
	
	self assertGivenCustomer: singleCustomer hasName: 'Pepe' andLastName: 'Sanchez' withIdType: 'D' andIdNumber: '22333444'.
	
	customers := self getJuanFromSession.
				
	self assert: customers size equals: 1.
	singleCustomer := customers anyOne.
	
	self assertGivenCustomer: singleCustomer hasName: 'Juan'andLastName: 'Perez'  withIdType: 'C' andIdNumber: '23-25666777-9'.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'LK 11/16/2023 00:46:56' prior: 50763863!
test01Import

	|numberOfCustomers singleCustomer customers |

	self importCustomersWithStream: inputFile.
	numberOfCustomers := (session selectAllOfType: Customer) size.
	
	self assert: numberOfCustomers equals: 2.
	
	customers := self getPepeFromSession.	
	self assert: customers size equals: 1.
	singleCustomer := customers anyOne.
	
	self assertGivenCustomer: singleCustomer hasName: 'Pepe' andLastName: 'Sanchez' withIdType: 'D' andIdNumber: '22333444'.
	
	customers := self getJuanFromSession.
	self assert: customers size equals: 1.
	singleCustomer := customers anyOne.
	
	self assertGivenCustomer: singleCustomer hasName: 'Juan'andLastName: 'Perez'  withIdType: 'C' andIdNumber: '23-25666777-9'.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'LK 11/16/2023 00:47:31' prior: 50763889!
test01Import

	|numberOfCustomers singleCustomer customers |

	self importCustomersWithStream: inputFile.
	numberOfCustomers := (session selectAllOfType: Customer) size.
	self assert: numberOfCustomers equals: 2.
	
	customers := self getPepeFromSession.	
	self assert: customers size equals: 1.
	
	singleCustomer := customers anyOne.
	self assertGivenCustomer: singleCustomer hasName: 'Pepe' andLastName: 'Sanchez' withIdType: 'D' andIdNumber: '22333444'.
	
	customers := self getJuanFromSession.
	self assert: customers size equals: 1.
	
	singleCustomer := customers anyOne.
	self assertGivenCustomer: singleCustomer hasName: 'Juan'andLastName: 'Perez'  withIdType: 'C' andIdNumber: '23-25666777-9'.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'LK 11/16/2023 00:50:26'!
test01shouldImportCustomers

	|numberOfCustomers singleCustomer customers |

	self importCustomersWithStream: inputFile.
	numberOfCustomers := (session selectAllOfType: Customer) size.
	self assert: numberOfCustomers equals: 2.
	
	customers := self getPepeFromSession.	
	self assert: customers size equals: 1.
	
	singleCustomer := customers anyOne.
	self assertGivenCustomer: singleCustomer hasName: 'Pepe' andLastName: 'Sanchez' withIdType: 'D' andIdNumber: '22333444'.
	
	customers := self getJuanFromSession.
	self assert: customers size equals: 1.
	
	singleCustomer := customers anyOne.
	self assertGivenCustomer: singleCustomer hasName: 'Juan'andLastName: 'Perez'  withIdType: 'C' andIdNumber: '23-25666777-9'.! !

!methodRemoval: ImportTest #test01Import stamp: 'LK 11/16/2023 00:50:27'!
test01Import

	|numberOfCustomers singleCustomer customers |

	self importCustomersWithStream: inputFile.
	numberOfCustomers := (session selectAllOfType: Customer) size.
	self assert: numberOfCustomers equals: 2.
	
	customers := self getPepeFromSession.	
	self assert: customers size equals: 1.
	
	singleCustomer := customers anyOne.
	self assertGivenCustomer: singleCustomer hasName: 'Pepe' andLastName: 'Sanchez' withIdType: 'D' andIdNumber: '22333444'.
	
	customers := self getJuanFromSession.
	self assert: customers size equals: 1.
	
	singleCustomer := customers anyOne.
	self assertGivenCustomer: singleCustomer hasName: 'Juan'andLastName: 'Perez'  withIdType: 'C' andIdNumber: '23-25666777-9'.!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'LK 11/16/2023 00:50:34'!
test02shouldImportAddresses

	|selectedCustomers customerAddresses singleAddress singleCustomer|

	self importCustomersWithStream: inputFile.
	
	selectedCustomers := self getPepeFromSession.
		
	singleCustomer := selectedCustomers anyOne.
	customerAddresses := singleCustomer addresses.
	
	self assert: customerAddresses size equals: 2.
	
	singleAddress := customerAddresses select: [:anAddress | anAddress streetName = 'Maipu'].
	singleAddress := singleAddress first.
	
	self assertGivenAddress: singleAddress hasName: 'Maipu' withNumber: 888 inTown: 'Florida' withZipCode: 1122 withProvince: 'Buenos Aires'.
	
	singleAddress := customerAddresses select: [:anAddress | anAddress streetName = 'San Martin'].
	singleAddress := singleAddress first.
	
	self assertGivenAddress: singleAddress hasName: 'San Martin' withNumber: 3322 inTown: 'Olivos' withZipCode:  1636 withProvince:  'BsAs'.
	
	selectedCustomers := self getJuanFromSession.
				
	singleCustomer := selectedCustomers anyOne.
	customerAddresses := singleCustomer addresses.
	
	singleAddress := customerAddresses select: [:anAddress | anAddress streetName = 'Alem'].
	singleAddress := singleAddress first.
	
	self assertGivenAddress: singleAddress hasName: 'Alem' withNumber: 1122 inTown: 'CABA' withZipCode: 1001 withProvince: 'CABA'.

	
	
	! !

!methodRemoval: ImportTest #test02Import stamp: 'LK 11/16/2023 00:50:35'!
test02Import

	|selectedCustomers customerAddresses singleAddress singleCustomer|

	self importCustomersWithStream: inputFile.
	
	selectedCustomers := self getPepeFromSession.
		
	singleCustomer := selectedCustomers anyOne.
	customerAddresses := singleCustomer addresses.
	
	self assert: customerAddresses size equals: 2.
	
	singleAddress := customerAddresses select: [:anAddress | anAddress streetName = 'Maipu'].
	singleAddress := singleAddress first.
	
	self assertGivenAddress: singleAddress hasName: 'Maipu' withNumber: 888 inTown: 'Florida' withZipCode: 1122 withProvince: 'Buenos Aires'.
	
	singleAddress := customerAddresses select: [:anAddress | anAddress streetName = 'San Martin'].
	singleAddress := singleAddress first.
	
	self assertGivenAddress: singleAddress hasName: 'San Martin' withNumber: 3322 inTown: 'Olivos' withZipCode:  1636 withProvince:  'BsAs'.
	
	selectedCustomers := self getJuanFromSession.
				
	singleCustomer := selectedCustomers anyOne.
	customerAddresses := singleCustomer addresses.
	
	singleAddress := customerAddresses select: [:anAddress | anAddress streetName = 'Alem'].
	singleAddress := singleAddress first.
	
	self assertGivenAddress: singleAddress hasName: 'Alem' withNumber: 1122 inTown: 'CABA' withZipCode: 1001 withProvince: 'CABA'.

	
	
	!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'LK 11/16/2023 00:52:23' prior: 50763990!
test02shouldImportAddresses

	|selectedCustomers customerAddresses singleAddress singleCustomer|

	self importCustomersWithStream: inputFile.
	
	selectedCustomers := self getPepeFromSession.
		
	singleCustomer := selectedCustomers anyOne.
	customerAddresses := singleCustomer addresses.
	
	self assert: customerAddresses size equals: 2.
	
	singleAddress := customerAddresses select: [:anAddress | anAddress streetName = 'Maipu'].
	singleAddress := singleAddress first.
	
	self assertGivenAddress: singleAddress hasName: 'Maipu' withNumber: 888 inTown: 'Florida' withZipCode: 1122 withProvince: 'Buenos Aires'.
	
	singleAddress := customerAddresses select: [:anAddress | anAddress streetName = 'San Martin'].
	singleAddress := singleAddress first.
	
	self assertGivenAddress: singleAddress hasName: 'San Martin' withNumber: 3322 inTown: 'Olivos' withZipCode:  1636 withProvince:  'BsAs'.
	
	selectedCustomers := self getJuanFromSession.
				
	singleCustomer := selectedCustomers anyOne.
	customerAddresses := singleCustomer addresses.
	self assert: customerAddresses size equals: 1.

	singleAddress := customerAddresses select: [:anAddress | anAddress streetName = 'Alem'].
	singleAddress := singleAddress first.
	
	self assertGivenAddress: singleAddress hasName: 'Alem' withNumber: 1122 inTown: 'CABA' withZipCode: 1001 withProvince: 'CABA'.

	
	
	! !

!testRun: #ImportTest #test02shouldImportAddresses stamp: 'LK 11/16/2023 00:52:24'!
PASSED!

!testRun: #ImportTest #test01shouldImportCustomers stamp: 'LK 11/16/2023 00:52:25'!
PASSED!

!testRun: #ImportTest #test02shouldImportAddresses stamp: 'LK 11/16/2023 00:52:26'!
PASSED!
!Address methodsFor: 'province' stamp: 'LK 11/16/2023 00:54:28' overrides: 16901772!
= anAddress

	^(anAddress province = province) & (anAddress streetName = streetName) & (anAddress streetNumber = streetNumber ) & (anAddress town = town) & (anAddress zipCode = zipCode).! !

!classDefinition: #NewMethodObject category: 'CustomerImporter' stamp: 'LK 11/16/2023 01:03:14'!
Object subclass: #NewMethodObject
	instanceVariableNames: 'currentSession inputStream'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!
!NewMethodObject class methodsFor: 'as yet unclassified' stamp: 'LK 11/16/2023 01:03:14'!
fromSession: aSession andInputStream: anAnInputStream
	^self new initializeFromSession: aSession andInputStream: anAnInputStream! !
!NewMethodObject methodsFor: 'as yet unclassified' stamp: 'LK 11/16/2023 01:03:14'!
initializeFromSession: aSession andInputStream: anAnInputStream
	currentSession := aSession.
	inputStream := anAnInputStream.! !
!NewMethodObject methodsFor: 'as yet unclassified' stamp: 'LK 11/16/2023 01:03:15'!
mom

	"
	self importCustomers
	"
	
	| newCustomer line |

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth.
			currentSession persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData sixth].

		line := inputStream nextLine. ].

	inputStream close.
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'LK 11/16/2023 01:03:15' prior: 50761707!
importCustomersWithStream: anInputStream
	(NewMethodObject fromSession: session andInputStream: anInputStream) mom! !

!testRun: #ImportTest #test01shouldImportCustomers stamp: 'LK 11/16/2023 01:03:37'!
PASSED!

!testRun: #ImportTest #test02shouldImportAddresses stamp: 'LK 11/16/2023 01:03:39'!
PASSED!

!classRenamed: #NewMethodObject as: #ImportCustomer stamp: 'LK 11/16/2023 01:05:08'!
Smalltalk renameClassNamed: #NewMethodObject as: #ImportCustomer!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'LK 11/16/2023 01:05:09' prior: 50764196!
importCustomersWithStream: anInputStream
	(ImportCustomer fromSession: session andInputStream: anInputStream) mom! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'LK 11/16/2023 01:05:39'!
importCustomersWithStream
	(ImportCustomer fromSession: session andInputStream: inputFile) mom! !

!methodRemoval: ImportTest #importCustomersWithStream: stamp: 'LK 11/16/2023 01:05:42'!
importCustomersWithStream: anInputStream
	(ImportCustomer fromSession: session andInputStream: anInputStream) mom!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'LK 11/16/2023 01:05:48' prior: 50763940!
test01shouldImportCustomers

	|numberOfCustomers singleCustomer customers |

	self importCustomersWithStream.
	numberOfCustomers := (session selectAllOfType: Customer) size.
	self assert: numberOfCustomers equals: 2.
	
	customers := self getPepeFromSession.	
	self assert: customers size equals: 1.
	
	singleCustomer := customers anyOne.
	self assertGivenCustomer: singleCustomer hasName: 'Pepe' andLastName: 'Sanchez' withIdType: 'D' andIdNumber: '22333444'.
	
	customers := self getJuanFromSession.
	self assert: customers size equals: 1.
	
	singleCustomer := customers anyOne.
	self assertGivenCustomer: singleCustomer hasName: 'Juan'andLastName: 'Perez'  withIdType: 'C' andIdNumber: '23-25666777-9'.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'LK 11/16/2023 01:05:52' prior: 50764077!
test02shouldImportAddresses

	|selectedCustomers customerAddresses singleAddress singleCustomer|

	self importCustomersWithStream.
	
	selectedCustomers := self getPepeFromSession.
		
	singleCustomer := selectedCustomers anyOne.
	customerAddresses := singleCustomer addresses.
	
	self assert: customerAddresses size equals: 2.
	
	singleAddress := customerAddresses select: [:anAddress | anAddress streetName = 'Maipu'].
	singleAddress := singleAddress first.
	
	self assertGivenAddress: singleAddress hasName: 'Maipu' withNumber: 888 inTown: 'Florida' withZipCode: 1122 withProvince: 'Buenos Aires'.
	
	singleAddress := customerAddresses select: [:anAddress | anAddress streetName = 'San Martin'].
	singleAddress := singleAddress first.
	
	self assertGivenAddress: singleAddress hasName: 'San Martin' withNumber: 3322 inTown: 'Olivos' withZipCode:  1636 withProvince:  'BsAs'.
	
	selectedCustomers := self getJuanFromSession.
				
	singleCustomer := selectedCustomers anyOne.
	customerAddresses := singleCustomer addresses.
	self assert: customerAddresses size equals: 1.

	singleAddress := customerAddresses select: [:anAddress | anAddress streetName = 'Alem'].
	singleAddress := singleAddress first.
	
	self assertGivenAddress: singleAddress hasName: 'Alem' withNumber: 1122 inTown: 'CABA' withZipCode: 1001 withProvince: 'CABA'.

	
	
	! !
!ImportCustomer methodsFor: 'evaluating' stamp: 'LK 11/16/2023 01:06:18'!
noSe

	"
	self importCustomers
	"
	
	| newCustomer line |

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth.
			currentSession persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData sixth].

		line := inputStream nextLine. ].

	inputStream close.
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'LK 11/16/2023 01:06:18' prior: 50764221!
importCustomersWithStream
	(ImportCustomer fromSession: session andInputStream: inputFile) noSe! !

!methodRemoval: ImportCustomer #mom stamp: 'LK 11/16/2023 01:06:18'!
mom

	"
	self importCustomers
	"
	
	| newCustomer line |

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth.
			currentSession persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData sixth].

		line := inputStream nextLine. ].

	inputStream close.
	!
!ImportCustomer methodsFor: 'evaluating' stamp: 'LK 11/16/2023 01:08:01'!
importCustomers

	"
	self importCustomers
	"
	
	| newCustomer line |

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth.
			currentSession persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData sixth].

		line := inputStream nextLine. ].

	inputStream close.
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'LK 11/16/2023 01:08:01' prior: 50764339!
importCustomersWithStream
	(ImportCustomer fromSession: session andInputStream: inputFile) importCustomers! !

!methodRemoval: ImportCustomer #noSe stamp: 'LK 11/16/2023 01:08:01'!
noSe

	"
	self importCustomers
	"
	
	| newCustomer line |

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth.
			currentSession persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData sixth].

		line := inputStream nextLine. ].

	inputStream close.
	!

----QUIT----(16 November 2023 01:09:59) CuisUniversity-5981.image priorSource: 13773040!

----STARTUP---- (18 November 2023 02:11:47) as C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\CuisUniversity-5981.image!


!classRemoval: #ImportCustomer stamp: 'LK 11/18/2023 02:12:03'!
Object subclass: #ImportCustomer
	instanceVariableNames: 'currentSession inputStream'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!classRemoval: #DataBaseSession stamp: 'LK 11/18/2023 02:12:03'!
Object subclass: #DataBaseSession
	instanceVariableNames: 'configuration tables id'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!classRemoval: #Customer stamp: 'LK 11/18/2023 02:12:03'!
Object subclass: #Customer
	instanceVariableNames: 'id firstName lastName identificationType identificationNumber addresses'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!classRemoval: #Address stamp: 'LK 11/18/2023 02:12:03'!
Object subclass: #Address
	instanceVariableNames: 'id streetName streetNumber town zipCode province'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!classRemoval: #ImportTest stamp: 'LK 11/18/2023 02:12:04'!
TestCase subclass: #ImportTest
	instanceVariableNames: 'session inputFile'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

----End fileIn of C:\Users\lucas\OneDrive\Desktop\CustomerImporter.st----!
!ImportTest methodsFor: 'tests' stamp: 'LK 11/18/2023 02:14:39'!
test02FailsWhenCustomerIsEmpty

	|importer| 
	
	importer := (CustomerImporter from: (ReadStream on: 'C,Pepe,Sanchez, D') into: session).
	
	self 
		should: [importer value]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText equals: importer invalidCustomerRecord.
			self assert: self numberOfCustomers equals: 0].
	
	! !
!ImportTest methodsFor: 'tests' stamp: 'LK 11/18/2023 02:15:06' prior: 50765152!
test02FailsWhenCustomerIsEmpty

	|importer| 
	
	importer := (CustomerImporter from: (ReadStream on: 'D,Alem,') into: session).
	
	self 
		should: [importer value]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText equals: importer invalidCustomerRecord.
			self assert: self numberOfCustomers equals: 0].
	
	! !

!testRun: #ImportTest #test02FailsImportingWhenCustomerRecordHasLessThanFiveFields stamp: 'LK 11/18/2023 02:15:25'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'LK 11/18/2023 02:15:26'!
PASSED!

!testRun: #ImportTest #test02FailsImportingWhenCustomerRecordHasLessThanFiveFields stamp: 'LK 11/18/2023 02:15:26'!
PASSED!

!testRun: #ImportTest #test02FailsWhenCustomerIsEmpty stamp: 'LK 11/18/2023 02:15:26'!
FAILURE!

!testRun: #ImportTest #test03FailsImportingWhenCustomerRecordHasMoreThanFiveFields stamp: 'LK 11/18/2023 02:15:26'!
PASSED!

!testRun: #ImportTest #test04FailsImportingWhenAddressRecordHasLessThanSixFields stamp: 'LK 11/18/2023 02:15:26'!
FAILURE!

!testRun: #ImportTest #test05FailsImportingWhenAddressRecordHasMoreThanSixFields stamp: 'LK 11/18/2023 02:15:26'!
PASSED!

!testRun: #ImportTest #test06FailsImportingWhenCustomerHasNoAddresses stamp: 'LK 11/18/2023 02:15:26'!
PASSED!

!testRun: #ImportTest #test02FailsWhenCustomerIsEmpty stamp: 'LK 11/18/2023 02:15:32'!
FAILURE!

!testRun: #ImportTest #test02FailsWhenCustomerIsEmpty stamp: 'LK 11/18/2023 02:15:32'!
FAILURE!
!ImportTest methodsFor: 'tests' stamp: 'LK 11/18/2023 02:15:42' prior: 50765166!
test02FailsWhenCustomerIsEmpty

	|importer| 
	
	importer := (CustomerImporter from: (ReadStream on: 'D,Alem,') into: session).
	
	importer value.
	self 
		should: [importer value]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText equals: importer invalidCustomerRecord.
			self assert: self numberOfCustomers equals: 0].
	
	! !

!testRun: #ImportTest #test02FailsWhenCustomerIsEmpty stamp: 'LK 11/18/2023 02:15:43'!
FAILURE!
!ImportTest methodsFor: 'tests' stamp: 'LK 11/18/2023 02:15:51' prior: 50765214!
test02FailsWhenCustomerIsEmpty

	|importer| 
	
	importer := (CustomerImporter from: (ReadStream on: 'D,Alem,') into: session).
	
	importer value.
	"self 
		should: [importer value]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText equals: importer invalidCustomerRecord.
			self assert: self numberOfCustomers equals: 0].
	
	"! !

!testRun: #ImportTest #test02FailsWhenCustomerIsEmpty stamp: 'LK 11/18/2023 02:15:52'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'LK 11/18/2023 02:15:52'!
PASSED!

!testRun: #ImportTest #test02FailsImportingWhenCustomerRecordHasLessThanFiveFields stamp: 'LK 11/18/2023 02:15:52'!
PASSED!

!testRun: #ImportTest #test02FailsWhenCustomerIsEmpty stamp: 'LK 11/18/2023 02:15:52'!
PASSED!

!testRun: #ImportTest #test03FailsImportingWhenCustomerRecordHasMoreThanFiveFields stamp: 'LK 11/18/2023 02:15:52'!
PASSED!

!testRun: #ImportTest #test04FailsImportingWhenAddressRecordHasLessThanSixFields stamp: 'LK 11/18/2023 02:15:52'!
FAILURE!

!testRun: #ImportTest #test05FailsImportingWhenAddressRecordHasMoreThanSixFields stamp: 'LK 11/18/2023 02:15:52'!
PASSED!

!testRun: #ImportTest #test06FailsImportingWhenCustomerHasNoAddresses stamp: 'LK 11/18/2023 02:15:52'!
PASSED!

!testRun: #ImportTest #test04FailsImportingWhenAddressRecordHasLessThanSixFields stamp: 'LK 11/18/2023 02:15:53'!
FAILURE!

!testRun: #ImportTest #test02FailsWhenCustomerIsEmpty stamp: 'LK 11/18/2023 02:15:56'!
PASSED!

!methodRemoval: ImportTest #test02FailsWhenCustomerIsEmpty stamp: 'LK 11/18/2023 02:19:15'!
test02FailsWhenCustomerIsEmpty

	|importer| 
	
	importer := (CustomerImporter from: (ReadStream on: 'D,Alem,') into: session).
	
	importer value.
	"self 
		should: [importer value]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText equals: importer invalidCustomerRecord.
			self assert: self numberOfCustomers equals: 0].
	
	"!

!testRun: #ImportTest #test04FailsImportingWhenAddressRecordHasLessThanSixFields stamp: 'LK 11/18/2023 02:19:22'!
FAILURE!

!testRun: #ImportTest #test04FailsImportingWhenAddressRecordHasLessThanSixFields stamp: 'LK 11/18/2023 02:19:22'!
FAILURE!
!ImportTest methodsFor: 'tests' stamp: 'LK 11/18/2023 02:20:05' prior: 50764587!
test04FailsImportingWhenAddressRecordHasLessThanSixFields

	|importer text| 
	
	text := 'C,Pepe,Sanchez,D,22333444
	A,San Martin,3322,Olivos'.
	
	importer := (CustomerImporter from: (ReadStream on: text ) into: session).
	
	importer value.
	self 
		should: [importer value]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText equals: importer invalidAddressRecord.
			self assert: self numberOfCustomers equals: 0].! !

!testRun: #ImportTest #test04FailsImportingWhenAddressRecordHasLessThanSixFields stamp: 'LK 11/18/2023 02:20:06'!
FAILURE!
!ImportTest methodsFor: 'tests' stamp: 'LK 11/18/2023 02:20:24' prior: 50765302!
test04FailsImportingWhenAddressRecordHasLessThanSixFields

	|importer text| 
	
	text := 'C,Pepe,Sanchez,D,22333444
	A,San Martin,3322,Olivos'.
	
	importer := (CustomerImporter from: (ReadStream on: text ) into: session).
	

	self 
		should: [importer value]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText equals: importer invalidAddressRecord.
			self assert: self numberOfCustomers equals: 0].! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'LK 11/18/2023 02:21:48' prior: 50764898!
importAddress

	|newAddress |
	"if customer nil"
	(record size < 6) ifTrue: [self error: 'daa'].
	
	newAddress := Address new.
	newCustomer addAddress: newAddress.
	newAddress streetName: record second.
	newAddress streetNumber: record third asNumber .
	newAddress town: record fourth.
	newAddress zipCode: record fifth asNumber .
	newAddress province: record sixth! !
!ImportTest methodsFor: 'tests' stamp: 'LK 11/18/2023 02:25:29' prior: 50765323!
test04FailsImportingWhenAddressRecordHasLessThanSixFields

	|importer text| 
	
	text := 'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires'.
	
	importer := (CustomerImporter from: (ReadStream on: text ) into: session).
	

	self 
		should: [importer value]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText equals: importer invalidAddressRecord.
			self assert: self numberOfCustomers equals: 0].! !

!testRun: #ImportTest #test04FailsImportingWhenAddressRecordHasLessThanSixFields stamp: 'LK 11/18/2023 02:25:30'!
FAILURE!
!CustomerImporter methodsFor: 'evaluating' stamp: 'LK 11/18/2023 02:26:55' prior: 50765340!
importAddress

	|newAddress |
	"if customer nil"
	(record size < 6) ifTrue: [self error: self invalidAddressRecord].
	
	newAddress := Address new.
	newCustomer addAddress: newAddress.
	newAddress streetName: record second.
	newAddress streetNumber: record third asNumber .
	newAddress town: record fourth.
	newAddress zipCode: record fifth asNumber .
	newAddress province: record sixth! !

!testRun: #ImportTest #test04FailsImportingWhenAddressRecordHasLessThanSixFields stamp: 'LK 11/18/2023 02:27:11'!
FAILURE!

!testRun: #ImportTest #test04FailsImportingWhenAddressRecordHasLessThanSixFields stamp: 'LK 11/18/2023 02:27:12'!
FAILURE!
!ImportTest methodsFor: 'tests' stamp: 'LK 11/18/2023 02:27:33' prior: 50764603!
test05FailsImportingWhenAddressRecordHasMoreThanSixFields

	|importer text| 
	
	text := 'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs,CABA'.
	
	importer := (CustomerImporter from: (ReadStream on: text) into: session).
	
	importer value.
	"self 
		should: [importer value]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText equals: importer invalidAddressRecord.
			self assert: self numberOfCustomers equals: 0]."! !
!ImportTest methodsFor: 'tests' stamp: 'LK 11/18/2023 02:27:59' prior: 50765400!
test05FailsImportingWhenAddressRecordHasMoreThanSixFields

	|importer text| 
	
	text := 'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs,CABA'.
	
	importer := (CustomerImporter from: (ReadStream on: text) into: session).
	
	self 
		should: [importer value]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText equals: importer invalidAddressRecord.
			self assert: self numberOfCustomers equals: 0].! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'LK 11/18/2023 02:28:32' prior: 50765377!
importAddress

	|newAddress |
	"if customer nil"
	((record size < 6) or: [record size > 6]) ifTrue: [self error: self invalidAddressRecord].
	
	newAddress := Address new.
	newCustomer addAddress: newAddress.
	newAddress streetName: record second.
	newAddress streetNumber: record third asNumber .
	newAddress town: record fourth.
	newAddress zipCode: record fifth asNumber .
	newAddress province: record sixth! !

!testRun: #ImportTest #test06FailsImportingWhenCustomerHasNoAddresses stamp: 'LK 11/18/2023 02:28:38'!
PASSED!

!testRun: #ImportTest #test05FailsImportingWhenAddressRecordHasMoreThanSixFields stamp: 'LK 11/18/2023 02:28:41'!
FAILURE!

!testRun: #ImportTest #test05FailsImportingWhenAddressRecordHasMoreThanSixFields stamp: 'LK 11/18/2023 02:28:41'!
FAILURE!

!testRun: #ImportTest #test04FailsImportingWhenAddressRecordHasLessThanSixFields stamp: 'LK 11/18/2023 02:28:59'!
FAILURE!

!testRun: #ImportTest #test05FailsImportingWhenAddressRecordHasMoreThanSixFields stamp: 'LK 11/18/2023 02:29:04'!
FAILURE!
!ImportTest methodsFor: 'tests' stamp: 'LK 11/18/2023 02:29:45'!
test06FailsImportingWhenAddressIsGivenWithoutCustomer

	|importer text| 
	
	text := ''.ReadStream on:
'C,Pepe,Sanchez,D,22333444
C,Juan,Perez,C,23-25666777-9'.
	
	importer := (CustomerImporter from: (ReadStream on: text) into: session).
	
	importer value.
	"self 
		should: [importer value]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText equals: importer invalidAddressRecord.
			self assert: self numberOfCustomers equals: 0]."! !

!methodRemoval: ImportTest #test06FailsImportingWhenCustomerHasNoAddresses stamp: 'LK 11/18/2023 02:29:45'!
test06FailsImportingWhenCustomerHasNoAddresses

	|importer text| 
	
	text := ''.ReadStream on:
'C,Pepe,Sanchez,D,22333444
C,Juan,Perez,C,23-25666777-9'.
	
	importer := (CustomerImporter from: (ReadStream on: text) into: session).
	
	importer value.
	"self 
		should: [importer value]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText equals: importer invalidAddressRecord.
			self assert: self numberOfCustomers equals: 0]."!
!ImportTest methodsFor: 'tests' stamp: 'LK 11/18/2023 02:29:59' prior: 50765469!
test06FailsImportingWhenAddressIsGivenWithoutCustomer

	|importer text| 
	
	text := ''.
	
	importer := (CustomerImporter from: (ReadStream on: text) into: session).
	
	importer value.
	"self 
		should: [importer value]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText equals: importer invalidAddressRecord.
			self assert: self numberOfCustomers equals: 0]."! !
!ImportTest methodsFor: 'tests' stamp: 'LK 11/18/2023 02:30:07' prior: 50765504!
test06FailsImportingWhenAddressIsGivenWithoutCustomer

	|importer text| 
	
	text := 'A,San Martin,3322,Olivos,1636,BsAs'.
	
	importer := (CustomerImporter from: (ReadStream on: text) into: session).
	
	importer value.
	"self 
		should: [importer value]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText equals: importer invalidAddressRecord.
			self assert: self numberOfCustomers equals: 0]."! !
!ImportTest methodsFor: 'tests' stamp: 'LK 11/18/2023 02:30:43' prior: 50765519!
test06FailsImportingWhenAddressIsGivenWithoutCustomer

	|importer text| 
	
	text := 'A,San Martin,3322,Olivos,1636,BsAs'.
	
	importer := (CustomerImporter from: (ReadStream on: text) into: session).
	
	self 
		should: [importer value]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText equals: importer addressWithNoCustomer.
			self assert: self numberOfCustomers equals: 0].! !

!testRun: #ImportTest #test06FailsImportingWhenAddressIsGivenWithoutCustomer stamp: 'LK 11/18/2023 02:30:46'!
ERROR!
!CustomerImporter methodsFor: 'error' stamp: 'LK 11/18/2023 02:30:54'!
addressWithNoCustomer
	self shouldBeImplemented.! !
!CustomerImporter methodsFor: 'error' stamp: 'LK 11/18/2023 02:31:08' prior: 50765554!
addressWithNoCustomer
	^'no'! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'LK 11/18/2023 02:32:00' prior: 50765435!
importAddress

	|newAddress |
	(newCustomer isNil) ifTrue: [self error: self addressWithNoCustomer].
	
	((record size < 6) or: [record size > 6]) ifTrue: [self error: self invalidAddressRecord].
	
	newAddress := Address new.
	newCustomer addAddress: newAddress.
	newAddress streetName: record second.
	newAddress streetNumber: record third asNumber .
	newAddress town: record fourth.
	newAddress zipCode: record fifth asNumber .
	newAddress province: record sixth! !

!testRun: #ImportTest #test06FailsImportingWhenAddressIsGivenWithoutCustomer stamp: 'LK 11/18/2023 02:32:06'!
PASSED!
!ImportTest methodsFor: 'tests' stamp: 'LK 11/18/2023 02:32:24'!
test06FailsImportingEmptyStream

	|importer text| 
	
	text := 'A,San Martin,3322,Olivos,1636,BsAs'.
	
	importer := (CustomerImporter from: (ReadStream on: text) into: session).
	
	self 
		should: [importer value]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText equals: importer addressWithNoCustomer.
			self assert: self numberOfCustomers equals: 0].! !
!ImportTest methodsFor: 'tests' stamp: 'LK 11/18/2023 02:32:26' prior: 50765584!
test06FailsImportingEmptyStream

	|importer text| 
	
	text := ''.
	
	importer := (CustomerImporter from: (ReadStream on: text) into: session).
	
	self 
		should: [importer value]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText equals: importer addressWithNoCustomer.
			self assert: self numberOfCustomers equals: 0].! !

!testRun: #ImportTest #test06FailsImportingEmptyStream stamp: 'LK 11/18/2023 02:32:28'!
FAILURE!
!ImportTest methodsFor: 'tests' stamp: 'LK 11/18/2023 02:32:40' prior: 50765599!
test06FailsImportingEmptyStream

	|importer text| 
	
	text := ''.
	
	importer := (CustomerImporter from: (ReadStream on: text) into: session).
	
	self 
		should: [importer value]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText equals: importer emptyStreamErrorDescription.
			self assert: self numberOfCustomers equals: 0].! !
!CustomerImporter methodsFor: 'error' stamp: 'LK 11/18/2023 02:33:26'!
invalidFieldsInRecord

	^'wrong'.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'LK 11/18/2023 02:33:26' prior: 50764558!
test02FailsImportingWhenCustomerRecordHasLessThanFiveFields

	|importer| 
	
	importer := (CustomerImporter from: (ReadStream on: 'C,Pepe,Sanchez, D') into: session).
	
	self 
		should: [importer value]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText equals: importer invalidFieldsInRecord.
			self assert: self numberOfCustomers equals: 0].
	
	! !
!CustomerImporter methodsFor: 'as yet unclassified' stamp: 'LK 11/18/2023 02:33:26' prior: 50764914!
importCustomer

	(record size < 5 or: [record size > 5]) ifTrue:  [self error: self invalidFieldsInRecord].
	
	newCustomer := Customer new.
	newCustomer firstName: record second.
	newCustomer lastName: record third.
	newCustomer identificationType: record fourth.
	newCustomer identificationNumber: record fifth.
	
	session persist: newCustomer! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'LK 11/18/2023 02:33:26' prior: 50764572!
test03FailsImportingWhenCustomerRecordHasMoreThanFiveFields

	|importer| 
	
	importer := (CustomerImporter from: (ReadStream on: 'C,Pepe,Sanchez, D,3,2') into: session).
	
	self 
		should: [importer value]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText equals: importer invalidFieldsInRecord.
			self assert: self numberOfCustomers equals: 0].
	
	! !

!methodRemoval: CustomerImporter #invalidCustomerRecord stamp: 'LK 11/18/2023 02:33:26'!
invalidCustomerRecord

	^'wrong'.!

!methodRemoval: CustomerImporter #invalidAddressRecord stamp: 'LK 11/18/2023 02:33:41'!
invalidAddressRecord
	
	^'wrong'!
!CustomerImporter methodsFor: 'evaluating' stamp: 'LK 11/18/2023 02:33:55' prior: 50765563!
importAddress

	|newAddress |
	(newCustomer isNil) ifTrue: [self error: self addressWithNoCustomer].
	
	((record size < 6) or: [record size > 6]) ifTrue: [self error: self invalidFieldsInRecord].
	
	newAddress := Address new.
	newCustomer addAddress: newAddress.
	newAddress streetName: record second.
	newAddress streetNumber: record third asNumber .
	newAddress town: record fourth.
	newAddress zipCode: record fifth asNumber .
	newAddress province: record sixth! !
!ImportTest methodsFor: 'tests' stamp: 'LK 11/18/2023 02:34:04' prior: 50765418!
test05FailsImportingWhenAddressRecordHasMoreThanSixFields

	|importer text| 
	
	text := 'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs,CABA'.
	
	importer := (CustomerImporter from: (ReadStream on: text) into: session).
	
	self 
		should: [importer value]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText equals: importer invalidFieldsInRecord.
			self assert: self numberOfCustomers equals: 0].! !
!ImportTest methodsFor: 'tests' stamp: 'LK 11/18/2023 02:34:11' prior: 50765355!
test04FailsImportingWhenAddressRecordHasLessThanSixFields

	|importer text| 
	
	text := 'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires'.
	
	importer := (CustomerImporter from: (ReadStream on: text ) into: session).
	

	self 
		should: [importer value]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText equals: importer invalidFieldsInRecord.
			self assert: self numberOfCustomers equals: 0].! !
!ImportTest methodsFor: 'tests' stamp: 'LK 11/18/2023 02:34:30'!
test07FailsImportingEmptyStream

	|importer text| 
	
	text := ''.
	
	importer := (CustomerImporter from: (ReadStream on: text) into: session).
	
	self 
		should: [importer value]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText equals: importer emptyStreamErrorDescription.
			self assert: self numberOfCustomers equals: 0].! !

!methodRemoval: ImportTest #test06FailsImportingEmptyStream stamp: 'LK 11/18/2023 02:34:31'!
test06FailsImportingEmptyStream

	|importer text| 
	
	text := ''.
	
	importer := (CustomerImporter from: (ReadStream on: text) into: session).
	
	self 
		should: [importer value]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText equals: importer emptyStreamErrorDescription.
			self assert: self numberOfCustomers equals: 0].!
!ImportTest methodsFor: 'tests' stamp: 'LK 11/18/2023 02:34:59'!
test01ImportsAllCustomersAndAddressesAsExpected

	CustomerImporter valueFrom: self validImportData into: session.

	self assertImportedRightNumberOfCustomers.
	self assertPepeSanchezWasImportedCorrecty.
	self assertJuanPerezWasImportedCorrectly ! !

!methodRemoval: ImportTest #test01Import stamp: 'LK 11/18/2023 02:34:59'!
test01Import

	CustomerImporter valueFrom: self validImportData into: session.

	self assertImportedRightNumberOfCustomers.
	self assertPepeSanchezWasImportedCorrecty.
	self assertJuanPerezWasImportedCorrectly !
!CustomerImporter methodsFor: 'error' stamp: 'LK 11/18/2023 02:35:43'!
invalidFieldFormatErrorDescription

	^'wrong'.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'LK 11/18/2023 02:35:43' prior: 50765665!
test03FailsImportingWhenCustomerRecordHasMoreThanFiveFields

	|importer| 
	
	importer := (CustomerImporter from: (ReadStream on: 'C,Pepe,Sanchez, D,3,2') into: session).
	
	self 
		should: [importer value]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText equals: importer invalidFieldFormatErrorDescription.
			self assert: self numberOfCustomers equals: 0].
	
	! !
!CustomerImporter methodsFor: 'as yet unclassified' stamp: 'LK 11/18/2023 02:35:43' prior: 50765651!
importCustomer

	(record size < 5 or: [record size > 5]) ifTrue:  [self error: self invalidFieldFormatErrorDescription].
	
	newCustomer := Customer new.
	newCustomer firstName: record second.
	newCustomer lastName: record third.
	newCustomer identificationType: record fourth.
	newCustomer identificationNumber: record fifth.
	
	session persist: newCustomer! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'LK 11/18/2023 02:35:43' prior: 50765706!
test05FailsImportingWhenAddressRecordHasMoreThanSixFields

	|importer text| 
	
	text := 'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs,CABA'.
	
	importer := (CustomerImporter from: (ReadStream on: text) into: session).
	
	self 
		should: [importer value]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText equals: importer invalidFieldFormatErrorDescription.
			self assert: self numberOfCustomers equals: 0].! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'LK 11/18/2023 02:35:43' prior: 50765635!
test02FailsImportingWhenCustomerRecordHasLessThanFiveFields

	|importer| 
	
	importer := (CustomerImporter from: (ReadStream on: 'C,Pepe,Sanchez, D') into: session).
	
	self 
		should: [importer value]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText equals: importer invalidFieldFormatErrorDescription.
			self assert: self numberOfCustomers equals: 0].
	
	! !
!CustomerImporter methodsFor: 'as yet unclassified' stamp: 'LK 11/18/2023 02:35:43' prior: 50765688!
importAddress

	|newAddress |
	(newCustomer isNil) ifTrue: [self error: self addressWithNoCustomer].
	
	((record size < 6) or: [record size > 6]) ifTrue: [self error: self invalidFieldFormatErrorDescription].
	
	newAddress := Address new.
	newCustomer addAddress: newAddress.
	newAddress streetName: record second.
	newAddress streetNumber: record third asNumber .
	newAddress town: record fourth.
	newAddress zipCode: record fifth asNumber .
	newAddress province: record sixth! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'LK 11/18/2023 02:35:43' prior: 50765723!
test04FailsImportingWhenAddressRecordHasLessThanSixFields

	|importer text| 
	
	text := 'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires'.
	
	importer := (CustomerImporter from: (ReadStream on: text ) into: session).
	

	self 
		should: [importer value]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText equals: importer invalidFieldFormatErrorDescription.
			self assert: self numberOfCustomers equals: 0].! !

!methodRemoval: CustomerImporter #invalidFieldsInRecord stamp: 'LK 11/18/2023 02:35:43'!
invalidFieldsInRecord

	^'wrong'.!
!CustomerImporter methodsFor: 'error' stamp: 'LK 11/18/2023 02:36:02'!
addressWithNoCustomerErrorDescription
	^'no'! !
!CustomerImporter methodsFor: 'as yet unclassified' stamp: 'LK 11/18/2023 02:36:02' prior: 50765858!
importAddress

	|newAddress |
	(newCustomer isNil) ifTrue: [self error: self addressWithNoCustomerErrorDescription].
	
	((record size < 6) or: [record size > 6]) ifTrue: [self error: self invalidFieldFormatErrorDescription].
	
	newAddress := Address new.
	newCustomer addAddress: newAddress.
	newAddress streetName: record second.
	newAddress streetNumber: record third asNumber .
	newAddress town: record fourth.
	newAddress zipCode: record fifth asNumber .
	newAddress province: record sixth! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'LK 11/18/2023 02:36:02' prior: 50765535!
test06FailsImportingWhenAddressIsGivenWithoutCustomer

	|importer text| 
	
	text := 'A,San Martin,3322,Olivos,1636,BsAs'.
	
	importer := (CustomerImporter from: (ReadStream on: text) into: session).
	
	self 
		should: [importer value]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText equals: importer addressWithNoCustomerErrorDescription.
			self assert: self numberOfCustomers equals: 0].! !

!methodRemoval: CustomerImporter #addressWithNoCustomer stamp: 'LK 11/18/2023 02:36:02'!
addressWithNoCustomer
	^'no'!

!testRun: #ImportTest #test01ImportsAllCustomersAndAddressesAsExpected stamp: 'LK 11/18/2023 02:36:15'!
PASSED!

!testRun: #ImportTest #test02FailsImportingWhenCustomerRecordHasLessThanFiveFields stamp: 'LK 11/18/2023 02:36:15'!
PASSED!

!testRun: #ImportTest #test03FailsImportingWhenCustomerRecordHasMoreThanFiveFields stamp: 'LK 11/18/2023 02:36:15'!
PASSED!

!testRun: #ImportTest #test04FailsImportingWhenAddressRecordHasLessThanSixFields stamp: 'LK 11/18/2023 02:36:15'!
FAILURE!

!testRun: #ImportTest #test05FailsImportingWhenAddressRecordHasMoreThanSixFields stamp: 'LK 11/18/2023 02:36:15'!
FAILURE!

!testRun: #ImportTest #test06FailsImportingWhenAddressIsGivenWithoutCustomer stamp: 'LK 11/18/2023 02:36:15'!
PASSED!

!testRun: #ImportTest #test07FailsImportingEmptyStream stamp: 'LK 11/18/2023 02:36:15'!
FAILURE!
!ImportTest methodsFor: 'tests' stamp: 'LK 11/18/2023 02:36:32' prior: 50765824!
test05FailsImportingWhenAddressRecordHasMoreThanSixFields

	|importer text| 
	
	text := 'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs,CABA'.
	
	importer := (CustomerImporter from: (ReadStream on: text) into: session).
	"
	self 
		should: [importer value]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText equals: importer invalidFieldFormatErrorDescription.
			self assert: self numberOfCustomers equals: 0]."! !
!ImportTest methodsFor: 'tests' stamp: 'LK 11/18/2023 02:36:48' prior: 50765876!
test04FailsImportingWhenAddressRecordHasLessThanSixFields

	|importer text| 
	
	text := 'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636'.
	
	importer := (CustomerImporter from: (ReadStream on: text ) into: session).
	

	self 
		should: [importer value]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText equals: importer invalidFieldFormatErrorDescription.
			self assert: self numberOfCustomers equals: 0].! !

!testRun: #ImportTest #test04FailsImportingWhenAddressRecordHasLessThanSixFields stamp: 'LK 11/18/2023 02:36:49'!
FAILURE!

!testRun: #ImportTest #test04FailsImportingWhenAddressRecordHasLessThanSixFields stamp: 'LK 11/18/2023 02:36:50'!
FAILURE!
!ImportTest methodsFor: 'tests' stamp: 'LK 11/18/2023 02:37:09' prior: 50765985!
test04FailsImportingWhenAddressRecordHasLessThanSixFields

	|importer text| 
	
	text := 'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636'.
	
	importer := (CustomerImporter from: (ReadStream on: text ) into: session).
	

	"self 
		should: [importer value]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText equals: importer invalidFieldFormatErrorDescription.
			self assert: self numberOfCustomers equals: 0]."! !

!testRun: #ImportTest #test04FailsImportingWhenAddressRecordHasLessThanSixFields stamp: 'LK 11/18/2023 02:37:12'!
PASSED!

!testRun: #ImportTest #test01ImportsAllCustomersAndAddressesAsExpected stamp: 'LK 11/18/2023 02:37:12'!
PASSED!

!testRun: #ImportTest #test02FailsImportingWhenCustomerRecordHasLessThanFiveFields stamp: 'LK 11/18/2023 02:37:12'!
PASSED!

!testRun: #ImportTest #test03FailsImportingWhenCustomerRecordHasMoreThanFiveFields stamp: 'LK 11/18/2023 02:37:13'!
PASSED!

!testRun: #ImportTest #test04FailsImportingWhenAddressRecordHasLessThanSixFields stamp: 'LK 11/18/2023 02:37:13'!
PASSED!

!testRun: #ImportTest #test05FailsImportingWhenAddressRecordHasMoreThanSixFields stamp: 'LK 11/18/2023 02:37:13'!
PASSED!

!testRun: #ImportTest #test06FailsImportingWhenAddressIsGivenWithoutCustomer stamp: 'LK 11/18/2023 02:37:13'!
PASSED!

!testRun: #ImportTest #test07FailsImportingEmptyStream stamp: 'LK 11/18/2023 02:37:13'!
FAILURE!

!testRun: #ImportTest #test07FailsImportingEmptyStream stamp: 'LK 11/18/2023 02:37:13'!
FAILURE!

!testRun: #ImportTest #test07FailsImportingEmptyStream stamp: 'LK 11/18/2023 02:37:21'!
FAILURE!

!testRun: #ImportTest #test07FailsImportingEmptyStream stamp: 'LK 11/18/2023 02:37:21'!
FAILURE!

!testRun: #ImportTest #test07FailsImportingEmptyStream stamp: 'LK 11/18/2023 02:37:38'!
FAILURE!
!CustomerImporter methodsFor: 'evaluating' stamp: 'LK 11/18/2023 02:38:11' prior: 50764928!
importRecord

	self assertRecordIsEmpty.

	(self isCustomerRecord) ifTrue: [ self importCustomer].

	(self isAddressRecord) ifTrue: [ self importAddress]
	
	"aca invalid record"! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'LK 11/18/2023 02:39:10'!
assertRecordIsEmpty

	(record isEmpty) ifTrue: [self error: self emptyStreamErrorDescription].! !
!CustomerImporter methodsFor: 'error' stamp: 'LK 11/18/2023 02:39:26'!
emptyStreamErrorDescription

	^'nosnd'! !

!testRun: #ImportTest #test07FailsImportingEmptyStream stamp: 'LK 11/18/2023 02:39:32'!
FAILURE!
!ImportTest methodsFor: 'tests' stamp: 'LK 11/18/2023 02:40:53'!
test08FailsImportingInvalidCustomerThatStartsWithC
	|importer text| 
	
	text := ''.
	
	importer := (CustomerImporter from: (ReadStream on: text) into: session).
	
	self 
		should: [importer value]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText equals: importer emptyStreamErrorDescription.
			self assert: self numberOfCustomers equals: 0].! !
!ImportTest methodsFor: 'tests' stamp: 'LK 11/18/2023 02:41:04'!
test09FailsImportingInvalidAddressThatStartsWithA
	|importer text| 
	
	text := ''.
	
	importer := (CustomerImporter from: (ReadStream on: text) into: session).
	
	self 
		should: [importer value]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText equals: importer emptyStreamErrorDescription.
			self assert: self numberOfCustomers equals: 0].! !

----QUIT----(18 November 2023 02:41:19) CuisUniversity-5981.image priorSource: 13849557!

----STARTUP---- (18 November 2023 11:57:41) as C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\CuisUniversity-5981.image!


!testRun: #ImportTest #test09FailsImportingInvalidAddressThatStartsWithA stamp: 'LK 11/18/2023 11:58:35'!
FAILURE!

!testRun: #ImportTest #test09FailsImportingInvalidAddressThatStartsWithA stamp: 'LK 11/18/2023 11:58:35'!
FAILURE!

!testRun: #ImportTest #test07FailsImportingEmptyStream stamp: 'LK 11/18/2023 11:58:43'!
FAILURE!

!testRun: #ImportTest #test07FailsImportingEmptyStream stamp: 'LK 11/18/2023 11:58:43'!
FAILURE!

----QUIT----(18 November 2023 12:02:09) CuisUniversity-5981.image priorSource: 13903001!

----STARTUP---- (18 November 2023 12:25:08) as C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\CuisUniversity-5981.image!

!ImportTest methodsFor: 'tests' stamp: 'LK 11/18/2023 12:25:56' prior: 50766091!
test08FailsImportingInvalidCustomerThatStartsWithC
	|importer text| 
	
	text := 'CC,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs'.
	
	importer := (CustomerImporter from: (ReadStream on: text) into: session).
	
	self 
		should: [importer value]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText equals: importer emptyStreamErrorDescription.
			self assert: self numberOfCustomers equals: 0].! !
!ImportTest methodsFor: 'tests' stamp: 'LK 11/18/2023 12:29:38' prior: 50766147!
test08FailsImportingInvalidCustomerThatStartsWithC
	|importer text| 
	
	text := 'CC,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs'.
	
	importer := (CustomerImporter from: (ReadStream on: text) into: session).
	
	importer value
	"self 
		should: [importer value]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText equals: importer emptyStreamErrorDescription.
			self assert: self numberOfCustomers equals: 0]."! !

!testRun: #ImportTest #test08FailsImportingInvalidCustomerThatStartsWithC stamp: 'LK 11/18/2023 12:29:40'!
PASSED!

!testRun: #ImportTest #test01ImportsAllCustomersAndAddressesAsExpected stamp: 'LK 11/18/2023 12:29:40'!
PASSED!

!testRun: #ImportTest #test02FailsImportingWhenCustomerRecordHasLessThanFiveFields stamp: 'LK 11/18/2023 12:29:40'!
PASSED!

!testRun: #ImportTest #test03FailsImportingWhenCustomerRecordHasMoreThanFiveFields stamp: 'LK 11/18/2023 12:29:41'!
PASSED!

!testRun: #ImportTest #test04FailsImportingWhenAddressRecordHasLessThanSixFields stamp: 'LK 11/18/2023 12:29:41'!
PASSED!

!testRun: #ImportTest #test05FailsImportingWhenAddressRecordHasMoreThanSixFields stamp: 'LK 11/18/2023 12:29:41'!
PASSED!

!testRun: #ImportTest #test06FailsImportingWhenAddressIsGivenWithoutCustomer stamp: 'LK 11/18/2023 12:29:41'!
PASSED!

!testRun: #ImportTest #test07FailsImportingEmptyStream stamp: 'LK 11/18/2023 12:29:41'!
FAILURE!

!testRun: #ImportTest #test08FailsImportingInvalidCustomerThatStartsWithC stamp: 'LK 11/18/2023 12:29:41'!
PASSED!

!testRun: #ImportTest #test09FailsImportingInvalidAddressThatStartsWithA stamp: 'LK 11/18/2023 12:29:41'!
FAILURE!

!testRun: #ImportTest #test08FailsImportingInvalidCustomerThatStartsWithC stamp: 'LK 11/18/2023 12:29:46'!
PASSED!
!ImportTest methodsFor: 'tests' stamp: 'LK 11/18/2023 12:30:42' prior: 50766164!
test08FailsImportingInvalidCustomerThatStartsWithC
	|importer text| 
	
	text := 'CC,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs'.
	
	importer := (CustomerImporter from: (ReadStream on: text) into: session).
	
	self 
		should: [importer value]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText equals: importer emptyStreamErrorDescription.
			self assert: self numberOfCustomers equals: 0].! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'LK 11/18/2023 12:31:08' prior: 50764936!
isAddressRecord

	^ record first = 'A'! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'LK 11/18/2023 12:45:27' prior: 50764940!
isCustomerRecord

	^ record first: 'C'! !

----QUIT----(18 November 2023 12:45:31) CuisUniversity-5981.image priorSource: 13903651!

----STARTUP---- (22 November 2023 17:10:15) as C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\CuisUniversity-5981.image!


!testRun: #ImportTest #test01ImportsAllCustomersAndAddressesAsExpected stamp: 'LK 11/22/2023 17:10:43'!
ERROR!

!testRun: #ImportTest #test02FailsImportingWhenCustomerRecordHasLessThanFiveFields stamp: 'LK 11/22/2023 17:10:43'!
FAILURE!

!testRun: #ImportTest #test03FailsImportingWhenCustomerRecordHasMoreThanFiveFields stamp: 'LK 11/22/2023 17:10:43'!
FAILURE!

!testRun: #ImportTest #test04FailsImportingWhenAddressRecordHasLessThanSixFields stamp: 'LK 11/22/2023 17:10:43'!
PASSED!

!testRun: #ImportTest #test05FailsImportingWhenAddressRecordHasMoreThanSixFields stamp: 'LK 11/22/2023 17:10:43'!
PASSED!

!testRun: #ImportTest #test06FailsImportingWhenAddressIsGivenWithoutCustomer stamp: 'LK 11/22/2023 17:10:43'!
FAILURE!

!testRun: #ImportTest #test07FailsImportingEmptyStream stamp: 'LK 11/22/2023 17:10:43'!
FAILURE!

!testRun: #ImportTest #test08FailsImportingInvalidCustomerThatStartsWithC stamp: 'LK 11/22/2023 17:10:43'!
FAILURE!

!testRun: #ImportTest #test09FailsImportingInvalidAddressThatStartsWithA stamp: 'LK 11/22/2023 17:10:43'!
FAILURE!

!testRun: #ImportTest #test01ImportsAllCustomersAndAddressesAsExpected stamp: 'LK 11/22/2023 17:10:54'!
ERROR!

!testRun: #ImportTest #test01ImportsAllCustomersAndAddressesAsExpected stamp: 'LK 11/22/2023 17:10:54'!
ERROR!
!CustomerImporter methodsFor: 'evaluating' stamp: 'LK 11/22/2023 17:11:28' prior: 50766244!
isCustomerRecord

	^ record first = 'C'! !

!testRun: #ImportTest #test01ImportsAllCustomersAndAddressesAsExpected stamp: 'LK 11/22/2023 17:11:33'!
PASSED!

!testRun: #ImportTest #test02FailsImportingWhenCustomerRecordHasLessThanFiveFields stamp: 'LK 11/22/2023 17:11:33'!
PASSED!

!testRun: #ImportTest #test03FailsImportingWhenCustomerRecordHasMoreThanFiveFields stamp: 'LK 11/22/2023 17:11:33'!
PASSED!

!testRun: #ImportTest #test04FailsImportingWhenAddressRecordHasLessThanSixFields stamp: 'LK 11/22/2023 17:11:33'!
PASSED!

!testRun: #ImportTest #test05FailsImportingWhenAddressRecordHasMoreThanSixFields stamp: 'LK 11/22/2023 17:11:33'!
PASSED!

!testRun: #ImportTest #test06FailsImportingWhenAddressIsGivenWithoutCustomer stamp: 'LK 11/22/2023 17:11:33'!
PASSED!

!testRun: #ImportTest #test07FailsImportingEmptyStream stamp: 'LK 11/22/2023 17:11:33'!
FAILURE!

!testRun: #ImportTest #test08FailsImportingInvalidCustomerThatStartsWithC stamp: 'LK 11/22/2023 17:11:33'!
FAILURE!

!testRun: #ImportTest #test09FailsImportingInvalidAddressThatStartsWithA stamp: 'LK 11/22/2023 17:11:33'!
FAILURE!
!CustomerImporter methodsFor: 'evaluating' stamp: 'LK 11/22/2023 17:12:26' prior: 50766069!
importRecord

	self assertRecordIsEmpty.

	(self isCustomerRecord) ifTrue: [ self importCustomer].

	(self isAddressRecord) ifTrue: [ self importAddress].
	
	self error: self invalidFieldFormatErrorDescription.! !
!ImportTest methodsFor: 'tests' stamp: 'LK 11/22/2023 17:12:48' prior: 50766222!
test08FailsImportingInvalidCustomerThatStartsWithC
	|importer text| 
	
	text := 'CC,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs'.
	
	importer := (CustomerImporter from: (ReadStream on: text) into: session).
	
	self 
		should: [importer value]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText equals: importer invalidFieldFormatErrorDescription.
			self assert: self numberOfCustomers equals: 0].! !

!testRun: #ImportTest #test08FailsImportingInvalidCustomerThatStartsWithC stamp: 'LK 11/22/2023 17:12:49'!
PASSED!

!testRun: #ImportTest #test01ImportsAllCustomersAndAddressesAsExpected stamp: 'LK 11/22/2023 17:12:49'!
ERROR!

!testRun: #ImportTest #test02FailsImportingWhenCustomerRecordHasLessThanFiveFields stamp: 'LK 11/22/2023 17:12:49'!
PASSED!

!testRun: #ImportTest #test03FailsImportingWhenCustomerRecordHasMoreThanFiveFields stamp: 'LK 11/22/2023 17:12:50'!
PASSED!

!testRun: #ImportTest #test04FailsImportingWhenAddressRecordHasLessThanSixFields stamp: 'LK 11/22/2023 17:12:50'!
PASSED!

!testRun: #ImportTest #test05FailsImportingWhenAddressRecordHasMoreThanSixFields stamp: 'LK 11/22/2023 17:12:50'!
PASSED!

!testRun: #ImportTest #test06FailsImportingWhenAddressIsGivenWithoutCustomer stamp: 'LK 11/22/2023 17:12:50'!
PASSED!

!testRun: #ImportTest #test07FailsImportingEmptyStream stamp: 'LK 11/22/2023 17:12:50'!
FAILURE!

!testRun: #ImportTest #test08FailsImportingInvalidCustomerThatStartsWithC stamp: 'LK 11/22/2023 17:12:50'!
PASSED!

!testRun: #ImportTest #test09FailsImportingInvalidAddressThatStartsWithA stamp: 'LK 11/22/2023 17:12:50'!
FAILURE!

!testRun: #ImportTest #test08FailsImportingInvalidCustomerThatStartsWithC stamp: 'LK 11/22/2023 17:12:55'!
PASSED!
!ImportTest methodsFor: 'tests' stamp: 'LK 11/22/2023 17:13:09' prior: 50766105!
test09FailsImportingInvalidAddressThatStartsWithA
	|importer text| 
	
	text := 'C,Pepe,Sanchez,D,22333444
AA,San Martin,3322,Olivos,1636,BsAs'.
	
	importer := (CustomerImporter from: (ReadStream on: text) into: session).
	
	self 
		should: [importer value]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText equals: importer emptyStreamErrorDescription.
			self assert: self numberOfCustomers equals: 0].! !

!testRun: #ImportTest #test09FailsImportingInvalidAddressThatStartsWithA stamp: 'LK 11/22/2023 17:13:09'!
FAILURE!
!ImportTest methodsFor: 'tests' stamp: 'LK 11/22/2023 17:13:17' prior: 50766401!
test09FailsImportingInvalidAddressThatStartsWithA
	|importer text| 
	
	text := 'C,Pepe,Sanchez,D,22333444
AA,San Martin,3322,Olivos,1636,BsAs'.
	
	importer := (CustomerImporter from: (ReadStream on: text) into: session).
	
	self 
		should: [importer value]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText equals: importer invalidFieldFormatErrorDescription.
			self assert: self numberOfCustomers equals: 0].! !

!testRun: #ImportTest #test09FailsImportingInvalidAddressThatStartsWithA stamp: 'LK 11/22/2023 17:13:18'!
FAILURE!

!testRun: #ImportTest #test08FailsImportingInvalidCustomerThatStartsWithC stamp: 'LK 11/22/2023 17:13:36'!
PASSED!
!ImportTest methodsFor: 'tests' stamp: 'LK 11/22/2023 17:13:57' prior: 50766421!
test09FailsImportingInvalidAddressThatStartsWithA
	|importer text| 
	
	text := 'C,Pepe,Sanchez,D,22333444
AA,San Martin,3322,Olivos,1636,BsAs'.
	
	importer := (CustomerImporter from: (ReadStream on: text) into: session).
	
	self 
		should: [importer value]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText equals: importer invalidFieldFormatErrorDescription.
			self assert: self numberOfCustomers equals: 1].! !
!ImportTest methodsFor: 'tests' stamp: 'LK 11/22/2023 17:14:02' prior: 50766445!
test09FailsImportingInvalidAddressThatStartsWithA
	|importer text| 
	
	text := 'C,Pepe,Sanchez,D,22333444
AA,San Martin,3322,Olivos,1636,BsAs'.
	
	importer := (CustomerImporter from: (ReadStream on: text) into: session).
	
	self 
		should: [importer value]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText equals: importer invalidFieldFormatErrorDescription.].! !

!testRun: #ImportTest #test02FailsImportingWhenCustomerRecordHasLessThanFiveFields stamp: 'LK 11/22/2023 17:14:09'!
PASSED!

!testRun: #ImportTest #test01ImportsAllCustomersAndAddressesAsExpected stamp: 'LK 11/22/2023 17:14:09'!
ERROR!

!testRun: #ImportTest #test02FailsImportingWhenCustomerRecordHasLessThanFiveFields stamp: 'LK 11/22/2023 17:14:09'!
PASSED!

!testRun: #ImportTest #test03FailsImportingWhenCustomerRecordHasMoreThanFiveFields stamp: 'LK 11/22/2023 17:14:09'!
PASSED!

!testRun: #ImportTest #test04FailsImportingWhenAddressRecordHasLessThanSixFields stamp: 'LK 11/22/2023 17:14:09'!
PASSED!

!testRun: #ImportTest #test05FailsImportingWhenAddressRecordHasMoreThanSixFields stamp: 'LK 11/22/2023 17:14:09'!
PASSED!

!testRun: #ImportTest #test06FailsImportingWhenAddressIsGivenWithoutCustomer stamp: 'LK 11/22/2023 17:14:09'!
PASSED!

!testRun: #ImportTest #test07FailsImportingEmptyStream stamp: 'LK 11/22/2023 17:14:09'!
FAILURE!

!testRun: #ImportTest #test08FailsImportingInvalidCustomerThatStartsWithC stamp: 'LK 11/22/2023 17:14:09'!
PASSED!

!testRun: #ImportTest #test09FailsImportingInvalidAddressThatStartsWithA stamp: 'LK 11/22/2023 17:14:09'!
PASSED!

!testRun: #ImportTest #test02FailsImportingWhenCustomerRecordHasLessThanFiveFields stamp: 'LK 11/22/2023 17:14:12'!
PASSED!

!testRun: #ImportTest #test03FailsImportingWhenCustomerRecordHasMoreThanFiveFields stamp: 'LK 11/22/2023 17:14:13'!
PASSED!

!testRun: #ImportTest #test06FailsImportingWhenAddressIsGivenWithoutCustomer stamp: 'LK 11/22/2023 17:14:23'!
PASSED!

!testRun: #ImportTest #test01ImportsAllCustomersAndAddressesAsExpected stamp: 'LK 11/22/2023 17:14:23'!
ERROR!

!testRun: #ImportTest #test02FailsImportingWhenCustomerRecordHasLessThanFiveFields stamp: 'LK 11/22/2023 17:14:23'!
PASSED!

!testRun: #ImportTest #test03FailsImportingWhenCustomerRecordHasMoreThanFiveFields stamp: 'LK 11/22/2023 17:14:23'!
PASSED!

!testRun: #ImportTest #test04FailsImportingWhenAddressRecordHasLessThanSixFields stamp: 'LK 11/22/2023 17:14:23'!
PASSED!

!testRun: #ImportTest #test05FailsImportingWhenAddressRecordHasMoreThanSixFields stamp: 'LK 11/22/2023 17:14:23'!
PASSED!

!testRun: #ImportTest #test06FailsImportingWhenAddressIsGivenWithoutCustomer stamp: 'LK 11/22/2023 17:14:23'!
PASSED!

!testRun: #ImportTest #test07FailsImportingEmptyStream stamp: 'LK 11/22/2023 17:14:23'!
FAILURE!

!testRun: #ImportTest #test08FailsImportingInvalidCustomerThatStartsWithC stamp: 'LK 11/22/2023 17:14:24'!
PASSED!

!testRun: #ImportTest #test09FailsImportingInvalidAddressThatStartsWithA stamp: 'LK 11/22/2023 17:14:24'!
PASSED!

!testRun: #ImportTest #test06FailsImportingWhenAddressIsGivenWithoutCustomer stamp: 'LK 11/22/2023 17:14:27'!
PASSED!
!CustomerImporter methodsFor: 'evaluating' stamp: 'LK 11/22/2023 17:15:50' prior: 50766334!
importRecord

	(record isEmpty) ifTrue: [self error: self emptyStreamErrorDescription].

	(self isCustomerRecord) ifTrue: [ self importCustomer].

	(self isAddressRecord) ifTrue: [ self importAddress].
	
	self error: self invalidFieldFormatErrorDescription.! !

!testRun: #ImportTest #test07FailsImportingEmptyStream stamp: 'LK 11/22/2023 17:15:54'!
FAILURE!

!testRun: #ImportTest #test07FailsImportingEmptyStream stamp: 'LK 11/22/2023 17:15:54'!
FAILURE!
!ImportTest methodsFor: 'tests' stamp: 'LK 11/22/2023 17:16:06' prior: 50766344!
test08FailsImportingInvalidCustomerThatStartsWithC
	|importer text| 
	
	text := 'CC,Pepe,Sanchez,D,22333444
	A,San Martin,3322,Olivos,1636,BsAs'.
	
	importer := (CustomerImporter from: (ReadStream on: text) into: session).
	
	self 
		should: [importer value]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText equals: importer invalidFieldFormatErrorDescription.
			self assert: self numberOfCustomers equals: 0].! !

!testRun: #ImportTest #test08FailsImportingInvalidCustomerThatStartsWithC stamp: 'LK 11/22/2023 17:16:07'!
PASSED!

!testRun: #ImportTest #test01ImportsAllCustomersAndAddressesAsExpected stamp: 'LK 11/22/2023 17:16:08'!
ERROR!

!testRun: #ImportTest #test02FailsImportingWhenCustomerRecordHasLessThanFiveFields stamp: 'LK 11/22/2023 17:16:08'!
PASSED!

!testRun: #ImportTest #test03FailsImportingWhenCustomerRecordHasMoreThanFiveFields stamp: 'LK 11/22/2023 17:16:08'!
PASSED!

!testRun: #ImportTest #test04FailsImportingWhenAddressRecordHasLessThanSixFields stamp: 'LK 11/22/2023 17:16:08'!
PASSED!

!testRun: #ImportTest #test05FailsImportingWhenAddressRecordHasMoreThanSixFields stamp: 'LK 11/22/2023 17:16:08'!
PASSED!

!testRun: #ImportTest #test06FailsImportingWhenAddressIsGivenWithoutCustomer stamp: 'LK 11/22/2023 17:16:08'!
PASSED!

!testRun: #ImportTest #test07FailsImportingEmptyStream stamp: 'LK 11/22/2023 17:16:08'!
FAILURE!

!testRun: #ImportTest #test08FailsImportingInvalidCustomerThatStartsWithC stamp: 'LK 11/22/2023 17:16:08'!
PASSED!

!testRun: #ImportTest #test09FailsImportingInvalidAddressThatStartsWithA stamp: 'LK 11/22/2023 17:16:08'!
PASSED!

!testRun: #ImportTest #test09FailsImportingInvalidAddressThatStartsWithA stamp: 'LK 11/22/2023 17:16:27'!
PASSED!

!testRun: #ImportTest #test01ImportsAllCustomersAndAddressesAsExpected stamp: 'LK 11/22/2023 17:16:27'!
ERROR!

!testRun: #ImportTest #test02FailsImportingWhenCustomerRecordHasLessThanFiveFields stamp: 'LK 11/22/2023 17:16:27'!
PASSED!

!testRun: #ImportTest #test03FailsImportingWhenCustomerRecordHasMoreThanFiveFields stamp: 'LK 11/22/2023 17:16:27'!
PASSED!

!testRun: #ImportTest #test04FailsImportingWhenAddressRecordHasLessThanSixFields stamp: 'LK 11/22/2023 17:16:27'!
PASSED!

!testRun: #ImportTest #test05FailsImportingWhenAddressRecordHasMoreThanSixFields stamp: 'LK 11/22/2023 17:16:27'!
PASSED!

!testRun: #ImportTest #test06FailsImportingWhenAddressIsGivenWithoutCustomer stamp: 'LK 11/22/2023 17:16:27'!
PASSED!

!testRun: #ImportTest #test07FailsImportingEmptyStream stamp: 'LK 11/22/2023 17:16:27'!
FAILURE!

!testRun: #ImportTest #test08FailsImportingInvalidCustomerThatStartsWithC stamp: 'LK 11/22/2023 17:16:27'!
PASSED!

!testRun: #ImportTest #test09FailsImportingInvalidAddressThatStartsWithA stamp: 'LK 11/22/2023 17:16:28'!
PASSED!

!testRun: #ImportTest #test07FailsImportingEmptyStream stamp: 'LK 11/22/2023 17:16:39'!
FAILURE!

!testRun: #ImportTest #test07FailsImportingEmptyStream stamp: 'LK 11/22/2023 17:16:39'!
FAILURE!
!PersistentCustomerSystem class methodsFor: 'nil' stamp: 'LK 11/22/2023 17:20:08'!
for: aSession
	
	^self new initializeFor: aSession! !
!PersistentCustomerSystem methodsFor: 'nil' stamp: 'LK 11/22/2023 17:20:21'!
initializeFor: aSession

	session := aSession.! !
!CustomerImporter methodsFor: 'error' stamp: 'LK 11/22/2023 17:21:05' prior: 50766084!
emptyStreamErrorDescription

	^'Cannot parse empty string'! !
!ImportTest methodsFor: 'setUp/tearDown' stamp: 'LK 11/22/2023 17:23:55' prior: 50764708 overrides: 16961394!
setUp

	customerSystem := PersistentCustomerSystem for: DataBaseSession for: (Array with: Address with: Customer).

	session beginTransaction.
! !
!ImportTest methodsFor: 'setUp/tearDown' stamp: 'LK 11/22/2023 17:24:06' prior: 50766692 overrides: 16961394!
setUp

	customerSystem := PersistentCustomerSystem for: DataBaseSession for: (Array with: Address with: Customer).

	customerSystem beginTransaction.
! !
!PersistentCustomerSystem methodsFor: 'as yet unclassified' stamp: 'LK 11/22/2023 17:24:36'!
beginTransaction

	session beginTransaction.! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'LK 11/22/2023 17:28:52' prior: 50765903!
importAddress

	| newAddress |
	
	(newCustomer isNil) ifTrue: [self error: self addressWithNoCustomerErrorDescription].
	
	((record size < 6) or: [record size > 6]) ifTrue: [self error: self invalidFieldFormatErrorDescription].
	
	newAddress := Address new.
	newCustomer addAddress: newAddress.
	newAddress streetName: record second.
	newAddress streetNumber: record third asNumber .
	newAddress town: record fourth.
	newAddress zipCode: record fifth asNumber .
	newAddress province: record sixth! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'LK 11/22/2023 17:29:18'!
assertCustomerWasImportedFirst

	^ (newCustomer isNil) ifTrue: [self error: self addressWithNoCustomerErrorDescription]! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'LK 11/22/2023 17:29:18' prior: 50766714!
importAddress

	| newAddress |
	
	self assertCustomerWasImportedFirst.
	
	((record size < 6) or: [record size > 6]) ifTrue: [self error: self invalidFieldFormatErrorDescription].
	
	newAddress := Address new.
	newCustomer addAddress: newAddress.
	newAddress streetName: record second.
	newAddress streetNumber: record third asNumber .
	newAddress town: record fourth.
	newAddress zipCode: record fifth asNumber .
	newAddress province: record sixth! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'LK 11/22/2023 17:30:30'!
assertAddressHasValidFields

	^ ((record size < 6) or: [record size > 6]) ifTrue: [self error: self invalidFieldFormatErrorDescription]! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'LK 11/22/2023 17:30:30' prior: 50766739!
importAddress

	| newAddress |
	
	self assertCustomerWasImportedFirst.
	
	self assertAddressHasValidFields.
	
	newAddress := Address new.
	newCustomer addAddress: newAddress.
	newAddress streetName: record second.
	newAddress streetNumber: record third asNumber .
	newAddress town: record fourth.
	newAddress zipCode: record fifth asNumber .
	newAddress province: record sixth! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'LK 11/22/2023 17:31:18'!
assertCustomerFieldsAreValid

	^ (record size < 5 or: [record size > 5]) ifTrue:  [self error: self invalidFieldFormatErrorDescription]! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'LK 11/22/2023 17:31:18' prior: 50765809!
importCustomer

	self assertCustomerFieldsAreValid.
	
	newCustomer := Customer new.
	newCustomer firstName: record second.
	newCustomer lastName: record third.
	newCustomer identificationType: record fourth.
	newCustomer identificationNumber: record fifth.
	
	session persist: newCustomer! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'LK 11/22/2023 17:31:40'!
assertAddressFieldsAreValid

	^ ((record size < 6) or: [record size > 6]) ifTrue: [self error: self invalidFieldFormatErrorDescription]! !
!CustomerImporter methodsFor: 'as yet unclassified' stamp: 'LK 11/22/2023 17:31:40' prior: 50766764!
importAddress

	| newAddress |
	
	self assertCustomerWasImportedFirst.
	
	self assertAddressFieldsAreValid.
	
	newAddress := Address new.
	newCustomer addAddress: newAddress.
	newAddress streetName: record second.
	newAddress streetNumber: record third asNumber .
	newAddress town: record fourth.
	newAddress zipCode: record fifth asNumber .
	newAddress province: record sixth! !

!methodRemoval: CustomerImporter #assertAddressHasValidFields stamp: 'LK 11/22/2023 17:31:40'!
assertAddressHasValidFields

	^ ((record size < 6) or: [record size > 6]) ifTrue: [self error: self invalidFieldFormatErrorDescription]!
!CustomerImporter methodsFor: 'evaluating' stamp: 'LK 11/22/2023 17:32:01' prior: 50766799!
assertAddressFieldsAreValid

	^ record size ~= 6 ifTrue: [self error: self invalidFieldFormatErrorDescription]! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'LK 11/22/2023 17:32:16' prior: 50766779!
assertCustomerFieldsAreValid

	^ record size ~= 5 ifTrue:  [self error: self invalidFieldFormatErrorDescription]! !
!ImportTest methodsFor: 'tests' stamp: 'LK 11/22/2023 17:32:46' prior: 50765968!
test05FailsImportingWhenAddressRecordHasMoreThanSixFields

	|importer text| 
	
	text := 'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs,CABA'.
	
	importer := (CustomerImporter from: (ReadStream on: text) into: session).
	
	self 
		should: [importer value]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText equals: importer invalidFieldFormatErrorDescription.
			self assert: self numberOfCustomers equals: 0].! !
!ImportTest methodsFor: 'setUp/tearDown' stamp: 'LK 11/22/2023 17:33:41' prior: 50766701 overrides: 16961394!
setUp

	customerSystem := PersistentCustomerSystem new.
	
	session := DataBaseSession for: (Array with: Address with: Customer).

	session beginTransaction.
! !

!testRun: #ImportTest #test01ImportsAllCustomersAndAddressesAsExpected stamp: 'LK 11/22/2023 17:33:53'!
ERROR!

!testRun: #ImportTest #test01ImportsAllCustomersAndAddressesAsExpected stamp: 'LK 11/22/2023 17:33:53'!
ERROR!
!CustomerImporter methodsFor: 'evaluating' stamp: 'LK 11/22/2023 17:34:48' prior: 50766563!
importRecord

	(record isEmpty) ifTrue: [self error: self emptyStreamErrorDescription].

	(self isCustomerRecord) ifTrue: [^self importCustomer].

	(self isAddressRecord) ifTrue: [^self importAddress].
	
	self error: self invalidFieldFormatErrorDescription.! !

!testRun: #ImportTest #test01ImportsAllCustomersAndAddressesAsExpected stamp: 'LK 11/22/2023 17:34:52'!
PASSED!

!testRun: #ImportTest #test02FailsImportingWhenCustomerRecordHasLessThanFiveFields stamp: 'LK 11/22/2023 17:34:53'!
PASSED!

!testRun: #ImportTest #test03FailsImportingWhenCustomerRecordHasMoreThanFiveFields stamp: 'LK 11/22/2023 17:34:55'!
PASSED!

!testRun: #ImportTest #test04FailsImportingWhenAddressRecordHasLessThanSixFields stamp: 'LK 11/22/2023 17:34:57'!
PASSED!
!ImportTest methodsFor: 'tests' stamp: 'LK 11/22/2023 17:35:02' prior: 50766010!
test04FailsImportingWhenAddressRecordHasLessThanSixFields

	|importer text| 
	
	text := 'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636'.
	
	importer := (CustomerImporter from: (ReadStream on: text ) into: session).
	

	self 
		should: [importer value]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText equals: importer invalidFieldFormatErrorDescription.
			self assert: self numberOfCustomers equals: 0].! !

!testRun: #ImportTest #test04FailsImportingWhenAddressRecordHasLessThanSixFields stamp: 'LK 11/22/2023 17:35:05'!
FAILURE!

!testRun: #ImportTest #test04FailsImportingWhenAddressRecordHasLessThanSixFields stamp: 'LK 11/22/2023 17:35:05'!
FAILURE!

!testRun: #ImportTest #test06FailsImportingWhenAddressIsGivenWithoutCustomer stamp: 'LK 11/22/2023 17:36:33'!
PASSED!

!testRun: #ImportTest #test07FailsImportingEmptyStream stamp: 'LK 11/22/2023 17:36:36'!
FAILURE!

!testRun: #ImportTest #test08FailsImportingInvalidCustomerThatStartsWithC stamp: 'LK 11/22/2023 17:37:13'!
PASSED!

!testRun: #ImportTest #test09FailsImportingInvalidAddressThatStartsWithA stamp: 'LK 11/22/2023 17:37:14'!
PASSED!
!ImportTest methodsFor: 'test data' stamp: 'LK 11/22/2023 17:38:28'!
numberOfAddressesOfCustomer

	^((session selectAllOfType: Customer) anyOne addresses) size! !

!testRun: #ImportTest #test04FailsImportingWhenAddressRecordHasLessThanSixFields stamp: 'LK 11/22/2023 17:38:41'!
FAILURE!
!ImportTest methodsFor: 'tests' stamp: 'LK 11/22/2023 17:42:16' prior: 50766903!
test04FailsImportingWhenAddressRecordHasLessThanSixFields

	|importer text| 
	
	text := 'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636'.
	
	importer := (CustomerImporter from: (ReadStream on: text ) into: session).
	

	self 
		should: [importer value]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText equals: importer invalidFieldFormatErrorDescription.
			self assert: self numberOfCustomers equals: 1.
			self assert: self numberOfAddressesOfCustomer equals: 0].! !

!testRun: #ImportTest #test04FailsImportingWhenAddressRecordHasLessThanSixFields stamp: 'LK 11/22/2023 17:42:17'!
PASSED!

!testRun: #ImportTest #test01ImportsAllCustomersAndAddressesAsExpected stamp: 'LK 11/22/2023 17:42:18'!
PASSED!

!testRun: #ImportTest #test02FailsImportingWhenCustomerRecordHasLessThanFiveFields stamp: 'LK 11/22/2023 17:42:18'!
PASSED!

!testRun: #ImportTest #test03FailsImportingWhenCustomerRecordHasMoreThanFiveFields stamp: 'LK 11/22/2023 17:42:18'!
PASSED!

!testRun: #ImportTest #test04FailsImportingWhenAddressRecordHasLessThanSixFields stamp: 'LK 11/22/2023 17:42:18'!
PASSED!

!testRun: #ImportTest #test05FailsImportingWhenAddressRecordHasMoreThanSixFields stamp: 'LK 11/22/2023 17:42:19'!
FAILURE!

!testRun: #ImportTest #test06FailsImportingWhenAddressIsGivenWithoutCustomer stamp: 'LK 11/22/2023 17:42:19'!
PASSED!

!testRun: #ImportTest #test07FailsImportingEmptyStream stamp: 'LK 11/22/2023 17:42:19'!
FAILURE!

!testRun: #ImportTest #test08FailsImportingInvalidCustomerThatStartsWithC stamp: 'LK 11/22/2023 17:42:19'!
PASSED!

!testRun: #ImportTest #test09FailsImportingInvalidAddressThatStartsWithA stamp: 'LK 11/22/2023 17:42:19'!
PASSED!

!testRun: #ImportTest #test04FailsImportingWhenAddressRecordHasLessThanSixFields stamp: 'LK 11/22/2023 17:42:23'!
PASSED!
!ImportTest methodsFor: 'tests' stamp: 'LK 11/22/2023 17:42:33' prior: 50766844!
test05FailsImportingWhenAddressRecordHasMoreThanSixFields

	|importer text| 
	
	text := 'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs,CABA'.
	
	importer := (CustomerImporter from: (ReadStream on: text) into: session).
	
	self 
		should: [importer value]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText equals: importer invalidFieldFormatErrorDescription.
			self assert: self numberOfCustomers equals: 1.
			self assert: self numberOfAddressesOfCustomer equals: 0].! !

!testRun: #ImportTest #test05FailsImportingWhenAddressRecordHasMoreThanSixFields stamp: 'LK 11/22/2023 17:42:34'!
PASSED!

!testRun: #ImportTest #test01ImportsAllCustomersAndAddressesAsExpected stamp: 'LK 11/22/2023 17:42:34'!
PASSED!

!testRun: #ImportTest #test02FailsImportingWhenCustomerRecordHasLessThanFiveFields stamp: 'LK 11/22/2023 17:42:34'!
PASSED!

!testRun: #ImportTest #test03FailsImportingWhenCustomerRecordHasMoreThanFiveFields stamp: 'LK 11/22/2023 17:42:35'!
PASSED!

!testRun: #ImportTest #test04FailsImportingWhenAddressRecordHasLessThanSixFields stamp: 'LK 11/22/2023 17:42:35'!
PASSED!

!testRun: #ImportTest #test05FailsImportingWhenAddressRecordHasMoreThanSixFields stamp: 'LK 11/22/2023 17:42:35'!
PASSED!

!testRun: #ImportTest #test06FailsImportingWhenAddressIsGivenWithoutCustomer stamp: 'LK 11/22/2023 17:42:35'!
PASSED!

!testRun: #ImportTest #test07FailsImportingEmptyStream stamp: 'LK 11/22/2023 17:42:35'!
FAILURE!

!testRun: #ImportTest #test08FailsImportingInvalidCustomerThatStartsWithC stamp: 'LK 11/22/2023 17:42:35'!
PASSED!

!testRun: #ImportTest #test09FailsImportingInvalidAddressThatStartsWithA stamp: 'LK 11/22/2023 17:42:35'!
PASSED!

!testRun: #ImportTest #test07FailsImportingEmptyStream stamp: 'LK 11/22/2023 17:42:35'!
FAILURE!

!testRun: #ImportTest #test05FailsImportingWhenAddressRecordHasMoreThanSixFields stamp: 'LK 11/22/2023 17:42:43'!
PASSED!
!ImportTest methodsFor: 'tests' stamp: 'LK 11/22/2023 17:43:54' prior: 50766462!
test09FailsImportingInvalidAddressThatStartsWithA
	|importer text| 
	
	text := 'C,Pepe,Sanchez,D,22333444
AA,San Martin,3322,Olivos,1636,BsAs'.
	
	importer := (CustomerImporter from: (ReadStream on: text) into: session).
	
	self 
		should: [importer value]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText equals: importer invalidFieldFormatErrorDescription.
			self assert: self numberOfCustomers equals: 1.
			self assert: self numberOfAddressesOfCustomer equals: 0].! !
!ImportTest methodsFor: 'tests' stamp: 'LK 11/22/2023 17:44:36'!
assertSessionHasOneCustomerWithoutAnAddress

	self assert: self numberOfCustomers equals: 1.
			self assert: self numberOfAddressesOfCustomer equals: 0! !
!ImportTest methodsFor: 'tests' stamp: 'LK 11/22/2023 17:44:36' prior: 50766951!
test04FailsImportingWhenAddressRecordHasLessThanSixFields

	|importer text| 
	
	text := 'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636'.
	
	importer := (CustomerImporter from: (ReadStream on: text ) into: session).
	

	self 
		should: [importer value]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText equals: importer invalidFieldFormatErrorDescription.
			self assertSessionHasOneCustomerWithoutAnAddress].! !
!ImportTest methodsFor: 'tests' stamp: 'LK 11/22/2023 17:44:36' prior: 50767011!
test05FailsImportingWhenAddressRecordHasMoreThanSixFields

	|importer text| 
	
	text := 'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs,CABA'.
	
	importer := (CustomerImporter from: (ReadStream on: text) into: session).
	
	self 
		should: [importer value]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText equals: importer invalidFieldFormatErrorDescription.
			self assertSessionHasOneCustomerWithoutAnAddress].! !
!ImportTest methodsFor: 'tests' stamp: 'LK 11/22/2023 17:44:36' prior: 50767074!
test09FailsImportingInvalidAddressThatStartsWithA
	|importer text| 
	
	text := 'C,Pepe,Sanchez,D,22333444
AA,San Martin,3322,Olivos,1636,BsAs'.
	
	importer := (CustomerImporter from: (ReadStream on: text) into: session).
	
	self 
		should: [importer value]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText equals: importer invalidFieldFormatErrorDescription.
			self assertSessionHasOneCustomerWithoutAnAddress].! !

!testRun: #ImportTest #test01ImportsAllCustomersAndAddressesAsExpected stamp: 'LK 11/22/2023 17:44:59'!
PASSED!

!testRun: #ImportTest #test02FailsImportingWhenCustomerRecordHasLessThanFiveFields stamp: 'LK 11/22/2023 17:44:59'!
PASSED!

!testRun: #ImportTest #test03FailsImportingWhenCustomerRecordHasMoreThanFiveFields stamp: 'LK 11/22/2023 17:44:59'!
PASSED!

!testRun: #ImportTest #test04FailsImportingWhenAddressRecordHasLessThanSixFields stamp: 'LK 11/22/2023 17:44:59'!
PASSED!

!testRun: #ImportTest #test05FailsImportingWhenAddressRecordHasMoreThanSixFields stamp: 'LK 11/22/2023 17:44:59'!
PASSED!

!testRun: #ImportTest #test06FailsImportingWhenAddressIsGivenWithoutCustomer stamp: 'LK 11/22/2023 17:45:00'!
PASSED!

!testRun: #ImportTest #test07FailsImportingEmptyStream stamp: 'LK 11/22/2023 17:45:00'!
FAILURE!

!testRun: #ImportTest #test08FailsImportingInvalidCustomerThatStartsWithC stamp: 'LK 11/22/2023 17:45:00'!
PASSED!

!testRun: #ImportTest #test09FailsImportingInvalidAddressThatStartsWithA stamp: 'LK 11/22/2023 17:45:00'!
PASSED!

!testRun: #ImportTest #test07FailsImportingEmptyStream stamp: 'LK 11/22/2023 17:45:00'!
FAILURE!
!CustomerImporter methodsFor: 'evaluating' stamp: 'LK 11/22/2023 17:46:37' prior: 50766078!
assertRecordIsEmpty

	record isEmpty ifTrue: [self error: self emptyStreamErrorDescription].! !
!CustomerImporter methodsFor: 'evaluating' stamp: 'LK 11/22/2023 17:46:53' prior: 50766877!
importRecord

	self assertRecordIsEmpty.

	(self isCustomerRecord) ifTrue: [^self importCustomer].

	(self isAddressRecord) ifTrue: [^self importAddress].
	
	self error: self invalidFieldFormatErrorDescription.! !

!testRun: #ImportTest #test07FailsImportingEmptyStream stamp: 'LK 11/22/2023 17:46:57'!
FAILURE!
!ImportTest methodsFor: 'tests' stamp: 'LK 11/22/2023 17:48:04' prior: 50765741!
test07FailsImportingEmptyStream

	|importer | 
	
	importer := (CustomerImporter from: (ReadStream on: '') into: session).
	
	self 
		should: [importer value]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText equals: importer emptyStreamErrorDescription.
			self assert: self numberOfCustomers equals: 0].! !
!ImportTest methodsFor: 'tests' stamp: 'LK 11/22/2023 17:48:18' prior: 50767206!
test07FailsImportingEmptyStream

	|importer | 
	
	importer := (CustomerImporter from: (ReadStream on: '') into: session).
	
	self 
		should: [importer value]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText equals: importer emptyStreamErrorDescription.].! !

!testRun: #ImportTest #test07FailsImportingEmptyStream stamp: 'LK 11/22/2023 17:48:20'!
FAILURE!

!methodRemoval: PersistentCustomerSystem #initializeFor: stamp: 'LK 11/22/2023 18:10:48'!
initializeFor: aSession

	session := aSession.!
!PersistentCustomerSystem methodsFor: 'as yet unclassified' stamp: 'LK 11/22/2023 18:10:58' overrides: 16920235!
initialize

	session := 10.! !

!methodRemoval: PersistentCustomerSystem class #for: stamp: 'LK 11/22/2023 18:11:04'!
for: aSession
	
	^self new initializeFor: aSession!
!PersistentCustomerSystem methodsFor: 'as yet unclassified' stamp: 'LK 11/22/2023 18:11:15'!
start

	session beginTransaction.! !
!PersistentCustomerSystem methodsFor: 'as yet unclassified' stamp: 'LK 11/22/2023 18:11:15' prior: 50766709!
beginTransaction

	session start.! !
!PersistentCustomerSystem methodsFor: 'as yet unclassified' stamp: 'LK 11/22/2023 18:11:15' prior: 50767250!
start

	session start.! !

!methodRemoval: PersistentCustomerSystem #beginTransaction stamp: 'LK 11/22/2023 18:11:15'!
beginTransaction

	session start.!
!PersistentCustomerSystem methodsFor: 'as yet unclassified' stamp: 'LK 11/22/2023 18:11:48' prior: 50767260!
start

	session beginTransaction.! !
!PersistentCustomerSystem methodsFor: 'as yet unclassified' stamp: 'LK 11/22/2023 18:12:18' prior: 50767241 overrides: 16920235!
initialize

	session := DataBaseSession for: (Array with: Address with: Customer).! !
!PersistentCustomerSystem methodsFor: 'as yet unclassified' stamp: 'LK 11/22/2023 18:12:26'!
session
	
	^session! !
!PersistentCustomerSystem methodsFor: 'as yet unclassified' stamp: 'LK 11/22/2023 18:15:00'!
close! !
!PersistentCustomerSystem methodsFor: 'as yet unclassified' stamp: 'LK 11/22/2023 18:16:06' prior: 50767285!
close

	session commit.
	session close.! !
!ImportTest methodsFor: 'setUp/tearDown' stamp: 'LK 11/22/2023 18:16:28' prior: 50766862 overrides: 16961394!
setUp

	customerSystem := PersistentCustomerSystem new.
	
	customerSystem start.
! !

!methodRemoval: ImportTest #start stamp: 'LK 11/22/2023 18:16:36'!
start

	^ session := DataBaseSession for: (Array with: Address with: Customer)!
!ImportTest methodsFor: 'setUp/tearDown' stamp: 'LK 11/22/2023 18:16:42' prior: 50764720 overrides: 16961402!
tearDown

	customerSystem close! !

!testRun: #ImportTest #test01ImportsAllCustomersAndAddressesAsExpected stamp: 'LK 11/22/2023 18:16:43'!
ERROR!

!testRun: #ImportTest #test02FailsImportingWhenCustomerRecordHasLessThanFiveFields stamp: 'LK 11/22/2023 18:16:43'!
ERROR!

!testRun: #ImportTest #test03FailsImportingWhenCustomerRecordHasMoreThanFiveFields stamp: 'LK 11/22/2023 18:16:43'!
ERROR!

!testRun: #ImportTest #test04FailsImportingWhenAddressRecordHasLessThanSixFields stamp: 'LK 11/22/2023 18:16:43'!
FAILURE!

!testRun: #ImportTest #test05FailsImportingWhenAddressRecordHasMoreThanSixFields stamp: 'LK 11/22/2023 18:16:43'!
FAILURE!

!testRun: #ImportTest #test06FailsImportingWhenAddressIsGivenWithoutCustomer stamp: 'LK 11/22/2023 18:16:43'!
ERROR!

!testRun: #ImportTest #test07FailsImportingEmptyStream stamp: 'LK 11/22/2023 18:16:43'!
FAILURE!

!testRun: #ImportTest #test08FailsImportingInvalidCustomerThatStartsWithC stamp: 'LK 11/22/2023 18:16:43'!
ERROR!

!testRun: #ImportTest #test09FailsImportingInvalidAddressThatStartsWithA stamp: 'LK 11/22/2023 18:16:43'!
FAILURE!

!testRun: #ImportTest #test01ImportsAllCustomersAndAddressesAsExpected stamp: 'LK 11/22/2023 18:18:46'!
ERROR!

!testRun: #ImportTest #test01ImportsAllCustomersAndAddressesAsExpected stamp: 'LK 11/22/2023 18:18:46'!
ERROR!
!PersistentCustomerSystem methodsFor: 'as yet unclassified' stamp: 'LK 11/22/2023 18:21:15'!
persist

	session persist! !

!classDefinition: #CustomerImporter category: 'CustomerImporter' stamp: 'LK 11/22/2023 18:21:33'!
Object subclass: #CustomerImporter
	instanceVariableNames: 'customerSystem readStream line newCustomer record'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!
!CustomerImporter methodsFor: 'as yet unclassified' stamp: 'LK 11/22/2023 18:21:33' prior: 50764883!
initializeFrom: aReadStream into: aSession

	customerSystem := aSession.
	readStream := aReadStream.! !
!CustomerImporter methodsFor: 'as yet unclassified' stamp: 'LK 11/22/2023 18:21:33' prior: 50766787!
importCustomer

	self assertCustomerFieldsAreValid.
	
	newCustomer := Customer new.
	newCustomer firstName: record second.
	newCustomer lastName: record third.
	newCustomer identificationType: record fourth.
	newCustomer identificationNumber: record fifth.
	
	customerSystem persist: newCustomer! !
!CustomerImporter class methodsFor: 'instance creation' stamp: 'LK 11/22/2023 18:21:58' prior: 50764968!
from: aReadStream into: aCustomerSystem

	^self new initializeFrom: aReadStream into: aCustomerSystem! !
!CustomerImporter class methodsFor: 'importing' stamp: 'LK 11/22/2023 18:22:06' prior: 50764974!
valueFrom: aReadStream into: aCustomerSystem

	^(self from: aReadStream into: aCustomerSystem) value! !
!ImportTest methodsFor: 'tests' stamp: 'LK 11/22/2023 18:22:40' prior: 50765769!
test01ImportsAllCustomersAndAddressesAsExpected

	CustomerImporter valueFrom: self validImportData into: customerSystem.

	self assertImportedRightNumberOfCustomers.
	self assertPepeSanchezWasImportedCorrecty.
	self assertJuanPerezWasImportedCorrectly ! !
!ImportTest methodsFor: 'tests' stamp: 'LK 11/22/2023 18:22:46' prior: 50765842!
test02FailsImportingWhenCustomerRecordHasLessThanFiveFields

	|importer| 
	
	importer := (CustomerImporter from: (ReadStream on: 'C,Pepe,Sanchez, D') into: customerSystem).
	
	self 
		should: [importer value]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText equals: importer invalidFieldFormatErrorDescription.
			self assert: self numberOfCustomers equals: 0].
	
	! !
!ImportTest methodsFor: 'tests' stamp: 'LK 11/22/2023 18:22:48' prior: 50765793!
test03FailsImportingWhenCustomerRecordHasMoreThanFiveFields

	|importer| 
	
	importer := (CustomerImporter from: (ReadStream on: 'C,Pepe,Sanchez, D,3,2') into: customerSystem).
	
	self 
		should: [importer value]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText equals: importer invalidFieldFormatErrorDescription.
			self assert: self numberOfCustomers equals: 0].
	
	! !
!ImportTest methodsFor: 'tests' stamp: 'LK 11/22/2023 18:22:51' prior: 50767100!
test04FailsImportingWhenAddressRecordHasLessThanSixFields

	|importer text| 
	
	text := 'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636'.
	
	importer := (CustomerImporter from: (ReadStream on: text ) into: customerSystem).
	

	self 
		should: [importer value]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText equals: importer invalidFieldFormatErrorDescription.
			self assertSessionHasOneCustomerWithoutAnAddress].! !
!ImportTest methodsFor: 'tests' stamp: 'LK 11/22/2023 18:22:55' prior: 50767117!
test05FailsImportingWhenAddressRecordHasMoreThanSixFields

	|importer text| 
	
	text := 'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs,CABA'.
	
	importer := (CustomerImporter from: (ReadStream on: text) into: customerSystem).
	
	self 
		should: [importer value]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText equals: importer invalidFieldFormatErrorDescription.
			self assertSessionHasOneCustomerWithoutAnAddress].! !
!ImportTest methodsFor: 'tests' stamp: 'LK 11/22/2023 18:22:57' prior: 50765922!
test06FailsImportingWhenAddressIsGivenWithoutCustomer

	|importer text| 
	
	text := 'A,San Martin,3322,Olivos,1636,BsAs'.
	
	importer := (CustomerImporter from: (ReadStream on: text) into: customerSystem).
	
	self 
		should: [importer value]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText equals: importer addressWithNoCustomerErrorDescription.
			self assert: self numberOfCustomers equals: 0].! !
!ImportTest methodsFor: 'tests' stamp: 'LK 11/22/2023 18:22:59' prior: 50767220!
test07FailsImportingEmptyStream

	|importer | 
	
	importer := (CustomerImporter from: (ReadStream on: '') into: customerSystem).
	
	self 
		should: [importer value]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText equals: importer emptyStreamErrorDescription.].! !
!ImportTest methodsFor: 'tests' stamp: 'LK 11/22/2023 18:23:05' prior: 50766580!
test08FailsImportingInvalidCustomerThatStartsWithC
	|importer text| 
	
	text := 'CC,Pepe,Sanchez,D,22333444
	A,San Martin,3322,Olivos,1636,BsAs'.
	
	importer := (CustomerImporter from: (ReadStream on: text) into: customerSystem ).
	
	self 
		should: [importer value]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText equals: importer invalidFieldFormatErrorDescription.
			self assert: self numberOfCustomers equals: 0].! !
!ImportTest methodsFor: 'tests' stamp: 'LK 11/22/2023 18:23:07' prior: 50767503!
test08FailsImportingInvalidCustomerThatStartsWithC
	|importer text| 
	
	text := 'CC,Pepe,Sanchez,D,22333444
	A,San Martin,3322,Olivos,1636,BsAs'.
	
	importer := (CustomerImporter from: (ReadStream on: text) into: customerSystem).
	
	self 
		should: [importer value]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText equals: importer invalidFieldFormatErrorDescription.
			self assert: self numberOfCustomers equals: 0].! !
!ImportTest methodsFor: 'tests' stamp: 'LK 11/22/2023 18:23:11' prior: 50767134!
test09FailsImportingInvalidAddressThatStartsWithA
	|importer text| 
	
	text := 'C,Pepe,Sanchez,D,22333444
AA,San Martin,3322,Olivos,1636,BsAs'.
	
	importer := (CustomerImporter from: (ReadStream on: text) into: customerSystem).
	
	self 
		should: [importer value]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText equals: importer invalidFieldFormatErrorDescription.
			self assertSessionHasOneCustomerWithoutAnAddress].! !

!testRun: #ImportTest #test01ImportsAllCustomersAndAddressesAsExpected stamp: 'LK 11/22/2023 18:23:14'!
ERROR!

!testRun: #ImportTest #test02FailsImportingWhenCustomerRecordHasLessThanFiveFields stamp: 'LK 11/22/2023 18:23:14'!
ERROR!

!testRun: #ImportTest #test03FailsImportingWhenCustomerRecordHasMoreThanFiveFields stamp: 'LK 11/22/2023 18:23:14'!
ERROR!

!testRun: #ImportTest #test04FailsImportingWhenAddressRecordHasLessThanSixFields stamp: 'LK 11/22/2023 18:23:14'!
FAILURE!

!testRun: #ImportTest #test05FailsImportingWhenAddressRecordHasMoreThanSixFields stamp: 'LK 11/22/2023 18:23:14'!
FAILURE!

!testRun: #ImportTest #test06FailsImportingWhenAddressIsGivenWithoutCustomer stamp: 'LK 11/22/2023 18:23:14'!
ERROR!

!testRun: #ImportTest #test07FailsImportingEmptyStream stamp: 'LK 11/22/2023 18:23:14'!
FAILURE!

!testRun: #ImportTest #test08FailsImportingInvalidCustomerThatStartsWithC stamp: 'LK 11/22/2023 18:23:14'!
ERROR!

!testRun: #ImportTest #test09FailsImportingInvalidAddressThatStartsWithA stamp: 'LK 11/22/2023 18:23:14'!
FAILURE!

!testRun: #ImportTest #test01ImportsAllCustomersAndAddressesAsExpected stamp: 'LK 11/22/2023 18:23:17'!
ERROR!

!testRun: #ImportTest #test02FailsImportingWhenCustomerRecordHasLessThanFiveFields stamp: 'LK 11/22/2023 18:23:18'!
ERROR!

!testRun: #ImportTest #test03FailsImportingWhenCustomerRecordHasMoreThanFiveFields stamp: 'LK 11/22/2023 18:23:18'!
ERROR!

!testRun: #ImportTest #test06FailsImportingWhenAddressIsGivenWithoutCustomer stamp: 'LK 11/22/2023 18:23:18'!
ERROR!

!testRun: #ImportTest #test08FailsImportingInvalidCustomerThatStartsWithC stamp: 'LK 11/22/2023 18:23:18'!
ERROR!

!testRun: #ImportTest #test04FailsImportingWhenAddressRecordHasLessThanSixFields stamp: 'LK 11/22/2023 18:23:18'!
FAILURE!

!testRun: #ImportTest #test05FailsImportingWhenAddressRecordHasMoreThanSixFields stamp: 'LK 11/22/2023 18:23:18'!
FAILURE!

!testRun: #ImportTest #test07FailsImportingEmptyStream stamp: 'LK 11/22/2023 18:23:18'!
FAILURE!

!testRun: #ImportTest #test09FailsImportingInvalidAddressThatStartsWithA stamp: 'LK 11/22/2023 18:23:18'!
FAILURE!

!testRun: #ImportTest #test01ImportsAllCustomersAndAddressesAsExpected stamp: 'LK 11/22/2023 18:23:20'!
ERROR!

!testRun: #ImportTest #test01ImportsAllCustomersAndAddressesAsExpected stamp: 'LK 11/22/2023 18:23:35'!
ERROR!

!testRun: #ImportTest #test01ImportsAllCustomersAndAddressesAsExpected stamp: 'LK 11/22/2023 18:23:35'!
ERROR!

!testRun: #ImportTest #test01ImportsAllCustomersAndAddressesAsExpected stamp: 'LK 11/22/2023 18:24:37'!
ERROR!

!testRun: #ImportTest #test01ImportsAllCustomersAndAddressesAsExpected stamp: 'LK 11/22/2023 18:24:37'!
ERROR!

!testRun: #ImportTest #test02FailsImportingWhenCustomerRecordHasLessThanFiveFields stamp: 'LK 11/22/2023 18:24:40'!
ERROR!

!testRun: #ImportTest #test02FailsImportingWhenCustomerRecordHasLessThanFiveFields stamp: 'LK 11/22/2023 18:24:40'!
ERROR!

!testRun: #ImportTest #test01ImportsAllCustomersAndAddressesAsExpected stamp: 'LK 11/22/2023 18:25:14'!
ERROR!

!testRun: #ImportTest #test01ImportsAllCustomersAndAddressesAsExpected stamp: 'LK 11/22/2023 18:25:14'!
ERROR!

PersistentCustomerSystem!

PersistentCustomerSystem new!
!ImportTest methodsFor: 'setUp/tearDown' stamp: 'LK 11/22/2023 18:29:47' prior: 50767294 overrides: 16961394!
setUp

	customerSystem := PersistentCustomerSystem new.
	
	customerSystem start.
! !
!ImportTest methodsFor: 'setUp/tearDown' stamp: 'LK 11/22/2023 18:31:19' prior: 50767655 overrides: 16961394!
setUp

	customerSystem := PersistentCustomerSystem new.
	customerSystem start.
! !

!testRun: #ImportTest #test02FailsImportingWhenCustomerRecordHasLessThanFiveFields stamp: 'LK 11/22/2023 18:31:38'!
ERROR!

!testRun: #ImportTest #test02FailsImportingWhenCustomerRecordHasLessThanFiveFields stamp: 'LK 11/22/2023 18:31:38'!
ERROR!

!testRun: #ImportTest #test03FailsImportingWhenCustomerRecordHasMoreThanFiveFields stamp: 'LK 11/22/2023 18:31:47'!
ERROR!

!testRun: #ImportTest #test03FailsImportingWhenCustomerRecordHasMoreThanFiveFields stamp: 'LK 11/22/2023 18:31:47'!
ERROR!
!PersistentCustomerSystem methodsFor: 'as yet unclassified' stamp: 'LK 11/22/2023 18:32:15'!
numberOfCustomers

	^(session selectAllOfType: Customer) size! !
!ImportTest methodsFor: 'test data' stamp: 'LK 11/22/2023 18:32:31' prior: 50764734!
numberOfCustomers

	^customerSystem numberOfCustomers ! !
!ImportTest methodsFor: 'test data' stamp: 'LK 11/22/2023 18:32:53' prior: 50766941!
numberOfAddressesOfCustomer

	^customerSystem numberOfAddresesOfCustomer! !
!PersistentCustomerSystem methodsFor: 'as yet unclassified' stamp: 'LK 11/22/2023 18:33:07'!
numberOfCustomer

	^((session selectAllOfType: Customer) anyOne addresses) size! !
!PersistentCustomerSystem methodsFor: 'as yet unclassified' stamp: 'LK 11/22/2023 18:33:26'!
numberOfAddressesOfCustomer

	^((session selectAllOfType: Customer) anyOne addresses) size! !

!methodRemoval: PersistentCustomerSystem #numberOfCustomer stamp: 'LK 11/22/2023 18:33:26'!
numberOfCustomer

	^((session selectAllOfType: Customer) anyOne addresses) size!
!PersistentCustomerSystem methodsFor: 'as yet unclassified' stamp: 'LK 11/22/2023 18:33:34' prior: 50767705!
numberOfAddressesOfCustomer

	^((session selectAllOfType: Customer) anyOne addresses) size! !

!testRun: #ImportTest #test05FailsImportingWhenAddressRecordHasMoreThanSixFields stamp: 'LK 11/22/2023 18:33:39'!
FAILURE!

!testRun: #ImportTest #test05FailsImportingWhenAddressRecordHasMoreThanSixFields stamp: 'LK 11/22/2023 18:33:39'!
FAILURE!

!testRun: #ImportTest #test02FailsImportingWhenCustomerRecordHasLessThanFiveFields stamp: 'LK 11/22/2023 18:33:45'!
PASSED!

!testRun: #ImportTest #test03FailsImportingWhenCustomerRecordHasMoreThanFiveFields stamp: 'LK 11/22/2023 18:33:48'!
PASSED!

!testRun: #ImportTest #test04FailsImportingWhenAddressRecordHasLessThanSixFields stamp: 'LK 11/22/2023 18:33:50'!
FAILURE!

!testRun: #ImportTest #test04FailsImportingWhenAddressRecordHasLessThanSixFields stamp: 'LK 11/22/2023 18:33:50'!
FAILURE!

!testRun: #ImportTest #test01ImportsAllCustomersAndAddressesAsExpected stamp: 'LK 11/22/2023 18:37:14'!
ERROR!

!testRun: #ImportTest #test01ImportsAllCustomersAndAddressesAsExpected stamp: 'LK 11/22/2023 18:37:14'!
ERROR!

CustomerImporter!
!PersistentCustomerSystem methodsFor: 'as yet unclassified' stamp: 'LK 11/22/2023 18:38:50'!
session: anObject
	
	^session! !

!methodRemoval: PersistentCustomerSystem #session stamp: 'LK 11/22/2023 18:38:50'!
session
	
	^session!
!PersistentCustomerSystem methodsFor: 'as yet unclassified' stamp: 'LK 11/22/2023 18:39:08'!
session

	^session! !

!methodRemoval: PersistentCustomerSystem #session: stamp: 'LK 11/22/2023 18:39:09'!
session: anObject
	
	^session!
!PersistentCustomerSystem methodsFor: 'as yet unclassified' stamp: 'LK 11/22/2023 18:39:22'!
persist: anObject

	^session persist: anObject! !

!methodRemoval: PersistentCustomerSystem #persist stamp: 'LK 11/22/2023 18:39:24'!
persist

	session persist!
!ImportTest methodsFor: 'test data' stamp: 'LK 11/22/2023 18:39:39' prior: 50767693!
numberOfAddressesOfCustomer

	^customerSystem numberOfAddressesOfCustomer! !

!testRun: #ImportTest #test01ImportsAllCustomersAndAddressesAsExpected stamp: 'LK 11/22/2023 18:39:44'!
ERROR!

!testRun: #ImportTest #test01ImportsAllCustomersAndAddressesAsExpected stamp: 'LK 11/22/2023 18:39:44'!
ERROR!

!testRun: #ImportTest #test02FailsImportingWhenCustomerRecordHasLessThanFiveFields stamp: 'LK 11/22/2023 18:39:51'!
PASSED!
!ImportTest methodsFor: 'assertions' stamp: 'LK 11/22/2023 18:40:19' prior: 50764673!
assertImportedRightNumberOfCustomers

	^ self assert: 2 equals: customerSystem numberOfCustomers! !
!ImportTest methodsFor: 'assertions' stamp: 'LK 11/22/2023 18:40:43' prior: 50767794!
assertImportedRightNumberOfCustomers

	^ self assert: 2 equals: self numberOfCustomers! !
!ImportTest methodsFor: 'assertions' stamp: 'LK 11/22/2023 18:40:53' prior: 50767092!
assertSessionHasOneCustomerWithoutAnAddress

	self assert: self numberOfCustomers equals: 1.
	self assert: self numberOfAddressesOfCustomer equals: 0! !

!testRun: #ImportTest #test01ImportsAllCustomersAndAddressesAsExpected stamp: 'LK 11/22/2023 18:41:14'!
ERROR!

!testRun: #ImportTest #test02FailsImportingWhenCustomerRecordHasLessThanFiveFields stamp: 'LK 11/22/2023 18:41:15'!
PASSED!

!testRun: #ImportTest #test03FailsImportingWhenCustomerRecordHasMoreThanFiveFields stamp: 'LK 11/22/2023 18:41:15'!
PASSED!

!testRun: #ImportTest #test04FailsImportingWhenAddressRecordHasLessThanSixFields stamp: 'LK 11/22/2023 18:41:15'!
PASSED!

!testRun: #ImportTest #test05FailsImportingWhenAddressRecordHasMoreThanSixFields stamp: 'LK 11/22/2023 18:41:15'!
PASSED!

!testRun: #ImportTest #test06FailsImportingWhenAddressIsGivenWithoutCustomer stamp: 'LK 11/22/2023 18:41:16'!
PASSED!

!testRun: #ImportTest #test07FailsImportingEmptyStream stamp: 'LK 11/22/2023 18:41:16'!
FAILURE!

!testRun: #ImportTest #test08FailsImportingInvalidCustomerThatStartsWithC stamp: 'LK 11/22/2023 18:41:16'!
PASSED!

!testRun: #ImportTest #test09FailsImportingInvalidAddressThatStartsWithA stamp: 'LK 11/22/2023 18:41:16'!
PASSED!

!testRun: #ImportTest #test01ImportsAllCustomersAndAddressesAsExpected stamp: 'LK 11/22/2023 18:41:21'!
ERROR!

!testRun: #ImportTest #test01ImportsAllCustomersAndAddressesAsExpected stamp: 'LK 11/22/2023 18:41:21'!
ERROR!
!ImportTest methodsFor: 'customer' stamp: 'LK 11/22/2023 18:42:58' prior: 50764724!
customerWithIdentificationType: anIdType number: anIdNumber

	^ customerSystem customerWithIdentificationType: anIdType number: anIdNumber.! !
!ImportTest methodsFor: 'customer' stamp: 'HAW 5/22/2022 18:14:22' prior: 50767854!
customerWithIdentificationType: anIdType number: anIdNumber

	^ (session
		select: [ :aCustomer | aCustomer identificationType = anIdType and: [ aCustomer identificationNumber = anIdNumber ]]
		ofType: Customer) anyOne! !
!ImportTest methodsFor: 'customer' stamp: 'LK 11/22/2023 18:42:58' prior: 50767862!
customerWithIdentificationType: anIdType number: anIdNumber

	^ customerSystem customerWithIdentificationType: anIdType number: anIdNumber.! !
!PersistentCustomerSystem methodsFor: 'as yet unclassified' stamp: 'LK 11/22/2023 18:43:39'!
customerWithIdentificationType: anIdType number: anIdNumber

	^ (session
		select: [ :aCustomer | aCustomer identificationType = anIdType and: [ aCustomer identificationNumber = anIdNumber ]]
		ofType: Customer) anyOne! !

!testRun: #ImportTest #test01ImportsAllCustomersAndAddressesAsExpected stamp: 'LK 11/22/2023 18:43:43'!
PASSED!

!testRun: #ImportTest #test02FailsImportingWhenCustomerRecordHasLessThanFiveFields stamp: 'LK 11/22/2023 18:43:43'!
PASSED!

!testRun: #ImportTest #test03FailsImportingWhenCustomerRecordHasMoreThanFiveFields stamp: 'LK 11/22/2023 18:43:43'!
PASSED!

!testRun: #ImportTest #test04FailsImportingWhenAddressRecordHasLessThanSixFields stamp: 'LK 11/22/2023 18:43:43'!
PASSED!

!testRun: #ImportTest #test05FailsImportingWhenAddressRecordHasMoreThanSixFields stamp: 'LK 11/22/2023 18:43:44'!
PASSED!

!testRun: #ImportTest #test06FailsImportingWhenAddressIsGivenWithoutCustomer stamp: 'LK 11/22/2023 18:43:44'!
PASSED!

!testRun: #ImportTest #test07FailsImportingEmptyStream stamp: 'LK 11/22/2023 18:43:44'!
FAILURE!

!testRun: #ImportTest #test08FailsImportingInvalidCustomerThatStartsWithC stamp: 'LK 11/22/2023 18:43:44'!
PASSED!

!testRun: #ImportTest #test09FailsImportingInvalidAddressThatStartsWithA stamp: 'LK 11/22/2023 18:43:44'!
PASSED!

!testRun: #ImportTest #test07FailsImportingEmptyStream stamp: 'LK 11/22/2023 18:43:44'!
FAILURE!

!testRun: #ImportTest #test07FailsImportingEmptyStream stamp: 'LK 11/22/2023 18:43:50'!
FAILURE!

!testRun: #ImportTest #test07FailsImportingEmptyStream stamp: 'LK 11/22/2023 18:43:50'!
FAILURE!

!testRun: #ImportTest #test06FailsImportingWhenAddressIsGivenWithoutCustomer stamp: 'LK 11/22/2023 18:43:52'!
PASSED!

!testRun: #ImportTest #test05FailsImportingWhenAddressRecordHasMoreThanSixFields stamp: 'LK 11/22/2023 18:43:54'!
PASSED!

!testRun: #ImportTest #test01ImportsAllCustomersAndAddressesAsExpected stamp: 'LK 11/22/2023 18:43:56'!
PASSED!

!methodRemoval: PersistentCustomerSystem #session stamp: 'LK 11/22/2023 18:45:30'!
session

	^session!

!classDefinition: #CustomerSystem category: 'CustomerImporter' stamp: 'LK 11/22/2023 19:02:31'!
Object subclass: #CustomerSystem
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!classDefinition: #PersistentCustomerSystem category: 'CustomerImporter' stamp: 'LK 11/22/2023 19:02:31'!
CustomerSystem subclass: #PersistentCustomerSystem
	instanceVariableNames: 'session'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!
!CustomerSystem methodsFor: 'as yet unclassified' stamp: 'LK 11/22/2023 19:19:44'!
start

	self subclassResponsibility! !
!CustomerSystem methodsFor: 'as yet unclassified' stamp: 'LK 11/22/2023 19:19:54'!
close

	self subclassResponsibility! !

CustomerSystem subclass: #TransientCustomerSystem
	instanceVariableNames: 'session'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!classDefinition: #TransientCustomerSystem category: 'CustomerImporter' stamp: 'LK 11/22/2023 19:20:11'!
CustomerSystem subclass: #TransientCustomerSystem
	instanceVariableNames: 'session'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!
!TransientCustomerSystem methodsFor: 'no messages' stamp: 'LK 11/22/2023 19:24:09' overrides: 50767966!
close! !
!TransientCustomerSystem methodsFor: 'as yet unclassified' stamp: 'LK 11/22/2023 19:24:12' overrides: 50767962!
start! !
!TransientCustomerSystem methodsFor: 'as yet unclassified' stamp: 'LK 11/22/2023 19:24:19' overrides: 16920235!
initialize

	session := Set new.! !
!TransientCustomerSystem methodsFor: 'as yet unclassified' stamp: 'LK 11/22/2023 19:28:51'!
numbersOfCustomers

	^session size! !
!TransientCustomerSystem methodsFor: 'as yet unclassified' stamp: 'LK 11/22/2023 19:32:52'!
numberOfAddressesOfCustomer

	^((session selectAllOfType: Customer) anyOne addresses) size! !
!TransientCustomerSystem methodsFor: 'as yet unclassified' stamp: 'LK 11/22/2023 19:33:14' prior: 50768001!
numberOfAddressesOfCustomer

	^((session anyOne )addresses) size! !
!TransientCustomerSystem methodsFor: 'as yet unclassified' stamp: 'LK 11/22/2023 19:34:01'!
customerWithIdentificationType: anIdType number: anIdNumber

	^ (session
		select: [ :aCustomer | aCustomer identificationType = anIdType and: [ aCustomer identificationNumber = anIdNumber ]])! !
!TransientCustomerSystem methodsFor: 'as yet unclassified' stamp: 'LK 11/22/2023 19:34:08' prior: 50768013!
customerWithIdentificationType: anIdType number: anIdNumber

	^ session
		select: [ :aCustomer | aCustomer identificationType = anIdType and: [ aCustomer identificationNumber = anIdNumber ]]! !
!TransientCustomerSystem methodsFor: 'as yet unclassified' stamp: 'LK 11/22/2023 19:35:25'!
persist: anObject

	session add: anObject.! !

!testRun: #ImportTest #test01ImportsAllCustomersAndAddressesAsExpected stamp: 'LK 11/22/2023 19:35:31'!
PASSED!

!testRun: #ImportTest #test02FailsImportingWhenCustomerRecordHasLessThanFiveFields stamp: 'LK 11/22/2023 19:35:31'!
PASSED!

!testRun: #ImportTest #test03FailsImportingWhenCustomerRecordHasMoreThanFiveFields stamp: 'LK 11/22/2023 19:35:31'!
PASSED!

!testRun: #ImportTest #test04FailsImportingWhenAddressRecordHasLessThanSixFields stamp: 'LK 11/22/2023 19:35:31'!
PASSED!

!testRun: #ImportTest #test05FailsImportingWhenAddressRecordHasMoreThanSixFields stamp: 'LK 11/22/2023 19:35:32'!
PASSED!

!testRun: #ImportTest #test06FailsImportingWhenAddressIsGivenWithoutCustomer stamp: 'LK 11/22/2023 19:35:32'!
PASSED!

!testRun: #ImportTest #test07FailsImportingEmptyStream stamp: 'LK 11/22/2023 19:35:32'!
FAILURE!

!testRun: #ImportTest #test08FailsImportingInvalidCustomerThatStartsWithC stamp: 'LK 11/22/2023 19:35:32'!
PASSED!

!testRun: #ImportTest #test09FailsImportingInvalidAddressThatStartsWithA stamp: 'LK 11/22/2023 19:35:32'!
PASSED!

!testRun: #ImportTest #test07FailsImportingEmptyStream stamp: 'LK 11/22/2023 19:35:32'!
FAILURE!
!ImportTest methodsFor: 'tests' stamp: 'LK 11/22/2023 19:35:41' prior: 50767491!
test07FailsImportingEmptyStream

	|importer | 
	
	importer := (CustomerImporter from: (ReadStream on: '') into: customerSystem).
	
	"self 
		should: [importer value]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText equals: importer emptyStreamErrorDescription.]."! !

!testRun: #ImportTest #test01ImportsAllCustomersAndAddressesAsExpected stamp: 'LK 11/22/2023 19:35:46'!
PASSED!

!testRun: #ImportTest #test02FailsImportingWhenCustomerRecordHasLessThanFiveFields stamp: 'LK 11/22/2023 19:35:46'!
PASSED!

!testRun: #ImportTest #test03FailsImportingWhenCustomerRecordHasMoreThanFiveFields stamp: 'LK 11/22/2023 19:35:46'!
PASSED!

!testRun: #ImportTest #test04FailsImportingWhenAddressRecordHasLessThanSixFields stamp: 'LK 11/22/2023 19:35:46'!
PASSED!

!testRun: #ImportTest #test05FailsImportingWhenAddressRecordHasMoreThanSixFields stamp: 'LK 11/22/2023 19:35:46'!
PASSED!

!testRun: #ImportTest #test06FailsImportingWhenAddressIsGivenWithoutCustomer stamp: 'LK 11/22/2023 19:35:47'!
PASSED!

!testRun: #ImportTest #test07FailsImportingEmptyStream stamp: 'LK 11/22/2023 19:35:47'!
PASSED!

!testRun: #ImportTest #test08FailsImportingInvalidCustomerThatStartsWithC stamp: 'LK 11/22/2023 19:35:47'!
PASSED!

!testRun: #ImportTest #test09FailsImportingInvalidAddressThatStartsWithA stamp: 'LK 11/22/2023 19:35:47'!
PASSED!
!PersistentCustomerSystem methodsFor: 'as yet unclassified' stamp: 'LK 11/22/2023 19:35:58'!
numbersOfCustomers

	^(session selectAllOfType: Customer) size! !

!methodRemoval: PersistentCustomerSystem #numberOfCustomers stamp: 'LK 11/22/2023 19:35:59'!
numberOfCustomers

	^(session selectAllOfType: Customer) size!

!methodRemoval: TransientCustomerSystem #numbersOfCustomers stamp: 'LK 11/22/2023 19:36:18'!
numbersOfCustomers

	^session size!
!TransientCustomerSystem methodsFor: 'as yet unclassified' stamp: 'LK 11/22/2023 19:36:33'!
numberOfCustomers

	^session size! !
!PersistentCustomerSystem methodsFor: 'as yet unclassified' stamp: 'LK 11/22/2023 19:36:43'!
numberOfCustomers

	^(session selectAllOfType: Customer) size! !

!methodRemoval: PersistentCustomerSystem #numbersOfCustomers stamp: 'LK 11/22/2023 19:36:43'!
numbersOfCustomers

	^(session selectAllOfType: Customer) size!

!testRun: #ImportTest #test01ImportsAllCustomersAndAddressesAsExpected stamp: 'LK 11/22/2023 19:36:48'!
PASSED!

!testRun: #ImportTest #test02FailsImportingWhenCustomerRecordHasLessThanFiveFields stamp: 'LK 11/22/2023 19:36:48'!
PASSED!

!testRun: #ImportTest #test03FailsImportingWhenCustomerRecordHasMoreThanFiveFields stamp: 'LK 11/22/2023 19:36:48'!
PASSED!

!testRun: #ImportTest #test04FailsImportingWhenAddressRecordHasLessThanSixFields stamp: 'LK 11/22/2023 19:36:48'!
PASSED!

!testRun: #ImportTest #test05FailsImportingWhenAddressRecordHasMoreThanSixFields stamp: 'LK 11/22/2023 19:36:49'!
PASSED!

!testRun: #ImportTest #test06FailsImportingWhenAddressIsGivenWithoutCustomer stamp: 'LK 11/22/2023 19:36:49'!
PASSED!

!testRun: #ImportTest #test07FailsImportingEmptyStream stamp: 'LK 11/22/2023 19:36:49'!
PASSED!

!testRun: #ImportTest #test08FailsImportingInvalidCustomerThatStartsWithC stamp: 'LK 11/22/2023 19:36:49'!
PASSED!

!testRun: #ImportTest #test09FailsImportingInvalidAddressThatStartsWithA stamp: 'LK 11/22/2023 19:36:49'!
PASSED!
!ImportTest methodsFor: 'setUp/tearDown' stamp: 'LK 11/22/2023 19:37:07' prior: 50767662 overrides: 16961394!
setUp

	customerSystem := TransientCustomerSystem new.
	customerSystem start.
! !

!testRun: #ImportTest #test01ImportsAllCustomersAndAddressesAsExpected stamp: 'LK 11/22/2023 19:37:09'!
ERROR!

!testRun: #ImportTest #test02FailsImportingWhenCustomerRecordHasLessThanFiveFields stamp: 'LK 11/22/2023 19:37:09'!
PASSED!

!testRun: #ImportTest #test03FailsImportingWhenCustomerRecordHasMoreThanFiveFields stamp: 'LK 11/22/2023 19:37:09'!
PASSED!

!testRun: #ImportTest #test04FailsImportingWhenAddressRecordHasLessThanSixFields stamp: 'LK 11/22/2023 19:37:09'!
PASSED!

!testRun: #ImportTest #test05FailsImportingWhenAddressRecordHasMoreThanSixFields stamp: 'LK 11/22/2023 19:37:09'!
PASSED!

!testRun: #ImportTest #test06FailsImportingWhenAddressIsGivenWithoutCustomer stamp: 'LK 11/22/2023 19:37:09'!
PASSED!

!testRun: #ImportTest #test07FailsImportingEmptyStream stamp: 'LK 11/22/2023 19:37:09'!
PASSED!

!testRun: #ImportTest #test08FailsImportingInvalidCustomerThatStartsWithC stamp: 'LK 11/22/2023 19:37:09'!
PASSED!

!testRun: #ImportTest #test09FailsImportingInvalidAddressThatStartsWithA stamp: 'LK 11/22/2023 19:37:09'!
PASSED!

!testRun: #ImportTest #test01ImportsAllCustomersAndAddressesAsExpected stamp: 'LK 11/22/2023 19:37:09'!
ERROR!

!testRun: #ImportTest #test01ImportsAllCustomersAndAddressesAsExpected stamp: 'LK 11/22/2023 19:37:35'!
ERROR!

!testRun: #ImportTest #test01ImportsAllCustomersAndAddressesAsExpected stamp: 'LK 11/22/2023 19:37:35'!
ERROR!
!TransientCustomerSystem methodsFor: 'as yet unclassified' stamp: 'LK 11/22/2023 19:38:11' prior: 50768023!
customerWithIdentificationType: anIdType number: anIdNumber

	^ (session
		select: [ :aCustomer | aCustomer identificationType = anIdType and: [ aCustomer identificationNumber = anIdNumber ]]) anyOne! !

!testRun: #ImportTest #test01ImportsAllCustomersAndAddressesAsExpected stamp: 'LK 11/22/2023 19:38:13'!
PASSED!

!testRun: #ImportTest #test02FailsImportingWhenCustomerRecordHasLessThanFiveFields stamp: 'LK 11/22/2023 19:38:13'!
PASSED!

!testRun: #ImportTest #test03FailsImportingWhenCustomerRecordHasMoreThanFiveFields stamp: 'LK 11/22/2023 19:38:13'!
PASSED!

!testRun: #ImportTest #test04FailsImportingWhenAddressRecordHasLessThanSixFields stamp: 'LK 11/22/2023 19:38:13'!
PASSED!

!testRun: #ImportTest #test05FailsImportingWhenAddressRecordHasMoreThanSixFields stamp: 'LK 11/22/2023 19:38:13'!
PASSED!

!testRun: #ImportTest #test06FailsImportingWhenAddressIsGivenWithoutCustomer stamp: 'LK 11/22/2023 19:38:13'!
PASSED!

!testRun: #ImportTest #test07FailsImportingEmptyStream stamp: 'LK 11/22/2023 19:38:13'!
PASSED!

!testRun: #ImportTest #test08FailsImportingInvalidCustomerThatStartsWithC stamp: 'LK 11/22/2023 19:38:13'!
PASSED!

!testRun: #ImportTest #test09FailsImportingInvalidAddressThatStartsWithA stamp: 'LK 11/22/2023 19:38:13'!
PASSED!

Object subclass: #Enviroment
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!classDefinition: #Enviroment category: 'CustomerImporter' stamp: 'LK 11/22/2023 19:43:30'!
Object subclass: #Enviroment
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

Enviroment subclass: #DevEnviroment
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!classDefinition: #DevEnviroment category: 'CustomerImporter' stamp: 'LK 11/22/2023 19:49:07'!
Enviroment subclass: #DevEnviroment
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

Enviroment subclass: #IntegrationEnviroment
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!classDefinition: #IntegrationEnviroment category: 'CustomerImporter' stamp: 'LK 11/22/2023 19:49:25'!
Enviroment subclass: #IntegrationEnviroment
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

Enviroment subclass: #DevelopmentEnviroment
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!classDefinition: #DevelopmentEnviroment category: 'CustomerImporter' stamp: 'LK 11/22/2023 19:49:35'!
Enviroment subclass: #DevelopmentEnviroment
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!classRemoval: #DevEnviroment stamp: 'LK 11/22/2023 19:49:38'!
Enviroment subclass: #DevEnviroment
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!
!DevelopmentEnviroment class methodsFor: 'nil' stamp: 'LK 11/22/2023 19:49:47'!
isCurrent

	^true! !
!IntegrationEnviroment class methodsFor: 'no messages' stamp: 'LK 11/22/2023 19:50:13'!
isCurrent
	^(DevelopmentEnviroment isCurrent) not! !
!Enviroment class methodsFor: 'no messages' stamp: 'LK 11/22/2023 19:50:44'!
current

	^(self subclasses detect: [ :subclass | subclass isCurrent]).! !
!Enviroment class methodsFor: 'as yet unclassified' stamp: 'LK 11/22/2023 19:50:57'!
newCustomerSystem
	^(self subclasses detect: [ :env | env isCurrent]) newCustomerSystem.! !
!Enviroment class methodsFor: 'as yet unclassified' stamp: 'LK 11/22/2023 19:51:11'!
isCurrent

	self subclassResponsibility! !
!IntegrationEnviroment class methodsFor: 'as yet unclassified' stamp: 'LK 11/22/2023 19:51:25' overrides: 50768343!
newCustomerSystem
	^(self subclasses detect: [ :env | env isCurrent]) newCustomerSystem.! !
!DevelopmentEnviroment class methodsFor: 'as yet unclassified' stamp: 'LK 11/22/2023 19:51:25' overrides: 50768343!
newCustomerSystem
	^(self subclasses detect: [ :env | env isCurrent]) newCustomerSystem.! !
!Enviroment class methodsFor: 'as yet unclassified' stamp: 'LK 11/22/2023 19:51:25' prior: 50768343!
newCustomerSystem

	self subclassResponsibility! !
!DevelopmentEnviroment class methodsFor: 'as yet unclassified' stamp: 'LK 11/22/2023 19:51:50' prior: 50768361 overrides: 50768368!
newCustomerSystem
	
	^DevelopmentEnviroment new.! !
!DevelopmentEnviroment class methodsFor: 'as yet unclassified' stamp: 'LK 11/22/2023 19:52:12' prior: 50768374 overrides: 50768368!
newCustomerSystem
	
	^TransientCustomerSystem new.! !
!IntegrationEnviroment class methodsFor: 'as yet unclassified' stamp: 'LK 11/22/2023 19:52:28' prior: 50768354 overrides: 50768368!
newCustomerSystem
	
	^PersistentCustomerSystem new.! !
!ImportTest methodsFor: 'setUp/tearDown' stamp: 'LK 11/22/2023 19:52:56' prior: 50768182 overrides: 16961394!
setUp

	customerSystem := Enviroment.
	customerSystem start.
! !
!ImportTest methodsFor: 'setUp/tearDown' stamp: 'LK 11/22/2023 19:53:09' prior: 50768392 overrides: 16961394!
setUp

	customerSystem := Enviroment newCustomerSystem.
	customerSystem start.
! !
!Enviroment class methodsFor: 'as yet unclassified' stamp: 'LK 11/22/2023 19:54:09' prior: 50768368!
newCustomerSystem
	^(self subclasses detect: [ :env | env isCurrent]) newCustomerSystem.! !

!testRun: #ImportTest #test01ImportsAllCustomersAndAddressesAsExpected stamp: 'LK 11/22/2023 19:54:12'!
PASSED!

!testRun: #ImportTest #test02FailsImportingWhenCustomerRecordHasLessThanFiveFields stamp: 'LK 11/22/2023 19:54:12'!
PASSED!

!testRun: #ImportTest #test03FailsImportingWhenCustomerRecordHasMoreThanFiveFields stamp: 'LK 11/22/2023 19:54:12'!
PASSED!

!testRun: #ImportTest #test04FailsImportingWhenAddressRecordHasLessThanSixFields stamp: 'LK 11/22/2023 19:54:12'!
PASSED!

!testRun: #ImportTest #test05FailsImportingWhenAddressRecordHasMoreThanSixFields stamp: 'LK 11/22/2023 19:54:12'!
PASSED!

!testRun: #ImportTest #test06FailsImportingWhenAddressIsGivenWithoutCustomer stamp: 'LK 11/22/2023 19:54:12'!
PASSED!

!testRun: #ImportTest #test07FailsImportingEmptyStream stamp: 'LK 11/22/2023 19:54:12'!
PASSED!

!testRun: #ImportTest #test08FailsImportingInvalidCustomerThatStartsWithC stamp: 'LK 11/22/2023 19:54:12'!
PASSED!

!testRun: #ImportTest #test09FailsImportingInvalidAddressThatStartsWithA stamp: 'LK 11/22/2023 19:54:12'!
PASSED!

!testRun: #ImportTest #test01ImportsAllCustomersAndAddressesAsExpected stamp: 'LK 11/22/2023 19:54:14'!
PASSED!

!testRun: #ImportTest #test02FailsImportingWhenCustomerRecordHasLessThanFiveFields stamp: 'LK 11/22/2023 19:54:14'!
PASSED!

!testRun: #ImportTest #test03FailsImportingWhenCustomerRecordHasMoreThanFiveFields stamp: 'LK 11/22/2023 19:54:14'!
PASSED!

!testRun: #ImportTest #test04FailsImportingWhenAddressRecordHasLessThanSixFields stamp: 'LK 11/22/2023 19:54:14'!
PASSED!

!testRun: #ImportTest #test05FailsImportingWhenAddressRecordHasMoreThanSixFields stamp: 'LK 11/22/2023 19:54:14'!
PASSED!

!testRun: #ImportTest #test06FailsImportingWhenAddressIsGivenWithoutCustomer stamp: 'LK 11/22/2023 19:54:14'!
PASSED!

!testRun: #ImportTest #test07FailsImportingEmptyStream stamp: 'LK 11/22/2023 19:54:14'!
PASSED!

!testRun: #ImportTest #test08FailsImportingInvalidCustomerThatStartsWithC stamp: 'LK 11/22/2023 19:54:14'!
PASSED!

!testRun: #ImportTest #test09FailsImportingInvalidAddressThatStartsWithA stamp: 'LK 11/22/2023 19:54:14'!
PASSED!
!DevelopmentEnviroment class methodsFor: 'as yet unclassified' stamp: 'LK 11/22/2023 19:54:28' prior: 50768329 overrides: 50768349!
isCurrent

	^false! !

!testRun: #ImportTest #test01ImportsAllCustomersAndAddressesAsExpected stamp: 'LK 11/22/2023 19:54:32'!
PASSED!

!testRun: #ImportTest #test02FailsImportingWhenCustomerRecordHasLessThanFiveFields stamp: 'LK 11/22/2023 19:54:32'!
PASSED!

!testRun: #ImportTest #test03FailsImportingWhenCustomerRecordHasMoreThanFiveFields stamp: 'LK 11/22/2023 19:54:32'!
PASSED!

!testRun: #ImportTest #test04FailsImportingWhenAddressRecordHasLessThanSixFields stamp: 'LK 11/22/2023 19:54:32'!
PASSED!

!testRun: #ImportTest #test05FailsImportingWhenAddressRecordHasMoreThanSixFields stamp: 'LK 11/22/2023 19:54:32'!
PASSED!

!testRun: #ImportTest #test06FailsImportingWhenAddressIsGivenWithoutCustomer stamp: 'LK 11/22/2023 19:54:33'!
PASSED!

!testRun: #ImportTest #test07FailsImportingEmptyStream stamp: 'LK 11/22/2023 19:54:33'!
PASSED!

!testRun: #ImportTest #test08FailsImportingInvalidCustomerThatStartsWithC stamp: 'LK 11/22/2023 19:54:33'!
PASSED!

!testRun: #ImportTest #test09FailsImportingInvalidAddressThatStartsWithA stamp: 'LK 11/22/2023 19:54:33'!
PASSED!

!methodRemoval: Enviroment class #current stamp: 'LK 11/22/2023 19:55:21'!
current

	^(self subclasses detect: [ :subclass | subclass isCurrent]).!

!testRun: #ImportTest #test01ImportsAllCustomersAndAddressesAsExpected stamp: 'LK 11/22/2023 19:55:24'!
PASSED!

!testRun: #ImportTest #test02FailsImportingWhenCustomerRecordHasLessThanFiveFields stamp: 'LK 11/22/2023 19:55:25'!
PASSED!

!testRun: #ImportTest #test03FailsImportingWhenCustomerRecordHasMoreThanFiveFields stamp: 'LK 11/22/2023 19:55:25'!
PASSED!

!testRun: #ImportTest #test04FailsImportingWhenAddressRecordHasLessThanSixFields stamp: 'LK 11/22/2023 19:55:25'!
PASSED!

!testRun: #ImportTest #test05FailsImportingWhenAddressRecordHasMoreThanSixFields stamp: 'LK 11/22/2023 19:55:25'!
PASSED!

!testRun: #ImportTest #test06FailsImportingWhenAddressIsGivenWithoutCustomer stamp: 'LK 11/22/2023 19:55:25'!
PASSED!

!testRun: #ImportTest #test07FailsImportingEmptyStream stamp: 'LK 11/22/2023 19:55:25'!
PASSED!

!testRun: #ImportTest #test08FailsImportingInvalidCustomerThatStartsWithC stamp: 'LK 11/22/2023 19:55:26'!
PASSED!

!testRun: #ImportTest #test09FailsImportingInvalidAddressThatStartsWithA stamp: 'LK 11/22/2023 19:55:26'!
PASSED!
!DevelopmentEnviroment class methodsFor: 'as yet unclassified' stamp: 'LK 11/22/2023 19:55:34' prior: 50768477 overrides: 50768349!
isCurrent

	^true! !

!testRun: #ImportTest #test01ImportsAllCustomersAndAddressesAsExpected stamp: 'LK 11/22/2023 19:55:37'!
PASSED!

!testRun: #ImportTest #test02FailsImportingWhenCustomerRecordHasLessThanFiveFields stamp: 'LK 11/22/2023 19:55:37'!
PASSED!

!testRun: #ImportTest #test03FailsImportingWhenCustomerRecordHasMoreThanFiveFields stamp: 'LK 11/22/2023 19:55:37'!
PASSED!

!testRun: #ImportTest #test04FailsImportingWhenAddressRecordHasLessThanSixFields stamp: 'LK 11/22/2023 19:55:37'!
PASSED!

!testRun: #ImportTest #test05FailsImportingWhenAddressRecordHasMoreThanSixFields stamp: 'LK 11/22/2023 19:55:37'!
PASSED!

!testRun: #ImportTest #test06FailsImportingWhenAddressIsGivenWithoutCustomer stamp: 'LK 11/22/2023 19:55:37'!
PASSED!

!testRun: #ImportTest #test07FailsImportingEmptyStream stamp: 'LK 11/22/2023 19:55:37'!
PASSED!

!testRun: #ImportTest #test08FailsImportingInvalidCustomerThatStartsWithC stamp: 'LK 11/22/2023 19:55:37'!
PASSED!

!testRun: #ImportTest #test09FailsImportingInvalidAddressThatStartsWithA stamp: 'LK 11/22/2023 19:55:37'!
PASSED!
!DevelopmentEnviroment class methodsFor: 'as yet unclassified' stamp: 'LK 11/22/2023 20:04:00' prior: 50768553 overrides: 50768349!
isCurrent

	^false! !

!testRun: #ImportTest #test01ImportsAllCustomersAndAddressesAsExpected stamp: 'LK 11/22/2023 20:04:05'!
PASSED!

!testRun: #ImportTest #test02FailsImportingWhenCustomerRecordHasLessThanFiveFields stamp: 'LK 11/22/2023 20:04:05'!
PASSED!

!testRun: #ImportTest #test03FailsImportingWhenCustomerRecordHasMoreThanFiveFields stamp: 'LK 11/22/2023 20:04:05'!
PASSED!

!testRun: #ImportTest #test04FailsImportingWhenAddressRecordHasLessThanSixFields stamp: 'LK 11/22/2023 20:04:06'!
PASSED!

!testRun: #ImportTest #test05FailsImportingWhenAddressRecordHasMoreThanSixFields stamp: 'LK 11/22/2023 20:04:06'!
PASSED!

!testRun: #ImportTest #test06FailsImportingWhenAddressIsGivenWithoutCustomer stamp: 'LK 11/22/2023 20:04:06'!
PASSED!

!testRun: #ImportTest #test07FailsImportingEmptyStream stamp: 'LK 11/22/2023 20:04:06'!
PASSED!

!testRun: #ImportTest #test08FailsImportingInvalidCustomerThatStartsWithC stamp: 'LK 11/22/2023 20:04:06'!
PASSED!

!testRun: #ImportTest #test09FailsImportingInvalidAddressThatStartsWithA stamp: 'LK 11/22/2023 20:04:07'!
PASSED!
!ImportTest methodsFor: 'tests' stamp: 'LK 11/22/2023 20:04:13' prior: 50768073!
test07FailsImportingEmptyStream

	|importer | 
	
	importer := (CustomerImporter from: (ReadStream on: '') into: customerSystem).
	
	self 
		should: [importer value]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText equals: importer emptyStreamErrorDescription.].! !

!testRun: #ImportTest #test07FailsImportingEmptyStream stamp: 'LK 11/22/2023 20:04:14'!
FAILURE!
!CustomerImporter methodsFor: 'evaluating' stamp: 'LK 11/22/2023 20:05:51'!
assertRecordIsNotEmpty

	record isEmpty ifTrue: [self error: self emptyStreamErrorDescription].! !
!CustomerImporter methodsFor: 'as yet unclassified' stamp: 'LK 11/22/2023 20:05:51' prior: 50767193!
importRecord

	self assertRecordIsNotEmpty.

	(self isCustomerRecord) ifTrue: [^self importCustomer].

	(self isAddressRecord) ifTrue: [^self importAddress].
	
	self error: self invalidFieldFormatErrorDescription.! !

!methodRemoval: CustomerImporter #assertRecordIsEmpty stamp: 'LK 11/22/2023 20:05:51'!
assertRecordIsEmpty

	record isEmpty ifTrue: [self error: self emptyStreamErrorDescription].!

----QUIT----(22 November 2023 20:06:26) CuisUniversity-5981.image priorSource: 13907113!

----STARTUP---- (22 November 2023 20:06:30) as C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\CuisUniversity-5981.image!

!CustomerImporter methodsFor: 'evaluating' stamp: 'LK 11/22/2023 20:07:03' prior: 50768650!
importRecord

	self assertRecordIsNotEmpty.

	(self isCustomerRecord) ifTrue: [^self importCustomer].
	(self isAddressRecord) ifTrue: [^self importAddress].
	
	self error: self invalidFieldFormatErrorDescription.! !
!ImportTest methodsFor: 'tests' stamp: 'LK 11/22/2023 20:07:17' prior: 50768628!
test07FailsImportingEmptyStream

	|importer | 
	
	importer := (CustomerImporter from: (ReadStream on: '') into: customerSystem).
	
	self 
		should: [importer value]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText equals: importer emptyStreamErrorDescription].! !
!ImportTest methodsFor: 'tests' stamp: 'LK 11/22/2023 20:07:27' prior: 50768683!
test07FailsImportingEmptyStream

	|importer | 
	
	importer := (CustomerImporter from: (ReadStream on: '') into: customerSystem).
	
	
	
	self 
		should: [importer value]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText equals: importer emptyStreamErrorDescription].! !
!ImportTest methodsFor: 'tests' stamp: 'LK 11/22/2023 20:07:46' prior: 50768695!
test07FailsImportingEmptyStream

	|importer | 
	
	importer := (CustomerImporter from: (ReadStream on: '') into: customerSystem).
	
	self 
		should: [importer value]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText equals: importer emptyStreamErrorDescription .
			self assert: self numberOfCustomers equals: 0].! !

!testRun: #ImportTest #test07FailsImportingEmptyStream stamp: 'LK 11/22/2023 20:07:47'!
FAILURE!

!testRun: #ImportTest #test07FailsImportingEmptyStream stamp: 'LK 11/22/2023 20:07:56'!
PASSED!

!testRun: #ImportTest #test07FailsImportingEmptyStream stamp: 'LK 11/22/2023 20:08:00'!
FAILURE!

!testRun: #ImportTest #test07FailsImportingEmptyStream stamp: 'LK 11/22/2023 20:08:00'!
FAILURE!

!testRun: #ImportTest #test07FailsImportingEmptyStream stamp: 'LK 11/22/2023 20:08:14'!
PASSED!
!ImportTest methodsFor: 'tests' stamp: 'LK 11/22/2023 20:09:44' prior: 50768707!
test07FailsImportingEmptyStream

	|importer | 
	
	importer := (CustomerImporter from: (ReadStream on: '
	') into: customerSystem).
	
	self 
		should: [importer value]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText equals: importer emptyStreamErrorDescription .
			self assert: self numberOfCustomers equals: 0].! !

!testRun: #ImportTest #test07FailsImportingEmptyStream stamp: 'LK 11/22/2023 20:09:46'!
PASSED!
!ImportTest methodsFor: 'tests' stamp: 'LK 11/22/2023 20:09:59' prior: 50768736!
test07FailsImportingEmptyStream

	|importer text| 
	
	text = '
	'.
	importer := (CustomerImporter from: (ReadStream on: text) into: customerSystem).
	
	self 
		should: [importer value]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText equals: importer emptyStreamErrorDescription .
			self assert: self numberOfCustomers equals: 0].! !

!testRun: #ImportTest #test07FailsImportingEmptyStream stamp: 'LK 11/22/2023 20:10:05'!
ERROR!
!ImportTest methodsFor: 'tests' stamp: 'LK 11/22/2023 20:10:21' prior: 50768753!
test07FailsImportingEmptyStream

	|importer | 
	
	importer := (CustomerImporter from: (ReadStream on: '
	') into: customerSystem).
	
	self 
		should: [importer value]
		raise: Error
		withExceptionDo: [:anError |
			self assert: anError messageText equals: importer emptyStreamErrorDescription .
			self assert: self numberOfCustomers equals: 0].! !

!testRun: #ImportTest #test07FailsImportingEmptyStream stamp: 'LK 11/22/2023 20:10:22'!
PASSED!

!testRun: #ImportTest #test01ImportsAllCustomersAndAddressesAsExpected stamp: 'LK 11/22/2023 20:10:22'!
PASSED!

!testRun: #ImportTest #test02FailsImportingWhenCustomerRecordHasLessThanFiveFields stamp: 'LK 11/22/2023 20:10:22'!
PASSED!

!testRun: #ImportTest #test03FailsImportingWhenCustomerRecordHasMoreThanFiveFields stamp: 'LK 11/22/2023 20:10:22'!
PASSED!

!testRun: #ImportTest #test04FailsImportingWhenAddressRecordHasLessThanSixFields stamp: 'LK 11/22/2023 20:10:23'!
PASSED!

!testRun: #ImportTest #test05FailsImportingWhenAddressRecordHasMoreThanSixFields stamp: 'LK 11/22/2023 20:10:23'!
PASSED!

!testRun: #ImportTest #test06FailsImportingWhenAddressIsGivenWithoutCustomer stamp: 'LK 11/22/2023 20:10:23'!
PASSED!

!testRun: #ImportTest #test07FailsImportingEmptyStream stamp: 'LK 11/22/2023 20:10:23'!
PASSED!

!testRun: #ImportTest #test08FailsImportingInvalidCustomerThatStartsWithC stamp: 'LK 11/22/2023 20:10:23'!
PASSED!

!testRun: #ImportTest #test09FailsImportingInvalidAddressThatStartsWithA stamp: 'LK 11/22/2023 20:10:24'!
PASSED!
!DevelopmentEnviroment class methodsFor: 'as yet unclassified' stamp: 'LK 11/22/2023 20:10:36' prior: 50768591 overrides: 50768349!
isCurrent

	^true! !

!testRun: #ImportTest #test01ImportsAllCustomersAndAddressesAsExpected stamp: 'LK 11/22/2023 20:10:37'!
PASSED!

!testRun: #ImportTest #test02FailsImportingWhenCustomerRecordHasLessThanFiveFields stamp: 'LK 11/22/2023 20:10:37'!
PASSED!

!testRun: #ImportTest #test03FailsImportingWhenCustomerRecordHasMoreThanFiveFields stamp: 'LK 11/22/2023 20:10:37'!
PASSED!

!testRun: #ImportTest #test04FailsImportingWhenAddressRecordHasLessThanSixFields stamp: 'LK 11/22/2023 20:10:37'!
PASSED!

!testRun: #ImportTest #test05FailsImportingWhenAddressRecordHasMoreThanSixFields stamp: 'LK 11/22/2023 20:10:38'!
PASSED!

!testRun: #ImportTest #test06FailsImportingWhenAddressIsGivenWithoutCustomer stamp: 'LK 11/22/2023 20:10:38'!
PASSED!

!testRun: #ImportTest #test07FailsImportingEmptyStream stamp: 'LK 11/22/2023 20:10:38'!
PASSED!

!testRun: #ImportTest #test08FailsImportingInvalidCustomerThatStartsWithC stamp: 'LK 11/22/2023 20:10:38'!
PASSED!

!testRun: #ImportTest #test09FailsImportingInvalidAddressThatStartsWithA stamp: 'LK 11/22/2023 20:10:38'!
PASSED!

!testRun: #ImportTest #test01ImportsAllCustomersAndAddressesAsExpected stamp: 'LK 11/22/2023 20:10:41'!
PASSED!

!testRun: #ImportTest #test02FailsImportingWhenCustomerRecordHasLessThanFiveFields stamp: 'LK 11/22/2023 20:10:41'!
PASSED!

!testRun: #ImportTest #test03FailsImportingWhenCustomerRecordHasMoreThanFiveFields stamp: 'LK 11/22/2023 20:10:41'!
PASSED!

!testRun: #ImportTest #test04FailsImportingWhenAddressRecordHasLessThanSixFields stamp: 'LK 11/22/2023 20:10:41'!
PASSED!

!testRun: #ImportTest #test05FailsImportingWhenAddressRecordHasMoreThanSixFields stamp: 'LK 11/22/2023 20:10:41'!
PASSED!

!testRun: #ImportTest #test06FailsImportingWhenAddressIsGivenWithoutCustomer stamp: 'LK 11/22/2023 20:10:41'!
PASSED!

!testRun: #ImportTest #test07FailsImportingEmptyStream stamp: 'LK 11/22/2023 20:10:41'!
PASSED!

!testRun: #ImportTest #test08FailsImportingInvalidCustomerThatStartsWithC stamp: 'LK 11/22/2023 20:10:41'!
PASSED!

!testRun: #ImportTest #test09FailsImportingInvalidAddressThatStartsWithA stamp: 'LK 11/22/2023 20:10:41'!
PASSED!

!testRun: #ImportTest #test04FailsImportingWhenAddressRecordHasLessThanSixFields stamp: 'LK 11/22/2023 20:10:44'!
PASSED!

!testRun: #ImportTest #test01ImportsAllCustomersAndAddressesAsExpected stamp: 'LK 11/22/2023 20:10:46'!
PASSED!

!testRun: #ImportTest #test02FailsImportingWhenCustomerRecordHasLessThanFiveFields stamp: 'LK 11/22/2023 20:10:46'!
PASSED!

!testRun: #ImportTest #test03FailsImportingWhenCustomerRecordHasMoreThanFiveFields stamp: 'LK 11/22/2023 20:10:46'!
PASSED!

!testRun: #ImportTest #test04FailsImportingWhenAddressRecordHasLessThanSixFields stamp: 'LK 11/22/2023 20:10:46'!
PASSED!

!testRun: #ImportTest #test05FailsImportingWhenAddressRecordHasMoreThanSixFields stamp: 'LK 11/22/2023 20:10:46'!
PASSED!

!testRun: #ImportTest #test06FailsImportingWhenAddressIsGivenWithoutCustomer stamp: 'LK 11/22/2023 20:10:46'!
PASSED!

!testRun: #ImportTest #test07FailsImportingEmptyStream stamp: 'LK 11/22/2023 20:10:46'!
PASSED!

!testRun: #ImportTest #test08FailsImportingInvalidCustomerThatStartsWithC stamp: 'LK 11/22/2023 20:10:46'!
PASSED!

!testRun: #ImportTest #test09FailsImportingInvalidAddressThatStartsWithA stamp: 'LK 11/22/2023 20:10:46'!
PASSED!

----QUIT----(22 November 2023 20:11:16) CuisUniversity-5981.image priorSource: 13984462!

----STARTUP---- (23 November 2023 17:23:24) as C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\CuisUniversity-5981.image!


!classRemoval: #IntegrationEnviroment stamp: 'LK 11/23/2023 17:29:30'!
Enviroment subclass: #IntegrationEnviroment
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!classRemoval: #DevelopmentEnviroment stamp: 'LK 11/23/2023 17:29:30'!
Enviroment subclass: #DevelopmentEnviroment
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!classRemoval: #Enviroment stamp: 'LK 11/23/2023 17:29:30'!
Object subclass: #Enviroment
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!classRemoval: #DataBaseSession stamp: 'LK 11/23/2023 17:29:30'!
Object subclass: #DataBaseSession
	instanceVariableNames: 'configuration tables id inTransaction closed'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!classRemoval: #TransientCustomerSystem stamp: 'LK 11/23/2023 17:29:30'!
CustomerSystem subclass: #TransientCustomerSystem
	instanceVariableNames: 'session'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!classRemoval: #PersistentCustomerSystem stamp: 'LK 11/23/2023 17:29:31'!
CustomerSystem subclass: #PersistentCustomerSystem
	instanceVariableNames: 'session'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!classRemoval: #CustomerSystem stamp: 'LK 11/23/2023 17:29:31'!
Object subclass: #CustomerSystem
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!classRemoval: #CustomerImporter stamp: 'LK 11/23/2023 17:29:31'!
Object subclass: #CustomerImporter
	instanceVariableNames: 'customerSystem readStream line newCustomer record'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!classRemoval: #Customer stamp: 'LK 11/23/2023 17:29:31'!
Object subclass: #Customer
	instanceVariableNames: 'id firstName lastName identificationType identificationNumber addresses'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!classRemoval: #Address stamp: 'LK 11/23/2023 17:29:32'!
Object subclass: #Address
	instanceVariableNames: 'id streetName streetNumber town zipCode province'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!classRemoval: #ImportTest stamp: 'LK 11/23/2023 17:29:32'!
TestCase subclass: #ImportTest
	instanceVariableNames: 'session customerSystem'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!classRemoval: #PersistentSet stamp: 'LK 11/23/2023 17:29:32'!
Set subclass: #PersistentSet
	instanceVariableNames: 'session'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

----End fileIn of C:\Users\lucas\OneDrive\Desktop\CustomerImporter-3.st----!

!classDefinition: #SupplierImporter category: 'CustomerImporter' stamp: 'LK 11/23/2023 17:32:32'!
CustomerImporter subclass: #SupplierImporter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!
!ImportTest methodsFor: 'tests~supplier' stamp: 'LK 11/23/2023 17:31:35'!
test01

	| stream |
	stream := ReadStream on: 'S,Supplier1,D,123'.
	SupplierImporter valueFrom: stream into: system.! !
!ImportTest methodsFor: 'tests~supplier' stamp: 'LK 11/23/2023 17:34:58' prior: 50770063!
test01

	| stream supplier |
	stream := ReadStream on: 'S,Supplier1,D,123'.
	SupplierImporter valueFrom: stream into: system.
	
	self assert: system numbersOfSuppliers equals: 1.
	supplier := system supplierWithIdentificationType: 'D' number: '123'.
	self assert: (supplier isNamed: 'Supplier1').
	self assert: supplier addressedIsEmpty.
	self assert: supplier customersIsEmpty! !
!ImportTest methodsFor: 'tests~supplier' stamp: 'LK 11/23/2023 17:35:12' prior: 50770070!
test01

	| stream supplier |
	stream := ReadStream on: 'S,Supplier1,D,123'.
	SupplierImporter valueFrom: stream into: system.
	
	self assert: system numbersOfSuppliers equals: 1.
	supplier := system supplierWithIdentificationType: 'D' number: '123'.
	self assert: (supplier isNamed: 'Supplier1').
	self assert: supplier addressedIsEmpty.
	self assert: supplier customersIsEmpty.! !
!SupplierImporter methodsFor: 'no messages' stamp: 'LK 11/23/2023 17:35:49' overrides: 50769557!
importRecord! !

!classDefinition: #Supplier category: 'CustomerImporter' stamp: 'LK 11/23/2023 17:37:26'!
Customer subclass: #Supplier
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!
!SupplierImporter methodsFor: 'as yet unclassified' stamp: 'LK 11/23/2023 17:37:04' prior: 50770100 overrides: 50769557!
importRecord

	system addSupplier: (Supplier named: record second identificationType: record third number: record fourth).! !
!Supplier class methodsFor: 'no messages' stamp: 'LK 11/23/2023 17:41:31'!
named: aName identificationType: anIdentificationType number: anIdentificationNumber

	^self initializeNamed: aName identificationType: anIdentificationType number: anIdentificationNumber.
! !

!classDefinition: #TransientCustomerSystem category: 'CustomerImporter' stamp: 'LK 11/23/2023 17:42:23'!
CustomerSystem subclass: #TransientCustomerSystem
	instanceVariableNames: 'customers suppliers'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!
!TransientCustomerSystem methodsFor: 'customers' stamp: 'LK 11/23/2023 17:42:21'!
addSupplier: aSupplier

	suppliers add: aSupplier! !
!TransientCustomerSystem methodsFor: 'system lifecycle' stamp: 'LK 11/23/2023 17:43:08' prior: 50769721 overrides: 50769642!
start

	customers := OrderedCollection new.
	
	suppliers := Set new.! !
!Supplier methodsFor: 'no messages' stamp: 'LK 11/23/2023 17:43:40'!
initializeNamed: aName identificationType: anIdentificationType number: anIdentificationNumber| name |
.

	name := aName.! !
!Supplier methodsFor: 'as yet unclassified' stamp: 'LK 11/23/2023 17:43:55' prior: 50770148!
initializeNamed: aName identificationType: anIdentificationType number: anIdentificationNumber

	| name |

	name := aName.! !
!Supplier methodsFor: 'as yet unclassified' stamp: 'LK 11/23/2023 17:44:54' prior: 50770155!
initializeNamed: aName identificationType: anIdentificationType number: anIdentificationNumber

	firstName := aName.
	identificationType := anIdentificationType.
	identificationNumber := anIdentificationNumber.! !

!classRenamed: #CustomerSystem as: #ErpSystem stamp: 'LK 11/23/2023 17:47:33'!
Smalltalk renameClassNamed: #CustomerSystem as: #ErpSystem!

!classRenamed: #PersistentCustomerSystem as: #PersistentErpSystem stamp: 'LK 11/23/2023 17:47:39'!
Smalltalk renameClassNamed: #PersistentCustomerSystem as: #PersistentErpSystem!
!IntegrationEnvironment methodsFor: 'as yet unclassified' stamp: 'LK 11/23/2023 17:47:39' prior: 50770028 overrides: 50769926!
createCustomerSystem

	^PersistentErpSystem new! !

!classRenamed: #TransientCustomerSystem as: #TransientErpSystem stamp: 'LK 11/23/2023 17:47:48'!
Smalltalk renameClassNamed: #TransientCustomerSystem as: #TransientErpSystem!
!DevelopmentEnvironment methodsFor: 'as yet unclassified' stamp: 'LK 11/23/2023 17:47:48' prior: 50769990 overrides: 50769926!
createCustomerSystem

	^TransientErpSystem new! !

!classDefinition: #CSVImporter category: 'CustomerImporter' stamp: 'LK 11/23/2023 17:48:47'!
Object subclass: #CSVImporter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!classDefinition: #CustomerImporter category: 'CustomerImporter' stamp: 'LK 11/23/2023 17:48:47'!
CSVImporter subclass: #CustomerImporter
	instanceVariableNames: 'readStream newCustomer line record system'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!classDefinition: #CustomerImporter category: 'CustomerImporter' stamp: 'LK 11/23/2023 17:49:21'!
CSVImporter subclass: #CustomerImporter
	instanceVariableNames: 'readStream newCustomer record system'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!classDefinition: #CSVImporter category: 'CustomerImporter' stamp: 'LK 11/23/2023 17:49:21'!
Object subclass: #CSVImporter
	instanceVariableNames: 'line'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!classDefinition: #CustomerImporter category: 'CustomerImporter' stamp: 'LK 11/23/2023 17:49:29'!
CSVImporter subclass: #CustomerImporter
	instanceVariableNames: 'newCustomer record system'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!classDefinition: #CSVImporter category: 'CustomerImporter' stamp: 'LK 11/23/2023 17:49:29'!
Object subclass: #CSVImporter
	instanceVariableNames: 'line readStream'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!classDefinition: #CustomerImporter category: 'CustomerImporter' stamp: 'LK 11/23/2023 17:49:35'!
CSVImporter subclass: #CustomerImporter
	instanceVariableNames: 'newCustomer system'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!classDefinition: #CSVImporter category: 'CustomerImporter' stamp: 'LK 11/23/2023 17:49:35'!
Object subclass: #CSVImporter
	instanceVariableNames: 'line readStream record'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!classDefinition: #CustomerImporter category: 'CustomerImporter' stamp: 'LK 11/23/2023 17:49:40'!
CSVImporter subclass: #CustomerImporter
	instanceVariableNames: 'newCustomer'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!classDefinition: #CSVImporter category: 'CustomerImporter' stamp: 'LK 11/23/2023 17:49:41'!
Object subclass: #CSVImporter
	instanceVariableNames: 'line readStream record system'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

self makeCurrent!

!testRun: #ImportTest #test01ValidDataIsImportedCorrectly stamp: 'LK 11/23/2023 17:51:14'!
PASSED!

!testRun: #ImportTest #test02CanNotImportAddressWithoutCustomer stamp: 'LK 11/23/2023 17:51:14'!
PASSED!

!testRun: #ImportTest #test03DoesNotImportRecordsStartingWithCButMoreCharacters stamp: 'LK 11/23/2023 17:51:14'!
PASSED!

!testRun: #ImportTest #test04DoesNotImportRecordsStartingWithAButMoreCharacters stamp: 'LK 11/23/2023 17:51:14'!
PASSED!

!testRun: #ImportTest #test05CanNotImportAddressRecordWithLessThanSixFields stamp: 'LK 11/23/2023 17:51:15'!
PASSED!

!testRun: #ImportTest #test06CanNotImportAddressRecordWithMoreThanSixFields stamp: 'LK 11/23/2023 17:51:15'!
PASSED!

!testRun: #ImportTest #test07CanNotImportCustomerRecordWithLessThanFiveFields stamp: 'LK 11/23/2023 17:51:15'!
PASSED!

!testRun: #ImportTest #test08CanNotImportCustomerRecordWithMoreThanFiveFields stamp: 'LK 11/23/2023 17:51:15'!
PASSED!

!testRun: #ImportTest #test09CannotImportEmptyLine stamp: 'LK 11/23/2023 17:51:15'!
PASSED!
!CSVImporter methodsFor: 'evaluating - private' stamp: 'LK 11/23/2023 17:52:30'!
assertRecordNotEmpty

	record isEmpty ifTrue: [ self error: self class invalidRecordTypeErrorDescription ]! !

!methodRemoval: CustomerImporter #assertRecordNotEmpty stamp: 'LK 11/23/2023 17:52:30'!
assertRecordNotEmpty

	record isEmpty ifTrue: [ self error: self class invalidRecordTypeErrorDescription ]!
!CSVImporter methodsFor: 'evaluating - private' stamp: 'LK 11/23/2023 17:52:36'!
createRecord

	^ record := line findTokens: $,! !

!methodRemoval: CustomerImporter #createRecord stamp: 'LK 11/23/2023 17:52:36'!
createRecord

	^ record := line findTokens: $,!
!CSVImporter methodsFor: 'evaluating - private' stamp: 'LK 11/23/2023 17:52:40'!
hasLineToImport

	line := readStream nextLine.
	^line notNil! !

!methodRemoval: CustomerImporter #hasLineToImport stamp: 'LK 11/23/2023 17:52:40'!
hasLineToImport

	line := readStream nextLine.
	^line notNil!
!CSVImporter methodsFor: 'evaluating' stamp: 'LK 11/23/2023 17:53:55' overrides: 16902254!
value

	[ self hasLineToImport ] whileTrue: [
		self createRecord.
		self importRecord ].

	! !

!methodRemoval: CustomerImporter #value stamp: 'LK 11/23/2023 17:53:55'!
value

	[ self hasLineToImport ] whileTrue: [
		self createRecord.
		self importRecord ].

	!
!CSVImporter methodsFor: 'initialization' stamp: 'LK 11/23/2023 17:54:05'!
initializeFrom: aReadStream into: aCustomerSystem

	readStream := aReadStream.
	system := aCustomerSystem ! !

!methodRemoval: CustomerImporter #initializeFrom:into: stamp: 'LK 11/23/2023 17:54:05'!
initializeFrom: aReadStream into: aCustomerSystem

	readStream := aReadStream.
	system := aCustomerSystem !

CustomerImporter subclass: #CSVImporter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

CustomerImporter subclass: #CSVImporter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!testRun: #ImportTest #test01ValidDataIsImportedCorrectly stamp: 'LK 11/23/2023 18:01:51'!
PASSED!

!testRun: #ImportTest #test02CanNotImportAddressWithoutCustomer stamp: 'LK 11/23/2023 18:01:51'!
PASSED!

!testRun: #ImportTest #test03DoesNotImportRecordsStartingWithCButMoreCharacters stamp: 'LK 11/23/2023 18:01:51'!
PASSED!

!testRun: #ImportTest #test04DoesNotImportRecordsStartingWithAButMoreCharacters stamp: 'LK 11/23/2023 18:01:51'!
PASSED!

!testRun: #ImportTest #test05CanNotImportAddressRecordWithLessThanSixFields stamp: 'LK 11/23/2023 18:01:51'!
PASSED!

!testRun: #ImportTest #test06CanNotImportAddressRecordWithMoreThanSixFields stamp: 'LK 11/23/2023 18:01:51'!
PASSED!

!testRun: #ImportTest #test07CanNotImportCustomerRecordWithLessThanFiveFields stamp: 'LK 11/23/2023 18:01:51'!
PASSED!

!testRun: #ImportTest #test08CanNotImportCustomerRecordWithMoreThanFiveFields stamp: 'LK 11/23/2023 18:01:51'!
PASSED!

!testRun: #ImportTest #test09CannotImportEmptyLine stamp: 'LK 11/23/2023 18:01:51'!
PASSED!

Customer subclass: #Supplier
	instanceVariableNames: 'name'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!classDefinition: #Supplier category: 'CustomerImporter' stamp: 'LK 11/23/2023 18:06:05'!
Customer subclass: #Supplier
	instanceVariableNames: 'name'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!
!Supplier methodsFor: 'as yet unclassified' stamp: 'LK 11/23/2023 18:06:13' prior: 50770162!
initializeNamed: aName identificationType: anIdentificationType number: anIdentificationNumber

	name := aName.
	identificationType := anIdentificationType.
	identificationNumber := anIdentificationNumber.! !

CSVImporter subclass: #SupplierImporter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!classDefinition: #SupplierImporter category: 'CustomerImporter' stamp: 'LK 11/23/2023 18:15:16'!
CSVImporter subclass: #SupplierImporter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!
!TransientErpSystem methodsFor: 'customers' stamp: 'LK 11/23/2023 18:16:23'!
numberOfSuppliers

	^suppliers size! !

!testRun: #ImportTest #test01 stamp: 'LK 11/23/2023 18:16:30'!
ERROR!

!testRun: #ImportTest #test01 stamp: 'LK 11/23/2023 18:16:30'!
ERROR!
!ImportTest methodsFor: 'tests~supplier' stamp: 'LK 11/23/2023 18:17:26' prior: 50770085!
test01

	| stream supplier |
	stream := ReadStream on: 'S,Supplier1,D,123'.
	SupplierImporter valueFrom: stream into: system.
	
	self assert: system numberOfSuppliers equals: 1.
	supplier := system supplierWithIdentificationType: 'D' number: '123'.
	self assert: (supplier isNamed: 'Supplier1').
	self assert: supplier addressedIsEmpty.
	self assert: supplier customersIsEmpty.! !
!ImportTest methodsFor: 'tests~supplier' stamp: 'LK 11/23/2023 18:18:26' prior: 50770451!
test01

	| stream supplier |
	stream := ReadStream on: 'S,Supplier1,D,123'.
	SupplierImporter valueFrom: stream into: system.
	
	self assert: system numberOfSuppliers equals: 1.
	supplier := system supplierWithIdentificationType: 'D' number: '123'.
	self assert: (supplier isNamed: 'Supplier1').
	self assert: supplier isAddressesEmpty .
	self assert: supplier isCustomersEmpty.! !
!Supplier methodsFor: 'as yet unclassified' stamp: 'LK 11/23/2023 18:18:56'!
isCustomersEmpty

	^true! !

!testRun: #ImportTest #test01 stamp: 'LK 11/23/2023 18:19:24'!
ERROR!
!CSVImporter class methodsFor: 'importing' stamp: 'LK 11/23/2023 18:19:53'!
valueFrom: aReadStream into: aCustomerSystem

	^(self from: aReadStream into: aCustomerSystem) value! !

!methodRemoval: CustomerImporter class #valueFrom:into: stamp: 'LK 11/23/2023 18:19:53'!
valueFrom: aReadStream into: aCustomerSystem

	^(self from: aReadStream into: aCustomerSystem) value!

!testRun: #ImportTest #test01 stamp: 'LK 11/23/2023 18:20:03'!
ERROR!

!testRun: #ImportTest #test01 stamp: 'LK 11/23/2023 18:20:03'!
ERROR!
!CSVImporter class methodsFor: 'instance creation' stamp: 'LK 11/23/2023 18:20:16'!
from: aReadStream into: aCustomerSystem

	^self new initializeFrom: aReadStream into: aCustomerSystem! !

!methodRemoval: CustomerImporter class #from:into: stamp: 'LK 11/23/2023 18:20:16'!
from: aReadStream into: aCustomerSystem

	^self new initializeFrom: aReadStream into: aCustomerSystem!

!testRun: #ImportTest #test01 stamp: 'LK 11/23/2023 18:20:22'!
ERROR!

!testRun: #ImportTest #test01 stamp: 'LK 11/23/2023 18:20:22'!
ERROR!

!testRun: #ImportTest #test01 stamp: 'LK 11/23/2023 18:20:55'!
ERROR!

!testRun: #ImportTest #test01 stamp: 'LK 11/23/2023 18:20:55'!
ERROR!
!Supplier class methodsFor: 'as yet unclassified' stamp: 'LK 11/23/2023 18:21:16' prior: 50770119!
named: aName identificationType: anIdentificationType number: anIdentificationNumber

	^self new initializeNamed: aName identificationType: anIdentificationType number: anIdentificationNumber.
! !

!testRun: #ImportTest #test01 stamp: 'LK 11/23/2023 18:21:22'!
ERROR!

!testRun: #ImportTest #test01 stamp: 'LK 11/23/2023 18:21:22'!
ERROR!
!TransientErpSystem methodsFor: 'customers' stamp: 'LK 11/23/2023 18:22:08'!
supplierWithIdentificationType: anIdentificationType number: aNumber! !
!TransientErpSystem methodsFor: 'customers' stamp: 'LK 11/23/2023 18:22:47' prior: 50770539!
supplierWithIdentificationType: anIdType number: anIdNumber

	^suppliers detect: [ :aSupplier | aSupplier identificationType = anIdType and: [ aSupplier identificationNumber = anIdNumber ]]! !

!testRun: #ImportTest #test01 stamp: 'LK 11/23/2023 18:22:53'!
ERROR!

!testRun: #ImportTest #test01 stamp: 'LK 11/23/2023 18:22:53'!
ERROR!
!Supplier methodsFor: 'sd' stamp: 'LK 11/23/2023 18:23:04'!
isNamed: aRenameMe1 
	self shouldBeImplemented.! !
!Supplier methodsFor: 'sd' stamp: 'LK 11/23/2023 18:23:09' prior: 50770558!
isNamed: aName 
	^true! !

!testRun: #ImportTest #test01 stamp: 'LK 11/23/2023 18:23:14'!
PASSED!

!testRun: #ImportTest #test01 stamp: 'LK 11/23/2023 18:23:14'!
PASSED!

!testRun: #ImportTest #test01ValidDataIsImportedCorrectly stamp: 'LK 11/23/2023 18:23:14'!
PASSED!

!testRun: #ImportTest #test02CanNotImportAddressWithoutCustomer stamp: 'LK 11/23/2023 18:23:14'!
PASSED!

!testRun: #ImportTest #test03DoesNotImportRecordsStartingWithCButMoreCharacters stamp: 'LK 11/23/2023 18:23:14'!
PASSED!

!testRun: #ImportTest #test04DoesNotImportRecordsStartingWithAButMoreCharacters stamp: 'LK 11/23/2023 18:23:14'!
PASSED!

!testRun: #ImportTest #test05CanNotImportAddressRecordWithLessThanSixFields stamp: 'LK 11/23/2023 18:23:14'!
PASSED!

!testRun: #ImportTest #test06CanNotImportAddressRecordWithMoreThanSixFields stamp: 'LK 11/23/2023 18:23:14'!
PASSED!

!testRun: #ImportTest #test07CanNotImportCustomerRecordWithLessThanFiveFields stamp: 'LK 11/23/2023 18:23:14'!
PASSED!

!testRun: #ImportTest #test08CanNotImportCustomerRecordWithMoreThanFiveFields stamp: 'LK 11/23/2023 18:23:14'!
PASSED!

!testRun: #ImportTest #test09CannotImportEmptyLine stamp: 'LK 11/23/2023 18:23:14'!
PASSED!

!testRun: #ImportTest #test01 stamp: 'LK 11/23/2023 18:23:18'!
PASSED!

!testRun: #ImportTest #test01 stamp: 'LK 11/23/2023 18:23:18'!
PASSED!

!testRun: #ImportTest #test01ValidDataIsImportedCorrectly stamp: 'LK 11/23/2023 18:23:18'!
PASSED!

!testRun: #ImportTest #test02CanNotImportAddressWithoutCustomer stamp: 'LK 11/23/2023 18:23:18'!
PASSED!

!testRun: #ImportTest #test03DoesNotImportRecordsStartingWithCButMoreCharacters stamp: 'LK 11/23/2023 18:23:18'!
PASSED!

!testRun: #ImportTest #test04DoesNotImportRecordsStartingWithAButMoreCharacters stamp: 'LK 11/23/2023 18:23:18'!
PASSED!

!testRun: #ImportTest #test05CanNotImportAddressRecordWithLessThanSixFields stamp: 'LK 11/23/2023 18:23:18'!
PASSED!

!testRun: #ImportTest #test06CanNotImportAddressRecordWithMoreThanSixFields stamp: 'LK 11/23/2023 18:23:18'!
PASSED!

!testRun: #ImportTest #test07CanNotImportCustomerRecordWithLessThanFiveFields stamp: 'LK 11/23/2023 18:23:18'!
PASSED!

!testRun: #ImportTest #test08CanNotImportCustomerRecordWithMoreThanFiveFields stamp: 'LK 11/23/2023 18:23:18'!
PASSED!

!testRun: #ImportTest #test09CannotImportEmptyLine stamp: 'LK 11/23/2023 18:23:18'!
PASSED!
!Supplier methodsFor: 'sd' stamp: 'LK 11/23/2023 18:24:05' prior: 50770562!
isNamed: aName 
	^name = aName! !

!testRun: #ImportTest #test01 stamp: 'LK 11/23/2023 18:24:09'!
PASSED!

!classDefinition: #Party category: 'CustomerImporter' stamp: 'LK 11/23/2023 18:24:43'!
Object subclass: #Party
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!classDefinition: #Customer category: 'CustomerImporter' stamp: 'LK 11/23/2023 18:24:43'!
Party subclass: #Customer
	instanceVariableNames: 'id firstName lastName identificationType identificationNumber addresses'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

Object subclass: #Par
	instanceVariableNames: 'id firstName lastName identificationType identificationNumber addresses'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!classDefinition: #Par category: 'CustomerImporter' stamp: 'LK 11/23/2023 18:25:05'!
Object subclass: #Par
	instanceVariableNames: 'id firstName lastName identificationType identificationNumber addresses'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!classRemoval: #Par stamp: 'LK 11/23/2023 18:25:33'!
Object subclass: #Par
	instanceVariableNames: 'id firstName lastName identificationType identificationNumber addresses'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!classDefinition: #Customer category: 'CustomerImporter' stamp: 'LK 11/23/2023 18:25:42'!
Party subclass: #Customer
	instanceVariableNames: 'id firstName lastName identificationType addresses'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!classDefinition: #Party category: 'CustomerImporter' stamp: 'LK 11/23/2023 18:25:42'!
Object subclass: #Party
	instanceVariableNames: 'identificationNumber'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!classDefinition: #Customer category: 'CustomerImporter' stamp: 'LK 11/23/2023 18:25:54'!
Party subclass: #Customer
	instanceVariableNames: 'id firstName lastName addresses'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!classDefinition: #Party category: 'CustomerImporter' stamp: 'LK 11/23/2023 18:25:54'!
Object subclass: #Party
	instanceVariableNames: 'identificationNumber identificationType'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!classDefinition: #Customer category: 'CustomerImporter' stamp: 'LK 11/23/2023 18:26:05'!
Party subclass: #Customer
	instanceVariableNames: 'firstName lastName addresses'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!classDefinition: #Party category: 'CustomerImporter' stamp: 'LK 11/23/2023 18:26:05'!
Object subclass: #Party
	instanceVariableNames: 'identificationNumber identificationType id'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!classDefinition: #Customer category: 'CustomerImporter' stamp: 'LK 11/23/2023 18:26:14'!
Party subclass: #Customer
	instanceVariableNames: 'lastName addresses'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!classDefinition: #Party category: 'CustomerImporter' stamp: 'LK 11/23/2023 18:26:14'!
Object subclass: #Party
	instanceVariableNames: 'identificationNumber identificationType id firstName'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

Customer subclass: #Supplier
	instanceVariableNames: 'name customers'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!classDefinition: #Supplier category: 'CustomerImporter' stamp: 'LK 11/23/2023 18:26:33'!
Customer subclass: #Supplier
	instanceVariableNames: 'name customers'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!
!Supplier methodsFor: 'as yet unclassified' stamp: 'LK 11/23/2023 18:26:44' prior: 50770420!
initializeNamed: aName identificationType: anIdentificationType number: anIdentificationNumber

	name := aName.
	identificationType := anIdentificationType.
	identificationNumber := anIdentificationNumber.
	customers := Set new.! !

Party subclass: #Supplier
	instanceVariableNames: 'name customers'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!classDefinition: #Supplier category: 'CustomerImporter' stamp: 'LK 11/23/2023 18:27:00'!
Party subclass: #Supplier
	instanceVariableNames: 'name customers'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!testRun: #ImportTest #test01 stamp: 'LK 11/23/2023 18:29:29'!
ERROR!

!testRun: #ImportTest #test01 stamp: 'LK 11/23/2023 18:29:29'!
ERROR!
!Party methodsFor: 'identification' stamp: 'LK 11/23/2023 18:36:58'!
identificationType

	^identificationType ! !

!methodRemoval: Customer #identificationType stamp: 'LK 11/23/2023 18:36:58'!
identificationType

	^identificationType !
!Party methodsFor: 'identification' stamp: 'LK 11/23/2023 18:37:07'!
identificationNumber

	^identificationNumber ! !

!methodRemoval: Customer #identificationNumber stamp: 'LK 11/23/2023 18:37:08'!
identificationNumber

	^identificationNumber !

!classDefinition: #Customer category: 'CustomerImporter' stamp: 'LK 11/23/2023 18:37:20'!
Party subclass: #Customer
	instanceVariableNames: 'lastName'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!classDefinition: #Party category: 'CustomerImporter' stamp: 'LK 11/23/2023 18:37:21'!
Object subclass: #Party
	instanceVariableNames: 'identificationNumber identificationType id firstName addresses'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!
!Party methodsFor: 'addresses' stamp: 'LK 11/23/2023 18:37:21'!
isAddressesEmpty

	^addresses isEmpty ! !

!methodRemoval: Customer #isAddressesEmpty stamp: 'LK 11/23/2023 18:37:21'!
isAddressesEmpty

	^addresses isEmpty !

Object subclass: #Party
	instanceVariableNames: 'identificationNumber identificationType id addresses'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!classDefinition: #Party category: 'CustomerImporter' stamp: 'LK 11/23/2023 18:37:32'!
Object subclass: #Party
	instanceVariableNames: 'identificationNumber identificationType id addresses'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

Party subclass: #Customer
	instanceVariableNames: 'lastName firstName'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!classDefinition: #Customer category: 'CustomerImporter' stamp: 'LK 11/23/2023 18:37:43'!
Party subclass: #Customer
	instanceVariableNames: 'lastName firstName'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!testRun: #ImportTest #test01 stamp: 'LK 11/23/2023 18:37:47'!
ERROR!

!testRun: #ImportTest #test01ValidDataIsImportedCorrectly stamp: 'LK 11/23/2023 18:37:47'!
PASSED!

!testRun: #ImportTest #test02CanNotImportAddressWithoutCustomer stamp: 'LK 11/23/2023 18:37:47'!
PASSED!

!testRun: #ImportTest #test03DoesNotImportRecordsStartingWithCButMoreCharacters stamp: 'LK 11/23/2023 18:37:47'!
PASSED!

!testRun: #ImportTest #test04DoesNotImportRecordsStartingWithAButMoreCharacters stamp: 'LK 11/23/2023 18:37:47'!
PASSED!

!testRun: #ImportTest #test05CanNotImportAddressRecordWithLessThanSixFields stamp: 'LK 11/23/2023 18:37:47'!
PASSED!

!testRun: #ImportTest #test06CanNotImportAddressRecordWithMoreThanSixFields stamp: 'LK 11/23/2023 18:37:47'!
PASSED!

!testRun: #ImportTest #test07CanNotImportCustomerRecordWithLessThanFiveFields stamp: 'LK 11/23/2023 18:37:47'!
PASSED!

!testRun: #ImportTest #test08CanNotImportCustomerRecordWithMoreThanFiveFields stamp: 'LK 11/23/2023 18:37:47'!
PASSED!

!testRun: #ImportTest #test09CannotImportEmptyLine stamp: 'LK 11/23/2023 18:37:47'!
PASSED!

!testRun: #ImportTest #test01 stamp: 'LK 11/23/2023 18:37:47'!
ERROR!
!Supplier methodsFor: 'as yet unclassified' stamp: 'LK 11/23/2023 18:38:14' prior: 50770759!
initializeNamed: aName identificationType: anIdentificationType number: anIdentificationNumber

	name := aName.
	identificationType := anIdentificationType.
	identificationNumber := anIdentificationNumber.
	customers := Set new.
	addresses := OrderedCollection new.! !

!testRun: #ImportTest #test01 stamp: 'LK 11/23/2023 18:38:19'!
PASSED!

!testRun: #ImportTest #test01ValidDataIsImportedCorrectly stamp: 'LK 11/23/2023 18:38:19'!
PASSED!

!testRun: #ImportTest #test02CanNotImportAddressWithoutCustomer stamp: 'LK 11/23/2023 18:38:19'!
PASSED!

!testRun: #ImportTest #test03DoesNotImportRecordsStartingWithCButMoreCharacters stamp: 'LK 11/23/2023 18:38:19'!
PASSED!

!testRun: #ImportTest #test04DoesNotImportRecordsStartingWithAButMoreCharacters stamp: 'LK 11/23/2023 18:38:19'!
PASSED!

!testRun: #ImportTest #test05CanNotImportAddressRecordWithLessThanSixFields stamp: 'LK 11/23/2023 18:38:19'!
PASSED!

!testRun: #ImportTest #test06CanNotImportAddressRecordWithMoreThanSixFields stamp: 'LK 11/23/2023 18:38:19'!
PASSED!

!testRun: #ImportTest #test07CanNotImportCustomerRecordWithLessThanFiveFields stamp: 'LK 11/23/2023 18:38:19'!
PASSED!

!testRun: #ImportTest #test08CanNotImportCustomerRecordWithMoreThanFiveFields stamp: 'LK 11/23/2023 18:38:19'!
PASSED!

!testRun: #ImportTest #test09CannotImportEmptyLine stamp: 'LK 11/23/2023 18:38:19'!
PASSED!
!Party methodsFor: 'addresses' stamp: 'LK 11/23/2023 18:38:34'!
addressAt: aStreetName ifNone: aNoneBlock

	^addresses detect: [ :address | address isAt: aStreetName ] ifNone: aNoneBlock ! !

!methodRemoval: Customer #addressAt:ifNone: stamp: 'LK 11/23/2023 18:38:34'!
addressAt: aStreetName ifNone: aNoneBlock

	^addresses detect: [ :address | address isAt: aStreetName ] ifNone: aNoneBlock !
!Party methodsFor: 'addresses' stamp: 'LK 11/23/2023 18:38:58'!
addresses

	^ addresses! !

!methodRemoval: Customer #addresses stamp: 'LK 11/23/2023 18:38:58'!
addresses

	^ addresses!

!testRun: #ImportTest #test01 stamp: 'LK 11/23/2023 18:39:09'!
PASSED!

!testRun: #ImportTest #test01ValidDataIsImportedCorrectly stamp: 'LK 11/23/2023 18:39:09'!
PASSED!

!testRun: #ImportTest #test02CanNotImportAddressWithoutCustomer stamp: 'LK 11/23/2023 18:39:09'!
PASSED!

!testRun: #ImportTest #test03DoesNotImportRecordsStartingWithCButMoreCharacters stamp: 'LK 11/23/2023 18:39:09'!
PASSED!

!testRun: #ImportTest #test04DoesNotImportRecordsStartingWithAButMoreCharacters stamp: 'LK 11/23/2023 18:39:09'!
PASSED!

!testRun: #ImportTest #test05CanNotImportAddressRecordWithLessThanSixFields stamp: 'LK 11/23/2023 18:39:09'!
PASSED!

!testRun: #ImportTest #test06CanNotImportAddressRecordWithMoreThanSixFields stamp: 'LK 11/23/2023 18:39:09'!
PASSED!

!testRun: #ImportTest #test07CanNotImportCustomerRecordWithLessThanFiveFields stamp: 'LK 11/23/2023 18:39:09'!
PASSED!

!testRun: #ImportTest #test08CanNotImportCustomerRecordWithMoreThanFiveFields stamp: 'LK 11/23/2023 18:39:09'!
PASSED!

!testRun: #ImportTest #test09CannotImportEmptyLine stamp: 'LK 11/23/2023 18:39:09'!
PASSED!
!TransientErpSystem methodsFor: 'system lifecycle' stamp: 'LK 11/23/2023 18:39:35' prior: 50770143 overrides: 50769642!
start

	customers := OrderedCollection new.
	suppliers := Set new.! !
!ErpSystem methodsFor: 'customers' stamp: 'LK 11/23/2023 18:40:04'!
addSupplier: aSupplier

	self subclassResponsibility! !
!ErpSystem methodsFor: 'customers' stamp: 'LK 11/23/2023 18:40:15'!
supplierWithIdentificationType: anIdType number: anIdNumber

	self subclassResponsibility! !

!classDefinition: #XXImporter category: 'CustomerImporter' stamp: 'LK 11/23/2023 18:42:01'!
CSVImporter subclass: #XXImporter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!classDefinition: #CustomerImporter category: 'CustomerImporter' stamp: 'LK 11/23/2023 18:42:01'!
XXImporter subclass: #CustomerImporter
	instanceVariableNames: 'newCustomer'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

XXImporter subclass: #SupplierImporter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!classDefinition: #SupplierImporter category: 'CustomerImporter' stamp: 'LK 11/23/2023 18:42:11'!
XXImporter subclass: #SupplierImporter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!
!XXImporter methodsFor: 'address' stamp: 'LK 11/23/2023 18:43:17'!
isAddressRecord

	^ record first = 'A'! !

!methodRemoval: CustomerImporter #isAddressRecord stamp: 'LK 11/23/2023 18:43:17'!
isAddressRecord

	^ record first = 'A'!
!XXImporter methodsFor: 'address' stamp: 'LK 11/23/2023 18:43:47'!
assertValidAddressRecord

	^ record size ~= 6 ifTrue: [ self error: self class invalidAddressRecordErrorDescription ]! !

!methodRemoval: CustomerImporter #assertValidAddressRecord stamp: 'LK 11/23/2023 18:43:47'!
assertValidAddressRecord

	^ record size ~= 6 ifTrue: [ self error: self class invalidAddressRecordErrorDescription ]!
!CSVImporter methodsFor: 'evaluating' stamp: 'LK 11/23/2023 18:47:00'!
importRecord

	self subclassResponsibility! !

!testRun: #ImportTest #test01 stamp: 'LK 11/23/2023 18:47:08'!
PASSED!

!testRun: #ImportTest #test01ValidDataIsImportedCorrectly stamp: 'LK 11/23/2023 18:47:08'!
PASSED!

!testRun: #ImportTest #test02CanNotImportAddressWithoutCustomer stamp: 'LK 11/23/2023 18:47:08'!
PASSED!

!testRun: #ImportTest #test03DoesNotImportRecordsStartingWithCButMoreCharacters stamp: 'LK 11/23/2023 18:47:08'!
PASSED!

!testRun: #ImportTest #test04DoesNotImportRecordsStartingWithAButMoreCharacters stamp: 'LK 11/23/2023 18:47:08'!
PASSED!

!testRun: #ImportTest #test05CanNotImportAddressRecordWithLessThanSixFields stamp: 'LK 11/23/2023 18:47:08'!
PASSED!

!testRun: #ImportTest #test06CanNotImportAddressRecordWithMoreThanSixFields stamp: 'LK 11/23/2023 18:47:08'!
PASSED!

!testRun: #ImportTest #test07CanNotImportCustomerRecordWithLessThanFiveFields stamp: 'LK 11/23/2023 18:47:08'!
PASSED!

!testRun: #ImportTest #test08CanNotImportCustomerRecordWithMoreThanFiveFields stamp: 'LK 11/23/2023 18:47:08'!
PASSED!

!testRun: #ImportTest #test09CannotImportEmptyLine stamp: 'LK 11/23/2023 18:47:08'!
PASSED!

!classDefinition: #CustomerImporter category: 'CustomerImporter' stamp: 'LK 11/23/2023 18:53:18'!
XXImporter subclass: #CustomerImporter
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!

!classDefinition: #XXImporter category: 'CustomerImporter' stamp: 'LK 11/23/2023 18:53:18'!
CSVImporter subclass: #XXImporter
	instanceVariableNames: 'newCustomer'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!
!XXImporter methodsFor: 'address' stamp: 'LK 11/23/2023 18:53:18'!
importAddress

	| newAddress |

	self assertCustomerWasImported.
	self assertValidAddressRecord.

	newAddress := Address new.
	newCustomer addAddress: newAddress.
	newAddress streetName: record second.
	newAddress streetNumber: record third asNumber .
	newAddress town: record fourth.
	newAddress zipCode: record fifth asNumber .
	newAddress province: record sixth! !

!methodRemoval: CustomerImporter #importAddress stamp: 'LK 11/23/2023 18:53:18'!
importAddress

	| newAddress |

	self assertCustomerWasImported.
	self assertValidAddressRecord.

	newAddress := Address new.
	newCustomer addAddress: newAddress.
	newAddress streetName: record second.
	newAddress streetNumber: record third asNumber .
	newAddress town: record fourth.
	newAddress zipCode: record fifth asNumber .
	newAddress province: record sixth!

!classDefinition: #XXImporter category: 'CustomerImporter' stamp: 'LK 11/23/2023 18:53:43'!
CSVImporter subclass: #XXImporter
	instanceVariableNames: 'newXX'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!
!XXImporter methodsFor: 'as yet unclassified' stamp: 'LK 11/23/2023 18:53:44' prior: 50771104!
importAddress

	| newAddress |

	self assertCustomerWasImported.
	self assertValidAddressRecord.

	newAddress := Address new.
	newXX addAddress: newAddress.
	newAddress streetName: record second.
	newAddress streetNumber: record third asNumber .
	newAddress town: record fourth.
	newAddress zipCode: record fifth asNumber .
	newAddress province: record sixth! !
!CustomerImporter methodsFor: 'as yet unclassified' stamp: 'LK 11/23/2023 18:53:44' prior: 50769492!
importCustomer

	self assertValidCustomerRecord.

	newXX := Customer new.
	newXX firstName: record second.
	newXX lastName: record third.
	newXX identificationType: record fourth.
	newXX identificationNumber: record fifth.
	system add: newXX! !
!CustomerImporter methodsFor: 'as yet unclassified' stamp: 'LK 11/23/2023 18:53:44' prior: 50769508!
assertCustomerWasImported

	^ newXX ifNil: [ self error: self class canNotImportAddressWithoutCustomerErrorDescription ]! !
!XXImporter methodsFor: 'address' stamp: 'LK 11/23/2023 18:54:04'!
assertCustomerWasImported

	^ newXX ifNil: [ self error: self class canNotImportAddressWithoutCustomerErrorDescription ]! !

!methodRemoval: CustomerImporter #assertCustomerWasImported stamp: 'LK 11/23/2023 18:54:04'!
assertCustomerWasImported

	^ newXX ifNil: [ self error: self class canNotImportAddressWithoutCustomerErrorDescription ]!
!XXImporter methodsFor: 'address' stamp: 'LK 11/23/2023 18:54:17'!
assertXXWasImported

	^ newXX ifNil: [ self error: self class canNotImportAddressWithoutCustomerErrorDescription ]! !
!XXImporter methodsFor: 'as yet unclassified' stamp: 'LK 11/23/2023 18:54:17' prior: 50771140!
importAddress

	| newAddress |

	self assertXXWasImported.
	self assertValidAddressRecord.

	newAddress := Address new.
	newXX addAddress: newAddress.
	newAddress streetName: record second.
	newAddress streetNumber: record third asNumber .
	newAddress town: record fourth.
	newAddress zipCode: record fifth asNumber .
	newAddress province: record sixth! !

!methodRemoval: XXImporter #assertCustomerWasImported stamp: 'LK 11/23/2023 18:54:17'!
assertCustomerWasImported

	^ newXX ifNil: [ self error: self class canNotImportAddressWithoutCustomerErrorDescription ]!

!testRun: #ImportTest #test01 stamp: 'LK 11/23/2023 18:54:22'!
PASSED!

!testRun: #ImportTest #test01ValidDataIsImportedCorrectly stamp: 'LK 11/23/2023 18:54:22'!
PASSED!

!testRun: #ImportTest #test02CanNotImportAddressWithoutCustomer stamp: 'LK 11/23/2023 18:54:22'!
PASSED!

!testRun: #ImportTest #test03DoesNotImportRecordsStartingWithCButMoreCharacters stamp: 'LK 11/23/2023 18:54:22'!
PASSED!

!testRun: #ImportTest #test04DoesNotImportRecordsStartingWithAButMoreCharacters stamp: 'LK 11/23/2023 18:54:22'!
PASSED!

!testRun: #ImportTest #test05CanNotImportAddressRecordWithLessThanSixFields stamp: 'LK 11/23/2023 18:54:22'!
PASSED!

!testRun: #ImportTest #test06CanNotImportAddressRecordWithMoreThanSixFields stamp: 'LK 11/23/2023 18:54:22'!
PASSED!

!testRun: #ImportTest #test07CanNotImportCustomerRecordWithLessThanFiveFields stamp: 'LK 11/23/2023 18:54:22'!
PASSED!

!testRun: #ImportTest #test08CanNotImportCustomerRecordWithMoreThanFiveFields stamp: 'LK 11/23/2023 18:54:22'!
PASSED!

!testRun: #ImportTest #test09CannotImportEmptyLine stamp: 'LK 11/23/2023 18:54:22'!
PASSED!
!Customer class methodsFor: 'no messages' stamp: 'LK 11/23/2023 18:58:46'!
for: aFirstName lastName: aLastName andIdType: anIdType andNumber: anIdNumber
	
	^self new initializeFor: aFirstName lastName: aLastName andIdType: anIdType andNumber: anIdNumber! !
!Customer methodsFor: 'initialization' stamp: 'LK 11/23/2023 18:59:39'!
initializeFor: aFirstName lastName: aLastName andIdType: anIdType andNumber: anIdNumber

	super initialize.
	firstName := aFirstName.
	lastName := aLastName.
	identificationType := anIdType.
	identificationNumber := anIdNumber.
	addresses := OrderedCollection new.! !

!methodRemoval: Customer #initialize stamp: 'LK 11/23/2023 18:59:48'!
initialize

	super initialize.
	addresses := OrderedCollection new.!
!CustomerImporter methodsFor: 'customer' stamp: 'LK 11/23/2023 19:00:42' prior: 50771155!
importCustomer

	self assertValidCustomerRecord.

	newXX := Customer for: record second lastName: record third andIdType: record fourth andNumber: record fifth.
	system add: newXX! !

!testRun: #ImportTest #test01 stamp: 'LK 11/23/2023 19:00:48'!
PASSED!

!testRun: #ImportTest #test01ValidDataIsImportedCorrectly stamp: 'LK 11/23/2023 19:00:48'!
PASSED!

!testRun: #ImportTest #test02CanNotImportAddressWithoutCustomer stamp: 'LK 11/23/2023 19:00:48'!
PASSED!

!testRun: #ImportTest #test03DoesNotImportRecordsStartingWithCButMoreCharacters stamp: 'LK 11/23/2023 19:00:48'!
PASSED!

!testRun: #ImportTest #test04DoesNotImportRecordsStartingWithAButMoreCharacters stamp: 'LK 11/23/2023 19:00:48'!
PASSED!

!testRun: #ImportTest #test05CanNotImportAddressRecordWithLessThanSixFields stamp: 'LK 11/23/2023 19:00:48'!
PASSED!

!testRun: #ImportTest #test06CanNotImportAddressRecordWithMoreThanSixFields stamp: 'LK 11/23/2023 19:00:48'!
PASSED!

!testRun: #ImportTest #test07CanNotImportCustomerRecordWithLessThanFiveFields stamp: 'LK 11/23/2023 19:00:48'!
PASSED!

!testRun: #ImportTest #test08CanNotImportCustomerRecordWithMoreThanFiveFields stamp: 'LK 11/23/2023 19:00:48'!
PASSED!

!testRun: #ImportTest #test09CannotImportEmptyLine stamp: 'LK 11/23/2023 19:00:48'!
PASSED!

!methodRemoval: Customer #firstName: stamp: 'LK 11/23/2023 19:00:53'!
firstName: aName

	firstName := aName!

!methodRemoval: Customer #identificationNumber: stamp: 'LK 11/23/2023 19:00:57'!
identificationNumber: anIdentificationNumber

	identificationNumber := anIdentificationNumber!

!methodRemoval: Customer #identificationType: stamp: 'LK 11/23/2023 19:00:59'!
identificationType: anIdentificationType

	identificationType := anIdentificationType!

!methodRemoval: Customer #lastName: stamp: 'LK 11/23/2023 19:01:01'!
lastName: aLastName

	lastName := aLastName
!
!Party methodsFor: 'addresses' stamp: 'LK 11/23/2023 19:01:34'!
addAddress: anAddress

	addresses add: anAddress ! !

!methodRemoval: Customer #addAddress: stamp: 'LK 11/23/2023 19:01:35'!
addAddress: anAddress

	addresses add: anAddress !

!testRun: #ImportTest #test01 stamp: 'LK 11/23/2023 19:01:40'!
PASSED!

!testRun: #ImportTest #test01ValidDataIsImportedCorrectly stamp: 'LK 11/23/2023 19:01:41'!
PASSED!

!testRun: #ImportTest #test02CanNotImportAddressWithoutCustomer stamp: 'LK 11/23/2023 19:01:41'!
PASSED!

!testRun: #ImportTest #test03DoesNotImportRecordsStartingWithCButMoreCharacters stamp: 'LK 11/23/2023 19:01:41'!
PASSED!

!testRun: #ImportTest #test04DoesNotImportRecordsStartingWithAButMoreCharacters stamp: 'LK 11/23/2023 19:01:41'!
PASSED!

!testRun: #ImportTest #test05CanNotImportAddressRecordWithLessThanSixFields stamp: 'LK 11/23/2023 19:01:41'!
PASSED!

!testRun: #ImportTest #test06CanNotImportAddressRecordWithMoreThanSixFields stamp: 'LK 11/23/2023 19:01:41'!
PASSED!

!testRun: #ImportTest #test07CanNotImportCustomerRecordWithLessThanFiveFields stamp: 'LK 11/23/2023 19:01:41'!
PASSED!

!testRun: #ImportTest #test08CanNotImportCustomerRecordWithMoreThanFiveFields stamp: 'LK 11/23/2023 19:01:41'!
PASSED!

!testRun: #ImportTest #test09CannotImportEmptyLine stamp: 'LK 11/23/2023 19:01:41'!
PASSED!
!Customer methodsFor: 'initialization' stamp: 'LK 11/23/2023 19:02:04' prior: 50771255!
initializeFor: aFirstName lastName: aLastName andIdType: anIdType andNumber: anIdNumber

	"super initialize."
	firstName := aFirstName.
	lastName := aLastName.
	identificationType := anIdType.
	identificationNumber := anIdNumber.
	addresses := OrderedCollection new.! !

!testRun: #ImportTest #test01 stamp: 'LK 11/23/2023 19:02:06'!
PASSED!

!testRun: #ImportTest #test01ValidDataIsImportedCorrectly stamp: 'LK 11/23/2023 19:02:06'!
PASSED!

!testRun: #ImportTest #test02CanNotImportAddressWithoutCustomer stamp: 'LK 11/23/2023 19:02:06'!
PASSED!

!testRun: #ImportTest #test03DoesNotImportRecordsStartingWithCButMoreCharacters stamp: 'LK 11/23/2023 19:02:06'!
PASSED!

!testRun: #ImportTest #test04DoesNotImportRecordsStartingWithAButMoreCharacters stamp: 'LK 11/23/2023 19:02:06'!
PASSED!

!testRun: #ImportTest #test05CanNotImportAddressRecordWithLessThanSixFields stamp: 'LK 11/23/2023 19:02:06'!
PASSED!

!testRun: #ImportTest #test06CanNotImportAddressRecordWithMoreThanSixFields stamp: 'LK 11/23/2023 19:02:06'!
PASSED!

!testRun: #ImportTest #test07CanNotImportCustomerRecordWithLessThanFiveFields stamp: 'LK 11/23/2023 19:02:06'!
PASSED!

!testRun: #ImportTest #test08CanNotImportCustomerRecordWithMoreThanFiveFields stamp: 'LK 11/23/2023 19:02:06'!
PASSED!

!testRun: #ImportTest #test09CannotImportEmptyLine stamp: 'LK 11/23/2023 19:02:06'!
PASSED!
!CustomerImporter methodsFor: 'customer' stamp: 'LK 11/23/2023 19:03:19' prior: 50771271!
importCustomer

	self assertValidCustomerRecord.

	newXX := Customer for: record second lastName: record third andIdType: record fourth andNumber: record fifth.
	
	system add: newXX! !
!Supplier methodsFor: 'as yet unclassified' stamp: 'LK 11/23/2023 19:06:21' prior: 50770481!
isCustomersEmpty

	^customers isEmpty! !

!testRun: #ImportTest #test01 stamp: 'LK 11/23/2023 19:06:23'!
PASSED!

!testRun: #ImportTest #test01 stamp: 'LK 11/23/2023 19:06:24'!
PASSED!

!testRun: #ImportTest #test01ValidDataIsImportedCorrectly stamp: 'LK 11/23/2023 19:06:24'!
PASSED!

!testRun: #ImportTest #test02CanNotImportAddressWithoutCustomer stamp: 'LK 11/23/2023 19:06:24'!
PASSED!

!testRun: #ImportTest #test03DoesNotImportRecordsStartingWithCButMoreCharacters stamp: 'LK 11/23/2023 19:06:24'!
PASSED!

!testRun: #ImportTest #test04DoesNotImportRecordsStartingWithAButMoreCharacters stamp: 'LK 11/23/2023 19:06:24'!
PASSED!

!testRun: #ImportTest #test05CanNotImportAddressRecordWithLessThanSixFields stamp: 'LK 11/23/2023 19:06:24'!
PASSED!

!testRun: #ImportTest #test06CanNotImportAddressRecordWithMoreThanSixFields stamp: 'LK 11/23/2023 19:06:24'!
PASSED!

!testRun: #ImportTest #test07CanNotImportCustomerRecordWithLessThanFiveFields stamp: 'LK 11/23/2023 19:06:24'!
PASSED!

!testRun: #ImportTest #test08CanNotImportCustomerRecordWithMoreThanFiveFields stamp: 'LK 11/23/2023 19:06:24'!
PASSED!

!testRun: #ImportTest #test09CannotImportEmptyLine stamp: 'LK 11/23/2023 19:06:24'!
PASSED!
!XXImporter methodsFor: 'address' stamp: 'LK 11/23/2023 19:09:17' prior: 50771192!
importAddress

	| newAddress |

	self assertXXWasImported.
	self assertValidAddressRecord.

	newAddress := Address named: record second andNumber: record third asNumber inTown: record fourth zipCode: record fifth asNumber andProvince: record sixth.
	newXX addAddress: newAddress.
	"newAddress streetName: record second.
	newAddress streetNumber: record third asNumber .
	newAddress town: record fourth.
	newAddress zipCode: record fifth asNumber .
	newAddress province: record sixth"! !
!Address class methodsFor: 'nil' stamp: 'LK 11/23/2023 19:11:39'!
named: aStreetName andNumber: aStreetNumber inTown: aTownName zipCode: aZipCode andProvince: aProvinceName

	^self new initializeNamed: aStreetName andNumber: aStreetNumber inTown: aTownName zipCode: aZipCode andProvince: aProvinceName! !
!Address methodsFor: 'province' stamp: 'LK 11/23/2023 19:12:32'!
initializeNamed: aStreetName andNumber: aStreetNumber inTown: aTownName zipCode: aZipCode andProvince: aProvinceName

	streetName := aStreetName.
	streetNumber := aStreetNumber.
	town := aTownName.
	zipCode := aZipCode.
	province := aProvinceName.! !

!testRun: #ImportTest #test01 stamp: 'LK 11/23/2023 19:13:15'!
PASSED!

!testRun: #ImportTest #test01ValidDataIsImportedCorrectly stamp: 'LK 11/23/2023 19:13:15'!
PASSED!

!testRun: #ImportTest #test02CanNotImportAddressWithoutCustomer stamp: 'LK 11/23/2023 19:13:15'!
PASSED!

!testRun: #ImportTest #test03DoesNotImportRecordsStartingWithCButMoreCharacters stamp: 'LK 11/23/2023 19:13:15'!
PASSED!

!testRun: #ImportTest #test04DoesNotImportRecordsStartingWithAButMoreCharacters stamp: 'LK 11/23/2023 19:13:15'!
PASSED!

!testRun: #ImportTest #test05CanNotImportAddressRecordWithLessThanSixFields stamp: 'LK 11/23/2023 19:13:15'!
PASSED!

!testRun: #ImportTest #test06CanNotImportAddressRecordWithMoreThanSixFields stamp: 'LK 11/23/2023 19:13:15'!
PASSED!

!testRun: #ImportTest #test07CanNotImportCustomerRecordWithLessThanFiveFields stamp: 'LK 11/23/2023 19:13:15'!
PASSED!

!testRun: #ImportTest #test08CanNotImportCustomerRecordWithMoreThanFiveFields stamp: 'LK 11/23/2023 19:13:15'!
PASSED!

!testRun: #ImportTest #test09CannotImportEmptyLine stamp: 'LK 11/23/2023 19:13:15'!
PASSED!

!methodRemoval: Address #province: stamp: 'LK 11/23/2023 19:13:28'!
province: aProvince

	province := aProvince
	!

!methodRemoval: Address #streetName: stamp: 'LK 11/23/2023 19:13:30'!
streetName: aStreetName

	streetName := aStreetName !

!methodRemoval: Address #streetNumber: stamp: 'LK 11/23/2023 19:13:32'!
streetNumber: aStreetNumber

	streetNumber := aStreetNumber !

!methodRemoval: Address #town: stamp: 'LK 11/23/2023 19:13:34'!
town: aTown

	town := aTown!

!methodRemoval: Address #zipCode: stamp: 'LK 11/23/2023 19:13:36'!
zipCode: aZipCode

	zipCode := aZipCode!
!XXImporter methodsFor: 'address' stamp: 'LK 11/23/2023 19:13:52' prior: 50771470!
importAddress

	| newAddress |

	self assertXXWasImported.
	self assertValidAddressRecord.

	newAddress := Address named: record second andNumber: record third asNumber inTown: record fourth zipCode: record fifth asNumber andProvince: record sixth.
	newXX addAddress: newAddress.
	! !
!XXImporter methodsFor: 'address' stamp: 'LK 11/23/2023 19:13:54' prior: 50771561!
importAddress

	| newAddress |

	self assertXXWasImported.
	self assertValidAddressRecord.

	newAddress := Address named: record second andNumber: record third asNumber inTown: record fourth zipCode: record fifth asNumber andProvince: record sixth.
	newXX addAddress: newAddress.! !

!testRun: #ImportTest #test01 stamp: 'LK 11/23/2023 19:13:56'!
PASSED!

!testRun: #ImportTest #test01ValidDataIsImportedCorrectly stamp: 'LK 11/23/2023 19:13:56'!
PASSED!

!testRun: #ImportTest #test02CanNotImportAddressWithoutCustomer stamp: 'LK 11/23/2023 19:13:56'!
PASSED!

!testRun: #ImportTest #test03DoesNotImportRecordsStartingWithCButMoreCharacters stamp: 'LK 11/23/2023 19:13:56'!
PASSED!

!testRun: #ImportTest #test04DoesNotImportRecordsStartingWithAButMoreCharacters stamp: 'LK 11/23/2023 19:13:56'!
PASSED!

!testRun: #ImportTest #test05CanNotImportAddressRecordWithLessThanSixFields stamp: 'LK 11/23/2023 19:13:56'!
PASSED!

!testRun: #ImportTest #test06CanNotImportAddressRecordWithMoreThanSixFields stamp: 'LK 11/23/2023 19:13:56'!
PASSED!

!testRun: #ImportTest #test07CanNotImportCustomerRecordWithLessThanFiveFields stamp: 'LK 11/23/2023 19:13:56'!
PASSED!

!testRun: #ImportTest #test08CanNotImportCustomerRecordWithMoreThanFiveFields stamp: 'LK 11/23/2023 19:13:56'!
PASSED!

!testRun: #ImportTest #test09CannotImportEmptyLine stamp: 'LK 11/23/2023 19:13:56'!
PASSED!
!PersistentErpSystem methodsFor: 'customers' stamp: 'LK 11/23/2023 19:17:14' overrides: 50770993!
addSupplier: aSupplier

	self subclassResponsibility! !
!ErpSystem methodsFor: 'customers' stamp: 'LK 11/23/2023 19:17:14' prior: 50770993!
addSupplier: aSupplier

	self subclassResponsibility! !
!ErpSystem methodsFor: 'customers' stamp: 'LK 11/23/2023 19:17:27'!
numberOfSuppliers

	self subclassResponsibility! !
!PersistentErpSystem methodsFor: 'customers' stamp: 'LK 11/23/2023 19:17:36' overrides: 50771628!
numberOfSuppliers

	self subclassResponsibility! !
!ErpSystem methodsFor: 'customers' stamp: 'LK 11/23/2023 19:17:36' prior: 50771628!
numberOfSuppliers

	self subclassResponsibility! !

!testRun: #ImportTest #test01 stamp: 'LK 11/23/2023 19:17:44'!
PASSED!

!testRun: #ImportTest #test01ValidDataIsImportedCorrectly stamp: 'LK 11/23/2023 19:17:44'!
PASSED!

!testRun: #ImportTest #test02CanNotImportAddressWithoutCustomer stamp: 'LK 11/23/2023 19:17:44'!
PASSED!

!testRun: #ImportTest #test03DoesNotImportRecordsStartingWithCButMoreCharacters stamp: 'LK 11/23/2023 19:17:44'!
PASSED!

!testRun: #ImportTest #test04DoesNotImportRecordsStartingWithAButMoreCharacters stamp: 'LK 11/23/2023 19:17:44'!
PASSED!

!testRun: #ImportTest #test05CanNotImportAddressRecordWithLessThanSixFields stamp: 'LK 11/23/2023 19:17:44'!
PASSED!

!testRun: #ImportTest #test06CanNotImportAddressRecordWithMoreThanSixFields stamp: 'LK 11/23/2023 19:17:44'!
PASSED!

!testRun: #ImportTest #test07CanNotImportCustomerRecordWithLessThanFiveFields stamp: 'LK 11/23/2023 19:17:44'!
PASSED!

!testRun: #ImportTest #test08CanNotImportCustomerRecordWithMoreThanFiveFields stamp: 'LK 11/23/2023 19:17:44'!
PASSED!

!testRun: #ImportTest #test09CannotImportEmptyLine stamp: 'LK 11/23/2023 19:17:44'!
PASSED!
!ImportTest methodsFor: 'tests~supplier' stamp: 'LK 11/23/2023 19:18:19'!
test01emptySupplierIsImportedCorrectly

	| stream supplier |
	stream := ReadStream on: 'S,Supplier1,D,123'.
	SupplierImporter valueFrom: stream into: system.
	
	self assert: system numberOfSuppliers equals: 1.
	supplier := system supplierWithIdentificationType: 'D' number: '123'.
	self assert: (supplier isNamed: 'Supplier1').
	self assert: supplier isAddressesEmpty .
	self assert: supplier isCustomersEmpty.! !

!methodRemoval: ImportTest #test01 stamp: 'LK 11/23/2023 19:18:19'!
test01

	| stream supplier |
	stream := ReadStream on: 'S,Supplier1,D,123'.
	SupplierImporter valueFrom: stream into: system.
	
	self assert: system numberOfSuppliers equals: 1.
	supplier := system supplierWithIdentificationType: 'D' number: '123'.
	self assert: (supplier isNamed: 'Supplier1').
	self assert: supplier isAddressesEmpty .
	self assert: supplier isCustomersEmpty.!
!ImportTest methodsFor: 'tests~supplier' stamp: 'LK 11/23/2023 19:18:25'!
test02

	| stream supplier |
	stream := ReadStream on: 'S,Supplier1,D,123'.
	SupplierImporter valueFrom: stream into: system.
	
	self assert: system numberOfSuppliers equals: 1.
	supplier := system supplierWithIdentificationType: 'D' number: '123'.
	self assert: (supplier isNamed: 'Supplier1').
	self assert: supplier isAddressesEmpty .
	self assert: supplier isCustomersEmpty.! !
!ImportTest methodsFor: 'tests~supplier' stamp: 'LK 11/23/2023 19:23:41' prior: 50771706!
test02

	" hacer tests, pasar todo de transient a persistent"
	| stream supplier |
	stream := ReadStream on: 'S,Supplier1,D,123'.
	SupplierImporter valueFrom: stream into: system.
	
	self assert: system numberOfSuppliers equals: 1.
	supplier := system supplierWithIdentificationType: 'D' number: '123'.
	self assert: (supplier isNamed: 'Supplier1').
	self assert: supplier isAddressesEmpty .
	self assert: supplier isCustomersEmpty.! !
!ImportTest methodsFor: 'tests~supplier' stamp: 'LK 11/23/2023 19:26:52' prior: 50771721!
test02

	" hacer tests, pasar todo de transient a persistent"
	| stream supplier text|
	
	text := 'S,Supplier1,D,123
	NC,Pepe,Sanchez,D,22333444'.
	
	stream := ReadStream on: text.
	SupplierImporter valueFrom: stream into: system.
	
	self assert: system numberOfSuppliers equals: 1.
	supplier := system supplierWithIdentificationType: 'D' number: '123'.
	self assert: (supplier isNamed: 'Supplier1').
	self assert: supplier isAddressesEmpty .
	self assert: supplier isCustomersEmpty.! !
!ImportTest methodsFor: 'tests~supplier' stamp: 'LK 11/23/2023 19:27:19'!
test02supplierWithExistingCustomerIsImported

	" hacer tests, pasar todo de transient a persistent"
	| stream supplier text|
	
	text := 'S,Supplier1,D,123
	NC,Pepe,Sanchez,D,22333444'.
	
	stream := ReadStream on: text.
	SupplierImporter valueFrom: stream into: system.
	
	self assert: system numberOfSuppliers equals: 1.
	supplier := system supplierWithIdentificationType: 'D' number: '123'.
	self assert: (supplier isNamed: 'Supplier1').
	self assert: supplier isAddressesEmpty .
	self assert: supplier isCustomersEmpty.! !

!methodRemoval: ImportTest #test02 stamp: 'LK 11/23/2023 19:27:19'!
test02

	" hacer tests, pasar todo de transient a persistent"
	| stream supplier text|
	
	text := 'S,Supplier1,D,123
	NC,Pepe,Sanchez,D,22333444'.
	
	stream := ReadStream on: text.
	SupplierImporter valueFrom: stream into: system.
	
	self assert: system numberOfSuppliers equals: 1.
	supplier := system supplierWithIdentificationType: 'D' number: '123'.
	self assert: (supplier isNamed: 'Supplier1').
	self assert: supplier isAddressesEmpty .
	self assert: supplier isCustomersEmpty.!
!ImportTest methodsFor: 'tests~supplier' stamp: 'LK 11/23/2023 19:28:42' prior: 50771756!
test02supplierWithExistingCustomerIsImported

	" hacer tests, pasar todo de transient a persistent"
	| stream supplier text|
	
	text := 'S,Supplier1,D,123
	NC,Pepe,Sanchez,D,22333444'.
	
	stream := ReadStream on: text.
	SupplierImporter valueFrom: stream into: system.
	
	self assert: supplier isAddressesEmpty .
	self assert: supplier numbersOfCustomers equals: 1.! !
!ImportTest methodsFor: 'tests~supplier' stamp: 'LK 11/23/2023 19:29:10' prior: 50771793!
test02supplierWithExistingCustomerIsImported

	" hacer tests, pasar todo de transient a persistent"
	| stream supplier text|
	
	text := 'S,Supplier1,D,123
	NC,Pepe,Sanchez,D,22333444'.
	
	stream := ReadStream on: text.
	SupplierImporter valueFrom: stream into: system.
	supplier := system supplierWithIdentificationType: 'D' number: '123'.
	
	self assert: supplier isAddressesEmpty.
	self assert: supplier numbersOfCustomers equals: 1.! !
!ImportTest methodsFor: 'tests~supplier' stamp: 'LK 11/23/2023 19:31:03' prior: 50771808!
test02supplierWithExistingCustomerIsImported

	" hacer tests, pasar todo de transient a persistent"
	| stream supplier text|
	
	text := 'S,Supplier1,D,123
	NC,Pepe,Sanchez,D,22333444'.
	
	stream := ReadStream on: text.
	SupplierImporter valueFrom: stream into: system.
	supplier := system supplierWithIdentificationType: 'D' number: '123'.
	
	self assert: supplier isAddressesEmpty.
	self assert: supplier numbersOfCustomers equals: 1.
	self assertCustomerWithIdentificationType: 'D' number: '22333444' hasFirstName: 'Pepe' lastName: 'Sanchez'.! !
!Supplier methodsFor: 'as yet unclassified' stamp: 'LK 11/23/2023 19:34:00'!
numberOfCustomers

	^customers size! !
!ImportTest methodsFor: 'tests~supplier' stamp: 'LK 11/23/2023 19:34:12' prior: 50771825!
test02supplierWithExistingCustomerIsImported

	" hacer tests, pasar todo de transient a persistent"
	| stream supplier text|
	
	text := 'S,Supplier1,D,123
	NC,Pepe,Sanchez,D,22333444'.
	
	stream := ReadStream on: text.
	SupplierImporter valueFrom: stream into: system.
	supplier := system supplierWithIdentificationType: 'D' number: '123'.
	
	self assert: supplier isAddressesEmpty.
	self assert: supplier numberOfCustomers equals: 1.
	self assertCustomerWithIdentificationType: 'D' number: '22333444' hasFirstName: 'Pepe' lastName: 'Sanchez'.! !
!ImportTest methodsFor: 'tests~supplier' stamp: 'LK 11/23/2023 19:52:55'!
test02supplierWithNewCustomerIsImported

	" hacer tests, pasar todo de transient a persistent"
	| stream supplier text|
	
	text := 'S,Supplier1,D,123
	NC,Pepe,Sanchez,D,22333444'.
	
	stream := ReadStream on: text.
	SupplierImporter valueFrom: stream into: system.
	supplier := system supplierWithIdentificationType: 'D' number: '123'.
	
	self assert: supplier isAddressesEmpty.
	self assert: supplier numberOfCustomers equals: 1.
	self assertCustomerWithIdentificationType: 'D' number: '22333444' hasFirstName: 'Pepe' lastName: 'Sanchez'.! !

!methodRemoval: ImportTest #test02supplierWithExistingCustomerIsImported stamp: 'LK 11/23/2023 19:52:55'!
test02supplierWithExistingCustomerIsImported

	" hacer tests, pasar todo de transient a persistent"
	| stream supplier text|
	
	text := 'S,Supplier1,D,123
	NC,Pepe,Sanchez,D,22333444'.
	
	stream := ReadStream on: text.
	SupplierImporter valueFrom: stream into: system.
	supplier := system supplierWithIdentificationType: 'D' number: '123'.
	
	self assert: supplier isAddressesEmpty.
	self assert: supplier numberOfCustomers equals: 1.
	self assertCustomerWithIdentificationType: 'D' number: '22333444' hasFirstName: 'Pepe' lastName: 'Sanchez'.!

!testRun: #ImportTest #test02supplierWithNewCustomerIsImported stamp: 'LK 11/23/2023 19:53:08'!
FAILURE!
!SupplierImporter methodsFor: 'as yet unclassified' stamp: 'LK 11/23/2023 19:55:47'!
importSupplier

	newXX := Supplier named: record second identificationType: record third number: record fourth.
	
	system addSupplier: newXX.! !
!SupplierImporter methodsFor: 'as yet unclassified' stamp: 'LK 11/23/2023 19:57:48' prior: 50770112 overrides: 50771051!
importRecord

	self assertRecordNotEmpty.
	
	(self isRecordSupplier) ifTrue: [self importSupplier].
	! !
!SupplierImporter methodsFor: 'as yet unclassified' stamp: 'LK 11/23/2023 19:58:09' prior: 50771923 overrides: 50771051!
importRecord

	self assertRecordNotEmpty.
	
	(self isSupplierRecord) ifTrue: [self importSupplier].
	! !
!SupplierImporter methodsFor: 'as yet unclassified' stamp: 'LK 11/23/2023 19:58:22'!
isSupplierRecord
	
	^record first = 	'S'! !
!SupplierImporter methodsFor: 'as yet unclassified' stamp: 'LK 11/23/2023 19:59:19' prior: 50771931 overrides: 50771051!
importRecord

	self assertRecordNotEmpty.
	
	(self isSupplierRecord) ifTrue: [self importSupplier].
	
	(self isNewCustomerRecord) ifTrue: [].
	
	(self isExistingCustomerRecord) ifTrue: [].
	
	(self isAddressRecord) ifTrue: [].
	! !
!SupplierImporter methodsFor: 'as yet unclassified' stamp: 'LK 11/23/2023 19:59:34'!
isNewCustomerRecord

	^record first = 'NC'! !
!SupplierImporter methodsFor: 'as yet unclassified' stamp: 'LK 11/23/2023 19:59:54'!
isExistingCustomerRecord

	^record first = 'EC'! !
!SupplierImporter methodsFor: 'as yet unclassified' stamp: 'LK 11/23/2023 20:00:56' prior: 50771943 overrides: 50771051!
importRecord

	self assertRecordNotEmpty.
	
	(self isSupplierRecord) ifTrue: [self importSupplier].
	
	(self isNewCustomerRecord) ifTrue: [].
	
	(self isExistingCustomerRecord) ifTrue: [].
	
	(self isAddressRecord) ifTrue: [self importAddress].
	! !
!SupplierImporter methodsFor: 'as yet unclassified' stamp: 'LK 11/23/2023 20:01:32' prior: 50771964 overrides: 50771051!
importRecord

	self assertRecordNotEmpty.
	
	(self isSupplierRecord) ifTrue: [self importSupplier].
	
	(self isNewCustomerRecord) ifTrue: [self importCustomer].
	
	(self isExistingCustomerRecord) ifTrue: [].
	
	(self isAddressRecord) ifTrue: [self importAddress].
	! !
!SupplierImporter methodsFor: 'as yet unclassified' stamp: 'LK 11/23/2023 20:01:40' prior: 50771976 overrides: 50771051!
importRecord

	self assertRecordNotEmpty.
	
	(self isSupplierRecord) ifTrue: [self importSupplier].
	
	(self isNewCustomerRecord) ifTrue: [self importCustomer].
	
	(self isExistingCustomerRecord) ifTrue: [self addCustomerToSupplier].
	
	(self isAddressRecord) ifTrue: [self importAddress].
	! !
!SupplierImporter methodsFor: 'as yet unclassified' stamp: 'LK 11/23/2023 20:05:13' prior: 50771989 overrides: 50771051!
importRecord

	self assertRecordNotEmpty.
	
	(self isSupplierRecord) ifTrue: [self importSupplier].
	
	(self isNewCustomerRecord) ifTrue: ["self importCustomer"].
	
	(self isExistingCustomerRecord) ifTrue: ["self addCustomerToSupplier"].
	
	(self isAddressRecord) ifTrue: [self importAddress].
	! !
!SupplierImporter methodsFor: 'as yet unclassified' stamp: 'LK 11/23/2023 20:06:03' prior: 50772002 overrides: 50771051!
importRecord

	self assertRecordNotEmpty.
	
	(self isSupplierRecord) ifTrue: [^self importSupplier].
	
	(self isNewCustomerRecord) ifTrue: ["self importCustomer"].
	
	(self isExistingCustomerRecord) ifTrue: ["self addCustomerToSupplier"].
	
	(self isAddressRecord) ifTrue: [^self importAddress].
	! !

!methodRemoval: CSVImporter #importRecord stamp: 'LK 11/23/2023 20:06:42'!
importRecord

	self subclassResponsibility!
!ImportTest methodsFor: 'tests~supplier' stamp: 'LK 11/23/2023 20:07:53'!
test02supplierWithAddressesIsImported

	" hacer tests, pasar todo de transient a persistent"
	| stream supplier text|
	
	text := 'S,Supplier1,D,123
	A,San Martin,3322,Olivos,1636,BsAs		
A,Maipu,888,Florida,1122,Buenos Aires'.
	
	stream := ReadStream on: text.
	SupplierImporter valueFrom: stream into: system.
	supplier := system supplierWithIdentificationType: 'D' number: '123'.
	
	self assert: (supplier isAddressesEmpty) not.
	! !

!testRun: #ImportTest #test02supplierWithAddressesIsImported stamp: 'LK 11/23/2023 20:07:55'!
PASSED!

!testRun: #ImportTest #test01ValidDataIsImportedCorrectly stamp: 'LK 11/23/2023 20:07:55'!
PASSED!

!testRun: #ImportTest #test01emptySupplierIsImportedCorrectly stamp: 'LK 11/23/2023 20:07:55'!
PASSED!

!testRun: #ImportTest #test02CanNotImportAddressWithoutCustomer stamp: 'LK 11/23/2023 20:07:55'!
PASSED!

!testRun: #ImportTest #test02supplierWithAddressesIsImported stamp: 'LK 11/23/2023 20:07:55'!
PASSED!

!testRun: #ImportTest #test02supplierWithNewCustomerIsImported stamp: 'LK 11/23/2023 20:07:55'!
FAILURE!

!testRun: #ImportTest #test03DoesNotImportRecordsStartingWithCButMoreCharacters stamp: 'LK 11/23/2023 20:07:55'!
PASSED!

!testRun: #ImportTest #test04DoesNotImportRecordsStartingWithAButMoreCharacters stamp: 'LK 11/23/2023 20:07:56'!
PASSED!

!testRun: #ImportTest #test05CanNotImportAddressRecordWithLessThanSixFields stamp: 'LK 11/23/2023 20:07:56'!
PASSED!

!testRun: #ImportTest #test06CanNotImportAddressRecordWithMoreThanSixFields stamp: 'LK 11/23/2023 20:07:56'!
PASSED!

!testRun: #ImportTest #test07CanNotImportCustomerRecordWithLessThanFiveFields stamp: 'LK 11/23/2023 20:07:56'!
PASSED!

!testRun: #ImportTest #test08CanNotImportCustomerRecordWithMoreThanFiveFields stamp: 'LK 11/23/2023 20:07:56'!
PASSED!

!testRun: #ImportTest #test09CannotImportEmptyLine stamp: 'LK 11/23/2023 20:07:56'!
PASSED!

!testRun: #ImportTest #test02supplierWithNewCustomerIsImported stamp: 'LK 11/23/2023 20:07:56'!
FAILURE!

!testRun: #ImportTest #test02supplierWithAddressesIsImported stamp: 'LK 11/23/2023 20:08:01'!
PASSED!
!ImportTest methodsFor: 'tests~supplier' stamp: 'LK 11/23/2023 20:08:07' prior: 50772032!
test02supplierWithAddressesIsImported

	" hacer tests, pasar todo de transient a persistent"
	| stream supplier text|
	
	text := 'S,Supplier1,D,123
	A,San Martin,3322,Olivos,1636,BsAs		
	A,Maipu,888,Florida,1122,Buenos Aires'.
	
	stream := ReadStream on: text.
	SupplierImporter valueFrom: stream into: system.
	supplier := system supplierWithIdentificationType: 'D' number: '123'.
	
	self assert: (supplier isAddressesEmpty) not.
	! !

!testRun: #ImportTest #test02supplierWithAddressesIsImported stamp: 'LK 11/23/2023 20:08:07'!
FAILURE!

!testRun: #ImportTest #test02supplierWithAddressesIsImported stamp: 'LK 11/23/2023 20:08:13'!
FAILURE!

!testRun: #ImportTest #test02supplierWithAddressesIsImported stamp: 'LK 11/23/2023 20:08:13'!
FAILURE!

!testRun: #ImportTest #test02supplierWithAddressesIsImported stamp: 'LK 11/23/2023 20:08:19'!
FAILURE!

!testRun: #ImportTest #test02supplierWithAddressesIsImported stamp: 'LK 11/23/2023 20:08:19'!
FAILURE!
!ImportTest methodsFor: 'tests~supplier' stamp: 'LK 11/23/2023 20:08:24' prior: 50772100!
test02supplierWithAddressesIsImported

	" hacer tests, pasar todo de transient a persistent"
	| stream supplier text|
	
	text := 'S,Supplier1,D,123
	A,San Martin,3322,Olivos,1636,BsAs		
A,Maipu,888,Florida,1122,Buenos Aires'.
	
	stream := ReadStream on: text.
	SupplierImporter valueFrom: stream into: system.
	supplier := system supplierWithIdentificationType: 'D' number: '123'.
	
	self assert: (supplier isAddressesEmpty) not.
	! !

!testRun: #ImportTest #test02supplierWithAddressesIsImported stamp: 'LK 11/23/2023 20:08:26'!
PASSED!

!testRun: #ImportTest #test01ValidDataIsImportedCorrectly stamp: 'LK 11/23/2023 20:08:26'!
PASSED!

!testRun: #ImportTest #test01emptySupplierIsImportedCorrectly stamp: 'LK 11/23/2023 20:08:26'!
PASSED!

!testRun: #ImportTest #test02CanNotImportAddressWithoutCustomer stamp: 'LK 11/23/2023 20:08:26'!
PASSED!

!testRun: #ImportTest #test02supplierWithAddressesIsImported stamp: 'LK 11/23/2023 20:08:26'!
PASSED!

!testRun: #ImportTest #test02supplierWithNewCustomerIsImported stamp: 'LK 11/23/2023 20:08:26'!
FAILURE!

!testRun: #ImportTest #test03DoesNotImportRecordsStartingWithCButMoreCharacters stamp: 'LK 11/23/2023 20:08:26'!
PASSED!

!testRun: #ImportTest #test04DoesNotImportRecordsStartingWithAButMoreCharacters stamp: 'LK 11/23/2023 20:08:26'!
PASSED!

!testRun: #ImportTest #test05CanNotImportAddressRecordWithLessThanSixFields stamp: 'LK 11/23/2023 20:08:26'!
PASSED!

!testRun: #ImportTest #test06CanNotImportAddressRecordWithMoreThanSixFields stamp: 'LK 11/23/2023 20:08:26'!
PASSED!

!testRun: #ImportTest #test07CanNotImportCustomerRecordWithLessThanFiveFields stamp: 'LK 11/23/2023 20:08:26'!
PASSED!

!testRun: #ImportTest #test08CanNotImportCustomerRecordWithMoreThanFiveFields stamp: 'LK 11/23/2023 20:08:26'!
PASSED!

!testRun: #ImportTest #test09CannotImportEmptyLine stamp: 'LK 11/23/2023 20:08:26'!
PASSED!

!testRun: #ImportTest #test02supplierWithNewCustomerIsImported stamp: 'LK 11/23/2023 20:08:26'!
FAILURE!

!testRun: #ImportTest #test02supplierWithAddressesIsImported stamp: 'LK 11/23/2023 20:08:31'!
PASSED!
!ImportTest methodsFor: 'tests~supplier' stamp: 'LK 11/23/2023 20:09:06' prior: 50772133!
test02supplierWithAddressesIsImported

	" hacer tests, pasar todo de transient a persistent"
	| stream supplier text|
	
	text := 'S,Supplier1,D,123
	A,San Martin,3322,Olivos,1636,BsAs		
A,Maipu,888,Florida,1122,Buenos Aires'.
	
	stream := ReadStream on: text.
	SupplierImporter valueFrom: stream into: system.
	supplier := system supplierWithIdentificationType: 'D' number: '123'.
	
	self assert: supplier numberOfAddresses equals: 2.
	! !
!Party methodsFor: 'addresses' stamp: 'LK 11/23/2023 20:09:24'!
numberOfAddresses
	^addresses size! !

!testRun: #ImportTest #test02supplierWithAddressesIsImported stamp: 'LK 11/23/2023 20:09:34'!
FAILURE!

!testRun: #ImportTest #test02supplierWithAddressesIsImported stamp: 'LK 11/23/2023 20:09:34'!
FAILURE!

!testRun: #ImportTest #test02supplierWithAddressesIsImported stamp: 'LK 11/23/2023 20:09:42'!
FAILURE!

supplier!

Address!

an Address!
!Supplier methodsFor: 'as yet unclassified' stamp: 'LK 11/23/2023 20:11:26' prior: 50770888!
initializeNamed: aName identificationType: anIdentificationType number: anIdentificationNumber

	name := aName.
	identificationType := anIdentificationType.
	identificationNumber := anIdentificationNumber.
	customers := Set new.
	addresses := Set new.! !
!Customer methodsFor: 'initialization' stamp: 'LK 11/23/2023 20:11:34' prior: 50771374!
initializeFor: aFirstName lastName: aLastName andIdType: anIdType andNumber: anIdNumber

	"super initialize."
	firstName := aFirstName.
	lastName := aLastName.
	identificationType := anIdType.
	identificationNumber := anIdNumber.
	addresses := Set new.! !

!testRun: #ImportTest #test02supplierWithAddressesIsImported stamp: 'LK 11/23/2023 20:11:40'!
FAILURE!

!testRun: #ImportTest #test02supplierWithAddressesIsImported stamp: 'LK 11/23/2023 20:11:40'!
FAILURE!
!CSVImporter methodsFor: 'evaluating' stamp: 'LK 11/23/2023 20:12:48'!
importRecord

	self subclassResponsibility ! !

!testRun: #ImportTest #test02supplierWithAddressesIsImported stamp: 'LK 11/23/2023 20:12:58'!
FAILURE!

!testRun: #ImportTest #test02supplierWithAddressesIsImported stamp: 'LK 11/23/2023 20:12:58'!
FAILURE!

----QUIT----(23 November 2023 20:14:50) CuisUniversity-5981.image priorSource: 13992911!

----STARTUP---- (27 November 2023 13:15:58) as C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\CuisUniversity-5981.image!


!testRun: #ImportTest #test02supplierWithAddressesIsImported stamp: 'LK 11/27/2023 13:24:25'!
FAILURE!

!testRun: #ImportTest #test02supplierWithAddressesIsImported stamp: 'LK 11/27/2023 13:26:44'!
FAILURE!

!testRun: #ImportTest #test02supplierWithAddressesIsImported stamp: 'LK 11/27/2023 13:26:44'!
FAILURE!

supplier!

	a Set!
!ImportTest methodsFor: 'tests~supplier' stamp: 'LK 11/27/2023 13:28:30' prior: 50772201!
test02supplierWithAddressesIsImported

	" hacer tests, pasar todo de transient a persistent"
	| stream supplier text addy|
	
	text := 'S,Supplier1,D,123
	A,San Martin,3322,Olivos,1636,BsAs		
A,Maipu,888,Florida,1122,Buenos Aires'.
	
	stream := ReadStream on: text.
	SupplierImporter valueFrom: stream into: system.
	supplier := system supplierWithIdentificationType: 'D' number: '123'.
	
	self assert: supplier numberOfAddresses equals: 2.
	
	addy := (supplier addresses) anyOne.
	! !
!ImportTest methodsFor: 'tests~supplier' stamp: 'LK 11/27/2023 13:29:07' prior: 50772289!
test02supplierWithAddressesIsImported

	" hacer tests, pasar todo de transient a persistent"
	| stream supplier text addy|
	
	text := 'S,Supplier1,D,123
	A,San Martin,3322,Olivos,1636,BsAs		
A,Maipu,888,Florida,1122,Buenos Aires'.
	
	stream := ReadStream on: text.
	SupplierImporter valueFrom: stream into: system.
	supplier := system supplierWithIdentificationType: 'D' number: '123'.
	
	self assert: supplier numberOfAddresses equals: 2.
	
	addy := (supplier addresses) anyOne.
	self assert: addy streetName equals: 'San Martin'.
	! !

!testRun: #ImportTest #test02supplierWithAddressesIsImported stamp: 'LK 11/27/2023 13:29:08'!
FAILURE!
!ImportTest methodsFor: 'tests~supplier' stamp: 'LK 11/27/2023 13:29:13' prior: 50772307!
test02supplierWithAddressesIsImported

	" hacer tests, pasar todo de transient a persistent"
	| stream supplier text addy|
	
	text := 'S,Supplier1,D,123
	A,San Martin,3322,Olivos,1636,BsAs		
A,Maipu,888,Florida,1122,Buenos Aires'.
	
	stream := ReadStream on: text.
	SupplierImporter valueFrom: stream into: system.
	supplier := system supplierWithIdentificationType: 'D' number: '123'.
	
	"self assert: supplier numberOfAddresses equals: 2."
	
	addy := (supplier addresses) anyOne.
	self assert: addy streetName equals: 'San Martin'.
	! !

!testRun: #ImportTest #test02supplierWithAddressesIsImported stamp: 'LK 11/27/2023 13:29:13'!
FAILURE!
!SupplierImporter methodsFor: 'as yet unclassified' stamp: 'LK 11/27/2023 13:31:11' prior: 50772016 overrides: 50772260!
importRecord

	self assertRecordNotEmpty.
	
	(self isSupplierRecord) ifTrue: [self importSupplier].
	
	(self isNewCustomerRecord) ifTrue: ["self importCustomer"].
	
	(self isExistingCustomerRecord) ifTrue: ["self addCustomerToSupplier"].
	
	(self isAddressRecord) ifTrue: [self importAddress].
	! !

!testRun: #ImportTest #test02supplierWithAddressesIsImported stamp: 'LK 11/27/2023 13:31:18'!
FAILURE!
!ImportTest methodsFor: 'tests~supplier' stamp: 'LK 11/27/2023 13:31:26' prior: 50772330!
test02supplierWithAddressesIsImported

	" hacer tests, pasar todo de transient a persistent"
	| stream supplier text addy|
	
	text := 'S,Supplier1,D,123
	A,San Martin,3322,Olivos,1636,BsAs		
A,Maipu,888,Florida,1122,Buenos Aires'.
	
	stream := ReadStream on: text.
	SupplierImporter valueFrom: stream into: system.
	supplier := system supplierWithIdentificationType: 'D' number: '123'.
	
	self assert: supplier numberOfAddresses equals: 2.
	
	addy := (supplier addresses) anyOne.
	self assert: addy streetName equals: 'San Martin'.
	! !

!testRun: #ImportTest #test02supplierWithAddressesIsImported stamp: 'LK 11/27/2023 13:31:27'!
FAILURE!

a SupplierImporter!

a Supplier!

supplier!
!SupplierImporter methodsFor: 'as yet unclassified' stamp: 'LK 11/27/2023 13:33:43' prior: 50772354 overrides: 50772260!
importRecord

	self assertRecordNotEmpty.
	
	(self isSupplierRecord) ifTrue: [self importSupplier].
	
	(self isAddressRecord) ifTrue: [self importAddress].
	
	(self isNewCustomerRecord) ifTrue: ["self importCustomer"].
	
	(self isExistingCustomerRecord) ifTrue: ["self addCustomerToSupplier"].
	
	
	! !

!testRun: #ImportTest #test02supplierWithAddressesIsImported stamp: 'LK 11/27/2023 13:33:53'!
FAILURE!

!testRun: #ImportTest #test02supplierWithAddressesIsImported stamp: 'LK 11/27/2023 13:33:53'!
FAILURE!
!ImportTest methodsFor: 'tests~supplier' stamp: 'LK 11/27/2023 13:34:02' prior: 50772370!
test02supplierWithAddressesIsImported

	" hacer tests, pasar todo de transient a persistent"
	| stream supplier text addy|
	
	text := 'S,Supplier1,D,123
A,San Martin,3322,Olivos,1636,BsAs		
A,Maipu,888,Florida,1122,Buenos Aires'.
	
	stream := ReadStream on: text.
	SupplierImporter valueFrom: stream into: system.
	supplier := system supplierWithIdentificationType: 'D' number: '123'.
	
	self assert: supplier numberOfAddresses equals: 2.
	
	addy := (supplier addresses) anyOne.
	self assert: addy streetName equals: 'San Martin'.
	! !

!testRun: #ImportTest #test02supplierWithAddressesIsImported stamp: 'LK 11/27/2023 13:34:03'!
FAILURE!
!ImportTest methodsFor: 'tests~supplier' stamp: 'LK 11/27/2023 13:34:10' prior: 50772415!
test02supplierWithAddressesIsImported

	" hacer tests, pasar todo de transient a persistent"
	| stream supplier text |
	
	text := 'S,Supplier1,D,123
A,San Martin,3322,Olivos,1636,BsAs		
A,Maipu,888,Florida,1122,Buenos Aires'.
	
	stream := ReadStream on: text.
	SupplierImporter valueFrom: stream into: system.
	supplier := system supplierWithIdentificationType: 'D' number: '123'.
	
	self assert: supplier numberOfAddresses equals: 2.
	
	! !

!testRun: #ImportTest #test02supplierWithAddressesIsImported stamp: 'LK 11/27/2023 13:34:13'!
PASSED!

!testRun: #ImportTest #test01ValidDataIsImportedCorrectly stamp: 'LK 11/27/2023 13:34:13'!
PASSED!

!testRun: #ImportTest #test01emptySupplierIsImportedCorrectly stamp: 'LK 11/27/2023 13:34:13'!
PASSED!

!testRun: #ImportTest #test02CanNotImportAddressWithoutCustomer stamp: 'LK 11/27/2023 13:34:13'!
PASSED!

!testRun: #ImportTest #test02supplierWithAddressesIsImported stamp: 'LK 11/27/2023 13:34:13'!
PASSED!

!testRun: #ImportTest #test02supplierWithNewCustomerIsImported stamp: 'LK 11/27/2023 13:34:13'!
FAILURE!

!testRun: #ImportTest #test03DoesNotImportRecordsStartingWithCButMoreCharacters stamp: 'LK 11/27/2023 13:34:13'!
PASSED!

!testRun: #ImportTest #test04DoesNotImportRecordsStartingWithAButMoreCharacters stamp: 'LK 11/27/2023 13:34:13'!
PASSED!

!testRun: #ImportTest #test05CanNotImportAddressRecordWithLessThanSixFields stamp: 'LK 11/27/2023 13:34:13'!
PASSED!

!testRun: #ImportTest #test06CanNotImportAddressRecordWithMoreThanSixFields stamp: 'LK 11/27/2023 13:34:13'!
PASSED!

!testRun: #ImportTest #test07CanNotImportCustomerRecordWithLessThanFiveFields stamp: 'LK 11/27/2023 13:34:13'!
PASSED!

!testRun: #ImportTest #test08CanNotImportCustomerRecordWithMoreThanFiveFields stamp: 'LK 11/27/2023 13:34:13'!
PASSED!

!testRun: #ImportTest #test09CannotImportEmptyLine stamp: 'LK 11/27/2023 13:34:13'!
PASSED!

!testRun: #ImportTest #test02supplierWithNewCustomerIsImported stamp: 'LK 11/27/2023 13:34:13'!
FAILURE!

!testRun: #ImportTest #test02supplierWithAddressesIsImported stamp: 'LK 11/27/2023 13:34:19'!
PASSED!

!testRun: #ImportTest #test01ValidDataIsImportedCorrectly stamp: 'LK 11/27/2023 13:34:19'!
PASSED!

!testRun: #ImportTest #test01emptySupplierIsImportedCorrectly stamp: 'LK 11/27/2023 13:34:19'!
PASSED!

!testRun: #ImportTest #test02CanNotImportAddressWithoutCustomer stamp: 'LK 11/27/2023 13:34:19'!
PASSED!

!testRun: #ImportTest #test02supplierWithAddressesIsImported stamp: 'LK 11/27/2023 13:34:19'!
PASSED!

!testRun: #ImportTest #test02supplierWithNewCustomerIsImported stamp: 'LK 11/27/2023 13:34:19'!
FAILURE!

!testRun: #ImportTest #test03DoesNotImportRecordsStartingWithCButMoreCharacters stamp: 'LK 11/27/2023 13:34:19'!
PASSED!

!testRun: #ImportTest #test04DoesNotImportRecordsStartingWithAButMoreCharacters stamp: 'LK 11/27/2023 13:34:20'!
PASSED!

!testRun: #ImportTest #test05CanNotImportAddressRecordWithLessThanSixFields stamp: 'LK 11/27/2023 13:34:20'!
PASSED!

!testRun: #ImportTest #test06CanNotImportAddressRecordWithMoreThanSixFields stamp: 'LK 11/27/2023 13:34:20'!
PASSED!

!testRun: #ImportTest #test07CanNotImportCustomerRecordWithLessThanFiveFields stamp: 'LK 11/27/2023 13:34:20'!
PASSED!

!testRun: #ImportTest #test08CanNotImportCustomerRecordWithMoreThanFiveFields stamp: 'LK 11/27/2023 13:34:20'!
PASSED!

!testRun: #ImportTest #test09CannotImportEmptyLine stamp: 'LK 11/27/2023 13:34:20'!
PASSED!

!testRun: #ImportTest #test02supplierWithNewCustomerIsImported stamp: 'LK 11/27/2023 13:34:20'!
FAILURE!

!testRun: #ImportTest #test02supplierWithAddressesIsImported stamp: 'LK 11/27/2023 13:34:23'!
PASSED!
!ImportTest methodsFor: 'tests~supplier' stamp: 'LK 11/27/2023 13:34:32' prior: 50771870!
test02supplierWithNewCustomerIsImported

	" hacer tests, pasar todo de transient a persistent"
	| stream supplier text|
	
	text := 'S,Supplier1,D,123
NC,Pepe,Sanchez,D,22333444'.
	
	stream := ReadStream on: text.
	SupplierImporter valueFrom: stream into: system.
	supplier := system supplierWithIdentificationType: 'D' number: '123'.
	
	self assert: supplier isAddressesEmpty.
	self assert: supplier numberOfCustomers equals: 1.
	self assertCustomerWithIdentificationType: 'D' number: '22333444' hasFirstName: 'Pepe' lastName: 'Sanchez'.! !

!testRun: #ImportTest #test02supplierWithNewCustomerIsImported stamp: 'LK 11/27/2023 13:34:33'!
FAILURE!
!ImportTest methodsFor: 'tests~supplier' stamp: 'LK 11/27/2023 13:36:45' prior: 50772438!
test02supplierWithAddressesIsImported

	" hacer tests, pasar todo de transient a persistent"
	| stream supplier text |
	
	text := 'S,Supplier1,D,123
A,San Martin,3322,Olivos,1636,BsAs		
A,Maipu,888,Florida,1122,Buenos Aires'.
	
	stream := ReadStream on: text.
	SupplierImporter valueFrom: stream into: system.
	supplier := system supplierWithIdentificationType: 'D' number: '123'.
	
	self assert: supplier numberOfAddresses equals: 2.
	self assertAddressOf: supplier at: 'San Martin' hasNumber: 3322 town: 'Olivos' zipCode: 1636 province: 'BsAs'.
	self assertAddressOf: supplier at: 'Maipu' hasNumber: 888 town: 'Florida' zipCode: 1122 province: 'Buenos Aires'.
	
	! !

!testRun: #ImportTest #test02supplierWithAddressesIsImported stamp: 'LK 11/27/2023 13:36:45'!
FAILURE!
!ImportTest methodsFor: 'tests~supplier' stamp: 'LK 11/27/2023 13:36:55' prior: 50772579!
test02supplierWithAddressesIsImported

	" hacer tests, pasar todo de transient a persistent"
	| stream supplier text |
	
	text := 'S,Supplier1,D,123
A,San Martin,3322,Olivos,1636,BsAs	
A,Maipu,888,Florida,1122,Buenos Aires'.
	
	stream := ReadStream on: text.
	SupplierImporter valueFrom: stream into: system.
	supplier := system supplierWithIdentificationType: 'D' number: '123'.
	
	self assert: supplier numberOfAddresses equals: 2.
	self assertAddressOf: supplier at: 'San Martin' hasNumber: 3322 town: 'Olivos' zipCode: 1636 province: 'BsAs'.
	self assertAddressOf: supplier at: 'Maipu' hasNumber: 888 town: 'Florida' zipCode: 1122 province: 'Buenos Aires'.
	
	! !

!testRun: #ImportTest #test02supplierWithAddressesIsImported stamp: 'LK 11/27/2023 13:36:56'!
FAILURE!
!ImportTest methodsFor: 'tests~supplier' stamp: 'LK 11/27/2023 13:37:04' prior: 50772606!
test02supplierWithAddressesIsImported

	" hacer tests, pasar todo de transient a persistent"
	| stream supplier text |
	
	text := 'S,Supplier1,D,123
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires'.
	
	stream := ReadStream on: text.
	SupplierImporter valueFrom: stream into: system.
	supplier := system supplierWithIdentificationType: 'D' number: '123'.
	
	self assert: supplier numberOfAddresses equals: 2.
	self assertAddressOf: supplier at: 'San Martin' hasNumber: 3322 town: 'Olivos' zipCode: 1636 province: 'BsAs'.
	self assertAddressOf: supplier at: 'Maipu' hasNumber: 888 town: 'Florida' zipCode: 1122 province: 'Buenos Aires'.
	
	! !

!testRun: #ImportTest #test02supplierWithAddressesIsImported stamp: 'LK 11/27/2023 13:37:05'!
PASSED!

!testRun: #ImportTest #test01ValidDataIsImportedCorrectly stamp: 'LK 11/27/2023 13:37:05'!
PASSED!

!testRun: #ImportTest #test01emptySupplierIsImportedCorrectly stamp: 'LK 11/27/2023 13:37:05'!
PASSED!

!testRun: #ImportTest #test02CanNotImportAddressWithoutCustomer stamp: 'LK 11/27/2023 13:37:05'!
PASSED!

!testRun: #ImportTest #test02supplierWithAddressesIsImported stamp: 'LK 11/27/2023 13:37:05'!
PASSED!

!testRun: #ImportTest #test02supplierWithNewCustomerIsImported stamp: 'LK 11/27/2023 13:37:05'!
FAILURE!

!testRun: #ImportTest #test03DoesNotImportRecordsStartingWithCButMoreCharacters stamp: 'LK 11/27/2023 13:37:05'!
PASSED!

!testRun: #ImportTest #test04DoesNotImportRecordsStartingWithAButMoreCharacters stamp: 'LK 11/27/2023 13:37:05'!
PASSED!

!testRun: #ImportTest #test05CanNotImportAddressRecordWithLessThanSixFields stamp: 'LK 11/27/2023 13:37:05'!
PASSED!

!testRun: #ImportTest #test06CanNotImportAddressRecordWithMoreThanSixFields stamp: 'LK 11/27/2023 13:37:05'!
PASSED!

!testRun: #ImportTest #test07CanNotImportCustomerRecordWithLessThanFiveFields stamp: 'LK 11/27/2023 13:37:05'!
PASSED!

!testRun: #ImportTest #test08CanNotImportCustomerRecordWithMoreThanFiveFields stamp: 'LK 11/27/2023 13:37:05'!
PASSED!

!testRun: #ImportTest #test09CannotImportEmptyLine stamp: 'LK 11/27/2023 13:37:05'!
PASSED!

!testRun: #ImportTest #test02supplierWithNewCustomerIsImported stamp: 'LK 11/27/2023 13:37:05'!
FAILURE!

!testRun: #ImportTest #test02supplierWithAddressesIsImported stamp: 'LK 11/27/2023 13:37:08'!
PASSED!
!SupplierImporter methodsFor: 'as yet unclassified' stamp: 'LK 11/27/2023 13:42:23'!
importNewCustomer! !
!SupplierImporter methodsFor: 'as yet unclassified' stamp: 'LK 11/27/2023 13:42:31' prior: 50772396 overrides: 50772260!
importRecord

	self assertRecordNotEmpty.
	
	(self isSupplierRecord) ifTrue: [self importSupplier].
	
	(self isAddressRecord) ifTrue: [self importAddress].
	
	(self isNewCustomerRecord) ifTrue: ["self importNewCustomer"].
	
	(self isExistingCustomerRecord) ifTrue: ["self addCustomerToSupplier"].
	
	
	! !
!Supplier methodsFor: 'as yet unclassified' stamp: 'LK 11/27/2023 13:43:43'!
addCustomer: aCustomer

	 customers add: aCustomer.! !
!SupplierImporter methodsFor: 'as yet unclassified' stamp: 'LK 11/27/2023 13:44:18' prior: 50772708!
importNewCustomer

	self assertValidCustomer.
	self addNewCustomerToSystem.
	
	! !
!SupplierImporter methodsFor: 'as yet unclassified' stamp: 'LK 11/27/2023 13:45:48' prior: 50772730!
importNewCustomer

	|newCustomer|
	
	self assertValidCustomer: newCustomer.
	self assertXXWasImported.
	
	
	self addNewCustomerToSystem.
	newXX addCustomer: newCustomer.
	
	! !
!SupplierImporter methodsFor: 'as yet unclassified' stamp: 'LK 11/27/2023 13:46:22' prior: 50772736!
importNewCustomer

	|newCustomer|
	
	self assertValidCustomer.
	self assertXXWasImported.
	
	
	self addNewCustomerToSystem.
	newXX addCustomer: newCustomer.
	
	! !
!SupplierImporter methodsFor: 'as yet unclassified' stamp: 'LK 11/27/2023 13:46:48' prior: 50772745!
importNewCustomer

	|newCustomer|
	
	self assertValidCustomer.
	self assertXXWasImported.
	
	newCustomer := Customer for: record second lastName: record third andIdType: record fourth andNumber: record fifth.
	
	
	self addNewCustomerToSystem.
	newXX addCustomer: newCustomer.
	
	! !
!XXImporter class methodsFor: 'error messages' stamp: 'LK 11/27/2023 13:48:01'!
invalidAddressRecordErrorDescription

	^'Address record has to have six fields'! !

!methodRemoval: CustomerImporter class #invalidAddressRecordErrorDescription stamp: 'LK 11/27/2023 13:48:01'!
invalidAddressRecordErrorDescription

	^'Address record has to have six fields'!
!XXImporter class methodsFor: 'error messages' stamp: 'LK 11/27/2023 13:48:05'!
invalidRecordTypeErrorDescription

	^'Invalid record type'! !

!methodRemoval: CustomerImporter class #invalidRecordTypeErrorDescription stamp: 'LK 11/27/2023 13:48:05'!
invalidRecordTypeErrorDescription

	^'Invalid record type'!
!SupplierImporter methodsFor: 'as yet unclassified' stamp: 'LK 11/27/2023 13:48:24' prior: 50772713 overrides: 50772260!
importRecord

	self assertRecordNotEmpty.
	
	(self isSupplierRecord) ifTrue: [self importSupplier].
	
	(self isAddressRecord) ifTrue: [self importAddress].
	
	(self isNewCustomerRecord) ifTrue: ["self importNewCustomer"].
	
	(self isExistingCustomerRecord) ifTrue: ["self addCustomerToSupplier"].
	
	self error: self class invalidRecordTypeErrorDescription
	
	
	! !
!SupplierImporter methodsFor: 'as yet unclassified' stamp: 'LK 11/27/2023 13:48:31' prior: 50772789 overrides: 50772260!
importRecord

	self assertRecordNotEmpty.
	
	(self isSupplierRecord) ifTrue: [self importSupplier].
	
	(self isAddressRecord) ifTrue: [self importAddress].
	
	(self isNewCustomerRecord) ifTrue: [self importNewCustomer].
	
	(self isExistingCustomerRecord) ifTrue: ["self addCustomerToSupplier"].
	
	self error: self class invalidRecordTypeErrorDescription
	
	
	! !
!SupplierImporter methodsFor: 'as yet unclassified' stamp: 'LK 11/27/2023 13:49:10'!
assertValidNewCustomerRecord

	^ record size ~= 5 ifTrue: [ self error: self class invalidCustomerRecordErrorDescription ]! !
!SupplierImporter methodsFor: 'as yet unclassified' stamp: 'LK 11/27/2023 13:50:31' prior: 50772754!
importNewCustomer

	|newCustomer|
	
	"self assertValidCustomer."
	self assertXXWasImported.
	
	newCustomer := Customer for: record second lastName: record third andIdType: record fourth andNumber: record fifth.
	
	
	self addNewCustomerToSystem.
	newXX addCustomer: newCustomer.
	
	! !
!SupplierImporter methodsFor: 'as yet unclassified' stamp: 'LK 11/27/2023 13:50:39'!
addNewCustomerToSystem! !
!SupplierImporter methodsFor: 'as yet unclassified' stamp: 'LK 11/27/2023 13:51:16'!
addNewCustomerToSystem: aCustomer

	system add: aCustomer! !

!methodRemoval: SupplierImporter #addNewCustomerToSystem stamp: 'LK 11/27/2023 13:51:18'!
addNewCustomerToSystem!
!SupplierImporter methodsFor: 'as yet unclassified' stamp: 'LK 11/27/2023 13:51:27' prior: 50772828!
importNewCustomer

	|newCustomer|
	
	"self assertValidCustomer."
	self assertXXWasImported.
	
	newCustomer := Customer for: record second lastName: record third andIdType: record fourth andNumber: record fifth.
	
	
	self addNewCustomerToSystem: newCustomer.
	newXX addCustomer: newCustomer.
	
	! !
!ImportTest methodsFor: 'tests~supplier' stamp: 'LK 11/27/2023 14:00:19'!
test03supplierWithNewCustomerIsImported

	" hacer tests, pasar todo de transient a persistent"
	| stream supplier text|
	
	text := 'S,Supplier1,D,123
NC,Pepe,Sanchez,D,22333444'.
	
	stream := ReadStream on: text.
	SupplierImporter valueFrom: stream into: system.
	supplier := system supplierWithIdentificationType: 'D' number: '123'.
	
	self assert: supplier isAddressesEmpty.
	self assert: supplier numberOfCustomers equals: 1.
	self assertCustomerWithIdentificationType: 'D' number: '22333444' hasFirstName: 'Pepe' lastName: 'Sanchez'.! !

!methodRemoval: ImportTest #test02supplierWithNewCustomerIsImported stamp: 'LK 11/27/2023 14:00:20'!
test02supplierWithNewCustomerIsImported

	" hacer tests, pasar todo de transient a persistent"
	| stream supplier text|
	
	text := 'S,Supplier1,D,123
NC,Pepe,Sanchez,D,22333444'.
	
	stream := ReadStream on: text.
	SupplierImporter valueFrom: stream into: system.
	supplier := system supplierWithIdentificationType: 'D' number: '123'.
	
	self assert: supplier isAddressesEmpty.
	self assert: supplier numberOfCustomers equals: 1.
	self assertCustomerWithIdentificationType: 'D' number: '22333444' hasFirstName: 'Pepe' lastName: 'Sanchez'.!

!testRun: #ImportTest #test03supplierWithNewCustomerIsImported stamp: 'LK 11/27/2023 14:00:31'!
ERROR!

!testRun: #ImportTest #test03supplierWithNewCustomerIsImported stamp: 'LK 11/27/2023 14:00:31'!
ERROR!
!SupplierImporter methodsFor: 'as yet unclassified' stamp: 'LK 11/27/2023 14:00:51' prior: 50772805 overrides: 50772260!
importRecord

	self assertRecordNotEmpty.
	
	(self isSupplierRecord) ifTrue: [^self importSupplier].
	
	(self isAddressRecord) ifTrue: [^self importAddress].
	
	(self isNewCustomerRecord) ifTrue: [^self importNewCustomer].
	
	(self isExistingCustomerRecord) ifTrue: ["self addCustomerToSupplier"].
	
	self error: self class invalidRecordTypeErrorDescription
	
	
	! !

!testRun: #ImportTest #test03supplierWithNewCustomerIsImported stamp: 'LK 11/27/2023 14:00:55'!
PASSED!
!ImportTest methodsFor: 'tests~supplier' stamp: 'LK 11/27/2023 14:01:04' prior: 50772865!
test03supplierWithNewCustomerIsImported

	| stream supplier text|
	
	text := 'S,Supplier1,D,123
NC,Pepe,Sanchez,D,22333444'.
	
	stream := ReadStream on: text.
	SupplierImporter valueFrom: stream into: system.
	supplier := system supplierWithIdentificationType: 'D' number: '123'.
	
	self assert: supplier isAddressesEmpty.
	self assert: supplier numberOfCustomers equals: 1.
	self assertCustomerWithIdentificationType: 'D' number: '22333444' hasFirstName: 'Pepe' lastName: 'Sanchez'.! !
!ImportTest methodsFor: 'tests~supplier' stamp: 'LK 11/27/2023 14:01:14'!
test04upplierWithExistingCustomerIsImported

	| stream supplier text|
	
	text := 'S,Supplier1,D,123
NC,Pepe,Sanchez,D,22333444'.
	
	stream := ReadStream on: text.
	SupplierImporter valueFrom: stream into: system.
	supplier := system supplierWithIdentificationType: 'D' number: '123'.
	
	self assert: supplier isAddressesEmpty.
	self assert: supplier numberOfCustomers equals: 1.
	self assertCustomerWithIdentificationType: 'D' number: '22333444' hasFirstName: 'Pepe' lastName: 'Sanchez'.! !
!ImportTest methodsFor: 'tests~supplier' stamp: 'LK 11/27/2023 14:01:54' prior: 50772949!
test04upplierWithExistingCustomerIsImported

	| stream supplier text|
	
	text := 'S,Supplier1,D,123
EC,D,5456774'.
	
	stream := ReadStream on: text.
	SupplierImporter valueFrom: stream into: system.
	supplier := system supplierWithIdentificationType: 'D' number: '123'.
	
	self assert: supplier isAddressesEmpty.
	self assert: supplier numberOfCustomers equals: 1.
	self assertCustomerWithIdentificationType: 'D' number: '22333444' hasFirstName: 'Pepe' lastName: 'Sanchez'.! !
!ImportTest methodsFor: 'tests~supplier' stamp: 'LK 11/27/2023 14:02:31' prior: 50772968!
test04upplierWithExistingCustomerIsImported

	| stream supplier text|
	
	text := 'S,Supplier1,D,123
EC,D,5456774'.
	
	stream := ReadStream on: text.
	SupplierImporter valueFrom: stream into: system.
	supplier := system supplierWithIdentificationType: 'D' number: '123'.
	
	self assert: supplier isAddressesEmpty.
	self assert: supplier numberOfCustomers equals: 1.
	self assertCustomerWithIdentificationType: 'D' number: '5456774' hasFirstName: 'Pepe' lastName: 'Sanchez'.! !

!testRun: #ImportTest #test04upplierWithExistingCustomerIsImported stamp: 'LK 11/27/2023 14:02:35'!
ERROR!
!SupplierImporter methodsFor: 'as yet unclassified' stamp: 'LK 11/27/2023 14:02:56' prior: 50772913 overrides: 50772260!
importRecord

	self assertRecordNotEmpty.
	
	(self isSupplierRecord) ifTrue: [^self importSupplier].
	
	(self isAddressRecord) ifTrue: [^self importAddress].
	
	(self isNewCustomerRecord) ifTrue: [^self importNewCustomer].
	
	(self isExistingCustomerRecord) ifTrue: [^self addExistingCustomerToSupplier].
	
	self error: self class invalidRecordTypeErrorDescription
	
	
	! !
!SupplierImporter methodsFor: 'as yet unclassified' stamp: 'LK 11/27/2023 14:03:01'!
addExistingCustomerToSupplier! !

!testRun: #ImportTest #test04upplierWithExistingCustomerIsImported stamp: 'LK 11/27/2023 14:03:06'!
FAILURE!

!testRun: #ImportTest #test04upplierWithExistingCustomerIsImported stamp: 'LK 11/27/2023 14:03:06'!
FAILURE!
!ImportTest methodsFor: 'tests~supplier' stamp: 'LK 11/27/2023 14:03:14'!
test04supplierWithExistingCustomerIsImported

	| stream supplier text|
	
	text := 'S,Supplier1,D,123
EC,D,5456774'.
	
	stream := ReadStream on: text.
	SupplierImporter valueFrom: stream into: system.
	supplier := system supplierWithIdentificationType: 'D' number: '123'.
	
	self assert: supplier isAddressesEmpty.
	self assert: supplier numberOfCustomers equals: 1.
	self assertCustomerWithIdentificationType: 'D' number: '5456774' hasFirstName: 'Pepe' lastName: 'Sanchez'.! !

!methodRemoval: ImportTest #test04upplierWithExistingCustomerIsImported stamp: 'LK 11/27/2023 14:03:14'!
test04upplierWithExistingCustomerIsImported

	| stream supplier text|
	
	text := 'S,Supplier1,D,123
EC,D,5456774'.
	
	stream := ReadStream on: text.
	SupplierImporter valueFrom: stream into: system.
	supplier := system supplierWithIdentificationType: 'D' number: '123'.
	
	self assert: supplier isAddressesEmpty.
	self assert: supplier numberOfCustomers equals: 1.
	self assertCustomerWithIdentificationType: 'D' number: '5456774' hasFirstName: 'Pepe' lastName: 'Sanchez'.!
!PersistentErpSystem methodsFor: 'customers' stamp: 'LK 11/27/2023 14:05:42' prior: 50771619 overrides: 50771624!
addSupplier: aSupplier

	! !
!SupplierImporter methodsFor: 'as yet unclassified' stamp: 'LK 11/27/2023 14:10:22' prior: 50771914!
importSupplier

	self assertValidSupplierRecord.
	newXX := Supplier named: record second identificationType: record third number: record fourth.
	
	system addSupplier: newXX.! !
!SupplierImporter methodsFor: 'as yet unclassified' stamp: 'LK 11/27/2023 14:10:29'!
assertValidSupplierRecord! !
!SupplierImporter methodsFor: 'as yet unclassified' stamp: 'LK 11/27/2023 14:10:48' prior: 50773086!
assertValidSupplierRecord

	^ record size ~= 4 ifTrue: [ self error: self class invalidSupplierRecordErrorDescription ]! !
!SupplierImporter class methodsFor: 'no messages' stamp: 'LK 11/27/2023 14:10:54'!
invalidSupplierRecordErrorDescription! !
!SupplierImporter methodsFor: 'as yet unclassified' stamp: 'LK 11/27/2023 14:12:16' prior: 50773024!
addExistingCustomerToSupplier

! !
!SupplierImporter methodsFor: 'as yet unclassified' stamp: 'LK 11/27/2023 14:13:17' prior: 50773103!
addExistingCustomerToSupplier

	|existingCustomer|
	
	existingCustomer := system customerWithIdentificationType: record second number: record third.

! !
!SupplierImporter methodsFor: 'as yet unclassified' stamp: 'LK 11/27/2023 14:14:12' prior: 50773108!
addExistingCustomerToSupplier

	|existingCustomer|
	
	existingCustomer := system customerWithIdentificationType: record second number: record third.
	
	newXX addCustomer: existingCustomer.

! !
!TransientErpSystem methodsFor: 'customers' stamp: 'LK 11/27/2023 14:17:18' prior: 50769744 overrides: 50769624!
customerWithIdentificationType: anIdType number: anIdNumber

	^customers detect: [ :aCustomer | aCustomer identificationType = anIdType and: [ aCustomer identificationNumber = anIdNumber ]] ifNone: [].! !
!SupplierImporter methodsFor: 'as yet unclassified' stamp: 'LK 11/27/2023 14:19:18' prior: 50773116!
addExistingCustomerToSupplier

	|existingCustomer|
	
	existingCustomer := system customerWithIdentificationType: record second number: record third.
		
	newXX addCustomer: existingCustomer.

! !
!SupplierImporter methodsFor: 'as yet unclassified' stamp: 'LK 11/27/2023 14:19:25' prior: 50773136!
addExistingCustomerToSupplier

	|existingCustomer|
	
	existingCustomer := system customerWithIdentificationType: record second number: record third.
	
		
	newXX addCustomer: existingCustomer.

! !
!SupplierImporter methodsFor: 'as yet unclassified' stamp: 'LK 11/27/2023 14:20:13' prior: 50773146!
addExistingCustomerToSupplier

	|existingCustomer|
	
	existingCustomer := system customerWithIdentificationType: record second number: record third.
	
	(existingCustomer isEmpty) ifEmpty: [self error: self nonExistingCustomerInSystem].
	newXX addCustomer: existingCustomer.

! !
!SupplierImporter methodsFor: 'as yet unclassified' stamp: 'LK 11/27/2023 14:20:17'!
nonExistingCustomerInSystem! !
!SupplierImporter methodsFor: 'as yet unclassified' stamp: 'LK 11/27/2023 14:20:26'!
nonExistingCustomerInSystemErrorDescription! !
!SupplierImporter methodsFor: 'as yet unclassified' stamp: 'LK 11/27/2023 14:20:26' prior: 50773156!
addExistingCustomerToSupplier

	|existingCustomer|
	
	existingCustomer := system customerWithIdentificationType: record second number: record third.
	
	(existingCustomer isEmpty) ifEmpty: [self error: self nonExistingCustomerInSystemErrorDescription].
	newXX addCustomer: existingCustomer.

! !

!methodRemoval: SupplierImporter #nonExistingCustomerInSystem stamp: 'LK 11/27/2023 14:20:26'!
nonExistingCustomerInSystem!
!SupplierImporter methodsFor: 'as yet unclassified' stamp: 'LK 11/27/2023 14:20:48' prior: 50773172!
nonExistingCustomerInSystemErrorDescription

	^'No esta aca'! !
!ImportTest methodsFor: 'tests~supplier' stamp: 'LK 11/27/2023 14:23:00' prior: 50773035!
test04supplierWithExistingCustomerIsImported

	| stream supplier text|
	
	text := 'S,Supplier1,D,123
EC,D,5456774'.
	
	stream := ReadStream on: text.
	SupplierImporter valueFrom: stream into: system.
	! !
!ImportTest methodsFor: 'tests~supplier' stamp: 'LK 11/27/2023 14:23:07' prior: 50773199!
test04supplierWithExistingCustomerIsImported

	| stream text|
	
	text := 'S,Supplier1,D,123
EC,D,5456774'.
	
	stream := ReadStream on: text.
	SupplierImporter valueFrom: stream into: system.
	! !
!ImportTest methodsFor: 'tests~supplier' stamp: 'LK 11/27/2023 14:25:11' prior: 50773209!
test04supplierWithExistingCustomerIsImported

	| stream text|
	
	text := 'S,Supplier1,D,123
EC,D,5456774'.
	
	stream := ReadStream on: text.
	
"	self
		should: [ SupplierImporter valueFrom: stream into: system. ]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
			self assert: anErrorMessageText equals: anError messageText.]

	
	"! !
!SupplierImporter methodsFor: 'as yet unclassified' stamp: 'LK 11/27/2023 14:25:47' prior: 50773177!
addExistingCustomerToSupplier

	|existingCustomer|
	
	existingCustomer := system customerWithIdentificationType: record second number: record third.
	
	(existingCustomer isEmpty) ifEmpty: [self error: SupplierImporter nonExistingCustomerInSystemErrorDescription].
	newXX addCustomer: existingCustomer.

! !

!methodRemoval: SupplierImporter #nonExistingCustomerInSystemErrorDescription stamp: 'LK 11/27/2023 14:25:57'!
nonExistingCustomerInSystemErrorDescription

	^'No esta aca'!
!SupplierImporter class methodsFor: 'as yet unclassified' stamp: 'LK 11/27/2023 14:26:00'!
nonExistingCustomerInSystemErrorDescription

	^'No esta aca'! !
!ImportTest methodsFor: 'tests~supplier' stamp: 'LK 11/27/2023 14:26:19' prior: 50773218!
test04supplierWithExistingCustomerIsImported

	| stream text|
	
	text := 'S,Supplier1,D,123
EC,D,5456774'.
	
	stream := ReadStream on: text.
	
	self
		should: [ SupplierImporter valueFrom: stream into: system. ]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [ :anError |
			self assert: SupplierImporter nonExistingCustomerInSystemErrorDescription equals: anError messageText.]

	
	! !

!testRun: #ImportTest #test04supplierWithExistingCustomerIsImported stamp: 'LK 11/27/2023 14:26:19'!
ERROR!

!testRun: #ImportTest #test04supplierWithExistingCustomerIsImported stamp: 'LK 11/27/2023 14:26:24'!
ERROR!
!TransientErpSystem methodsFor: 'customers' stamp: 'LK 11/27/2023 14:26:51' prior: 50773126 overrides: 50769624!
customerWithIdentificationType: anIdType number: anIdNumber

	^customers detect: [ :aCustomer | aCustomer identificationType = anIdType and: [ aCustomer identificationNumber = anIdNumber ]] ifNone: [0].! !
!SupplierImporter methodsFor: 'as yet unclassified' stamp: 'LK 11/27/2023 14:27:13' prior: 50773233!
addExistingCustomerToSupplier

	|existingCustomer|
	
	existingCustomer := system customerWithIdentificationType: record second number: record third.
	
	(existingCustomer = 0) ifEmpty: [self error: SupplierImporter nonExistingCustomerInSystemErrorDescription].
	newXX addCustomer: existingCustomer.

! !

!testRun: #ImportTest #test04supplierWithExistingCustomerIsImported stamp: 'LK 11/27/2023 14:27:19'!
ERROR!

!testRun: #ImportTest #test04supplierWithExistingCustomerIsImported stamp: 'LK 11/27/2023 14:27:19'!
ERROR!
!SupplierImporter methodsFor: 'as yet unclassified' stamp: 'LK 11/27/2023 14:27:40' prior: 50773289!
addExistingCustomerToSupplier

	|existingCustomer|
	
	existingCustomer := system customerWithIdentificationType: record second number: record third.
	
	(existingCustomer = 0) ifTrue: [self error: SupplierImporter nonExistingCustomerInSystemErrorDescription].
	newXX addCustomer: existingCustomer.

! !
!SupplierImporter methodsFor: 'as yet unclassified' stamp: 'LK 11/27/2023 14:28:05' prior: 50773309!
addExistingCustomerToSupplier

	|existingCustomer|
	
	existingCustomer := system customerWithIdentificationType: record second number: record third.
	
	(existingCustomer = 0) ifTrue: [self error: SupplierImporter nonExistingCustomerInSystemErrorDescription].
	newXX addCustomer: existingCustomer.

! !

!testRun: #ImportTest #test04supplierWithExistingCustomerIsImported stamp: 'LK 11/27/2023 14:28:09'!
PASSED!

!testRun: #ImportTest #test01emptySupplierIsImportedCorrectly stamp: 'LK 11/27/2023 14:28:10'!
PASSED!

!testRun: #ImportTest #test02supplierWithAddressesIsImported stamp: 'LK 11/27/2023 14:28:10'!
PASSED!

!testRun: #ImportTest #test03supplierWithNewCustomerIsImported stamp: 'LK 11/27/2023 14:28:10'!
PASSED!

!testRun: #ImportTest #test04supplierWithExistingCustomerIsImported stamp: 'LK 11/27/2023 14:28:10'!
PASSED!

----QUIT----(27 November 2023 14:30:50) CuisUniversity-5981.image priorSource: 14099838!