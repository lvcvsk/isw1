

----QUIT----(13 August 2023 19:14:09) CuisUniversity-5981.image priorSource: 5713367!

----STARTUP---- (13 August 2023 19:14:10) as /Users/hernan/Documents/Cuis/5.0-64Bits/Cuis-University-Installer/CuisUniversity-5981.image!


----QUIT----(13 August 2023 19:14:10) CuisUniversity-5981.image priorSource: 10197065!

----STARTUP---- (19 September 2023 00:44:39) as C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\CuisUniversity-5981.image!


----End fileIn of C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\ejs\Clase 2.st----!

!classRemoval: #Pepe stamp: 'LK 9/19/2023 00:46:12'!
DenotativeObject subclass: #Pepe
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 2'!

----End fileIn of C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\ejs\Clase 3.st----!

----End fileIn of C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\ejs\ISW1.st----!

----End fileIn of C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\repo\isw1\00-NumerosNaturales\Clase 3.st----!

!classRemoval: #IIIII stamp: 'LK 9/19/2023 00:47:54'!
II subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classRemoval: #IIII stamp: 'LK 9/19/2023 00:47:55'!
II subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classRemoval: #III stamp: 'LK 9/19/2023 00:47:55'!
II subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classRemoval: #II stamp: 'LK 9/19/2023 00:47:55'!
DenotativeObject subclass: #II
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classRemoval: #I stamp: 'LK 9/19/2023 00:47:55'!
DenotativeObject subclass: #I
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

----End fileIn of C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\ejs\Clase 3.st----!

----End fileIn of C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\repo\isw1\01-CodigoRepetido\CodigoRepetido-Ejercicio.st----!

----End fileIn of C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\repo\isw1\03-Stack\Stack-Exercise.st----!

----End fileIn of C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\ejs\02\Numero-Solution-4.st----!

----End fileIn of C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\ejs\02\Numero-Solution-3.st----!

!classRemoval: #Fraccion stamp: 'LK 9/19/2023 00:51:24'!
Numero subclass: #Fraccion
	instanceVariableNames: 'numerator denominator'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Solution-3'!

!classRemoval: #Uno stamp: 'LK 9/19/2023 00:51:25'!
Entero subclass: #Uno
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Solution-3'!

!classRemoval: #PositivoMayorAUno stamp: 'LK 9/19/2023 00:51:25'!
EnteroMenosCeroYUno subclass: #PositivoMayorAUno
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Solution-3'!

!classRemoval: #Negativo stamp: 'LK 9/19/2023 00:51:25'!
EnteroMenosCeroYUno subclass: #Negativo
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Solution-3'!

!classRemoval: #EnteroMenosCeroYUno stamp: 'LK 9/19/2023 00:51:25'!
Entero subclass: #EnteroMenosCeroYUno
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Solution-3'!

!classRemoval: #Cero stamp: 'LK 9/19/2023 00:51:26'!
Entero subclass: #Cero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Solution-3'!

!classRemoval: #Entero stamp: 'LK 9/19/2023 00:51:26'!
Numero subclass: #Entero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Solution-3'!

!classRemoval: #Numero stamp: 'LK 9/19/2023 00:51:26'!
Object subclass: #Numero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Solution-3'!

!classRemoval: #NumeroTest stamp: 'LK 9/19/2023 00:51:27'!
TestCase subclass: #NumeroTest
	instanceVariableNames: 'zero one two four oneFifth oneHalf five twoFifth twoTwentyfifth fiveHalfs three eight negativeOne negativeTwo'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Solution-3'!

----End fileIn of C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\ejs\02\Numero-Solution-3.st----!

----STARTUP---- (19 September 2023 00:55:13) as C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\CuisUniversity-5981.image!


!classDefinition: #Falso category: 'Clase 2' stamp: 'LK 9/19/2023 00:55:25'!
DenotativeObject subclass: #Falso
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 2'!

!classDefinition: #Falso category: 'Clase 2' stamp: 'LK 9/19/2023 00:55:25'!
DenotativeObject subclass: #Falso
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 2'!

!classDefinition: 'Falso class' category: 'Clase 2' stamp: 'LK 9/19/2023 00:55:25'!
Falso class
	instanceVariableNames: ''!

!classDefinition: 'Falso class' category: 'Clase 2' stamp: 'LK 9/19/2023 00:55:25'!
Falso class
	instanceVariableNames: ''!
!Falso class methodsFor: 'as yet unclassified' stamp: 'LK 8/17/2023 20:55:18'!
no
	^Verdadero! !
!Falso class methodsFor: 'as yet unclassified' stamp: 'LK 8/17/2023 21:15:02'!
o:unBooleano
	^unBooleano! !
!Falso class methodsFor: 'as yet unclassified' stamp: 'LK 8/17/2023 21:26:50'!
siEsFalso: aClosure
	^aClosure value! !
!Falso class methodsFor: 'as yet unclassified' stamp: 'LK 8/17/2023 21:53:55'!
siEsVerdadero: aClosure
	^self.! !
!Falso class methodsFor: 'as yet unclassified' stamp: 'LK 8/17/2023 20:59:43'!
y:unBooleano
	^Falso! !

!classDefinition: #Pepe category: 'Clase 2' stamp: 'LK 9/19/2023 00:55:25'!
DenotativeObject subclass: #Pepe
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 2'!

!classDefinition: #Pepe category: 'Clase 2' stamp: 'LK 9/19/2023 00:55:25'!
DenotativeObject subclass: #Pepe
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 2'!

!classDefinition: #Verdadero category: 'Clase 2' stamp: 'LK 9/19/2023 00:55:25'!
DenotativeObject subclass: #Verdadero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 2'!

!classDefinition: #Verdadero category: 'Clase 2' stamp: 'LK 9/19/2023 00:55:25'!
DenotativeObject subclass: #Verdadero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 2'!

!classDefinition: 'Verdadero class' category: 'Clase 2' stamp: 'LK 9/19/2023 00:55:25'!
Verdadero class
	instanceVariableNames: ''!

!classDefinition: 'Verdadero class' category: 'Clase 2' stamp: 'LK 9/19/2023 00:55:25'!
Verdadero class
	instanceVariableNames: ''!
!Verdadero class methodsFor: 'as yet unclassified' stamp: 'LK 8/17/2023 20:55:25'!
no
	^Falso! !
!Verdadero class methodsFor: 'as yet unclassified' stamp: 'LK 8/17/2023 21:04:31'!
o:unBooleano
	^Verdadero! !
!Verdadero class methodsFor: 'as yet unclassified' stamp: 'LK 8/17/2023 21:53:44'!
siEsFalso: aClosure
	^self.! !
!Verdadero class methodsFor: 'as yet unclassified' stamp: 'LK 8/17/2023 21:27:02'!
siEsVerdadero: aClosure
	^aClosure value! !
!Verdadero class methodsFor: 'as yet unclassified' stamp: 'LK 8/17/2023 21:14:30'!
y:unBooleano
	^unBooleano! !

!classDefinition: #VerdaderoFalsoTests category: 'Clase 2' stamp: 'LK 9/19/2023 00:55:26'!
DenotativeObject subclass: #VerdaderoFalsoTests
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 2'!

!classDefinition: #VerdaderoFalsoTests category: 'Clase 2' stamp: 'LK 9/19/2023 00:55:26'!
DenotativeObject subclass: #VerdaderoFalsoTests
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 2'!

!classDefinition: 'VerdaderoFalsoTests class' category: 'Clase 2' stamp: 'LK 9/19/2023 00:55:26'!
VerdaderoFalsoTests class
	instanceVariableNames: ''!

!classDefinition: 'VerdaderoFalsoTests class' category: 'Clase 2' stamp: 'LK 9/19/2023 00:55:26'!
VerdaderoFalsoTests class
	instanceVariableNames: ''!
!VerdaderoFalsoTests class methodsFor: 'as yet unclassified' stamp: 'LK 8/17/2023 20:48:44'!
test01NoVerdaderoEsFalso
	Assert that: Verdadero no isEqualTo: Falso ! !
!VerdaderoFalsoTests class methodsFor: 'as yet unclassified' stamp: 'LK 8/17/2023 20:54:06'!
test02NoFalsoEsVerdadero
	Assert that: Falso no isEqualTo: Verdadero ! !
!VerdaderoFalsoTests class methodsFor: 'as yet unclassified' stamp: 'LK 8/17/2023 21:17:52'!
test03FalsoYVerdaderoEsFalso
	Assert that: (Falso y:Verdadero) isEqualTo: Falso ! !
!VerdaderoFalsoTests class methodsFor: 'as yet unclassified' stamp: 'LK 8/17/2023 21:18:10'!
test04FalsoYFalsoEsFalso
	Assert that: (Falso y:Falso) isEqualTo: Falso ! !
!VerdaderoFalsoTests class methodsFor: 'as yet unclassified' stamp: 'LK 8/17/2023 21:18:39'!
test05VerdaderoYFalsoEsFalso
	Assert that: (Verdadero y:Falso) isEqualTo: Falso ! !
!VerdaderoFalsoTests class methodsFor: 'as yet unclassified' stamp: 'LK 8/17/2023 21:18:59'!
test06VerdaderoYVerdaderoEsVerdadero
	Assert that: (Verdadero y:Verdadero) isEqualTo: Verdadero ! !
!VerdaderoFalsoTests class methodsFor: 'as yet unclassified' stamp: 'LK 8/17/2023 21:19:27'!
test07VerdaderoOVerdaderoEsVerdadero
	Assert that: (Verdadero o:Verdadero) isEqualTo: Verdadero ! !
!VerdaderoFalsoTests class methodsFor: 'as yet unclassified' stamp: 'LK 8/17/2023 21:19:52'!
test08VerdaderoOFalsoEsVerdadero
	Assert that: (Verdadero o:Falso) isEqualTo: Verdadero ! !
!VerdaderoFalsoTests class methodsFor: 'as yet unclassified' stamp: 'LK 8/17/2023 21:20:25'!
test09FalsoOFalsoEsFalso
	Assert that: (Falso o:Falso) isEqualTo: Falso ! !
!VerdaderoFalsoTests class methodsFor: 'as yet unclassified' stamp: 'LK 8/17/2023 21:20:45'!
test09FalsoOVerdaderoEsVerdadero
	Assert that: (Falso o:Verdadero) isEqualTo: Verdadero! !
!VerdaderoFalsoTests class methodsFor: 'as yet unclassified' stamp: 'LK 8/17/2023 21:34:17'!
test10FalsoOVerdaderoEsVerdadero
	Assert that: (Falso o:Verdadero) isEqualTo: Verdadero! !
!VerdaderoFalsoTests class methodsFor: 'as yet unclassified' stamp: 'LK 8/17/2023 21:35:50'!
test11FalsoSiesFalso
	Assert that: (Falso siEsFalso:['hola']) isEqualTo: 'hola'! !
!VerdaderoFalsoTests class methodsFor: 'as yet unclassified' stamp: 'LK 8/17/2023 21:37:41'!
test12FalsoSiesVerdadero
	Assert that: (Falso siEsVerdadero:['hola']) isNotEqualTo: 'hola'! !
!VerdaderoFalsoTests class methodsFor: 'as yet unclassified' stamp: 'LK 8/17/2023 21:39:40'!
test13FalsoSiesVerdaderobis
	Assert that: [Falso siEsVerdadero:['hola'].^1] value isEqualTo: 1! !
!VerdaderoFalsoTests class methodsFor: 'as yet unclassified' stamp: 'LK 8/17/2023 21:43:48'!
test14VerdaderoSiEsVerdadero
	Assert that: (Verdadero siEsVerdadero:['hola']) isEqualTo: 'hola'! !
!VerdaderoFalsoTests class methodsFor: 'as yet unclassified' stamp: 'LK 8/17/2023 21:45:14'!
test15VerdaderoSiEsFalso
	Assert that: (Verdadero siEsFalso:['hola']) isNotEqualTo: 'hola'! !
!VerdaderoFalsoTests class methodsFor: 'as yet unclassified' stamp: 'LK 8/17/2023 21:56:36'!
test16VerdaderoSiEsFalso

	| aClosure n1 |
	n1 := 0.
	aClosure := [n1 := 5].
	
	Verdadero siEsVerdadero: aClosure .
	Assert that: n1 isEqualTo: 0! !

!classRemoval: #Pepe stamp: 'LK 9/19/2023 00:55:28'!
DenotativeObject subclass: #Pepe
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 2'!

!classDefinition: #I category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:28'!
DenotativeObject subclass: #I
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classDefinition: #I category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:28'!
DenotativeObject subclass: #I
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classDefinition: 'I class' category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:28'!
I class
	instanceVariableNames: ''!

!classDefinition: 'I class' category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:28'!
I class
	instanceVariableNames: ''!
!I class methodsFor: 'as yet unclassified' stamp: 'LK 8/28/2023 12:26:00'!
* aNaturalNumber
	^aNaturalNumber! !
!I class methodsFor: 'as yet unclassified' stamp: 'lk 8/24/2023 21:01:54'!
+ aNaturalNumber
	
	^aNaturalNumber next! !
!I class methodsFor: 'as yet unclassified' stamp: 'LK 9/3/2023 18:09:02'!
- aNaturalNumber
	^self error: self descripcionDeErrorDeNumerosNegativosNoSoportados! !
!I class methodsFor: 'as yet unclassified' stamp: 'LK 9/3/2023 18:11:14'!
/ aNaturalNumber
	self = aNaturalNumber ifTrue:[^self.].
	^self error: self descripcionDeErrorDeNoSePuedeDividirPorUnNumeroMayor.! !
!I class methodsFor: 'as yet unclassified' stamp: 'LK 9/3/2023 18:45:28'!
descripcionDeErrorDeNoSePuedeDividirPorUnNumeroMayor
	^'No puedo dividir por un número mayor!!!!!!'.! !
!I class methodsFor: 'as yet unclassified' stamp: 'LK 9/3/2023 18:45:38'!
descripcionDeErrorDeNumerosNegativosNoSoportados
	^'No soporto a los numeros negativos'.! !
!I class methodsFor: 'as yet unclassified' stamp: 'LK 9/3/2023 18:15:54'!
next
	^II.! !
!I class methodsFor: 'as yet unclassified' stamp: 'lk 8/24/2023 21:57:00'!
restateA: aNaturalNumber

	^aNaturalNumber previous.! !

!classDefinition: #II category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:29'!
DenotativeObject subclass: #II
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classDefinition: #II category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:29'!
DenotativeObject subclass: #II
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classDefinition: 'II class' category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:30'!
II class
	instanceVariableNames: 'next previous'!

!classDefinition: 'II class' category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:30'!
II class
	instanceVariableNames: 'next previous'!
!II class methodsFor: 'as yet unclassified' stamp: 'LK 8/28/2023 21:00:36'!
* aNaturalNumber
	^(self previous * aNaturalNumber) + aNaturalNumber
	! !
!II class methodsFor: 'as yet unclassified' stamp: 'LK 8/28/2023 20:39:54'!
+ aNaturalNumber
	^self previous + aNaturalNumber next.! !
!II class methodsFor: 'as yet unclassified' stamp: 'LK 9/3/2023 17:39:44'!
- aNaturalNumber
	^aNaturalNumber restateA: self! !
!II class methodsFor: 'as yet unclassified' stamp: 'LK 9/3/2023 18:37:59'!
/ aNaturalNumber
	
	| resultado |
	self = aNaturalNumber ifTrue: [^I].
	[resultado := self - aNaturalNumber] on: Error do: [^self error: self descripcionDeErrorDeNoSePuedeDividirPorUnNumeroMayor].
	^ I + (resultado / aNaturalNumber).
	
! !
!II class methodsFor: 'as yet unclassified' stamp: 'LK 9/3/2023 18:44:07'!
descripcionDeErrorDeNoSePuedeDividirPorUnNumeroMayor
	^'No puedo dividir por un número mayor!!!!!!'.! !
!II class methodsFor: 'as yet unclassified' stamp: 'LK 9/3/2023 18:44:19'!
descripcionDeErrorDeNumerosNegativosNoSoportados
	^'No soporto a los numeros negativos'.! !
!II class methodsFor: 'as yet unclassified' stamp: 'LK 8/28/2023 21:18:51'!
next
	next ifNotNil: [^next].
	next := II createChildNamed: self name , 'I'.
	next previous: self.
	^next.! !
!II class methodsFor: 'as yet unclassified' stamp: 'lk 8/24/2023 21:22:03'!
previous
	
	^ previous.! !
!II class methodsFor: 'as yet unclassified' stamp: 'lk 8/24/2023 21:27:05'!
previous: aNaturalNumber
	
	previous := aNaturalNumber! !
!II class methodsFor: 'as yet unclassified' stamp: 'LK 9/3/2023 17:39:44'!
restateA: aNaturalNumber

	^aNaturalNumber  previous - self previous.! !
!II class methodsFor: '--** private fileout/in **--' stamp: 'LK 9/3/2023 18:50:43' overrides: 50637315!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := III.
	previous := I.! !

!classDefinition: #III category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:31'!
II subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classDefinition: #III category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:31'!
II subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classDefinition: 'III class' category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:31'!
III class
	instanceVariableNames: ''!

!classDefinition: 'III class' category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:31'!
III class
	instanceVariableNames: ''!
!III class methodsFor: '--** private fileout/in **--' stamp: 'LK 9/3/2023 18:50:43' overrides: 50656200!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := IIII.
	previous := II.! !

!classDefinition: #IIII category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:31'!
II subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classDefinition: #IIII category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:31'!
II subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classDefinition: 'IIII class' category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:31'!
IIII class
	instanceVariableNames: ''!

!classDefinition: 'IIII class' category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:31'!
IIII class
	instanceVariableNames: ''!
!IIII class methodsFor: '--** private fileout/in **--' stamp: 'LK 9/3/2023 18:50:43' overrides: 50656200!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := IIIII.
	previous := III.! !

!classDefinition: #IIIII category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:31'!
II subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classDefinition: #IIIII category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:31'!
II subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classDefinition: 'IIIII class' category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:31'!
IIIII class
	instanceVariableNames: ''!

!classDefinition: 'IIIII class' category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:31'!
IIIII class
	instanceVariableNames: ''!
!IIIII class methodsFor: '--** private fileout/in **--' stamp: 'LK 9/3/2023 18:50:43' overrides: 50656200!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := nil.
	previous := IIII.! !

!methodRemoval: II class #initializeCollaboratorsFromFile stamp: 'LK 9/19/2023 00:55:31'!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := III.
	previous := I.!

!methodRemoval: III class #initializeCollaboratorsFromFile stamp: 'LK 9/19/2023 00:55:32'!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := IIII.
	previous := II.!

!methodRemoval: IIII class #initializeCollaboratorsFromFile stamp: 'LK 9/19/2023 00:55:32'!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := IIIII.
	previous := III.!

!methodRemoval: IIIII class #initializeCollaboratorsFromFile stamp: 'LK 9/19/2023 00:55:32'!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := nil.
	previous := IIII.!

!classDefinition: #XXX category: 'ISW1' stamp: 'LK 9/19/2023 00:55:32'!
Object subclass: #XXX
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1'!

!classDefinition: #XXX category: 'ISW1' stamp: 'LK 9/19/2023 00:55:32'!
Object subclass: #XXX
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1'!
!XXX methodsFor: 'as yet unclassified' stamp: 'LK 8/31/2023 21:47:22'!
extractVowels
 'sidashdiahsdnienweq' select: [ :char | char isVowel]
	
! !
!XXX methodsFor: 'as yet unclassified' stamp: 'LK 8/31/2023 21:22:57'!
findDoubles

        | elements |

        elements:= #(1 2 5 6 9).

	^elements collect:[ :element | element * 2].
! !
!XXX methodsFor: 'as yet unclassified' stamp: 'LK 8/31/2023 21:36:09'!
findFirstEven

        | elements |

        elements:= #(1 2 5 6 9).

	^elements detect: [:element | element even]! !
!XXX methodsFor: 'as yet unclassified' stamp: 'LK 8/31/2023 21:36:37'!
findFirstEvenWithoutMatching

        | elements |

        elements:= #(1 5 9).

	^elements detect:[ :element | element even] ifNone: [42].
! !
!XXX methodsFor: 'as yet unclassified' stamp: 'LK 8/31/2023 21:37:03'!
findFirstEvenWithoutMatchingReturningString

        | elements |

        elements:= #(1 5 9).

	^elements detect:[ :element | element even] ifNone: ['42'].
! !
!XXX methodsFor: 'as yet unclassified' stamp: 'LK 8/31/2023 20:48:26'!
findOddsPart0

        | elements index odds |

        elements:= #(1 2 5 6 9).

        odds := OrderedCollection new.
        index := 1.

        [index <= elements size]
        whileTrue: [
                ((elements at: index) odd) ifTrue: [odds add: (elements at: index)].
                index := index +1.
                ].
        ^odds! !
!XXX methodsFor: 'as yet unclassified' stamp: 'LK 8/31/2023 21:16:17'!
findOddsPart1

        | elements odds |

        elements:= #(1 2 5 6 9).

        odds := OrderedCollection new.

	elements do:[ :element | 
		
                element odd ifTrue: [odds add: element]].              
  
        ^odds! !
!XXX methodsFor: 'as yet unclassified' stamp: 'LK 8/31/2023 21:16:32'!
findOddsPart2

        | elements |

        elements:= #(1 2 5 6 9).

	^elements select:[ :element | element odd].                ! !
!XXX methodsFor: 'as yet unclassified' stamp: 'LK 8/31/2023 21:20:44'!
findOddsPart3

        | elements |

        elements:= #(1 2 5 6 9) asSet.

	^elements select:[ :element | element odd].                ! !
!XXX methodsFor: 'as yet unclassified' stamp: 'LK 8/31/2023 21:41:24'!
sumElementsInjecting
	
	| elements |
	
	elements := #(1 5 9).
	
	^elements inject: 0 into: [ :sum :element | sum + element].! !
!XXX methodsFor: 'as yet unclassified' stamp: 'LK 8/31/2023 21:46:32'!
sumElementsSum
	
	| elements |
	
	elements := #(1 5 9).
	
	^elements inject: 0 into: [ :sum :element | sum + element].! !

!classDefinition: #I category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:33'!
DenotativeObject subclass: #I
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classDefinition: #I category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:33'!
DenotativeObject subclass: #I
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classDefinition: 'I class' category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:33'!
I class
	instanceVariableNames: ''!

!classDefinition: 'I class' category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:33'!
I class
	instanceVariableNames: ''!
!I class methodsFor: 'as yet unclassified' stamp: 'LK 8/28/2023 12:26:00' prior: 50656082!
* aNaturalNumber
	^aNaturalNumber! !
!I class methodsFor: 'as yet unclassified' stamp: 'lk 8/24/2023 21:01:54' prior: 50656086!
+ aNaturalNumber
	
	^aNaturalNumber next! !
!I class methodsFor: 'as yet unclassified' stamp: 'LK 9/3/2023 18:09:02' prior: 50656090!
- aNaturalNumber
	^self error: self descripcionDeErrorDeNumerosNegativosNoSoportados! !
!I class methodsFor: 'as yet unclassified' stamp: 'LK 9/3/2023 18:11:14' prior: 50656096!
/ aNaturalNumber
	self = aNaturalNumber ifTrue:[^self.].
	^self error: self descripcionDeErrorDeNoSePuedeDividirPorUnNumeroMayor.! !
!I class methodsFor: 'as yet unclassified' stamp: 'LK 9/3/2023 18:45:28' prior: 50656103!
descripcionDeErrorDeNoSePuedeDividirPorUnNumeroMayor
	^'No puedo dividir por un número mayor!!!!!!'.! !
!I class methodsFor: 'as yet unclassified' stamp: 'LK 9/3/2023 18:45:38' prior: 50656109!
descripcionDeErrorDeNumerosNegativosNoSoportados
	^'No soporto a los numeros negativos'.! !
!I class methodsFor: 'as yet unclassified' stamp: 'LK 9/3/2023 18:15:54' prior: 50656115!
next
	^II.! !
!I class methodsFor: 'as yet unclassified' stamp: 'lk 8/24/2023 21:57:00' prior: 50656118!
restateA: aNaturalNumber

	^aNaturalNumber previous.! !

!classDefinition: #II category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:33'!
DenotativeObject subclass: #II
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classDefinition: #II category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:33'!
DenotativeObject subclass: #II
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classDefinition: 'II class' category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:33'!
II class
	instanceVariableNames: 'next previous'!

!classDefinition: 'II class' category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:33'!
II class
	instanceVariableNames: 'next previous'!
!II class methodsFor: 'as yet unclassified' stamp: 'LK 8/28/2023 21:00:36' prior: 50656143!
* aNaturalNumber
	^(self previous * aNaturalNumber) + aNaturalNumber
	! !
!II class methodsFor: 'as yet unclassified' stamp: 'LK 8/28/2023 20:39:54' prior: 50656148!
+ aNaturalNumber
	^self previous + aNaturalNumber next.! !
!II class methodsFor: 'as yet unclassified' stamp: 'LK 9/3/2023 17:39:44' prior: 50656153!
- aNaturalNumber
	^aNaturalNumber restateA: self! !
!II class methodsFor: 'as yet unclassified' stamp: 'LK 9/3/2023 18:37:59' prior: 50656157!
/ aNaturalNumber
	
	| resultado |
	self = aNaturalNumber ifTrue: [^I].
	[resultado := self - aNaturalNumber] on: Error do: [^self error: self descripcionDeErrorDeNoSePuedeDividirPorUnNumeroMayor].
	^ I + (resultado / aNaturalNumber).
	
! !
!II class methodsFor: 'as yet unclassified' stamp: 'LK 9/3/2023 18:44:07' prior: 50656167!
descripcionDeErrorDeNoSePuedeDividirPorUnNumeroMayor
	^'No puedo dividir por un número mayor!!!!!!'.! !
!II class methodsFor: 'as yet unclassified' stamp: 'LK 9/3/2023 18:44:19' prior: 50656173!
descripcionDeErrorDeNumerosNegativosNoSoportados
	^'No soporto a los numeros negativos'.! !
!II class methodsFor: 'as yet unclassified' stamp: 'LK 8/28/2023 21:18:51' prior: 50656179!
next
	next ifNotNil: [^next].
	next := II createChildNamed: self name , 'I'.
	next previous: self.
	^next.! !
!II class methodsFor: 'as yet unclassified' stamp: 'lk 8/24/2023 21:22:03' prior: 50656185!
previous
	
	^ previous.! !
!II class methodsFor: 'as yet unclassified' stamp: 'lk 8/24/2023 21:27:05' prior: 50656189!
previous: aNaturalNumber
	
	previous := aNaturalNumber! !
!II class methodsFor: 'as yet unclassified' stamp: 'LK 9/3/2023 17:39:44' prior: 50656194!
restateA: aNaturalNumber

	^aNaturalNumber  previous - self previous.! !
!II class methodsFor: '--** private fileout/in **--' stamp: 'LK 9/3/2023 18:50:43' overrides: 50637315!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := III.
	previous := I.! !

!classDefinition: #III category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:34'!
II subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classDefinition: #III category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:34'!
II subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classDefinition: 'III class' category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:34'!
III class
	instanceVariableNames: ''!

!classDefinition: 'III class' category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:34'!
III class
	instanceVariableNames: ''!
!III class methodsFor: '--** private fileout/in **--' stamp: 'LK 9/3/2023 18:50:43' overrides: 50656561!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := IIII.
	previous := II.! !

!classDefinition: #IIII category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:34'!
II subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classDefinition: #IIII category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:34'!
II subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classDefinition: 'IIII class' category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:34'!
IIII class
	instanceVariableNames: ''!

!classDefinition: 'IIII class' category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:34'!
IIII class
	instanceVariableNames: ''!
!IIII class methodsFor: '--** private fileout/in **--' stamp: 'LK 9/3/2023 18:50:43' overrides: 50656561!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := IIIII.
	previous := III.! !

!classDefinition: #IIIII category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:34'!
II subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classDefinition: #IIIII category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:34'!
II subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classDefinition: 'IIIII class' category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:34'!
IIIII class
	instanceVariableNames: ''!

!classDefinition: 'IIIII class' category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:34'!
IIIII class
	instanceVariableNames: ''!
!IIIII class methodsFor: '--** private fileout/in **--' stamp: 'LK 9/3/2023 18:50:43' overrides: 50656561!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := nil.
	previous := IIII.! !

!methodRemoval: II class #initializeCollaboratorsFromFile stamp: 'LK 9/19/2023 00:55:34'!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := III.
	previous := I.!

!methodRemoval: III class #initializeCollaboratorsFromFile stamp: 'LK 9/19/2023 00:55:34'!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := IIII.
	previous := II.!

!methodRemoval: IIII class #initializeCollaboratorsFromFile stamp: 'LK 9/19/2023 00:55:34'!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := IIIII.
	previous := III.!

!methodRemoval: IIIII class #initializeCollaboratorsFromFile stamp: 'LK 9/19/2023 00:55:34'!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := nil.
	previous := IIII.!

!classRemoval: #IIIII stamp: 'LK 9/19/2023 00:55:35'!
II subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classRemoval: #IIII stamp: 'LK 9/19/2023 00:55:35'!
II subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classRemoval: #III stamp: 'LK 9/19/2023 00:55:35'!
II subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classRemoval: #II stamp: 'LK 9/19/2023 00:55:35'!
DenotativeObject subclass: #II
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classRemoval: #I stamp: 'LK 9/19/2023 00:55:35'!
DenotativeObject subclass: #I
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classDefinition: #I category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:35'!
DenotativeObject subclass: #I
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classDefinition: #I category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:35'!
DenotativeObject subclass: #I
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classDefinition: 'I class' category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:35'!
I class
	instanceVariableNames: ''!

!classDefinition: 'I class' category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:36'!
I class
	instanceVariableNames: ''!
!I class methodsFor: 'as yet unclassified' stamp: 'LK 8/28/2023 12:26:00'!
* aNaturalNumber
	^aNaturalNumber! !
!I class methodsFor: 'as yet unclassified' stamp: 'lk 8/24/2023 21:01:54'!
+ aNaturalNumber
	
	^aNaturalNumber next! !
!I class methodsFor: 'as yet unclassified' stamp: 'LK 9/3/2023 18:09:02'!
- aNaturalNumber
	^self error: self descripcionDeErrorDeNumerosNegativosNoSoportados! !
!I class methodsFor: 'as yet unclassified' stamp: 'LK 9/3/2023 18:11:14'!
/ aNaturalNumber
	self = aNaturalNumber ifTrue:[^self.].
	^self error: self descripcionDeErrorDeNoSePuedeDividirPorUnNumeroMayor.! !
!I class methodsFor: 'as yet unclassified' stamp: 'LK 9/3/2023 18:45:28'!
descripcionDeErrorDeNoSePuedeDividirPorUnNumeroMayor
	^'No puedo dividir por un número mayor!!!!!!'.! !
!I class methodsFor: 'as yet unclassified' stamp: 'LK 9/3/2023 18:45:38'!
descripcionDeErrorDeNumerosNegativosNoSoportados
	^'No soporto a los numeros negativos'.! !
!I class methodsFor: 'as yet unclassified' stamp: 'LK 9/3/2023 18:15:54'!
next
	^II.! !
!I class methodsFor: 'as yet unclassified' stamp: 'lk 8/24/2023 21:57:00'!
restateA: aNaturalNumber

	^aNaturalNumber previous.! !

!classDefinition: #II category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:37'!
DenotativeObject subclass: #II
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classDefinition: #II category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:37'!
DenotativeObject subclass: #II
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classDefinition: 'II class' category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:37'!
II class
	instanceVariableNames: 'next previous'!

!classDefinition: 'II class' category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:37'!
II class
	instanceVariableNames: 'next previous'!
!II class methodsFor: 'as yet unclassified' stamp: 'LK 8/28/2023 21:00:36'!
* aNaturalNumber
	^(self previous * aNaturalNumber) + aNaturalNumber
	! !
!II class methodsFor: 'as yet unclassified' stamp: 'LK 8/28/2023 20:39:54'!
+ aNaturalNumber
	^self previous + aNaturalNumber next.! !
!II class methodsFor: 'as yet unclassified' stamp: 'LK 9/3/2023 17:39:44'!
- aNaturalNumber
	^aNaturalNumber restateA: self! !
!II class methodsFor: 'as yet unclassified' stamp: 'LK 9/3/2023 18:37:59'!
/ aNaturalNumber
	
	| resultado |
	self = aNaturalNumber ifTrue: [^I].
	[resultado := self - aNaturalNumber] on: Error do: [^self error: self descripcionDeErrorDeNoSePuedeDividirPorUnNumeroMayor].
	^ I + (resultado / aNaturalNumber).
	
! !
!II class methodsFor: 'as yet unclassified' stamp: 'LK 9/3/2023 18:44:07'!
descripcionDeErrorDeNoSePuedeDividirPorUnNumeroMayor
	^'No puedo dividir por un número mayor!!!!!!'.! !
!II class methodsFor: 'as yet unclassified' stamp: 'LK 9/3/2023 18:44:19'!
descripcionDeErrorDeNumerosNegativosNoSoportados
	^'No soporto a los numeros negativos'.! !
!II class methodsFor: 'as yet unclassified' stamp: 'LK 8/28/2023 21:18:51'!
next
	next ifNotNil: [^next].
	next := II createChildNamed: self name , 'I'.
	next previous: self.
	^next.! !
!II class methodsFor: 'as yet unclassified' stamp: 'lk 8/24/2023 21:22:03'!
previous
	
	^ previous.! !
!II class methodsFor: 'as yet unclassified' stamp: 'lk 8/24/2023 21:27:05'!
previous: aNaturalNumber
	
	previous := aNaturalNumber! !
!II class methodsFor: 'as yet unclassified' stamp: 'LK 9/3/2023 17:39:44'!
restateA: aNaturalNumber

	^aNaturalNumber  previous - self previous.! !
!II class methodsFor: '--** private fileout/in **--' stamp: 'LK 9/3/2023 18:50:43' overrides: 50637315!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := III.
	previous := I.! !

!classDefinition: #III category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:38'!
II subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classDefinition: #III category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:38'!
II subclass: #III
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classDefinition: 'III class' category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:38'!
III class
	instanceVariableNames: ''!

!classDefinition: 'III class' category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:38'!
III class
	instanceVariableNames: ''!
!III class methodsFor: '--** private fileout/in **--' stamp: 'LK 9/3/2023 18:50:43' overrides: 50656844!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := IIII.
	previous := II.! !

!classDefinition: #IIII category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:39'!
II subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classDefinition: #IIII category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:39'!
II subclass: #IIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classDefinition: 'IIII class' category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:39'!
IIII class
	instanceVariableNames: ''!

!classDefinition: 'IIII class' category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:39'!
IIII class
	instanceVariableNames: ''!
!IIII class methodsFor: '--** private fileout/in **--' stamp: 'LK 9/3/2023 18:50:43' overrides: 50656844!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := IIIII.
	previous := III.! !

!classDefinition: #IIIII category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:39'!
II subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classDefinition: #IIIII category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:39'!
II subclass: #IIIII
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Clase 3'!

!classDefinition: 'IIIII class' category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:39'!
IIIII class
	instanceVariableNames: ''!

!classDefinition: 'IIIII class' category: 'Clase 3' stamp: 'LK 9/19/2023 00:55:39'!
IIIII class
	instanceVariableNames: ''!
!IIIII class methodsFor: '--** private fileout/in **--' stamp: 'LK 9/3/2023 18:50:43' overrides: 50656844!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := nil.
	previous := IIII.! !

!methodRemoval: II class #initializeCollaboratorsFromFile stamp: 'LK 9/19/2023 00:55:39'!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := III.
	previous := I.!

!methodRemoval: III class #initializeCollaboratorsFromFile stamp: 'LK 9/19/2023 00:55:39'!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := IIII.
	previous := II.!

!methodRemoval: IIII class #initializeCollaboratorsFromFile stamp: 'LK 9/19/2023 00:55:39'!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := IIIII.
	previous := III.!

!methodRemoval: IIIII class #initializeCollaboratorsFromFile stamp: 'LK 9/19/2023 00:55:39'!
initializeCollaboratorsFromFile
	"Auto generated method for loading purposes - Do not modify it"

	next := nil.
	previous := IIII.!

!classDefinition: #CantSuspend category: 'CodigoRepetido-Ejercicio' stamp: 'LK 9/19/2023 00:55:39'!
Error subclass: #CantSuspend
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CodigoRepetido-Ejercicio'!

!classDefinition: #CantSuspend category: 'CodigoRepetido-Ejercicio' stamp: 'LK 9/19/2023 00:55:39'!
Error subclass: #CantSuspend
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CodigoRepetido-Ejercicio'!

!classDefinition: #NotFound category: 'CodigoRepetido-Ejercicio' stamp: 'LK 9/19/2023 00:55:39'!
Error subclass: #NotFound
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CodigoRepetido-Ejercicio'!

!classDefinition: #NotFound category: 'CodigoRepetido-Ejercicio' stamp: 'LK 9/19/2023 00:55:39'!
Error subclass: #NotFound
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CodigoRepetido-Ejercicio'!

!classDefinition: #CustomerBookTest category: 'CodigoRepetido-Ejercicio' stamp: 'LK 9/19/2023 00:55:39'!
TestCase subclass: #CustomerBookTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CodigoRepetido-Ejercicio'!

!classDefinition: #CustomerBookTest category: 'CodigoRepetido-Ejercicio' stamp: 'LK 9/19/2023 00:55:39'!
TestCase subclass: #CustomerBookTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CodigoRepetido-Ejercicio'!
!CustomerBookTest methodsFor: 'testing' stamp: 'LK 9/12/2023 13:37:54'!
assertCantidadEn: aCustomerBook activos: activeNumber suspendidos: suspendedNumber
	
	
	self assert: activeNumber equals: aCustomerBook numberOfActiveCustomers.
	self assert: suspendedNumber equals: aCustomerBook numberOfSuspendedCustomers.
	self assert:(suspendedNumber  + activeNumber) equals: aCustomerBook numberOfCustomers.


	
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'LK 9/12/2023 13:11:51'!
assertQueClosureCorra: aClosureToMeasure enMenosQueMs: aTimeLimitInMs
	
	self assert: (self tomarTiempoA: aClosureToMeasure ) < ( aTimeLimitInMs * millisecond)
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'LK 9/12/2023 13:30:47'!
shouldDo: aClosureQueFalla on: anError thenDo: aClosureCatch

	[ aClosureQueFalla value
	self fail ]
		on: anError
		do: aClosureCatch! !
!CustomerBookTest methodsFor: 'testing' stamp: 'LK 9/7/2023 20:15:32'!
test01AddingCustomerShouldNotTakeMoreThan50Milliseconds

	| customerBook |
	
	customerBook := CustomerBook new.
	
	self assertQueClosureCorra: [customerBook addCustomerNamed: 'John Lennon'.] enMenosQueMs: 50.
	
	
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'LK 9/7/2023 20:15:32'!
test02RemovingCustomerShouldNotTakeMoreThan100Milliseconds

	| customerBook paulMcCartney |
	
	customerBook := CustomerBook new.
	paulMcCartney := 'Paul McCartney'.
	
	customerBook addCustomerNamed: paulMcCartney.
	  
	
	self assertQueClosureCorra:[customerBook removeCustomerNamed: paulMcCartney.] enMenosQueMs: 100.

	
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'LK 9/12/2023 13:30:48'!
test03CanNotAddACustomerWithEmptyName 

	| customerBook |
			
	customerBook := CustomerBook new.
	
	self shouldDo:[customerBook addCustomerNamed: ''.] on: Error thenDo: [ :anError | 
			self assert: anError messageText = CustomerBook customerCanNotBeEmptyErrorMessage.
			self assert: customerBook isEmpty ]
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'LK 9/12/2023 13:30:48'!
test04CanNotRemoveAnInvalidCustomer
	
	| customerBook johnLennon |
			
	customerBook := CustomerBook new.
	johnLennon := 'John Lennon'.
	customerBook addCustomerNamed: johnLennon.
	
	self shouldDo: [customerBook removeCustomerNamed: 'Paul McCartney'] on:NotFound thenDo:[ :anError | 
			self assert: customerBook numberOfCustomers = 1.
			self assert: (customerBook includesCustomerNamed: johnLennon)].
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'LK 9/12/2023 13:39:13'!
test05SuspendingACustomerShouldNotRemoveItFromCustomerBook

	| customerBook paulMcCartney|
	
	customerBook := CustomerBook new.
	paulMcCartney := 'Paul McCartney'.
	
	customerBook addCustomerNamed: paulMcCartney.
	customerBook suspendCustomerNamed: paulMcCartney.
	
	self assertCantidadEn: customerBook activos:  0 suspendidos: 1.
	self assert: (customerBook includesCustomerNamed: paulMcCartney).
	

	
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'LK 9/12/2023 13:38:40'!
test06RemovingASuspendedCustomerShouldRemoveItFromCustomerBook

	| customerBook paulMcCartney|
	
	customerBook := CustomerBook new.
	paulMcCartney := 'Paul McCartney'.
	
	customerBook addCustomerNamed: paulMcCartney.
	customerBook suspendCustomerNamed: paulMcCartney.
	customerBook removeCustomerNamed: paulMcCartney.
	
	self assertCantidadEn: customerBook activos: 0 suspendidos: 0.
	self deny: (customerBook includesCustomerNamed: paulMcCartney).


	
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'LK 9/12/2023 13:46:40'!
test07CanNotSuspendAnInvalidCustomer
	
	| customerBook johnLennon |
			
	customerBook := CustomerBook new.
	johnLennon := 'John Lennon'.
	customerBook addCustomerNamed: johnLennon.
	
	self shouldDo: [ customerBook suspendCustomerNamed: 'George Harrison'] on:CantSuspend thenDo: 
	[ :anError | 
			self assert: customerBook numberOfCustomers = 1.
			self assert: (customerBook includesCustomerNamed: johnLennon)].

! !
!CustomerBookTest methodsFor: 'testing' stamp: 'LK 9/12/2023 13:46:44'!
test08CanNotSuspendAnAlreadySuspendedCustomer
	
	| customerBook johnLennon |
			
	customerBook := CustomerBook new.
	johnLennon := 'John Lennon'.
	customerBook addCustomerNamed: johnLennon.
	customerBook suspendCustomerNamed: johnLennon.
	
	self shouldDo: [ customerBook suspendCustomerNamed: johnLennon] on: CantSuspend thenDo: 
	[ :anError | 
			self assert: customerBook numberOfCustomers = 1.
			self assert: (customerBook includesCustomerNamed: johnLennon)].
	
! !
!CustomerBookTest methodsFor: 'testing' stamp: 'LK 9/12/2023 13:27:41'!
tomarTiempoA: aClosureToMeasure

	| millisecondsBeforeRunning millisecondsAfterRunning|
	
	millisecondsBeforeRunning := Time millisecondClockValue * millisecond.
	aClosureToMeasure value.
	millisecondsAfterRunning := Time millisecondClockValue * millisecond.
	
	^millisecondsAfterRunning-millisecondsBeforeRunning
! !

!classDefinition: #CustomerBook category: 'CodigoRepetido-Ejercicio' stamp: 'LK 9/19/2023 00:55:41'!
Object subclass: #CustomerBook
	instanceVariableNames: 'suspended active'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CodigoRepetido-Ejercicio'!

!classDefinition: #CustomerBook category: 'CodigoRepetido-Ejercicio' stamp: 'LK 9/19/2023 00:55:41'!
Object subclass: #CustomerBook
	instanceVariableNames: 'suspended active'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CodigoRepetido-Ejercicio'!
!CustomerBook methodsFor: 'testing' stamp: 'NR 4/3/2019 10:14:26'!
includesCustomerNamed: aName

	^(active includes: aName) or: [ suspended includes: aName ]! !
!CustomerBook methodsFor: 'testing' stamp: 'NR 4/3/2019 10:14:26'!
isEmpty
	
	^active isEmpty and: [ suspended isEmpty ]! !
!CustomerBook methodsFor: 'initialization' stamp: 'NR 9/17/2020 07:23:04' overrides: 16920235!
initialize

	active := OrderedCollection new.
	suspended:= OrderedCollection new.! !
!CustomerBook methodsFor: 'customer management' stamp: 'NR 4/3/2019 10:14:26'!
addCustomerNamed: aName

	aName isEmpty ifTrue: [ self signalCustomerNameCannotBeEmpty ].
	((active includes: aName) or: [suspended includes: aName]) ifTrue: [ self signalCustomerAlreadyExists ].
	
	active add: aName ! !
!CustomerBook methodsFor: 'customer management' stamp: 'NR 4/3/2019 10:14:26'!
numberOfActiveCustomers
	
	^active size! !
!CustomerBook methodsFor: 'customer management' stamp: 'NR 4/3/2019 10:14:26'!
numberOfCustomers
	
	^active size + suspended size! !
!CustomerBook methodsFor: 'customer management' stamp: 'NR 9/19/2018 17:36:09'!
numberOfSuspendedCustomers
	
	^suspended size! !
!CustomerBook methodsFor: 'customer management' stamp: 'LK 9/12/2023 13:46:06'!
remove: elem from: aCollectionToRemove ifAbsent: aClosure
 
	1 to: aCollectionToRemove size do: 
	[ :index |
		elem = (aCollectionToRemove at: index)
			ifTrue: [
				aCollectionToRemove removeAt: index.
				^ elem 
			] 
	].

	^ aClosure value.
	
! !
!CustomerBook methodsFor: 'customer management' stamp: 'LK 9/12/2023 13:42:06'!
removeCustomerNamed: aName 

	^self remove: aName from: active ifAbsent: 
		[self remove: aName from: suspended ifAbsent: 
			[^NotFound signal.]]
	
! !
!CustomerBook methodsFor: 'customer management' stamp: 'HernanWilkinson 7/6/2011 17:52'!
signalCustomerAlreadyExists 

	self error: self class customerAlreadyExistsErrorMessage! !
!CustomerBook methodsFor: 'customer management' stamp: 'HernanWilkinson 7/6/2011 17:51'!
signalCustomerNameCannotBeEmpty 

	self error: self class customerCanNotBeEmptyErrorMessage ! !
!CustomerBook methodsFor: 'customer management' stamp: 'LK 9/12/2023 13:26:40'!
suspendCustomerNamed: aName 
	
	self remove: aName from: active ifAbsent: [^CantSuspend signal].
	
	suspended add: aName.! !

!classDefinition: 'CustomerBook class' category: 'CodigoRepetido-Ejercicio' stamp: 'LK 9/19/2023 00:55:43'!
CustomerBook class
	instanceVariableNames: ''!

!classDefinition: 'CustomerBook class' category: 'CodigoRepetido-Ejercicio' stamp: 'LK 9/19/2023 00:55:43'!
CustomerBook class
	instanceVariableNames: ''!
!CustomerBook class methodsFor: 'error messages' stamp: 'NR 9/4/2023 17:02:48'!
customerAlreadyExistsErrorMessage

	^'Customer already exists!!!!!!'! !
!CustomerBook class methodsFor: 'error messages' stamp: 'NR 9/4/2023 17:02:52'!
customerCanNotBeEmptyErrorMessage

	^'Customer name cannot be empty!!!!!!'! !

!classDefinition: #OOStackTest category: 'Stack-Exercise' stamp: 'LK 9/19/2023 00:55:43'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStackTest category: 'Stack-Exercise' stamp: 'LK 9/19/2023 00:55:43'!
TestCase subclass: #OOStackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStackTest methodsFor: 'test' stamp: 'HernanWilkinson 5/7/2012 11:30'!
test01StackShouldBeEmptyWhenCreated

	| stack |
	
	stack := OOStack new.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:29:55'!
test02PushAddElementsToTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	
	self deny: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:01'!
test03PopRemovesElementsFromTheStack

	| stack |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self assert: stack isEmpty! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:09'!
test04PopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	stack push: pushedObject.
	
	self assert: stack pop = pushedObject! !
!OOStackTest methodsFor: 'test' stamp: 'NR 9/16/2021 17:40:17'!
test05StackBehavesLIFO

	| stack firstPushedObject secondPushedObject |
	
	stack := OOStack new.
	firstPushedObject := 'firstSomething'.
	secondPushedObject := 'secondSomething'.
	
	stack push: firstPushedObject.
	stack push: secondPushedObject.
	
	self assert: stack pop = secondPushedObject.
	self assert: stack pop = firstPushedObject.
	self assert: stack isEmpty 
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:20'!
test06TopReturnsLastPushedObject

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack top = pushedObject.
	! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:24'!
test07TopDoesNotRemoveObjectFromStack

	| stack pushedObject |
	
	stack := OOStack new.
	pushedObject := 'something'.
	
	stack push: pushedObject.
	
	self assert: stack size = 1.
	stack top.
	self assert: stack size = 1.
	! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:26'!
test08CanNotPopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'NR 5/13/2020 13:30:31'!
test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects

	| stack  |
	
	stack := OOStack new.
	stack push: 'something'.
	stack pop.
	
	self
		should: [ stack pop ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !
!OOStackTest methodsFor: 'test' stamp: 'HAW 4/14/2017 22:48:44'!
test10CanNotTopWhenThereAreNoObjectsInTheStack

	| stack  |
	
	stack := OOStack new.
	self
		should: [ stack top ]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = OOStack stackEmptyErrorDescription ]
		
! !

!classDefinition: #SentenceFinderByPrefixTest category: 'Stack-Exercise' stamp: 'LK 9/19/2023 00:55:44'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: 'stackTest finderTest'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefixTest category: 'Stack-Exercise' stamp: 'LK 9/19/2023 00:55:44'!
TestCase subclass: #SentenceFinderByPrefixTest
	instanceVariableNames: 'stackTest finderTest'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!SentenceFinderByPrefixTest methodsFor: 'as yet unclassified' stamp: 'LK 9/18/2023 16:02:29' overrides: 16961394!
setUp

	stackTest := OOStack new.
	
	stackTest push: 'hola'.
	stackTest push: 'holanda'.
	stackTest push: 'chau'.
	stackTest push: 'Hola'.
	
	finderTest := SentenceFinderByPrefix new.
! !
!SentenceFinderByPrefixTest methodsFor: 'as yet unclassified' stamp: 'LK 9/18/2023 16:02:44'!
test01findEncuentraEnElStack

	| matchingPrefix|

	finderTest initializeWith: stackTest andPrefix: 'hola'.
	
	matchingPrefix := finderTest find.
	
	self assert: matchingPrefix size = 2.
	self assert: (matchingPrefix first) = 'holanda'.
	self assert: (matchingPrefix last) = 'hola'
! !
!SentenceFinderByPrefixTest methodsFor: 'as yet unclassified' stamp: 'LK 9/18/2023 16:02:56'!
test02findNoEncuentraEnElStack

	| matchingPrefix |

	finderTest := SentenceFinderByPrefix new.
	finderTest initializeWith: stackTest andPrefix: 'wint'.
	
	matchingPrefix := finderTest find.
	
	self assert: matchingPrefix isEmpty.! !
!SentenceFinderByPrefixTest methodsFor: 'as yet unclassified' stamp: 'LK 9/18/2023 16:03:05'!
test03findEsCaseSensitive

	| matchingPrefix |	

	finderTest initializeWith: stackTest andPrefix: 'H'.
	
	matchingPrefix := finderTest find.
	self assert: matchingPrefix first = 'Hola'.
	self assert: matchingPrefix size = 1.
	! !
!SentenceFinderByPrefixTest methodsFor: 'as yet unclassified' stamp: 'LK 9/18/2023 16:03:11'!
test04findNoAceptaPrefijoVacio
	
	self
		should: [ finderTest initializeWith: stackTest andPrefix: ''.]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = SentenceFinderByPrefix cannotUseEmptyPrefix ].
	
! !
!SentenceFinderByPrefixTest methodsFor: 'as yet unclassified' stamp: 'LK 9/18/2023 16:03:27'!
test05findNoModificaElStack

	| matchingPrefix staticStack|
	
	staticStack := stackTest .
	
	finderTest := SentenceFinderByPrefix new.
	finderTest initializeWith: stackTest andPrefix: 'hola'.
	matchingPrefix := finderTest find.
	
	self assert: staticStack = stackTest .
	

	
	
! !
!SentenceFinderByPrefixTest methodsFor: 'as yet unclassified' stamp: 'LK 9/18/2023 16:03:35'!
test06assertErrorNoAceptaEspaciosEnBlanco
	
	self
		should: [ finderTest initializeWith: stackTest andPrefix: ' hola'.]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = SentenceFinderByPrefix cannotUseWhiteSpacesInPrefix].
	
! !
!SentenceFinderByPrefixTest methodsFor: 'as yet unclassified' stamp: 'LK 9/18/2023 16:03:53'!
test07inicializarConStackVacio

	| emptyStack |
	
	emptyStack := OOStack new.
	
	self
		should: [ finderTest initializeWith: emptyStack andPrefix: 'hola'.]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError |
			self assert: anError messageText = SentenceFinderByPrefix cannotInitializeWithEmptyStack ].
	
! !

!classDefinition: #ContentStack category: 'Stack-Exercise' stamp: 'LK 9/19/2023 00:55:46'!
Object subclass: #ContentStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #ContentStack category: 'Stack-Exercise' stamp: 'LK 9/19/2023 00:55:46'!
Object subclass: #ContentStack
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!ContentStack methodsFor: 'as yet unclassified' stamp: 'LK 9/17/2023 21:11:48'!
isEmpty

	^self subclassResponsibility ! !
!ContentStack methodsFor: 'as yet unclassified' stamp: 'LK 9/17/2023 21:11:51' overrides: 16901663!
size

	^self subclassResponsibility ! !
!ContentStack methodsFor: 'as yet unclassified' stamp: 'LK 9/17/2023 21:11:37'!
top
	^self subclassResponsibility ! !
!ContentStack methodsFor: 'as yet unclassified' stamp: 'LK 9/17/2023 21:10:09'!
withoutTop
	^self subclassResponsibility ! !

!classDefinition: #ContentNode category: 'Stack-Exercise' stamp: 'LK 9/19/2023 00:55:46'!
ContentStack subclass: #ContentNode
	instanceVariableNames: 'nodo previous'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #ContentNode category: 'Stack-Exercise' stamp: 'LK 9/19/2023 00:55:46'!
ContentStack subclass: #ContentNode
	instanceVariableNames: 'nodo previous'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!ContentNode methodsFor: 'as yet unclassified' stamp: 'LK 9/17/2023 21:21:17' overrides: 50657511!
isEmpty
	^false! !
!ContentNode methodsFor: 'as yet unclassified' stamp: 'LK 9/17/2023 21:15:39' overrides: 50657516!
size
	^ 1+ previous size.! !
!ContentNode methodsFor: 'as yet unclassified' stamp: 'LK 9/17/2023 21:15:48' overrides: 50657520!
top
	^nodo! !
!ContentNode methodsFor: 'as yet unclassified' stamp: 'LK 9/18/2023 00:12:42'!
with: anElement onTopOf: aPreviousStack

	nodo := anElement .
	previous := aPreviousStack ! !
!ContentNode methodsFor: 'as yet unclassified' stamp: 'LK 9/18/2023 15:47:15' overrides: 50657524!
withoutTop
	^previous ! !

!classDefinition: #EmptyNode category: 'Stack-Exercise' stamp: 'LK 9/19/2023 00:55:47'!
ContentStack subclass: #EmptyNode
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #EmptyNode category: 'Stack-Exercise' stamp: 'LK 9/19/2023 00:55:47'!
ContentStack subclass: #EmptyNode
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!EmptyNode methodsFor: 'as yet unclassified' stamp: 'LK 9/17/2023 21:23:53' overrides: 50657511!
isEmpty
	^true! !
!EmptyNode methodsFor: 'as yet unclassified' stamp: 'LK 9/17/2023 21:12:10' overrides: 50657516!
size
	^0! !
!EmptyNode methodsFor: 'as yet unclassified' stamp: 'LK 9/17/2023 21:14:09' overrides: 50657520!
top
	^self error: OOStack stackEmptyErrorDescription! !
!EmptyNode methodsFor: 'as yet unclassified' stamp: 'LK 9/18/2023 16:05:17' overrides: 50657524!
withoutTop

	^self error: OOStack stackEmptyErrorDescription! !

!classDefinition: #OOStack category: 'Stack-Exercise' stamp: 'LK 9/19/2023 00:55:48'!
Object subclass: #OOStack
	instanceVariableNames: 'content'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #OOStack category: 'Stack-Exercise' stamp: 'LK 9/19/2023 00:55:48'!
Object subclass: #OOStack
	instanceVariableNames: 'content'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!OOStack methodsFor: 'as yet unclassified' stamp: 'LK 9/18/2023 15:45:50' overrides: 16920235!
initialize

	content := EmptyNode new.
	
! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'LK 9/18/2023 15:45:54'!
isEmpty
		
	^content isEmpty
! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'LK 9/18/2023 15:46:02'!
pop

	|last|
	
	last := content top.
	
	content := content withoutTop.
	
	^last
	! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'LK 9/18/2023 15:46:40'!
push: somethingToPush

	content := ContentNode new with: somethingToPush onTopOf: content.! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'LK 9/18/2023 15:46:44' overrides: 16901663!
size
	^content size! !
!OOStack methodsFor: 'as yet unclassified' stamp: 'LK 9/18/2023 15:46:48'!
top

	^content top! !

!classDefinition: 'OOStack class' category: 'Stack-Exercise' stamp: 'LK 9/19/2023 00:55:49'!
OOStack class
	instanceVariableNames: ''!

!classDefinition: 'OOStack class' category: 'Stack-Exercise' stamp: 'LK 9/19/2023 00:55:49'!
OOStack class
	instanceVariableNames: ''!
!OOStack class methodsFor: 'error descriptions' stamp: 'NR 9/14/2023 08:12:21'!
stackEmptyErrorDescription
	
	^ 'stack is empty!!!!!!'! !

!classDefinition: #SentenceFinderByPrefix category: 'Stack-Exercise' stamp: 'LK 9/19/2023 00:55:49'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: 'originalStack prefixToFind found reversedStack'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!

!classDefinition: #SentenceFinderByPrefix category: 'Stack-Exercise' stamp: 'LK 9/19/2023 00:55:49'!
Object subclass: #SentenceFinderByPrefix
	instanceVariableNames: 'originalStack prefixToFind found reversedStack'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Stack-Exercise'!
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'LK 9/18/2023 15:38:46'!
filterPrefix: aPrefix

	|hasWhitespace|
	
	(aPrefix = '') ifTrue: [^self error: SentenceFinderByPrefix cannotUseEmptyPrefix].
	
	hasWhitespace := aPrefix includesAnyOf: ' '.
	
	(hasWhitespace) ifTrue:
			 [^self error: SentenceFinderByPrefix cannotUseWhiteSpacesInPrefix].
	! !
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'LK 9/18/2023 15:29:14'!
find
	
	[(originalStack isEmpty) not] whileTrue: [self getIfTopMatchesPrefix].
	
	self recoverStack.
	
	^found.! !
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'LK 9/18/2023 15:29:14'!
getIfTopMatchesPrefix

	| currentString | 
	
	currentString := originalStack pop.
	
	(self matchesPrefix: currentString ) ifTrue: [found add: currentString].
	
	reversedStack push: currentString.! !
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'LK 9/18/2023 14:23:00'!
initializeWith: aStack andPrefix: aPrefix
	
	
	(self filterPrefix: aPrefix).
	
	(aStack isEmpty) ifTrue: [^self error: SentenceFinderByPrefix cannotInitializeWithEmptyStack].
	
	originalStack := aStack.
	
	prefixToFind := aPrefix.
	
	reversedStack := OOStack new.
	
	found := OrderedCollection new.! !
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'LK 9/18/2023 12:10:41'!
matchesPrefix: aStringToMatch

	| prefixToFindLength sameSize|
	
	prefixToFindLength := prefixToFind size.
	
	(aStringToMatch size < prefixToFindLength) ifTrue: [^false].

	sameSize := aStringToMatch copyFrom: 1 to: (prefixToFind size).
	
	^(sameSize = prefixToFind).
	! !
!SentenceFinderByPrefix methodsFor: 'as yet unclassified' stamp: 'LK 9/18/2023 15:29:38'!
recoverStack

	[reversedStack isEmpty] whileFalse: 
		[originalStack push: (reversedStack pop)].! !

!classDefinition: 'SentenceFinderByPrefix class' category: 'Stack-Exercise' stamp: 'LK 9/19/2023 00:55:50'!
SentenceFinderByPrefix class
	instanceVariableNames: ''!

!classDefinition: 'SentenceFinderByPrefix class' category: 'Stack-Exercise' stamp: 'LK 9/19/2023 00:55:50'!
SentenceFinderByPrefix class
	instanceVariableNames: ''!
!SentenceFinderByPrefix class methodsFor: 'as yet unclassified' stamp: 'LK 9/18/2023 14:20:55'!
cannotInitializeWithEmptyStack
	^ 'No acepto stacks vacios'! !
!SentenceFinderByPrefix class methodsFor: 'as yet unclassified' stamp: 'LK 9/18/2023 12:17:55'!
cannotUseEmptyPrefix
	^ 'No acepto el prefijo vacio'! !
!SentenceFinderByPrefix class methodsFor: 'as yet unclassified' stamp: 'oa 9/18/2023 12:56:04'!
cannotUseWhiteSpacesInPrefix
	^ 'No acepto prefijos con espacios vacios'! !

!classDefinition: #NumeroTest category: 'Numero-Solution-4' stamp: 'LK 9/19/2023 00:55:50'!
TestCase subclass: #NumeroTest
	instanceVariableNames: 'zero one two four oneFifth oneHalf five twoFifth twoTwentyfifth fiveHalfs eight negativeOne negativeTwo three'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Solution-4'!

!classDefinition: #NumeroTest category: 'Numero-Solution-4' stamp: 'LK 9/19/2023 00:55:50'!
TestCase subclass: #NumeroTest
	instanceVariableNames: 'zero one two four oneFifth oneHalf five twoFifth twoTwentyfifth fiveHalfs eight negativeOne negativeTwo three'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Solution-4'!
!NumeroTest methodsFor: 'setup' stamp: 'NR 9/30/2018 18:29:17' overrides: 16961394!
setUp

	zero := Entero with: 0.
	one := Entero with: 1.
	two := Entero with: 2.
	three:= Entero with: 3.
	four := Entero with: 4.
	five := Entero with: 5.
	eight := Entero with: 8.
	negativeOne := Entero with: -1.
	negativeTwo := Entero with: -2.
	
	oneHalf := one / two.
	oneFifth := one / five.
	twoFifth := two / five.
	twoTwentyfifth := two / (Entero with: 25).
	fiveHalfs := five / two.
	! !
!NumeroTest methodsFor: 'tests' stamp: 'HAW 5/3/2017 15:49:20'!
shouldRaiseDivideByZeroException: aBlock

	self 
		should: aBlock
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :anError | self assert: anError messageText equals: Numero canNotDivideByZeroErrorDescription ]
	! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 20:11'!
test01isCeroReturnsTrueWhenAskToZero

	self assert: zero isZero! !
!NumeroTest methodsFor: 'tests' stamp: 'HAW 5/3/2017 15:37:57'!
test02isCeroReturnsFalseWhenAskToOthersButZero

	self deny: one isZero.
	self deny: two isZero.! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 20:13'!
test03isOneReturnsTrueWhenAskToOne

	self assert: one isOne! !
!NumeroTest methodsFor: 'tests' stamp: 'HAW 5/3/2017 15:37:46'!
test04isOneReturnsFalseWhenAskToOtherThanOne

	self deny: zero isOne.
	self deny: two isOne.! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 9/30/2018 23:19:11'!
test05EnteroAddsWithEnteroCorrectly

	"Lo correcto seria hacer un test por cada uno de estos asserts ya que son casos distintos.
	Lo hago todo aca para no modificar mucho la estructura del test suite - Hernan"
	self assert: zero + zero equals: zero.
	self assert: zero + one equals: one.
	self assert: zero + two equals: two.
	self assert: zero + negativeTwo equals: negativeTwo.
	
	self assert: one + zero equals: one.
	self assert: one + one equals: two.
	self assert: one + two equals: three.
	self assert: one + negativeTwo equals: negativeOne.
	
	self assert: two + zero equals: two.
	self assert: two + one equals: three.
	self assert: two + two equals: four.
	self assert: two + negativeTwo equals: zero.
	
	self assert: negativeTwo + zero equals: negativeTwo.
	self assert: negativeTwo + one equals: negativeOne.
	self assert: negativeTwo + two equals: zero.
	self assert: negativeTwo + negativeTwo equals: (Entero with: -4).! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 9/30/2018 23:21:17'!
test06EnteroMultipliesWithEnteroCorrectly

	"Lo correcto seria hacer un test por cada uno de estos asserts ya que son casos distintos.
	Lo hago todo aca para no modificar mucho la estructura del test suite - Hernan"
	self assert: zero * zero equals: zero.
	self assert: zero * one equals: zero.
	self assert: zero * two equals: zero.
	self assert: zero * negativeTwo equals: zero.
	
	self assert: one * zero equals: zero.
	self assert: one * one equals: one.
	self assert: one * two equals: two.
	self assert: one * negativeTwo equals: negativeTwo.
	
	self assert: two * zero equals: zero.
	self assert: two * one equals: two.
	self assert: two * two equals: four.
	self assert: two * negativeTwo equals: (Entero with: -4).
	
	self assert: negativeTwo * zero equals: zero.
	self assert: negativeTwo * one equals: negativeTwo.
	self assert: negativeTwo * two equals: (Entero with: -4).
	self assert: negativeTwo * negativeTwo equals: four! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 9/30/2018 23:25:58'!
test07EnteroDividesEnteroCorrectly

	"Lo correcto seria hacer un test por cada uno de estos asserts ya que son casos distintos.
	Lo hago todo aca para no modificar mucho la estructura del test suite - Hernan"
	self shouldRaiseDivideByZeroException: [ zero / zero ].
	self assert: zero / one equals: zero.
	self assert: zero / two equals: zero.
	self assert: zero / negativeTwo equals: zero.
	
	self shouldRaiseDivideByZeroException: [ one / zero ].
	self assert: one / one equals: one.
	self assert: one / two equals: oneHalf.
	self assert: one / negativeTwo equals: oneHalf negated.
	
	self shouldRaiseDivideByZeroException: [ two / zero ].
	self assert: two / one equals: two.
	self assert: two / two equals: one.
	self assert: two / negativeTwo equals: one negated.
	
	self shouldRaiseDivideByZeroException: [ negativeTwo / zero ].
	self assert: negativeTwo / one equals: negativeTwo.
	self assert: negativeTwo / two equals: negativeOne.
	self assert: negativeTwo / negativeTwo equals: one.
	! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 20:38'!
test08FraccionAddsWithFraccionCorrectly
"
    La suma de fracciones es:
	 
	a/b + c/d = (a.d + c.b) / (b.d)
	 
	SI ESTAN PENSANDO EN LA REDUCCION DE FRACCIONES NO SE PREOCUPEN!!
	TODAVIA NO SE ESTA TESTEANDO ESE CASO
"
	| sevenTenths |

	sevenTenths := (Entero with: 7) / (Entero with: 10).

	self assert: oneFifth + oneHalf equals: sevenTenths! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 20:52'!
test09FraccionMultipliesWithFraccionCorrectly
"
    La multiplicacion de fracciones es:
	 
	(a/b) * (c/d) = (a.c) / (b.d)
"

	self assert: oneFifth * twoFifth equals: twoTwentyfifth! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 20:56'!
test10FraccionDividesFraccionCorrectly
"
    La division de fracciones es:
	 
	(a/b) / (c/d) = (a.d) / (b.c)
"

	self assert: oneHalf / oneFifth equals: fiveHalfs! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 9/30/2018 23:27:57'!
test11EnteroAddsFraccionCorrectly

	"Ahora empieza la diversion!!

	Lo correcto seria hacer un test por cada uno de estos asserts ya que son casos distintos.
	Lo hago todo aca para no modificar mucho la estructura del test suite - Hernan"

	self assert: zero + oneFifth equals: oneFifth.
	self assert: one + oneFifth equals:  (Entero with: 6) / five.
	self assert: two + oneFifth equals: (Entero with: 11) / five.
	self assert: negativeTwo + oneFifth equals: (Entero with: -9) / five
	! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 9/30/2018 23:28:45'!
test12FraccionAddsEnteroCorrectly

	"Lo correcto seria hacer un test por cada uno de estos asserts ya que son casos distintos.
	Lo hago todo aca para no modificar mucho la estructura del test suite - Hernan"

	self assert: oneFifth + zero equals: oneFifth.
	self assert: oneFifth + one equals:  (Entero with: 6) / five.
	self assert: oneFifth + two equals: (Entero with: 11) / five.
	self assert: oneFifth + negativeTwo equals: (Entero with: -9) / five.
	! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 9/30/2018 23:29:16'!
test13EnteroMultipliesFraccionCorrectly
	
	"Lo correcto seria hacer un test por cada uno de estos asserts ya que son casos distintos.
	Lo hago todo aca para no modificar mucho la estructura del test suite - Hernan"

	self assert: zero * oneFifth equals: zero.
	self assert: one * oneFifth equals: oneFifth.
	self assert: two * oneFifth equals: twoFifth.
	self assert: negativeTwo * oneFifth equals: twoFifth negated ! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 9/30/2018 23:30:36'!
test14FraccionMultipliesEnteroCorrectly

	"Lo correcto seria hacer un test por cada uno de estos asserts ya que son casos distintos.
	Lo hago todo aca para no modificar mucho la estructura del test suite - Hernan"

	self assert: oneFifth * zero equals: zero.
	self assert: oneFifth * one  equals:  oneFifth.
	self assert: oneFifth * two equals: twoFifth.
	self assert: oneFifth * negativeTwo equals: twoFifth negated ! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 9/30/2018 23:31:12'!
test15EnteroDividesFraccionCorrectly

	"Lo correcto seria hacer un test por cada uno de estos asserts ya que son casos distintos.
	Lo hago todo aca para no modificar mucho la estructura del test suite - Hernan"

	self assert: zero / oneFifth equals: zero.
	self assert: one / oneFifth equals: five.
	self assert: two / oneFifth equals: (Entero with: 10).
	self assert: negativeTwo / oneFifth equals: (Entero with: -10)
! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 9/30/2018 23:32:05'!
test16FraccionDividesEnteroCorrectly

	"Lo correcto seria hacer un test por cada uno de estos asserts ya que son casos distintos.
	Lo hago todo aca para no modificar mucho la estructura del test suite - Hernan"

	self shouldRaiseDivideByZeroException: [ oneFifth / zero ].
	self assert: oneFifth / one equals: oneFifth.
	self assert: oneFifth / two equals: one/ (Entero with: 10).
	self assert: oneFifth / negativeTwo equals: one/ (Entero with: -10)
	

	! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 22:38'!
test17AFraccionCanBeEqualToAnEntero

	self assert: two equals: four / two! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 22:39'!
test18AparentFraccionesAreEqual

	self assert: oneHalf equals: two / four! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 22:40'!
test19AddingFraccionesCanReturnAnEntero

	self assert: oneHalf + oneHalf equals: one! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 22:42'!
test20MultiplyingFraccionesCanReturnAnEntero

	self assert: (two/five) * (five/two) equals: one! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 22:42'!
test21DividingFraccionesCanReturnAnEntero

	self assert: oneHalf / oneHalf equals: one! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 22:43'!
test22DividingEnterosCanReturnAFraccion

	self assert: two / four equals: oneHalf! !
!NumeroTest methodsFor: 'tests' stamp: 'HAW 5/3/2017 15:35:56'!
test23CanNotDivideEnteroByZero

	"Este test ya no tiene sentido porque se esta verificando en los tests de division.
	Lo dejo solo para que se vea que ya no tiene sentido - Hernan
	self 
		should: [ one / zero ]
		raise: Error
		withExceptionDo: [ :anError | self assert: anError messageText equals: Numero canNotDivideByZeroErrorDescription ]
	"! !
!NumeroTest methodsFor: 'tests' stamp: 'HAW 5/3/2017 15:36:09'!
test24CanNotDivideFraccionByZero

	"Este test ya no tiene sentido porque se esta verificando en los tests de division.
	Lo dejo solo para que se vea que ya no tiene sentido - Hernan
	self 
		should: [ oneHalf / zero ]
		raise: Error
		withExceptionDo: [ :anError | self assert: anError messageText equals: Numero canNotDivideByZeroErrorDescription ]
	"	! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 22:50'!
test25AFraccionCanNotBeZero

	self deny: oneHalf isZero! !
!NumeroTest methodsFor: 'tests' stamp: 'HernanWilkinson 5/7/2016 22:50'!
test26AFraccionCanNotBeOne

	self deny: oneHalf isOne! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 10/1/2018 00:09:23'!
test27BisEnteroSubstractsEnteroCorrecty
	
	"Lo correcto seria hacer un test por cada uno de estos asserts ya que son casos distintos.
	Lo hago todo aca para no modificar mucho la estructura del test suite "
	
	self assert: zero - zero equals: zero.
	self assert: zero - one equals: negativeOne.
	self assert: zero - two equals: negativeTwo.
	self assert: zero - negativeTwo equals: two.
	
	self assert: one - zero equals: one.
	self assert: one - one equals: zero.
	self assert: one - two equals: negativeOne.
	self assert: one - negativeTwo equals: three.
	
	self assert: two - zero equals: two.
	self assert: two - one equals: one.
	self assert: two - two equals: zero.
	self assert: two - negativeTwo equals: four.
	
	self assert: negativeTwo - zero equals: negativeTwo.
	self assert: negativeTwo - one equals: three negated.
	self assert: negativeTwo - two equals: four negated.
	self assert: negativeTwo - negativeTwo equals: zero! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 9/30/2018 23:37:54'!
test27ZeroDivideAnythingIsZero

	"Este test ya no tiene sentido porque se esta verificando en los tests de division.
	Lo dejo solo para que se vea que ya no tiene sentido - Hernan
	
	self assert: zero / one equals: zero
	"! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 9/30/2018 18:27:15'!
test28FraccionSubstractsFraccionCorrectly
	
	self assert: twoFifth - oneFifth equals: oneFifth.! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 9/30/2018 23:52:59'!
test29EnteroSubstractsFraccionCorrectly

	"Lo correcto seria hacer un test por cada uno de estos asserts ya que son casos distintos.
	Lo hago todo aca para no modificar mucho la estructura del test suite"

	self assert: zero - oneHalf equals: oneHalf negated.
	self assert: one - oneHalf equals: oneHalf.
	self assert: two - oneHalf equals: three / two.
	self assert: negativeTwo - oneHalf equals: five negated / two! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 9/30/2018 23:58:36'!
test30FraccionSubstractsEnteroCorrectly

	"Lo correcto seria hacer un test por cada uno de estos asserts ya que son casos distintos.
	Lo hago todo aca para no modificar mucho la estructura del test suite"

	| sixFifth |
	
	sixFifth := (Entero with: 6) / (Entero with: 5).
	
	self assert: sixFifth - zero equals: sixFifth.
	self assert: sixFifth - one equals: oneFifth.
	self assert: sixFifth - two equals: (Entero with: -4) / (Entero with: 5).
	self assert: sixFifth - negativeTwo equals: (Entero with: 16) / (Entero with: 5)
	! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 9/30/2018 18:27:51'!
test31SubstractingFraccionesCanReturnAnEntero

	| threeHalfs |
	
	threeHalfs := (Entero with: 3) / (Entero with: 2).
	
	self assert: threeHalfs - oneHalf equals: one.! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 9/30/2018 18:28:02'!
test32SubstractingSameEnterosReturnsZero

	self assert: one - one equals: zero.! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 9/30/2018 18:28:10'!
test33SubstractingSameFraccionesReturnsZero

	self assert: oneHalf - oneHalf equals: zero.! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 9/30/2018 18:28:17'!
test34SubstractingAHigherValueToANumberReturnsANegativeNumber

	| negativeThreeHalfs |
	
	negativeThreeHalfs := (Entero with: -3) / (Entero with: 2).	

	self assert: one - fiveHalfs equals: negativeThreeHalfs.! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 9/30/2018 18:28:24'!
test35FibonacciZeroIsOne

	self assert: zero fibonacci equals: one! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 9/30/2018 18:28:31'!
test36FibonacciOneIsOne

	self assert: one fibonacci equals: one! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 9/30/2018 18:29:42'!
test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros

	self assert: four fibonacci equals: five.
	self assert: three fibonacci equals: three. 
	self assert: five fibonacci equals: four fibonacci + three fibonacci.! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 9/30/2018 18:29:51'!
test38FibonacciNotDefinedForNegativeNumbers

	self 
		should: [negativeOne fibonacci]
		raise: Error
		withExceptionDo: [ :anError | self assert: anError messageText equals: Entero negativeFibonacciErrorDescription ].! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 9/30/2018 18:29:58'!
test39NegationOfEnteroIsCorrect

	self assert: two negated equals: negativeTwo.! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 9/30/2018 18:30:05'!
test40NegationOfFraccionIsCorrect

	self assert: oneHalf negated equals: negativeOne / two.
		! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 9/30/2018 18:30:27'!
test41SignIsCorrectlyAssignedToFractionWithTwoNegatives

	self assert: oneHalf equals: (negativeOne / negativeTwo)
		! !
!NumeroTest methodsFor: 'tests' stamp: 'NR 9/30/2018 18:30:37'!
test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor

	self assert: oneHalf negated equals: (one / negativeTwo)
	
		! !

!classDefinition: #Numero category: 'Numero-Solution-4' stamp: 'LK 9/19/2023 00:55:56'!
Object subclass: #Numero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Solution-4'!

!classDefinition: #Numero category: 'Numero-Solution-4' stamp: 'LK 9/19/2023 00:55:56'!
Object subclass: #Numero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Solution-4'!
!Numero methodsFor: 'arithmetic operations' stamp: 'HernanWilkinson 5/7/2016 22:48'!
* aMultiplier

	self subclassResponsibility ! !
!Numero methodsFor: 'arithmetic operations' stamp: 'HernanWilkinson 5/7/2016 22:49'!
+ anAdder

	self subclassResponsibility ! !
!Numero methodsFor: 'arithmetic operations' stamp: 'NR 9/30/2018 20:22:19'!
- anAdder

	self subclassResponsibility ! !
!Numero methodsFor: 'arithmetic operations' stamp: 'HernanWilkinson 5/7/2016 22:49'!
/ aDivisor

	self subclassResponsibility ! !
!Numero methodsFor: 'arithmetic operations' stamp: 'NR 9/30/2018 20:21:50'!
negated
	
	^self * (Entero with: -1)! !
!Numero methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:53:47'!
addToEnteroMenosUnoYCeroNegativo: anAdder

	self subclassResponsibility ! !
!Numero methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:54:02'!
addToEnteroMenosUnoYCeroPositivo: anAdder

	self subclassResponsibility ! !
!Numero methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:54:20'!
addToFraccion: anAdder

	self subclassResponsibility ! !
!Numero methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:54:42'!
addToUno: anAdder

	self subclassResponsibility ! !
!Numero methodsFor: 'arithmetic operations - private' stamp: 'HAW 5/3/2017 18:05:01'!
divideCero: aDividend

	self subclassResponsibility ! !
!Numero methodsFor: 'arithmetic operations - private' stamp: 'NR 10/1/2018 00:11:50'!
divideEnteroMenosUnoYCeroNegativo: aDividend

	self subclassResponsibility ! !
!Numero methodsFor: 'arithmetic operations - private' stamp: 'NR 10/1/2018 00:11:41'!
divideEnteroMenosUnoYCeroPositivo: aDividend

	self subclassResponsibility ! !
!Numero methodsFor: 'arithmetic operations - private' stamp: 'HernanWilkinson 5/7/2016 23:10'!
divideFraccion: aDividend

	self subclassResponsibility ! !
!Numero methodsFor: 'arithmetic operations - private' stamp: 'HAW 5/3/2017 18:05:35'!
divideUno: aDividend

	self subclassResponsibility ! !
!Numero methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:55:08'!
multiplyToEnteroMenosUnoYCeroNegativo: aMultiplier

	self subclassResponsibility ! !
!Numero methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:55:26'!
multiplyToEnteroMenosUnoYCeroPositivo: aMultiplier

	self subclassResponsibility ! !
!Numero methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:55:17'!
multiplyToFraccion: aMultiplier

	self subclassResponsibility ! !
!Numero methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:55:52'!
substractFromEnteroMenosUnoYCeroNegativo: aMinuend

	self subclassResponsibility ! !
!Numero methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:56:36'!
substractFromEnteroMenosUnoYCeroPositivo: aMinuend

	self subclassResponsibility ! !
!Numero methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:56:02'!
substractFromFraccion: aMinuend

	self subclassResponsibility ! !
!Numero methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:56:11'!
substractFromUno: aMinuend

	self subclassResponsibility ! !
!Numero methodsFor: 'testing' stamp: 'NR 10/1/2018 01:31:46'!
isNegative

	self subclassResponsibility ! !
!Numero methodsFor: 'testing' stamp: 'HernanWilkinson 5/7/2016 22:49'!
isOne

	self subclassResponsibility ! !
!Numero methodsFor: 'testing' stamp: 'HernanWilkinson 5/7/2016 22:49'!
isZero

	self subclassResponsibility ! !

!classDefinition: 'Numero class' category: 'Numero-Solution-4' stamp: 'LK 9/19/2023 00:56:00'!
Numero class
	instanceVariableNames: ''!

!classDefinition: 'Numero class' category: 'Numero-Solution-4' stamp: 'LK 9/19/2023 00:56:00'!
Numero class
	instanceVariableNames: ''!
!Numero class methodsFor: 'error descriptions' stamp: 'HernanWilkinson 5/7/2016 22:45'!
canNotDivideByZeroErrorDescription

	^'No se puede dividir por cero'! !

!classDefinition: #Entero category: 'Numero-Solution-4' stamp: 'LK 9/19/2023 00:56:00'!
Numero subclass: #Entero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Solution-4'!

!classDefinition: #Entero category: 'Numero-Solution-4' stamp: 'LK 9/19/2023 00:56:00'!
Numero subclass: #Entero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Solution-4'!
!Entero methodsFor: 'arithmetic operations' stamp: 'HAW 5/2/2017 17:13:09'!
// aDivisor 
	
	^self class with: self integerValue // aDivisor integerValue
	! !
!Entero methodsFor: 'arithmetic operations' stamp: 'NR 9/30/2018 20:26:03'!
fibonacci

	self subclassResponsibility ! !
!Entero methodsFor: 'arithmetic operations' stamp: 'HAW 5/2/2017 17:19:13'!
greatestCommonDivisorWith: anEntero 
	
	self subclassResponsibility ! !
!Entero methodsFor: 'arithmetic operations - private' stamp: 'HAW 5/2/2017 17:43:13'!
asDenominatorOf: aNumerator

	self subclassResponsibility ! !
!Entero methodsFor: 'value' stamp: 'HAW 5/2/2017 17:21:12'!
integerValue

	"Usamos integerValue en vez de value para que no haya problemas con el mensaje value implementado en Object - Hernan"
	
	self subclassResponsibility ! !
!Entero methodsFor: 'printing' stamp: 'NR 10/1/2018 09:19:26' overrides: 16902975!
printOn: aStream

	aStream print: self integerValue ! !

!classDefinition: 'Entero class' category: 'Numero-Solution-4' stamp: 'LK 9/19/2023 00:56:01'!
Entero class
	instanceVariableNames: ''!

!classDefinition: 'Entero class' category: 'Numero-Solution-4' stamp: 'LK 9/19/2023 00:56:01'!
Entero class
	instanceVariableNames: ''!
!Entero class methodsFor: 'error descriptions' stamp: 'NR 9/30/2018 20:12:01'!
negativeFibonacciErrorDescription
	
	^ ' Fibonacci no está definido aquí para enteros negativos'! !
!Entero class methodsFor: 'instance creation' stamp: 'NR 10/1/2018 16:05:03'!
with: aValue 
	
	"Esta verificacion esta puesta por si se equivocan y quieren crear un Entero pasando otra cosa que un Integer - Hernan"
	aValue isInteger ifFalse: [  self error: 'aValue debe ser anInteger' ].
	
	aValue = 0 ifTrue: [ ^Cero new ].
	aValue = 1 ifTrue: [ ^Uno new ].
	aValue < 0 ifTrue: [ ^Negativo safeWith: aValue].
	 
	^ PositivoMayorAUno safeWith: aValue
	! !

!classDefinition: #Cero category: 'Numero-Solution-4' stamp: 'LK 9/19/2023 00:56:01'!
Entero subclass: #Cero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Solution-4'!

!classDefinition: #Cero category: 'Numero-Solution-4' stamp: 'LK 9/19/2023 00:56:01'!
Entero subclass: #Cero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Solution-4'!
!Cero methodsFor: 'arithmetic operations' stamp: 'HAW 5/2/2017 17:31:30' overrides: 50658298!
* aMultiplier 
	
	^self! !
!Cero methodsFor: 'arithmetic operations' stamp: 'HAW 5/2/2017 17:31:48' overrides: 50658303!
+ anAdder 
	
	^anAdder! !
!Cero methodsFor: 'arithmetic operations' stamp: 'NR 9/30/2018 20:21:13' overrides: 50658307!
- aSubtrahend
	
	^aSubtrahend negated! !
!Cero methodsFor: 'arithmetic operations' stamp: 'HAW 5/3/2017 12:40:57' overrides: 50658312!
/ aDivisor 
	
	^aDivisor divideCero: self! !
!Cero methodsFor: 'arithmetic operations' stamp: 'HAW 5/3/2017 18:14:09' overrides: 50658447!
// aDivisor

	^self! !
!Cero methodsFor: 'arithmetic operations' stamp: 'NR 9/30/2018 20:27:31' overrides: 50658452!
fibonacci

	^ Entero with: 1! !
!Cero methodsFor: 'arithmetic operations' stamp: 'HAW 5/2/2017 17:14:45' overrides: 50658456!
greatestCommonDivisorWith: anEntero 
	
	^ anEntero ! !
!Cero methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:53:47' overrides: 50658320!
addToEnteroMenosUnoYCeroNegativo: anAdder

	^ anAdder 
	
	! !
!Cero methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:54:02' overrides: 50658326!
addToEnteroMenosUnoYCeroPositivo: anAdder

	^ anAdder 
	
	! !
!Cero methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:54:20' overrides: 50658332!
addToFraccion: anAdder 
	
	^ anAdder ! !
!Cero methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:54:42' overrides: 50658337!
addToUno: anAdder 
	
	^ anAdder ! !
!Cero methodsFor: 'arithmetic operations - private' stamp: 'HAW 5/3/2017 15:56:43' overrides: 50658461!
asDenominatorOf: aNumerator

	self signalCanNotDivideByZero ! !
!Cero methodsFor: 'arithmetic operations - private' stamp: 'HAW 5/3/2017 15:56:50' overrides: 50658342!
divideCero: aCero 
	
	self signalCanNotDivideByZero ! !
!Cero methodsFor: 'arithmetic operations - private' stamp: 'NR 9/30/2018 18:37:05' overrides: 50658347!
divideEnteroMenosUnoYCeroNegativo: aDividend

	self signalCanNotDivideByZero ! !
!Cero methodsFor: 'arithmetic operations - private' stamp: 'NR 9/30/2018 18:37:00' overrides: 50658353!
divideEnteroMenosUnoYCeroPositivo: aDividend

	self signalCanNotDivideByZero ! !
!Cero methodsFor: 'arithmetic operations - private' stamp: 'HAW 5/3/2017 15:57:14' overrides: 50658359!
divideFraccion: aDividend

	self signalCanNotDivideByZero ! !
!Cero methodsFor: 'arithmetic operations - private' stamp: 'HAW 5/3/2017 15:49:51' overrides: 50658364!
divideUno: anUno 
	
	self signalCanNotDivideByZero! !
!Cero methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:55:08' overrides: 50658369!
multiplyToEnteroMenosUnoYCeroNegativo: aMultiplier

	^self! !
!Cero methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:55:26' overrides: 50658375!
multiplyToEnteroMenosUnoYCeroPositivo: aMultiplier

	^self! !
!Cero methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:55:17' overrides: 50658381!
multiplyToFraccion: aMultiplier

	^self
	! !
!Cero methodsFor: 'arithmetic operations - private' stamp: 'HAW 5/3/2017 15:50:07'!
signalCanNotDivideByZero
	
	self error: self class canNotDivideByZeroErrorDescription ! !
!Cero methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:55:52' overrides: 50658386!
substractFromEnteroMenosUnoYCeroNegativo: aMinuend

	^ aMinuend 
	
	! !
!Cero methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:56:36' overrides: 50658392!
substractFromEnteroMenosUnoYCeroPositivo: aMinuend

	^ aMinuend 
	
	! !
!Cero methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:56:02' overrides: 50658398!
substractFromFraccion: aMinuend

	^ aMinuend 
	
	! !
!Cero methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:56:11' overrides: 50658403!
substractFromUno: aMinuend

	^ aMinuend 
	
	! !
!Cero methodsFor: 'value' stamp: 'HAW 5/2/2017 17:11:32' overrides: 50658465!
integerValue

	^0! !
!Cero methodsFor: 'testing' stamp: 'NR 10/1/2018 01:32:56' overrides: 50658407!
isNegative
	
	^false! !
!Cero methodsFor: 'testing' stamp: 'HAW 5/2/2017 17:22:15' overrides: 50658411!
isOne

	^false! !
!Cero methodsFor: 'testing' stamp: 'HAW 5/2/2017 17:22:09' overrides: 50658415!
isZero

	^true! !

!classDefinition: 'Cero class' category: 'Numero-Solution-4' stamp: 'LK 9/19/2023 00:56:05'!
Cero class
	instanceVariableNames: 'uniqueInstance'!

!classDefinition: 'Cero class' category: 'Numero-Solution-4' stamp: 'LK 9/19/2023 00:56:05'!
Cero class
	instanceVariableNames: 'uniqueInstance'!
!Cero class methodsFor: 'initialization' stamp: 'HAW 5/3/2017 18:11:21' overrides: 16904184!
initialize

	uniqueInstance := self basicNew! !
!Cero class methodsFor: 'instance creation' stamp: 'HAW 5/3/2017 18:10:38' overrides: 16785646!
new

	^uniqueInstance! !

!classDefinition: #EnteroMenosCeroYUno category: 'Numero-Solution-4' stamp: 'LK 9/19/2023 00:56:05'!
Entero subclass: #EnteroMenosCeroYUno
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Solution-4'!

!classDefinition: #EnteroMenosCeroYUno category: 'Numero-Solution-4' stamp: 'LK 9/19/2023 00:56:05'!
Entero subclass: #EnteroMenosCeroYUno
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Solution-4'!
!EnteroMenosCeroYUno methodsFor: 'comparing' stamp: 'NR 10/1/2018 00:21:11' overrides: 16901772!
= anObject

	^(anObject isKindOf: self class) and: [ value = anObject integerValue ]! !
!EnteroMenosCeroYUno methodsFor: 'comparing' stamp: 'NR 10/1/2018 00:24:26' overrides: 16901788!
hash

	^value hash! !
!EnteroMenosCeroYUno methodsFor: 'arithmetic operations' stamp: 'NR 10/1/2018 00:23:08' overrides: 50658456!
greatestCommonDivisorWith: anEntero 
	
	^self class with: (value gcd: anEntero integerValue)! !
!EnteroMenosCeroYUno methodsFor: 'testing' stamp: 'NR 10/1/2018 00:24:50' overrides: 50658411!
isOne

	^false! !
!EnteroMenosCeroYUno methodsFor: 'testing' stamp: 'NR 10/1/2018 00:25:00' overrides: 50658415!
isZero

	^false! !
!EnteroMenosCeroYUno methodsFor: 'value' stamp: 'NR 10/1/2018 00:29:16' overrides: 50658465!
integerValue
	
	^value! !
!EnteroMenosCeroYUno methodsFor: 'initialization' stamp: 'NR 10/1/2018 00:31:00'!
initializeSafeWith: aValue 
	
	value := aValue! !

!classDefinition: 'EnteroMenosCeroYUno class' category: 'Numero-Solution-4' stamp: 'LK 9/19/2023 00:56:06'!
EnteroMenosCeroYUno class
	instanceVariableNames: ''!

!classDefinition: 'EnteroMenosCeroYUno class' category: 'Numero-Solution-4' stamp: 'LK 9/19/2023 00:56:06'!
EnteroMenosCeroYUno class
	instanceVariableNames: ''!
!EnteroMenosCeroYUno class methodsFor: 'instance creation - private' stamp: 'NR 10/1/2018 00:30:31'!
safeWith: anIntegerValue

	"Solo debe ser enviado este mensaje cuando es seguro que anIntegerValue es distinto de 0 y 1,
	y solo debe ser enviado desde la misma jerarquia - Hernan"
	
	^self new initializeSafeWith: anIntegerValue ! !

!classDefinition: #Negativo category: 'Numero-Solution-4' stamp: 'LK 9/19/2023 00:56:06'!
EnteroMenosCeroYUno subclass: #Negativo
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Solution-4'!

!classDefinition: #Negativo category: 'Numero-Solution-4' stamp: 'LK 9/19/2023 00:56:06'!
EnteroMenosCeroYUno subclass: #Negativo
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Solution-4'!
!Negativo methodsFor: 'arithmetic operations' stamp: 'NR 9/14/2023 07:55:08' overrides: 50658298!
* aMultiplier 
	
	^aMultiplier multiplyToEnteroMenosUnoYCeroNegativo: self ! !
!Negativo methodsFor: 'arithmetic operations' stamp: 'NR 9/14/2023 07:53:47' overrides: 50658303!
+ anAdder 
	
	^anAdder addToEnteroMenosUnoYCeroNegativo: self.
	! !
!Negativo methodsFor: 'arithmetic operations' stamp: 'NR 9/14/2023 07:55:52' overrides: 50658307!
- anAdder 
	
	^anAdder substractFromEnteroMenosUnoYCeroNegativo: self.
	! !
!Negativo methodsFor: 'arithmetic operations' stamp: 'NR 9/30/2018 20:59:18' overrides: 50658312!
/ aDivisor 
	
	^aDivisor divideEnteroMenosUnoYCeroNegativo: self! !
!Negativo methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:53:47' overrides: 50658320!
addToEnteroMenosUnoYCeroNegativo: anAdder

	^self class safeWith: value + anAdder integerValue ! !
!Negativo methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:54:02' overrides: 50658326!
addToEnteroMenosUnoYCeroPositivo: anAdder

	^Entero with: value + anAdder integerValue ! !
!Negativo methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:54:20' overrides: 50658332!
addToFraccion: anAdder

	^self + anAdder 
	! !
!Negativo methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:54:42' overrides: 50658337!
addToUno: anAdder 
	
	"Si soy -1 daria 0, por eso envia mensaje a Entero y no a self class - Hernan"
	
	^Entero with: 1 + value ! !
!Negativo methodsFor: 'arithmetic operations - private' stamp: 'NR 9/30/2018 19:36:31' overrides: 50658342!
divideCero: aDividend 
	
	^ aDividend ! !
!Negativo methodsFor: 'arithmetic operations - private' stamp: 'NR 9/30/2018 20:27:56' overrides: 50658347!
divideEnteroMenosUnoYCeroNegativo: aDividend 
	
	^ aDividend negated / self negated ! !
!Negativo methodsFor: 'arithmetic operations - private' stamp: 'NR 9/30/2018 20:22:05' overrides: 50658353!
divideEnteroMenosUnoYCeroPositivo: aDividend 
	
	^ aDividend negated / self negated ! !
!Negativo methodsFor: 'arithmetic operations - private' stamp: 'NR 9/30/2018 20:33:02' overrides: 50658359!
divideFraccion: aDividend

	^aDividend numerator negated / (aDividend denominator * self negated) ! !
!Negativo methodsFor: 'arithmetic operations - private' stamp: 'NR 9/30/2018 20:32:28' overrides: 50658364!
divideUno: aDividend
	
	^Fraccion safeWith: aDividend negated over: self negated! !
!Negativo methodsFor: 'arithmetic operations - private' stamp: 'NR 9/30/2018 22:47:27' overrides: 50658452!
fibonacci
	
	^ self error: Entero negativeFibonacciErrorDescription ! !
!Negativo methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:55:08' overrides: 50658369!
multiplyToEnteroMenosUnoYCeroNegativo: aMultiplier

	^PositivoMayorAUno safeWith: value * aMultiplier integerValue ! !
!Negativo methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:55:26' overrides: 50658375!
multiplyToEnteroMenosUnoYCeroPositivo: aMultiplier

	^self class safeWith: value * aMultiplier integerValue ! !
!Negativo methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:55:17' overrides: 50658381!
multiplyToFraccion: aMultiplier

	^self * aMultiplier ! !
!Negativo methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:55:52' overrides: 50658386!
substractFromEnteroMenosUnoYCeroNegativo: aMinuend

	^Entero with: aMinuend integerValue - value ! !
!Negativo methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:56:36' overrides: 50658392!
substractFromEnteroMenosUnoYCeroPositivo: aMinuend

	^PositivoMayorAUno safeWith: aMinuend integerValue - value ! !
!Negativo methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:56:02' overrides: 50658398!
substractFromFraccion: aMinuend

	^aMinuend numerator - (self * aMinuend denominator) / (aMinuend denominator)
	! !
!Negativo methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:56:11' overrides: 50658403!
substractFromUno: aMinuend

	^PositivoMayorAUno safeWith: 1 - value ! !
!Negativo methodsFor: 'testing' stamp: 'NR 10/1/2018 01:34:37' overrides: 50658407!
isNegative
	
	^true! !

!classDefinition: #PositivoMayorAUno category: 'Numero-Solution-4' stamp: 'LK 9/19/2023 00:56:09'!
EnteroMenosCeroYUno subclass: #PositivoMayorAUno
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Solution-4'!

!classDefinition: #PositivoMayorAUno category: 'Numero-Solution-4' stamp: 'LK 9/19/2023 00:56:09'!
EnteroMenosCeroYUno subclass: #PositivoMayorAUno
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Solution-4'!
!PositivoMayorAUno methodsFor: 'arithmetic operations' stamp: 'NR 9/14/2023 07:55:26' overrides: 50658298!
* aMultiplier 
	
	^aMultiplier multiplyToEnteroMenosUnoYCeroPositivo: self ! !
!PositivoMayorAUno methodsFor: 'arithmetic operations' stamp: 'NR 9/14/2023 07:54:03' overrides: 50658303!
+ anAdder 
	
	^anAdder addToEnteroMenosUnoYCeroPositivo: self.
	! !
!PositivoMayorAUno methodsFor: 'arithmetic operations' stamp: 'NR 9/14/2023 07:56:37' overrides: 50658307!
- anAdder 
	
	^anAdder substractFromEnteroMenosUnoYCeroPositivo: self.
	! !
!PositivoMayorAUno methodsFor: 'arithmetic operations' stamp: 'NR 9/30/2018 21:49:30' overrides: 50658312!
/ aDivisor 
	
	^aDivisor divideEnteroMenosUnoYCeroPositivo: self! !
!PositivoMayorAUno methodsFor: 'arithmetic operations' stamp: 'NR 9/30/2018 22:48:12' overrides: 50658452!
fibonacci

	| one two |
	
	one := Entero with: 1.
	two := Entero with: 2.

	^ (self - one) fibonacci + (self - two) fibonacci! !
!PositivoMayorAUno methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:53:47' overrides: 50658320!
addToEnteroMenosUnoYCeroNegativo: anAdder

	^Entero with: value + anAdder integerValue ! !
!PositivoMayorAUno methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:54:02' overrides: 50658326!
addToEnteroMenosUnoYCeroPositivo: anAdder

	^self class safeWith: value + anAdder integerValue ! !
!PositivoMayorAUno methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:54:20' overrides: 50658332!
addToFraccion: anAdder

	^self + anAdder 
	! !
!PositivoMayorAUno methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:54:42' overrides: 50658337!
addToUno: anAdder 
	
	^self class safeWith: 1 + value ! !
!PositivoMayorAUno methodsFor: 'arithmetic operations - private' stamp: 'NR 9/30/2018 22:09:09' overrides: 50658461!
asDenominatorOf: aNumerator

	^Fraccion safeWith: aNumerator over: self
! !
!PositivoMayorAUno methodsFor: 'arithmetic operations - private' stamp: 'NR 9/30/2018 21:36:02' overrides: 50658342!
divideCero: aDividend 
	
	^ aDividend ! !
!PositivoMayorAUno methodsFor: 'arithmetic operations - private' stamp: 'NR 9/30/2018 22:32:03' overrides: 50658347!
divideEnteroMenosUnoYCeroNegativo: aDividend 
	
	| denominator greatestCommonDivisor numerator |
	
	greatestCommonDivisor := aDividend greatestCommonDivisorWith: self. 
	numerator := aDividend // greatestCommonDivisor.
	denominator := self // greatestCommonDivisor.
	
	^denominator asDenominatorOf: numerator	! !
!PositivoMayorAUno methodsFor: 'arithmetic operations - private' stamp: 'NR 9/30/2018 22:31:36' overrides: 50658353!
divideEnteroMenosUnoYCeroPositivo: aDividend 
	
 	| denominator greatestCommonDivisor numerator |
	
	greatestCommonDivisor := aDividend greatestCommonDivisorWith: self. 
	numerator := aDividend // greatestCommonDivisor.
	denominator := self // greatestCommonDivisor.
	
	^denominator asDenominatorOf: numerator	 ! !
!PositivoMayorAUno methodsFor: 'arithmetic operations - private' stamp: 'NR 9/30/2018 22:10:20' overrides: 50658359!
divideFraccion: aDividend

	^aDividend numerator / (aDividend denominator * self) ! !
!PositivoMayorAUno methodsFor: 'arithmetic operations - private' stamp: 'NR 9/30/2018 22:10:30' overrides: 50658364!
divideUno: aDividend
	
	^Fraccion safeWith: aDividend over: self! !
!PositivoMayorAUno methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:55:08' overrides: 50658369!
multiplyToEnteroMenosUnoYCeroNegativo: aMultiplier

	^Negativo safeWith: value * aMultiplier integerValue ! !
!PositivoMayorAUno methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:55:26' overrides: 50658375!
multiplyToEnteroMenosUnoYCeroPositivo: aMultiplier

	^self class safeWith: value * aMultiplier integerValue ! !
!PositivoMayorAUno methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:55:17' overrides: 50658381!
multiplyToFraccion: aMultiplier

	^self * aMultiplier ! !
!PositivoMayorAUno methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:55:52' overrides: 50658386!
substractFromEnteroMenosUnoYCeroNegativo: aMinuend

	^Negativo safeWith: aMinuend integerValue - value ! !
!PositivoMayorAUno methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:56:36' overrides: 50658392!
substractFromEnteroMenosUnoYCeroPositivo: aMinuend

	^Entero with: aMinuend integerValue - value ! !
!PositivoMayorAUno methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:56:02' overrides: 50658398!
substractFromFraccion: aMinuend

	^aMinuend numerator - (self * aMinuend denominator) / (aMinuend denominator). 
	! !
!PositivoMayorAUno methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:56:11' overrides: 50658403!
substractFromUno: aMinuend

	^Entero with: 1 - value ! !
!PositivoMayorAUno methodsFor: 'testing' stamp: 'NR 10/1/2018 01:35:52' overrides: 50658407!
isNegative
	
	^false! !

!classDefinition: #Uno category: 'Numero-Solution-4' stamp: 'LK 9/19/2023 00:56:13'!
Entero subclass: #Uno
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Solution-4'!

!classDefinition: #Uno category: 'Numero-Solution-4' stamp: 'LK 9/19/2023 00:56:13'!
Entero subclass: #Uno
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Solution-4'!
!Uno methodsFor: 'arithmetic operations' stamp: 'HAW 5/2/2017 17:33:00' overrides: 50658298!
* aMultiplier 
	
	^aMultiplier ! !
!Uno methodsFor: 'arithmetic operations' stamp: 'NR 9/14/2023 07:54:42' overrides: 50658303!
+ anAdder 
	
	^anAdder addToUno: self.
	! !
!Uno methodsFor: 'arithmetic operations' stamp: 'NR 9/14/2023 07:56:11' overrides: 50658307!
- anAdder 
	
	^anAdder substractFromUno: self.
	! !
!Uno methodsFor: 'arithmetic operations' stamp: 'HAW 5/3/2017 12:56:15' overrides: 50658312!
/ aDivisor 
	
	^aDivisor divideUno: self! !
!Uno methodsFor: 'arithmetic operations' stamp: 'HAW 5/2/2017 17:15:00' overrides: 50658456!
greatestCommonDivisorWith: anEntero 
	
	^self 
	! !
!Uno methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:53:47' overrides: 50658320!
addToEnteroMenosUnoYCeroNegativo: anAdder

	^Entero with: 1 + anAdder integerValue ! !
!Uno methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:54:02' overrides: 50658326!
addToEnteroMenosUnoYCeroPositivo: anAdder

	^PositivoMayorAUno safeWith: 1 + anAdder integerValue ! !
!Uno methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:54:20' overrides: 50658332!
addToFraccion: anAdder

	^ anAdder denominator + anAdder numerator / anAdder denominator ! !
!Uno methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:54:42' overrides: 50658337!
addToUno: anAdder

	^PositivoMayorAUno safeWith: 2! !
!Uno methodsFor: 'arithmetic operations - private' stamp: 'HAW 5/2/2017 17:42:16' overrides: 50658461!
asDenominatorOf: aNumerator

	^aNumerator ! !
!Uno methodsFor: 'arithmetic operations - private' stamp: 'HAW 5/3/2017 16:03:52' overrides: 50658342!
divideCero: aDividend 
	
	^aDividend ! !
!Uno methodsFor: 'arithmetic operations - private' stamp: 'NR 9/30/2018 19:44:42' overrides: 50658347!
divideEnteroMenosUnoYCeroNegativo: aDividend

	^aDividend ! !
!Uno methodsFor: 'arithmetic operations - private' stamp: 'NR 9/30/2018 19:44:28' overrides: 50658353!
divideEnteroMenosUnoYCeroPositivo: aDividend

	^aDividend ! !
!Uno methodsFor: 'arithmetic operations - private' stamp: 'HAW 5/2/2017 17:57:49' overrides: 50658359!
divideFraccion: aDividend

	^aDividend ! !
!Uno methodsFor: 'arithmetic operations - private' stamp: 'HAW 5/3/2017 16:04:05' overrides: 50658364!
divideUno: aDividend 
	
	^self! !
!Uno methodsFor: 'arithmetic operations - private' stamp: 'NR 9/30/2018 22:48:43' overrides: 50658452!
fibonacci
	
	^ self		! !
!Uno methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:55:08' overrides: 50658369!
multiplyToEnteroMenosUnoYCeroNegativo: aMultiplier

	^aMultiplier ! !
!Uno methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:55:26' overrides: 50658375!
multiplyToEnteroMenosUnoYCeroPositivo: aMultiplier

	^aMultiplier ! !
!Uno methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:55:17' overrides: 50658381!
multiplyToFraccion: aMultiplier

	^aMultiplier ! !
!Uno methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:55:52' overrides: 50658386!
substractFromEnteroMenosUnoYCeroNegativo: aMinuend

	^Negativo safeWith: aMinuend integerValue - 1  ! !
!Uno methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:56:37' overrides: 50658392!
substractFromEnteroMenosUnoYCeroPositivo: aMinuend

	^Entero with: aMinuend integerValue - 1 ! !
!Uno methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:56:02' overrides: 50658398!
substractFromFraccion: aMinuend

	^ aMinuend numerator - aMinuend denominator / aMinuend denominator ! !
!Uno methodsFor: 'arithmetic operations - private' stamp: 'NR 9/14/2023 07:56:11' overrides: 50658403!
substractFromUno: anAdder

	^Entero with: 0! !
!Uno methodsFor: 'value' stamp: 'HAW 5/2/2017 17:11:39' overrides: 50658465!
integerValue

	^1! !
!Uno methodsFor: 'testing' stamp: 'NR 10/1/2018 01:33:27' overrides: 50658407!
isNegative

	^false! !
!Uno methodsFor: 'testing' stamp: 'HAW 5/2/2017 17:22:43' overrides: 50658411!
isOne

	^true! !
!Uno methodsFor: 'testing' stamp: 'HAW 5/2/2017 17:22:39' overrides: 50658415!
isZero

	^false! !

!classDefinition: 'Uno class' category: 'Numero-Solution-4' stamp: 'LK 9/19/2023 00:56:17'!
Uno class
	instanceVariableNames: 'uniqueInstance'!

!classDefinition: 'Uno class' category: 'Numero-Solution-4' stamp: 'LK 9/19/2023 00:56:17'!
Uno class
	instanceVariableNames: 'uniqueInstance'!
!Uno class methodsFor: 'initialization' stamp: 'HAW 5/3/2017 18:12:13' overrides: 16904184!
initialize

	uniqueInstance := self basicNew ! !
!Uno class methodsFor: 'instance creation' stamp: 'HAW 5/3/2017 18:11:48' overrides: 16785646!
new

	^uniqueInstance! !

!classDefinition: #Fraccion category: 'Numero-Solution-4' stamp: 'LK 9/19/2023 00:56:18'!
Numero subclass: #Fraccion
	instanceVariableNames: 'numerator denominator'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Solution-4'!

!classDefinition: #Fraccion category: 'Numero-Solution-4' stamp: 'LK 9/19/2023 00:56:18'!
Numero subclass: #Fraccion
	instanceVariableNames: 'numerator denominator'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Numero-Solution-4'!
!Fraccion methodsFor: 'initialization' stamp: 'HAW 5/3/2017 16:16:31'!
initializeSafeWith: aNumerator over: aDenominator

	"Estas precondiciones estan por si se comenten errores en la implementacion durante la 
	realizacion del ejercicio, sino por como creacion esto no podria pasar - Hernan"
	aNumerator isZero ifTrue: [ self error: 'una fraccion no puede ser cero' ].
	aDenominator isOne ifTrue: [ self error: 'una fraccion no puede tener denominador 1 porque sino es un entero' ].
	
	numerator := aNumerator.
	denominator := aDenominator ! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'NR 9/14/2023 07:55:17' overrides: 50658298!
* aMultiplier 
	
	^aMultiplier multiplyToFraccion: self! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'NR 9/14/2023 07:54:20' overrides: 50658303!
+ anAdder 
	
	^anAdder addToFraccion: self! !
!Fraccion methodsFor: 'arithmetic operations' stamp: 'NR 9/14/2023 07:56:02' overrides: 50658307!
- anAdder 
	
	^anAdder substractFromFraccion: self! !

----STARTUP---- (19 September 2023 00:56:49) as C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\CuisUniversity-5981.image!


----End fileIn of C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\ejs\Clase 3.st----!

----End fileIn of C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\ejs\Clase 2.st----!

----End fileIn of C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\ejs\ISW1.st----!

----End fileIn of C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\repo\isw1\01-CodigoRepetido\CodigoRepetido-Ejercicio.st----!

----End fileIn of C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\repo\isw1\03-Stack\Stack-Exercise.st----!

----End fileIn of C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\repo\isw1\02-Numeros\Numeros-ejercicio.st----!

----QUIT----(19 September 2023 00:59:10) CuisUniversity-5981.image priorSource: 10197292!

----STARTUP---- (24 September 2023 21:23:11) as C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\CuisUniversity-5981.image!


----End fileIn of C:\Users\lucas\OneDrive\Desktop\ISW1-2023-1C-Parcial-1.st----!

!testRun: #TestDePerforación #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'LK 9/24/2023 21:24:05'!
PASSED!

!testRun: #TestDePerforación #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'LK 9/24/2023 21:24:06'!
PASSED!

!testRun: #TestDePerforación #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'LK 9/24/2023 21:24:07'!
PASSED!

!testRun: #TestDePerforación #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'LK 9/24/2023 21:24:07'!
PASSED!

!testRun: #TestDePerforación #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'LK 9/24/2023 21:24:07'!
PASSED!

!testRun: #TestDePerforación #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'LK 9/24/2023 21:24:07'!
PASSED!

!testRun: #TestDePerforación #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'LK 9/24/2023 21:24:07'!
PASSED!

!testRun: #TestDePerforación #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'LK 9/24/2023 21:24:07'!
PASSED!

!testRun: #TestDePerforación #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'LK 9/24/2023 21:24:07'!
PASSED!

!testRun: #TestDePerforación #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'LK 9/24/2023 21:24:07'!
PASSED!

!testRun: #TestDePerforación #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'LK 9/24/2023 21:24:07'!
PASSED!

!testRun: #TestDePerforación #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'LK 9/24/2023 21:24:07'!
PASSED!

!testRun: #TestDePerforación #test12NoPuedePerforarSinMecha stamp: 'LK 9/24/2023 21:24:07'!
PASSED!

!testRun: #TestDePerforación #test13PuedeCalcularProfundidadDelSuelo stamp: 'LK 9/24/2023 21:24:07'!
PASSED!

!testRun: #TestDePerforación #test14PuedeContarLasCapasDeTipoArenoso stamp: 'LK 9/24/2023 21:24:07'!
PASSED!

!testRun: #TestDePerforación #test15PuedeContarLasCapasDeTipoTierra stamp: 'LK 9/24/2023 21:24:07'!
PASSED!

!testRun: #TestDePerforación #test16PuedeContarLasCapasDeTipoConcreto stamp: 'LK 9/24/2023 21:24:07'!
PASSED!

!testRun: #TestDePerforación #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'LK 9/24/2023 21:24:07'!
PASSED!

!testRun: #TestDePerforación #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'LK 9/24/2023 21:24:07'!
PASSED!

!testRun: #TestDePerforación #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'LK 9/24/2023 21:24:07'!
PASSED!

----End fileIn of C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\Packages\TerseGuide.pck.st----!
!Perforadora methodsFor: 'scan' stamp: 'LK 9/24/2023 21:40:24' prior: 50661917!
calcularProfundidadDelSuelo
	
	| acc altura |

	acc := 0.
	
	capasDeSueloDebajo do: [:capaActual | 	altura := capaActual altura.
									altura = nil ifTrue: [ altura := 0 ]. 
									acc := acc + altura.].
	"
	[ix <= capasDeSueloDebajo size] whileTrue: [ | capa altura |
		capa := capasDeSueloDebajo at: ix.
		altura := capa altura.
		altura = nil ifTrue: [ altura := 0 ].
		acc := acc + altura.
		ix := ix + 1.		
	]."

	^ acc.
	
	 ! !

!testRun: #TestDePerforación #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'LK 9/24/2023 21:40:31'!
PASSED!

!testRun: #TestDePerforación #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'LK 9/24/2023 21:40:31'!
PASSED!

!testRun: #TestDePerforación #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'LK 9/24/2023 21:40:31'!
PASSED!

!testRun: #TestDePerforación #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'LK 9/24/2023 21:40:31'!
PASSED!

!testRun: #TestDePerforación #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'LK 9/24/2023 21:40:31'!
PASSED!

!testRun: #TestDePerforación #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'LK 9/24/2023 21:40:31'!
PASSED!

!testRun: #TestDePerforación #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'LK 9/24/2023 21:40:31'!
PASSED!

!testRun: #TestDePerforación #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'LK 9/24/2023 21:40:31'!
PASSED!

!testRun: #TestDePerforación #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'LK 9/24/2023 21:40:31'!
PASSED!

!testRun: #TestDePerforación #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'LK 9/24/2023 21:40:31'!
PASSED!

!testRun: #TestDePerforación #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'LK 9/24/2023 21:40:31'!
PASSED!

!testRun: #TestDePerforación #test12NoPuedePerforarSinMecha stamp: 'LK 9/24/2023 21:40:31'!
PASSED!

!testRun: #TestDePerforación #test13PuedeCalcularProfundidadDelSuelo stamp: 'LK 9/24/2023 21:40:31'!
PASSED!

!testRun: #TestDePerforación #test14PuedeContarLasCapasDeTipoArenoso stamp: 'LK 9/24/2023 21:40:31'!
PASSED!

!testRun: #TestDePerforación #test15PuedeContarLasCapasDeTipoTierra stamp: 'LK 9/24/2023 21:40:31'!
PASSED!

!testRun: #TestDePerforación #test16PuedeContarLasCapasDeTipoConcreto stamp: 'LK 9/24/2023 21:40:31'!
PASSED!

!testRun: #TestDePerforación #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'LK 9/24/2023 21:40:31'!
PASSED!

!testRun: #TestDePerforación #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'LK 9/24/2023 21:40:31'!
PASSED!

!testRun: #TestDePerforación #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'LK 9/24/2023 21:40:31'!
PASSED!
!Perforadora methodsFor: 'scan' stamp: 'LK 9/24/2023 21:47:46' prior: 50661948!
contarCapas: tipoDeCapa
	
	"Cuenta las capas de tipo tipoDeCapa. Recordar que para identificar cada capa se utiliza el valor de scan que retorna. Por ej. un capa tipo Arenoso retorna 7 al scan"
	
	| capitas valor |
	
	valor := 0.
	tipoDeCapa = #Arenoso ifTrue: [ valor := 7 ].
	tipoDeCapa = #Tierra ifTrue: [ valor := 10 ].
	tipoDeCapa = #Concreto ifTrue: [ valor := 50].	
	
	"capasDeSueloDebajo do: [ :capaActual | valor = capaActual scan ifTrue: [acc := acc + 1]. ^acc"
		
	capitas := capasDeSueloDebajo select: [ :capaActual | valor = capaActual scan].
	
	 ^capitas size.
	
	"
	[ix <= capasDeSueloDebajo size] whileTrue: [ | capa |
		capa := capasDeSueloDebajo at: ix.
		valor = capa scan ifTrue: [ acc := acc + 1 ].
		ix := ix + 1.		
	]."
! !

!testRun: #TestDePerforación #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'LK 9/24/2023 21:47:55'!
PASSED!

!testRun: #TestDePerforación #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'LK 9/24/2023 21:47:55'!
PASSED!

!testRun: #TestDePerforación #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'LK 9/24/2023 21:47:55'!
PASSED!

!testRun: #TestDePerforación #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'LK 9/24/2023 21:47:55'!
PASSED!

!testRun: #TestDePerforación #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'LK 9/24/2023 21:47:55'!
PASSED!

!testRun: #TestDePerforación #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'LK 9/24/2023 21:47:55'!
PASSED!

!testRun: #TestDePerforación #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'LK 9/24/2023 21:47:55'!
PASSED!

!testRun: #TestDePerforación #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'LK 9/24/2023 21:47:55'!
PASSED!

!testRun: #TestDePerforación #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'LK 9/24/2023 21:47:55'!
PASSED!

!testRun: #TestDePerforación #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'LK 9/24/2023 21:47:55'!
PASSED!

!testRun: #TestDePerforación #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'LK 9/24/2023 21:47:55'!
PASSED!

!testRun: #TestDePerforación #test12NoPuedePerforarSinMecha stamp: 'LK 9/24/2023 21:47:55'!
PASSED!

!testRun: #TestDePerforación #test13PuedeCalcularProfundidadDelSuelo stamp: 'LK 9/24/2023 21:47:55'!
PASSED!

!testRun: #TestDePerforación #test14PuedeContarLasCapasDeTipoArenoso stamp: 'LK 9/24/2023 21:47:55'!
PASSED!

!testRun: #TestDePerforación #test15PuedeContarLasCapasDeTipoTierra stamp: 'LK 9/24/2023 21:47:55'!
PASSED!

!testRun: #TestDePerforación #test16PuedeContarLasCapasDeTipoConcreto stamp: 'LK 9/24/2023 21:47:55'!
PASSED!

!testRun: #TestDePerforación #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'LK 9/24/2023 21:47:55'!
PASSED!

!testRun: #TestDePerforación #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'LK 9/24/2023 21:47:55'!
PASSED!

!testRun: #TestDePerforación #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'LK 9/24/2023 21:47:55'!
PASSED!
!Perforadora methodsFor: 'scan' stamp: 'LK 9/24/2023 21:48:02' prior: 50665077!
contarCapas: tipoDeCapa
	
	"Cuenta las capas de tipo tipoDeCapa. Recordar que para identificar cada capa se utiliza el valor de scan que retorna. Por ej. un capa tipo Arenoso retorna 7 al scan"
	
	| capitas valor |
	
	valor := 0.
	tipoDeCapa = #Arenoso ifTrue: [ valor := 7 ].
	tipoDeCapa = #Tierra ifTrue: [ valor := 10 ].
	tipoDeCapa = #Concreto ifTrue: [ valor := 50].	
	
	"capasDeSueloDebajo do: [ :capaActual | valor = capaActual scan ifTrue: [acc := acc + 1]. ^acc"
		
	capitas := capasDeSueloDebajo select: [ :capaActual | valor = capaActual scan].
	
	 ^capitas size + 1.
	
	"
	[ix <= capasDeSueloDebajo size] whileTrue: [ | capa |
		capa := capasDeSueloDebajo at: ix.
		valor = capa scan ifTrue: [ acc := acc + 1 ].
		ix := ix + 1.		
	]."
! !

!testRun: #TestDePerforación #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'LK 9/24/2023 21:48:03'!
PASSED!

!testRun: #TestDePerforación #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'LK 9/24/2023 21:48:03'!
PASSED!

!testRun: #TestDePerforación #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'LK 9/24/2023 21:48:03'!
PASSED!

!testRun: #TestDePerforación #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'LK 9/24/2023 21:48:03'!
PASSED!

!testRun: #TestDePerforación #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'LK 9/24/2023 21:48:03'!
PASSED!

!testRun: #TestDePerforación #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'LK 9/24/2023 21:48:03'!
PASSED!

!testRun: #TestDePerforación #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'LK 9/24/2023 21:48:03'!
PASSED!

!testRun: #TestDePerforación #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'LK 9/24/2023 21:48:03'!
PASSED!

!testRun: #TestDePerforación #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'LK 9/24/2023 21:48:03'!
PASSED!

!testRun: #TestDePerforación #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'LK 9/24/2023 21:48:03'!
PASSED!

!testRun: #TestDePerforación #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'LK 9/24/2023 21:48:03'!
PASSED!

!testRun: #TestDePerforación #test12NoPuedePerforarSinMecha stamp: 'LK 9/24/2023 21:48:03'!
PASSED!

!testRun: #TestDePerforación #test13PuedeCalcularProfundidadDelSuelo stamp: 'LK 9/24/2023 21:48:03'!
PASSED!

!testRun: #TestDePerforación #test14PuedeContarLasCapasDeTipoArenoso stamp: 'LK 9/24/2023 21:48:03'!
FAILURE!

!testRun: #TestDePerforación #test15PuedeContarLasCapasDeTipoTierra stamp: 'LK 9/24/2023 21:48:03'!
FAILURE!

!testRun: #TestDePerforación #test16PuedeContarLasCapasDeTipoConcreto stamp: 'LK 9/24/2023 21:48:03'!
FAILURE!

!testRun: #TestDePerforación #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'LK 9/24/2023 21:48:03'!
PASSED!

!testRun: #TestDePerforación #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'LK 9/24/2023 21:48:03'!
PASSED!

!testRun: #TestDePerforación #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'LK 9/24/2023 21:48:03'!
PASSED!
!Perforadora methodsFor: 'scan' stamp: 'LK 9/24/2023 21:48:10' prior: 50665179!
contarCapas: tipoDeCapa
	
	"Cuenta las capas de tipo tipoDeCapa. Recordar que para identificar cada capa se utiliza el valor de scan que retorna. Por ej. un capa tipo Arenoso retorna 7 al scan"
	
	| capitas valor |
	
	valor := 0.
	tipoDeCapa = #Arenoso ifTrue: [ valor := 7 ].
	tipoDeCapa = #Tierra ifTrue: [ valor := 10 ].
	tipoDeCapa = #Concreto ifTrue: [ valor := 50].	
	
	"capasDeSueloDebajo do: [ :capaActual | valor = capaActual scan ifTrue: [acc := acc + 1]. ^acc"
		
	capitas := capasDeSueloDebajo select: [ :capaActual | valor = capaActual scan].
	
	 ^capitas size.
	
	"
	[ix <= capasDeSueloDebajo size] whileTrue: [ | capa |
		capa := capasDeSueloDebajo at: ix.
		valor = capa scan ifTrue: [ acc := acc + 1 ].
		ix := ix + 1.		
	]."
! !
!Perforadora methodsFor: 'scan' stamp: 'LK 9/24/2023 21:48:28' prior: 50665281!
contarCapas: tipoDeCapa
	
	"Cuenta las capas de tipo tipoDeCapa. Recordar que para identificar cada capa se utiliza el valor de scan que retorna. Por ej. un capa tipo Arenoso retorna 7 al scan"
	
	| capitas valor |
	
	valor := 0.
	tipoDeCapa = #Arenoso ifTrue: [ valor := 7 ].
	tipoDeCapa = #Tierra ifTrue: [ valor := 10 ].
	tipoDeCapa = #Concreto ifTrue: [ valor := 50].	
	
	"capasDeSueloDebajo do: [ :capaActual | valor = capaActual scan ifTrue: [acc := acc + 1]. ^acc"
		
	"capitas := capasDeSueloDebajo select: [ :capaActual | valor = capaActual scan].
	
	 ^capitas size."
	
	"
	[ix <= capasDeSueloDebajo size] whileTrue: [ | capa |
		capa := capasDeSueloDebajo at: ix.
		valor = capa scan ifTrue: [ acc := acc + 1 ].
		ix := ix + 1.		
	]."
! !
!Perforadora methodsFor: 'scan' stamp: 'LK 9/24/2023 21:49:18' prior: 50665307!
contarCapas: tipoDeCapa
	
	"Cuenta las capas de tipo tipoDeCapa. Recordar que para identificar cada capa se utiliza el valor de scan que retorna. Por ej. un capa tipo Arenoso retorna 7 al scan"
	
	| acc valor |
	
	valor := 0.
	tipoDeCapa = #Arenoso ifTrue: [ valor := 7 ].
	tipoDeCapa = #Tierra ifTrue: [ valor := 10 ].
	tipoDeCapa = #Concreto ifTrue: [ valor := 50].	
	
	acc := 0.
	
	capasDeSueloDebajo do: [ :capaActual | valor = capaActual scan ifTrue: [acc := acc + 1]]. 
		
	^acc
		
	"capitas := capasDeSueloDebajo select: [ :capaActual | valor = capaActual scan].
	
	 ^capitas size."
	
	"
	[ix <= capasDeSueloDebajo size] whileTrue: [ | capa |
		capa := capasDeSueloDebajo at: ix.
		valor = capa scan ifTrue: [ acc := acc + 1 ].
		ix := ix + 1.		
	]."! !

!testRun: #TestDePerforación #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'LK 9/24/2023 21:49:23'!
PASSED!

!testRun: #TestDePerforación #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'LK 9/24/2023 21:49:23'!
PASSED!

!testRun: #TestDePerforación #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'LK 9/24/2023 21:49:23'!
PASSED!

!testRun: #TestDePerforación #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'LK 9/24/2023 21:49:23'!
PASSED!

!testRun: #TestDePerforación #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'LK 9/24/2023 21:49:23'!
PASSED!

!testRun: #TestDePerforación #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'LK 9/24/2023 21:49:23'!
PASSED!

!testRun: #TestDePerforación #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'LK 9/24/2023 21:49:23'!
PASSED!

!testRun: #TestDePerforación #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'LK 9/24/2023 21:49:23'!
PASSED!

!testRun: #TestDePerforación #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'LK 9/24/2023 21:49:23'!
PASSED!

!testRun: #TestDePerforación #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'LK 9/24/2023 21:49:23'!
PASSED!

!testRun: #TestDePerforación #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'LK 9/24/2023 21:49:23'!
PASSED!

!testRun: #TestDePerforación #test12NoPuedePerforarSinMecha stamp: 'LK 9/24/2023 21:49:23'!
PASSED!

!testRun: #TestDePerforación #test13PuedeCalcularProfundidadDelSuelo stamp: 'LK 9/24/2023 21:49:23'!
PASSED!

!testRun: #TestDePerforación #test14PuedeContarLasCapasDeTipoArenoso stamp: 'LK 9/24/2023 21:49:23'!
PASSED!

!testRun: #TestDePerforación #test15PuedeContarLasCapasDeTipoTierra stamp: 'LK 9/24/2023 21:49:23'!
PASSED!

!testRun: #TestDePerforación #test16PuedeContarLasCapasDeTipoConcreto stamp: 'LK 9/24/2023 21:49:23'!
PASSED!

!testRun: #TestDePerforación #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'LK 9/24/2023 21:49:23'!
PASSED!

!testRun: #TestDePerforación #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'LK 9/24/2023 21:49:23'!
PASSED!

!testRun: #TestDePerforación #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'LK 9/24/2023 21:49:23'!
PASSED!
!Perforadora methodsFor: 'scan' stamp: 'LK 9/24/2023 21:49:40' prior: 50665333!
contarCapas: tipoDeCapa
	
	"Cuenta las capas de tipo tipoDeCapa. Recordar que para identificar cada capa se utiliza el valor de scan que retorna. Por ej. un capa tipo Arenoso retorna 7 al scan"
	
	| capitas valor |
	
	valor := 0.
	tipoDeCapa = #Arenoso ifTrue: [ valor := 7 ].
	tipoDeCapa = #Tierra ifTrue: [ valor := 10 ].
	tipoDeCapa = #Concreto ifTrue: [ valor := 50].	
	
	"capasDeSueloDebajo do: [ :capaActual | valor = capaActual scan ifTrue: [acc := acc + 1]]. 
		
	^acc"
		
	capitas := capasDeSueloDebajo select: [ :capaActual | valor = capaActual scan].
	
	 ^capitas size.
	
	"
	[ix <= capasDeSueloDebajo size] whileTrue: [ | capa |
		capa := capasDeSueloDebajo at: ix.
		valor = capa scan ifTrue: [ acc := acc + 1 ].
		ix := ix + 1.		
	]."! !
!Perforadora methodsFor: 'scan' stamp: 'LK 9/24/2023 21:49:51' prior: 50665435!
contarCapas: tipoDeCapa
	
	"Cuenta las capas de tipo tipoDeCapa. Recordar que para identificar cada capa se utiliza el valor de scan que retorna. Por ej. un capa tipo Arenoso retorna 7 al scan"
	
	| capitas valor |
	
	valor := 0.
	tipoDeCapa = #Arenoso ifTrue: [ valor := 7 ].
	tipoDeCapa = #Tierra ifTrue: [ valor := 10 ].
	tipoDeCapa = #Concreto ifTrue: [ valor := 50].	
	
	capitas := capasDeSueloDebajo select: [ :capaActual | valor = capaActual scan].
	
	 ^capitas size.
! !
!Perforadora methodsFor: 'scan' stamp: 'LK 9/24/2023 22:42:48' prior: 50661929!
calcularProfundidadDelSueloHasta: tipoDeCapa
	
	| valor acc altura |
	
	valor := 0.
	tipoDeCapa = #Arenoso ifTrue: [ valor := 7 ].
	tipoDeCapa = #Tierra ifTrue: [ valor := 10 ].
	tipoDeCapa = #Concreto ifTrue: [ valor := 50].	
	
	acc := 0.
	capasDeSueloDebajo do: [ :capaActual | valor = capaActual scan ifTrue: [ ^ acc ].
							altura := capaActual altura.
							altura = nil ifTrue: [ altura := 0 ].
							acc := acc + altura.].
						
	"
	[ix <= capasDeSueloDebajo size] whileTrue: [ | capa altura |
		capa := capasDeSueloDebajo at: ix.
		
		valor = capa scan ifTrue: [ ^ acc ].
		
		altura := capa altura.
		altura = nil ifTrue: [ altura := 0 ].
		acc := acc + altura.
		ix := ix + 1.		
	].

	^ acc.
	
	 "! !

!testRun: #TestDePerforación #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'LK 9/24/2023 22:42:54'!
PASSED!

!testRun: #TestDePerforación #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'LK 9/24/2023 22:42:54'!
PASSED!

!testRun: #TestDePerforación #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'LK 9/24/2023 22:42:54'!
PASSED!

!testRun: #TestDePerforación #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'LK 9/24/2023 22:42:54'!
PASSED!

!testRun: #TestDePerforación #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'LK 9/24/2023 22:42:54'!
PASSED!

!testRun: #TestDePerforación #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'LK 9/24/2023 22:42:54'!
PASSED!

!testRun: #TestDePerforación #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'LK 9/24/2023 22:42:54'!
PASSED!

!testRun: #TestDePerforación #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'LK 9/24/2023 22:42:54'!
PASSED!

!testRun: #TestDePerforación #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'LK 9/24/2023 22:42:54'!
PASSED!

!testRun: #TestDePerforación #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'LK 9/24/2023 22:42:54'!
PASSED!

!testRun: #TestDePerforación #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'LK 9/24/2023 22:42:54'!
PASSED!

!testRun: #TestDePerforación #test12NoPuedePerforarSinMecha stamp: 'LK 9/24/2023 22:42:54'!
PASSED!

!testRun: #TestDePerforación #test13PuedeCalcularProfundidadDelSuelo stamp: 'LK 9/24/2023 22:42:54'!
PASSED!

!testRun: #TestDePerforación #test14PuedeContarLasCapasDeTipoArenoso stamp: 'LK 9/24/2023 22:42:54'!
PASSED!

!testRun: #TestDePerforación #test15PuedeContarLasCapasDeTipoTierra stamp: 'LK 9/24/2023 22:42:54'!
PASSED!

!testRun: #TestDePerforación #test16PuedeContarLasCapasDeTipoConcreto stamp: 'LK 9/24/2023 22:42:54'!
PASSED!

!testRun: #TestDePerforación #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'LK 9/24/2023 22:42:54'!
PASSED!

!testRun: #TestDePerforación #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'LK 9/24/2023 22:42:54'!
PASSED!

!testRun: #TestDePerforación #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'LK 9/24/2023 22:42:54'!
PASSED!

Object subclass: #TipoDeSuelo
	instanceVariableNames: 'tipo resistencia altura'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classDefinition: #TipoDeSuelo category: 'ISW1-2023-1C-Parcial-1' stamp: 'LK 9/24/2023 22:43:44'!
Object subclass: #TipoDeSuelo
	instanceVariableNames: 'tipo resistencia altura'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

TipoDeSuelo subclass: #Arenoso
	instanceVariableNames: 'tipo resistencia altura'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

TipoDeSuelo subclass: #Arenoso
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classDefinition: #Arenoso category: 'ISW1-2023-1C-Parcial-1' stamp: 'LK 9/24/2023 22:44:00'!
TipoDeSuelo subclass: #Arenoso
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

TipoDeSuelo subclass: #Tierra
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classDefinition: #Tierra category: 'ISW1-2023-1C-Parcial-1' stamp: 'LK 9/24/2023 22:44:09'!
TipoDeSuelo subclass: #Tierra
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

TipoDeSuelo subclass: #Concreto
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classDefinition: #Concreto category: 'ISW1-2023-1C-Parcial-1' stamp: 'LK 9/24/2023 22:44:12'!
TipoDeSuelo subclass: #Concreto
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

Perforadora subclass: #MechaSoft
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classDefinition: #MechaSoft category: 'ISW1-2023-1C-Parcial-1' stamp: 'LK 9/24/2023 22:44:43'!
Perforadora subclass: #MechaSoft
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

Perforadora subclass: #MechaWidia
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classDefinition: #MechaWidia category: 'ISW1-2023-1C-Parcial-1' stamp: 'LK 9/24/2023 22:44:49'!
Perforadora subclass: #MechaWidia
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

Perforadora subclass: #MechaDiamante
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classDefinition: #MechaDiamante category: 'ISW1-2023-1C-Parcial-1' stamp: 'LK 9/24/2023 22:44:56'!
Perforadora subclass: #MechaDiamante
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

Perforadora subclass: #SinMecha
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classDefinition: #SinMecha category: 'ISW1-2023-1C-Parcial-1' stamp: 'LK 9/24/2023 22:46:30'!
Perforadora subclass: #SinMecha
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

Perforadora subclass: #MechaRota
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classDefinition: #MechaRota category: 'ISW1-2023-1C-Parcial-1' stamp: 'LK 9/24/2023 22:47:07'!
Perforadora subclass: #MechaRota
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!
!SinMecha methodsFor: 'no messages' stamp: 'LK 9/24/2023 22:50:16' overrides: 50661825!
darGolpeDeTaladro
		
	self error: 'No puede perforar'.! !
!SinMecha class methodsFor: 'nil' stamp: 'LK 9/24/2023 22:50:53'!
errorSinMecha
	^'No puede perforar'.! !
!SinMecha methodsFor: 'as yet unclassified' stamp: 'LK 9/24/2023 22:51:23' prior: 50665694 overrides: 50661825!
darGolpeDeTaladro
		
	self error: self errorSinMecha.! !
!SinMecha methodsFor: 'as yet unclassified' stamp: 'LK 9/24/2023 22:52:14' prior: 50665703 overrides: 50661825!
darGolpeDeTaladro
		
	self error: SinMecha errorSinMecha.! !

!testRun: #TestDePerforación #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'LK 9/24/2023 22:52:23'!
PASSED!

!testRun: #TestDePerforación #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'LK 9/24/2023 22:52:23'!
PASSED!

!testRun: #TestDePerforación #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'LK 9/24/2023 22:52:23'!
PASSED!

!testRun: #TestDePerforación #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'LK 9/24/2023 22:52:23'!
PASSED!

!testRun: #TestDePerforación #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'LK 9/24/2023 22:52:23'!
PASSED!

!testRun: #TestDePerforación #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'LK 9/24/2023 22:52:23'!
PASSED!

!testRun: #TestDePerforación #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'LK 9/24/2023 22:52:23'!
PASSED!

!testRun: #TestDePerforación #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'LK 9/24/2023 22:52:23'!
PASSED!

!testRun: #TestDePerforación #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'LK 9/24/2023 22:52:23'!
PASSED!

!testRun: #TestDePerforación #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'LK 9/24/2023 22:52:23'!
PASSED!

!testRun: #TestDePerforación #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'LK 9/24/2023 22:52:23'!
PASSED!

!testRun: #TestDePerforación #test12NoPuedePerforarSinMecha stamp: 'LK 9/24/2023 22:52:23'!
PASSED!

!testRun: #TestDePerforación #test13PuedeCalcularProfundidadDelSuelo stamp: 'LK 9/24/2023 22:52:23'!
PASSED!

!testRun: #TestDePerforación #test14PuedeContarLasCapasDeTipoArenoso stamp: 'LK 9/24/2023 22:52:23'!
PASSED!

!testRun: #TestDePerforación #test15PuedeContarLasCapasDeTipoTierra stamp: 'LK 9/24/2023 22:52:23'!
PASSED!

!testRun: #TestDePerforación #test16PuedeContarLasCapasDeTipoConcreto stamp: 'LK 9/24/2023 22:52:23'!
PASSED!

!testRun: #TestDePerforación #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'LK 9/24/2023 22:52:23'!
PASSED!

!testRun: #TestDePerforación #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'LK 9/24/2023 22:52:23'!
PASSED!

!testRun: #TestDePerforación #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'LK 9/24/2023 22:52:23'!
PASSED!
!Perforadora methodsFor: 'excavation' stamp: 'LK 9/24/2023 22:53:20' prior: 50661825!
darGolpeDeTaladro

	vecesQueGolpeoCapaActual := vecesQueGolpeoCapaActual + 1.
	
	self sobreSueloArenoso ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Widia ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Diamante ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
		^self].
	
	self sobreSueloTierra ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 2 ifTrue: [ ^self transformarCapaEnArenoso ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ ^self pasarAProximaCapa ]].
	
	self sobreSueloConcreto ifTrue: [
		mechaPuesta = #Soft ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió'  ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 3 ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ 
			vecesQueGolpeoCapaActual even ifTrue: [ capasDeSueloDebajo first bajaUnDecimoDeResistencia].
			capasDeSueloDebajo first sinResistencia ifTrue: [ ^self transformarCapaEnArenoso].
			^vecesQueGolpeoCapaActual ]].
	
	self error: 'error'! !

Object subclass: #TipoDeSuelo
	instanceVariableNames: 'altura'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classDefinition: #TipoDeSuelo category: 'ISW1-2023-1C-Parcial-1' stamp: 'LK 9/24/2023 22:54:13'!
Object subclass: #TipoDeSuelo
	instanceVariableNames: 'altura'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

TipoDeSuelo subclass: #Concreto
	instanceVariableNames: 'resistencia'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classDefinition: #Concreto category: 'ISW1-2023-1C-Parcial-1' stamp: 'LK 9/24/2023 22:54:18'!
TipoDeSuelo subclass: #Concreto
	instanceVariableNames: 'resistencia'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!
!Concreto methodsFor: 'no messages' stamp: 'LK 9/24/2023 22:54:28'!
bajaUnDecimoDeResistencia
	resistencia := resistencia - 1! !
!Tierra methodsFor: 'no messages' stamp: 'LK 9/24/2023 22:57:24'!
esTierra
	^true! !
!Tierra methodsFor: 'as yet unclassified' stamp: 'LK 9/24/2023 22:57:49'!
esConcreto
	^false! !
!Tierra methodsFor: 'as yet unclassified' stamp: 'LK 9/24/2023 22:57:56'!
esArenoso
	^false! !

!classRemoval: #Arenoso stamp: 'LK 9/24/2023 23:13:13'!
TipoDeSuelo subclass: #Arenoso
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classRemoval: #Tierra stamp: 'LK 9/24/2023 23:13:14'!
TipoDeSuelo subclass: #Tierra
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classRemoval: #Concreto stamp: 'LK 9/24/2023 23:13:14'!
TipoDeSuelo subclass: #Concreto
	instanceVariableNames: 'resistencia'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classRemoval: #TipoDeSuelo stamp: 'LK 9/24/2023 23:13:14'!
Object subclass: #TipoDeSuelo
	instanceVariableNames: 'altura'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

Object subclass: #CapaDeSuelo
	instanceVariableNames: 'altura'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classDefinition: #CapaDeSuelo category: 'ISW1-2023-1C-Parcial-1' stamp: 'LK 9/24/2023 23:15:22'!
Object subclass: #CapaDeSuelo
	instanceVariableNames: 'altura'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

CapaDeSuelo subclass: #Arenoso
	instanceVariableNames: 'altura'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

CapaDeSuelo subclass: #Arenoso
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classDefinition: #Arenoso category: 'ISW1-2023-1C-Parcial-1' stamp: 'LK 9/24/2023 23:15:36'!
CapaDeSuelo subclass: #Arenoso
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

CapaDeSuelo subclass: #Tierra
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classDefinition: #Tierra category: 'ISW1-2023-1C-Parcial-1' stamp: 'LK 9/24/2023 23:15:39'!
CapaDeSuelo subclass: #Tierra
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

CapaDeSuelo subclass: #Concreto
	instanceVariableNames: 'resistencia'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classDefinition: #Concreto category: 'ISW1-2023-1C-Parcial-1' stamp: 'LK 9/24/2023 23:15:48'!
CapaDeSuelo subclass: #Concreto
	instanceVariableNames: 'resistencia'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!
!Concreto methodsFor: 'nil' stamp: 'LK 9/24/2023 23:16:09' overrides: 50661739!
bajaUnDecimoDeResistencia
	resistencia := resistencia - 1! !
!Arenoso methodsFor: 'initialization' stamp: 'LK 9/24/2023 23:18:23' overrides: 50661700!
initializeArenoso
	
	tipo := #Arenoso.
	altura := nil.! !

!methodRemoval: CapaDeSuelo #initializeArenoso stamp: 'LK 9/24/2023 23:18:23'!
initializeArenoso
	
	tipo := #Arenoso.
	altura := nil.!
!Tierra methodsFor: 'initialization' stamp: 'LK 9/24/2023 23:18:38' overrides: 50661712!
initializeTierra
	
	tipo := #Tierra.
	altura := nil.! !

!methodRemoval: CapaDeSuelo #initializeTierra stamp: 'LK 9/24/2023 23:18:38'!
initializeTierra
	
	tipo := #Tierra.
	altura := nil.!
!Concreto methodsFor: 'initialization' stamp: 'LK 9/24/2023 23:18:47' overrides: 50661705!
initializeConcretoConResistencia: resistenciaInicial 

	resistencia := resistenciaInicial.
	tipo := #Concreto.
	altura := nil.! !

!methodRemoval: CapaDeSuelo #initializeConcretoConResistencia: stamp: 'LK 9/24/2023 23:18:47'!
initializeConcretoConResistencia: resistenciaInicial 

	resistencia := resistenciaInicial.
	tipo := #Concreto.
	altura := nil.!
!Concreto methodsFor: 'accessing' stamp: 'LK 9/24/2023 23:18:58' overrides: 50661751!
resistencia

	^ resistencia.! !

!methodRemoval: CapaDeSuelo #resistencia stamp: 'LK 9/24/2023 23:18:58'!
resistencia

	^ resistencia.!
!Arenoso methodsFor: 'scan' stamp: 'LK 9/24/2023 23:19:10' overrides: 50661758!
scan

	self esArenoso ifTrue: [ ^ 7 ].
	self esTierra ifTrue: [ ^ 10 ].
	^ 50. ! !
!Tierra methodsFor: 'scan' stamp: 'LK 9/24/2023 23:19:10' overrides: 50661758!
scan

	self esArenoso ifTrue: [ ^ 7 ].
	self esTierra ifTrue: [ ^ 10 ].
	^ 50. ! !
!Concreto methodsFor: 'scan' stamp: 'LK 9/24/2023 23:19:10' overrides: 50661758!
scan

	self esArenoso ifTrue: [ ^ 7 ].
	self esTierra ifTrue: [ ^ 10 ].
	^ 50. ! !
!CapaDeSuelo methodsFor: 'scan' stamp: 'LK 9/24/2023 23:19:10' prior: 50661758!
scan

	self subclassResponsibility! !
!Arenoso methodsFor: 'accessing' stamp: 'LK 9/24/2023 23:19:19' overrides: 50661755!
tipo

	^tipo! !
!Tierra methodsFor: 'accessing' stamp: 'LK 9/24/2023 23:19:19' overrides: 50661755!
tipo

	^tipo! !
!Concreto methodsFor: 'accessing' stamp: 'LK 9/24/2023 23:19:19' overrides: 50661755!
tipo

	^tipo! !
!CapaDeSuelo methodsFor: 'accessing' stamp: 'LK 9/24/2023 23:19:19' prior: 50661755!
tipo

	self subclassResponsibility! !
!Concreto methodsFor: 'bajar resistencia' stamp: 'LK 9/24/2023 23:19:36' overrides: 50661744!
sinResistencia
	^resistencia = 0! !

!methodRemoval: CapaDeSuelo #sinResistencia stamp: 'LK 9/24/2023 23:19:36'!
sinResistencia
	^resistencia = 0!
!Arenoso methodsFor: 'tipo' stamp: 'LK 9/24/2023 23:19:58' overrides: 50661716!
esArenoso
	^tipo = #Arenoso! !
!Tierra methodsFor: 'tipo' stamp: 'LK 9/24/2023 23:19:58' overrides: 50661716!
esArenoso
	^tipo = #Arenoso! !
!Concreto methodsFor: 'tipo' stamp: 'LK 9/24/2023 23:19:58' overrides: 50661716!
esArenoso
	^tipo = #Arenoso! !
!CapaDeSuelo methodsFor: 'tipo' stamp: 'LK 9/24/2023 23:19:58' prior: 50661716!
esArenoso

	self subclassResponsibility! !

!methodRemoval: CapaDeSuelo #bajaUnDecimoDeResistencia stamp: 'LK 9/24/2023 23:22:04'!
bajaUnDecimoDeResistencia
	resistencia := resistencia - 1!
!Arenoso methodsFor: 'tipo' stamp: 'LK 9/24/2023 23:22:51' overrides: 50661719!
esConcreto
	^tipo = #Concreto! !
!Tierra methodsFor: 'tipo' stamp: 'LK 9/24/2023 23:22:52' overrides: 50661719!
esConcreto
	^tipo = #Concreto! !
!Concreto methodsFor: 'tipo' stamp: 'LK 9/24/2023 23:22:52' overrides: 50661719!
esConcreto
	^tipo = #Concreto! !
!CapaDeSuelo methodsFor: 'tipo' stamp: 'LK 9/24/2023 23:22:52' prior: 50661719!
esConcreto

	self subclassResponsibility! !
!Arenoso methodsFor: 'tipo' stamp: 'LK 9/24/2023 23:23:00' overrides: 50661723!
esTierra
	^tipo = #Tierra! !
!Tierra methodsFor: 'tipo' stamp: 'LK 9/24/2023 23:23:00' overrides: 50661723!
esTierra
	^tipo = #Tierra! !
!Concreto methodsFor: 'tipo' stamp: 'LK 9/24/2023 23:23:00' overrides: 50661723!
esTierra
	^tipo = #Tierra! !
!CapaDeSuelo methodsFor: 'tipo' stamp: 'LK 9/24/2023 23:23:00' prior: 50661723!
esTierra

	self subclassResponsibility! !
!Arenoso methodsFor: 'tipo' stamp: 'LK 9/24/2023 23:23:53' prior: 50666036 overrides: 50666048!
esArenoso
	^true! !
!Arenoso methodsFor: 'tipo' stamp: 'LK 9/24/2023 23:23:58' prior: 50666057 overrides: 50666069!
esConcreto
	^false! !
!Arenoso methodsFor: 'tipo' stamp: 'LK 9/24/2023 23:24:01' prior: 50666073 overrides: 50666085!
esTierra
	^false! !
!Arenoso methodsFor: 'initialization' stamp: 'LK 9/24/2023 23:24:07' prior: 50665950!
initializeArenoso

	altura := nil.! !
!Arenoso methodsFor: 'scan' stamp: 'LK 9/24/2023 23:24:17' prior: 50665989 overrides: 50666007!
scan
	^7.! !
!Arenoso methodsFor: 'accessing' stamp: 'LK 9/24/2023 23:24:25' prior: 50666011 overrides: 50666023!
tipo
	^#Arenoso! !
!Concreto methodsFor: 'tipo' stamp: 'LK 9/24/2023 23:24:36' prior: 50666044 overrides: 50666048!
esArenoso
	^false! !
!Concreto methodsFor: 'tipo' stamp: 'LK 9/24/2023 23:24:40' prior: 50666065 overrides: 50666069!
esConcreto
	^true! !
!Concreto methodsFor: 'tipo' stamp: 'LK 9/24/2023 23:24:44' prior: 50666081 overrides: 50666085!
esTierra
	^false! !
!Concreto methodsFor: 'initialization' stamp: 'LK 9/24/2023 23:24:53' prior: 50665968!
initializeConcretoConResistencia: resistenciaInicial 

	resistencia := resistenciaInicial.
	altura := nil.! !
!Concreto methodsFor: 'scan' stamp: 'LK 9/24/2023 23:25:00' prior: 50666001 overrides: 50666007!
scan
	^ 50. ! !
!Concreto methodsFor: 'accessing' stamp: 'LK 9/24/2023 23:25:08' prior: 50666019 overrides: 50666023!
tipo

	^#Concreto! !
!Tierra methodsFor: 'tipo' stamp: 'LK 9/24/2023 23:25:14' prior: 50666040 overrides: 50666048!
esArenoso
	^false! !
!Tierra methodsFor: 'tipo' stamp: 'LK 9/24/2023 23:25:18' prior: 50666061 overrides: 50666069!
esConcreto
	^false! !
!Tierra methodsFor: 'tipo' stamp: 'LK 9/24/2023 23:25:25' prior: 50666077 overrides: 50666085!
esTierra
	^true! !
!CapaDeSuelo methodsFor: 'comparing' stamp: 'LK 9/24/2023 23:26:24' prior: 50661727 overrides: 16901772!
= unaCapaDeSuelo

	^(unaCapaDeSuelo isKindOf: self class) and: [self tipo = unaCapaDeSuelo tipo].! !
!Concreto methodsFor: 'bajar resistencia' stamp: 'LK 9/24/2023 23:26:42' overrides: 50666154!
= unaCapaDeSuelo

	^(unaCapaDeSuelo isKindOf: self class) and: [self tipo = unaCapaDeSuelo tipo and: [resistencia = unaCapaDeSuelo resistencia]].! !

!testRun: #TestDePerforación #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'LK 9/24/2023 23:28:38'!
ERROR!

!testRun: #TestDePerforación #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'LK 9/24/2023 23:28:38'!
ERROR!

!testRun: #TestDePerforación #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'LK 9/24/2023 23:28:38'!
ERROR!

!testRun: #TestDePerforación #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'LK 9/24/2023 23:28:38'!
ERROR!

!testRun: #TestDePerforación #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'LK 9/24/2023 23:28:38'!
ERROR!

!testRun: #TestDePerforación #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'LK 9/24/2023 23:28:38'!
ERROR!

!testRun: #TestDePerforación #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'LK 9/24/2023 23:28:39'!
ERROR!

!testRun: #TestDePerforación #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'LK 9/24/2023 23:28:39'!
ERROR!

!testRun: #TestDePerforación #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'LK 9/24/2023 23:28:39'!
ERROR!

!testRun: #TestDePerforación #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'LK 9/24/2023 23:28:39'!
ERROR!

!testRun: #TestDePerforación #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'LK 9/24/2023 23:28:39'!
ERROR!

!testRun: #TestDePerforación #test12NoPuedePerforarSinMecha stamp: 'LK 9/24/2023 23:28:39'!
ERROR!

!testRun: #TestDePerforación #test13PuedeCalcularProfundidadDelSuelo stamp: 'LK 9/24/2023 23:28:39'!
ERROR!

!testRun: #TestDePerforación #test14PuedeContarLasCapasDeTipoArenoso stamp: 'LK 9/24/2023 23:28:39'!
ERROR!

!testRun: #TestDePerforación #test15PuedeContarLasCapasDeTipoTierra stamp: 'LK 9/24/2023 23:28:39'!
ERROR!

!testRun: #TestDePerforación #test16PuedeContarLasCapasDeTipoConcreto stamp: 'LK 9/24/2023 23:28:39'!
ERROR!

!testRun: #TestDePerforación #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'LK 9/24/2023 23:28:39'!
ERROR!

!testRun: #TestDePerforación #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'LK 9/24/2023 23:28:39'!
ERROR!

!testRun: #TestDePerforación #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'LK 9/24/2023 23:28:39'!
ERROR!

DoIt

!
!CapaDeSuelo class methodsFor: 'instance creation' stamp: 'LK 9/24/2023 23:31:03' prior: 50661776!
arenoso

	^Arenoso new initializeArenoso! !
!CapaDeSuelo class methodsFor: 'instance creation' stamp: 'LK 9/24/2023 23:31:10' prior: 50661780!
concretoConResistencia: resistencia 

	^Concreto new initializeConcretoConResistencia: resistencia ! !
!CapaDeSuelo class methodsFor: 'instance creation' stamp: 'LK 9/24/2023 23:31:14' prior: 50661786!
tierra

	^Tierra new initializeTierra! !

!testRun: #TestDePerforación #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'LK 9/24/2023 23:31:23'!
PASSED!

!testRun: #TestDePerforación #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'LK 9/24/2023 23:31:23'!
PASSED!

!testRun: #TestDePerforación #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'LK 9/24/2023 23:31:23'!
PASSED!

!testRun: #TestDePerforación #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'LK 9/24/2023 23:31:23'!
PASSED!

!testRun: #TestDePerforación #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'LK 9/24/2023 23:31:23'!
PASSED!

!testRun: #TestDePerforación #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'LK 9/24/2023 23:31:23'!
PASSED!

!testRun: #TestDePerforación #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'LK 9/24/2023 23:31:23'!
PASSED!

!testRun: #TestDePerforación #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'LK 9/24/2023 23:31:23'!
PASSED!

!testRun: #TestDePerforación #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'LK 9/24/2023 23:31:23'!
PASSED!

!testRun: #TestDePerforación #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'LK 9/24/2023 23:31:23'!
PASSED!

!testRun: #TestDePerforación #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'LK 9/24/2023 23:31:23'!
PASSED!

!testRun: #TestDePerforación #test12NoPuedePerforarSinMecha stamp: 'LK 9/24/2023 23:31:23'!
FAILURE!

!testRun: #TestDePerforación #test13PuedeCalcularProfundidadDelSuelo stamp: 'LK 9/24/2023 23:31:23'!
PASSED!

!testRun: #TestDePerforación #test14PuedeContarLasCapasDeTipoArenoso stamp: 'LK 9/24/2023 23:31:23'!
PASSED!

!testRun: #TestDePerforación #test15PuedeContarLasCapasDeTipoTierra stamp: 'LK 9/24/2023 23:31:23'!
PASSED!

!testRun: #TestDePerforación #test16PuedeContarLasCapasDeTipoConcreto stamp: 'LK 9/24/2023 23:31:23'!
PASSED!

!testRun: #TestDePerforación #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'LK 9/24/2023 23:31:23'!
PASSED!

!testRun: #TestDePerforación #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'LK 9/24/2023 23:31:23'!
PASSED!

!testRun: #TestDePerforación #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'LK 9/24/2023 23:31:23'!
PASSED!

!testRun: #TestDePerforación #test12NoPuedePerforarSinMecha stamp: 'LK 9/24/2023 23:31:23'!
FAILURE!

!testRun: #TestDePerforación #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'LK 9/24/2023 23:31:36'!
PASSED!

!testRun: #TestDePerforación #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'LK 9/24/2023 23:31:38'!
PASSED!

!testRun: #TestDePerforación #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'LK 9/24/2023 23:31:39'!
PASSED!

!testRun: #TestDePerforación #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'LK 9/24/2023 23:31:41'!
PASSED!

!testRun: #TestDePerforación #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'LK 9/24/2023 23:31:42'!
PASSED!

!testRun: #TestDePerforación #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'LK 9/24/2023 23:31:44'!
PASSED!

!testRun: #TestDePerforación #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'LK 9/24/2023 23:31:47'!
PASSED!

!testRun: #TestDePerforación #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'LK 9/24/2023 23:31:47'!
PASSED!

!testRun: #TestDePerforación #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'LK 9/24/2023 23:31:47'!
PASSED!

!testRun: #TestDePerforación #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'LK 9/24/2023 23:31:47'!
PASSED!

!testRun: #TestDePerforación #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'LK 9/24/2023 23:31:47'!
PASSED!

!testRun: #TestDePerforación #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'LK 9/24/2023 23:31:47'!
PASSED!

!testRun: #TestDePerforación #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'LK 9/24/2023 23:31:47'!
PASSED!

!testRun: #TestDePerforación #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'LK 9/24/2023 23:31:47'!
PASSED!

!testRun: #TestDePerforación #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'LK 9/24/2023 23:31:47'!
PASSED!

!testRun: #TestDePerforación #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'LK 9/24/2023 23:31:47'!
PASSED!

!testRun: #TestDePerforación #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'LK 9/24/2023 23:31:47'!
PASSED!

!testRun: #TestDePerforación #test12NoPuedePerforarSinMecha stamp: 'LK 9/24/2023 23:31:47'!
FAILURE!

!testRun: #TestDePerforación #test13PuedeCalcularProfundidadDelSuelo stamp: 'LK 9/24/2023 23:31:47'!
PASSED!

!testRun: #TestDePerforación #test14PuedeContarLasCapasDeTipoArenoso stamp: 'LK 9/24/2023 23:31:47'!
PASSED!

!testRun: #TestDePerforación #test15PuedeContarLasCapasDeTipoTierra stamp: 'LK 9/24/2023 23:31:47'!
PASSED!

!testRun: #TestDePerforación #test16PuedeContarLasCapasDeTipoConcreto stamp: 'LK 9/24/2023 23:31:47'!
PASSED!

!testRun: #TestDePerforación #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'LK 9/24/2023 23:31:47'!
PASSED!

!testRun: #TestDePerforación #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'LK 9/24/2023 23:31:47'!
PASSED!

!testRun: #TestDePerforación #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'LK 9/24/2023 23:31:47'!
PASSED!

!testRun: #TestDePerforación #test12NoPuedePerforarSinMecha stamp: 'LK 9/24/2023 23:31:47'!
FAILURE!

!testRun: #TestDePerforación #test13PuedeCalcularProfundidadDelSuelo stamp: 'LK 9/24/2023 23:31:52'!
PASSED!

!testRun: #TestDePerforación #test14PuedeContarLasCapasDeTipoArenoso stamp: 'LK 9/24/2023 23:31:53'!
PASSED!

!testRun: #TestDePerforación #test15PuedeContarLasCapasDeTipoTierra stamp: 'LK 9/24/2023 23:31:54'!
PASSED!

!testRun: #TestDePerforación #test16PuedeContarLasCapasDeTipoConcreto stamp: 'LK 9/24/2023 23:31:56'!
PASSED!
!Perforadora methodsFor: 'scan' stamp: 'LK 9/24/2023 23:33:49' prior: 50664985!
calcularProfundidadDelSuelo
	
	| acc altura |

	acc := 0.
	
	capasDeSueloDebajo do: [:capaActual | 	altura := capaActual altura.
									altura = nil ifTrue: [ altura := 0 ]. 
									acc := acc + altura.].

	
	 ! !
!Perforadora methodsFor: 'scan' stamp: 'LK 9/24/2023 23:33:56' prior: 50665479!
calcularProfundidadDelSueloHasta: tipoDeCapa
	
	| valor acc altura |
	
	valor := 0.
	tipoDeCapa = #Arenoso ifTrue: [ valor := 7 ].
	tipoDeCapa = #Tierra ifTrue: [ valor := 10 ].
	tipoDeCapa = #Concreto ifTrue: [ valor := 50].	
	
	acc := 0.
	capasDeSueloDebajo do: [ :capaActual | valor = capaActual scan ifTrue: [ ^ acc ].
							altura := capaActual altura.
							altura = nil ifTrue: [ altura := 0 ].
							acc := acc + altura.].
! !
!Perforadora methodsFor: 'scan' stamp: 'LK 9/24/2023 23:34:32' prior: 50666467!
calcularProfundidadDelSueloHasta: tipoDeCapa
	
	| valor acc altura |
	
	valor := 3.
	tipoDeCapa = #Arenoso ifTrue: [ valor := 7 ].
	tipoDeCapa = #Tierra ifTrue: [ valor := 10 ].
	tipoDeCapa = #Concreto ifTrue: [ valor := 50].	
	
	acc := 0.
	capasDeSueloDebajo do: [ :capaActual | valor = capaActual scan ifTrue: [ ^ acc ].
							altura := capaActual altura.
							altura = nil ifTrue: [ altura := 0 ].
							acc := acc + altura.].
! !

!testRun: #TestDePerforación #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'LK 9/24/2023 23:34:37'!
PASSED!

!testRun: #TestDePerforación #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'LK 9/24/2023 23:34:37'!
PASSED!

!testRun: #TestDePerforación #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'LK 9/24/2023 23:34:37'!
PASSED!

!testRun: #TestDePerforación #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'LK 9/24/2023 23:34:37'!
PASSED!

!testRun: #TestDePerforación #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'LK 9/24/2023 23:34:37'!
PASSED!

!testRun: #TestDePerforación #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'LK 9/24/2023 23:34:37'!
PASSED!

!testRun: #TestDePerforación #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'LK 9/24/2023 23:34:37'!
PASSED!

!testRun: #TestDePerforación #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'LK 9/24/2023 23:34:37'!
PASSED!

!testRun: #TestDePerforación #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'LK 9/24/2023 23:34:37'!
PASSED!

!testRun: #TestDePerforación #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'LK 9/24/2023 23:34:37'!
PASSED!

!testRun: #TestDePerforación #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'LK 9/24/2023 23:34:37'!
PASSED!

!testRun: #TestDePerforación #test12NoPuedePerforarSinMecha stamp: 'LK 9/24/2023 23:34:37'!
FAILURE!

!testRun: #TestDePerforación #test13PuedeCalcularProfundidadDelSuelo stamp: 'LK 9/24/2023 23:34:37'!
FAILURE!

!testRun: #TestDePerforación #test14PuedeContarLasCapasDeTipoArenoso stamp: 'LK 9/24/2023 23:34:37'!
PASSED!

!testRun: #TestDePerforación #test15PuedeContarLasCapasDeTipoTierra stamp: 'LK 9/24/2023 23:34:37'!
PASSED!

!testRun: #TestDePerforación #test16PuedeContarLasCapasDeTipoConcreto stamp: 'LK 9/24/2023 23:34:37'!
PASSED!

!testRun: #TestDePerforación #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'LK 9/24/2023 23:34:37'!
PASSED!

!testRun: #TestDePerforación #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'LK 9/24/2023 23:34:37'!
PASSED!

!testRun: #TestDePerforación #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'LK 9/24/2023 23:34:37'!
PASSED!
!Perforadora methodsFor: 'scan' stamp: 'LK 9/24/2023 23:35:40' prior: 50666484!
calcularProfundidadDelSueloHasta: tipoDeCapa
	
	| valor acc altura |
	

	valor := tipoDeCapa scan.
	"tipoDeCapa = #Arenoso ifTrue: [ valor := 7 ].
	tipoDeCapa = #Tierra ifTrue: [ valor := 10 ].
	tipoDeCapa = #Concreto ifTrue: [ valor := 50].	"
	
	acc := 0.
	capasDeSueloDebajo do: [ :capaActual | valor = capaActual scan ifTrue: [ ^ acc ].
							altura := capaActual altura.
							altura = nil ifTrue: [ altura := 0 ].
							acc := acc + altura.].
! !

!testRun: #TestDePerforación #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'LK 9/24/2023 23:35:46'!
PASSED!

!testRun: #TestDePerforación #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'LK 9/24/2023 23:35:46'!
PASSED!

!testRun: #TestDePerforación #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'LK 9/24/2023 23:35:46'!
PASSED!

!testRun: #TestDePerforación #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'LK 9/24/2023 23:35:46'!
PASSED!

!testRun: #TestDePerforación #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'LK 9/24/2023 23:35:46'!
PASSED!

!testRun: #TestDePerforación #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'LK 9/24/2023 23:35:46'!
PASSED!

!testRun: #TestDePerforación #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'LK 9/24/2023 23:35:46'!
PASSED!

!testRun: #TestDePerforación #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'LK 9/24/2023 23:35:46'!
PASSED!

!testRun: #TestDePerforación #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'LK 9/24/2023 23:35:46'!
PASSED!

!testRun: #TestDePerforación #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'LK 9/24/2023 23:35:46'!
PASSED!

!testRun: #TestDePerforación #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'LK 9/24/2023 23:35:46'!
PASSED!

!testRun: #TestDePerforación #test12NoPuedePerforarSinMecha stamp: 'LK 9/24/2023 23:35:46'!
FAILURE!

!testRun: #TestDePerforación #test13PuedeCalcularProfundidadDelSuelo stamp: 'LK 9/24/2023 23:35:46'!
FAILURE!

!testRun: #TestDePerforación #test14PuedeContarLasCapasDeTipoArenoso stamp: 'LK 9/24/2023 23:35:46'!
PASSED!

!testRun: #TestDePerforación #test15PuedeContarLasCapasDeTipoTierra stamp: 'LK 9/24/2023 23:35:46'!
PASSED!

!testRun: #TestDePerforación #test16PuedeContarLasCapasDeTipoConcreto stamp: 'LK 9/24/2023 23:35:46'!
PASSED!

!testRun: #TestDePerforación #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'LK 9/24/2023 23:35:46'!
ERROR!

!testRun: #TestDePerforación #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'LK 9/24/2023 23:35:46'!
ERROR!

!testRun: #TestDePerforación #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'LK 9/24/2023 23:35:46'!
ERROR!
!Perforadora methodsFor: 'scan' stamp: 'LK 9/24/2023 23:36:17' prior: 50666576!
calcularProfundidadDelSueloHasta: tipoDeCapa
	
	| valor acc altura |
	

	valor := 0.
	tipoDeCapa = #Arenoso ifTrue: [ valor := 7 ].
	tipoDeCapa = #Tierra ifTrue: [ valor := 10 ].
	tipoDeCapa = #Concreto ifTrue: [ valor := 50].	
	
	acc := 0.
	capasDeSueloDebajo do: [ :capaActual | valor = capaActual scan ifTrue: [ ^ acc ].
							altura := capaActual altura.
							altura = nil ifTrue: [ altura := 0 ].
							acc := acc + altura.].
! !

!testRun: #TestDePerforación #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'LK 9/24/2023 23:36:20'!
PASSED!

!testRun: #TestDePerforación #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'LK 9/24/2023 23:36:21'!
PASSED!

!testRun: #TestDePerforación #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'LK 9/24/2023 23:36:21'!
PASSED!

!testRun: #TestDePerforación #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'LK 9/24/2023 23:36:21'!
PASSED!

!testRun: #TestDePerforación #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'LK 9/24/2023 23:36:21'!
PASSED!

!testRun: #TestDePerforación #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'LK 9/24/2023 23:36:21'!
PASSED!

!testRun: #TestDePerforación #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'LK 9/24/2023 23:36:21'!
PASSED!

!testRun: #TestDePerforación #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'LK 9/24/2023 23:36:21'!
PASSED!

!testRun: #TestDePerforación #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'LK 9/24/2023 23:36:21'!
PASSED!

!testRun: #TestDePerforación #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'LK 9/24/2023 23:36:21'!
PASSED!

!testRun: #TestDePerforación #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'LK 9/24/2023 23:36:21'!
PASSED!

!testRun: #TestDePerforación #test12NoPuedePerforarSinMecha stamp: 'LK 9/24/2023 23:36:21'!
FAILURE!

!testRun: #TestDePerforación #test13PuedeCalcularProfundidadDelSuelo stamp: 'LK 9/24/2023 23:36:21'!
FAILURE!

!testRun: #TestDePerforación #test14PuedeContarLasCapasDeTipoArenoso stamp: 'LK 9/24/2023 23:36:21'!
PASSED!

!testRun: #TestDePerforación #test15PuedeContarLasCapasDeTipoTierra stamp: 'LK 9/24/2023 23:36:21'!
PASSED!

!testRun: #TestDePerforación #test16PuedeContarLasCapasDeTipoConcreto stamp: 'LK 9/24/2023 23:36:21'!
PASSED!

!testRun: #TestDePerforación #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'LK 9/24/2023 23:36:21'!
PASSED!

!testRun: #TestDePerforación #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'LK 9/24/2023 23:36:21'!
PASSED!

!testRun: #TestDePerforación #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'LK 9/24/2023 23:36:21'!
PASSED!
!Perforadora methodsFor: 'scan' stamp: 'LK 9/24/2023 23:36:30' prior: 50666669!
calcularProfundidadDelSueloHasta: tipoDeCapa
	
	| valor acc altura |
	
	valor := 0.
	
	tipoDeCapa = #Arenoso ifTrue: [ valor := 7 ].
	tipoDeCapa = #Tierra ifTrue: [ valor := 10 ].
	tipoDeCapa = #Concreto ifTrue: [ valor := 50].	
	
	acc := 0.
	capasDeSueloDebajo do: [ :capaActual | valor = capaActual scan ifTrue: [ ^ acc ].
							altura := capaActual altura.
							altura = nil ifTrue: [ altura := 0 ].
							acc := acc + altura.].
! !

!testRun: #TestDePerforación #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'LK 9/24/2023 23:36:32'!
PASSED!

!testRun: #TestDePerforación #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'LK 9/24/2023 23:36:32'!
PASSED!

!testRun: #TestDePerforación #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'LK 9/24/2023 23:36:32'!
PASSED!

!testRun: #TestDePerforación #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'LK 9/24/2023 23:36:32'!
PASSED!

!testRun: #TestDePerforación #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'LK 9/24/2023 23:36:32'!
PASSED!

!testRun: #TestDePerforación #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'LK 9/24/2023 23:36:32'!
PASSED!

!testRun: #TestDePerforación #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'LK 9/24/2023 23:36:32'!
PASSED!

!testRun: #TestDePerforación #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'LK 9/24/2023 23:36:32'!
PASSED!

!testRun: #TestDePerforación #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'LK 9/24/2023 23:36:32'!
PASSED!

!testRun: #TestDePerforación #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'LK 9/24/2023 23:36:32'!
PASSED!

!testRun: #TestDePerforación #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'LK 9/24/2023 23:36:32'!
PASSED!

!testRun: #TestDePerforación #test12NoPuedePerforarSinMecha stamp: 'LK 9/24/2023 23:36:32'!
FAILURE!

!testRun: #TestDePerforación #test13PuedeCalcularProfundidadDelSuelo stamp: 'LK 9/24/2023 23:36:32'!
FAILURE!

!testRun: #TestDePerforación #test14PuedeContarLasCapasDeTipoArenoso stamp: 'LK 9/24/2023 23:36:32'!
PASSED!

!testRun: #TestDePerforación #test15PuedeContarLasCapasDeTipoTierra stamp: 'LK 9/24/2023 23:36:32'!
PASSED!

!testRun: #TestDePerforación #test16PuedeContarLasCapasDeTipoConcreto stamp: 'LK 9/24/2023 23:36:32'!
PASSED!

!testRun: #TestDePerforación #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'LK 9/24/2023 23:36:32'!
PASSED!

!testRun: #TestDePerforación #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'LK 9/24/2023 23:36:32'!
PASSED!

!testRun: #TestDePerforación #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'LK 9/24/2023 23:36:32'!
PASSED!
!Perforadora methodsFor: 'scan' stamp: 'LK 9/24/2023 23:33:56' prior: 50666761!
calcularProfundidadDelSueloHasta: tipoDeCapa
	
	| valor acc altura |
	
	valor := 0.
	tipoDeCapa = #Arenoso ifTrue: [ valor := 7 ].
	tipoDeCapa = #Tierra ifTrue: [ valor := 10 ].
	tipoDeCapa = #Concreto ifTrue: [ valor := 50].	
	
	acc := 0.
	capasDeSueloDebajo do: [ :capaActual | valor = capaActual scan ifTrue: [ ^ acc ].
							altura := capaActual altura.
							altura = nil ifTrue: [ altura := 0 ].
							acc := acc + altura.].
! !

!testRun: #TestDePerforación #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'LK 9/24/2023 23:37:06'!
PASSED!

!testRun: #TestDePerforación #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'LK 9/24/2023 23:37:06'!
PASSED!

!testRun: #TestDePerforación #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'LK 9/24/2023 23:37:06'!
PASSED!

!testRun: #TestDePerforación #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'LK 9/24/2023 23:37:06'!
PASSED!

!testRun: #TestDePerforación #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'LK 9/24/2023 23:37:06'!
PASSED!

!testRun: #TestDePerforación #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'LK 9/24/2023 23:37:06'!
PASSED!

!testRun: #TestDePerforación #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'LK 9/24/2023 23:37:06'!
PASSED!

!testRun: #TestDePerforación #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'LK 9/24/2023 23:37:06'!
PASSED!

!testRun: #TestDePerforación #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'LK 9/24/2023 23:37:06'!
PASSED!

!testRun: #TestDePerforación #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'LK 9/24/2023 23:37:06'!
PASSED!

!testRun: #TestDePerforación #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'LK 9/24/2023 23:37:06'!
PASSED!

!testRun: #TestDePerforación #test12NoPuedePerforarSinMecha stamp: 'LK 9/24/2023 23:37:06'!
FAILURE!

!testRun: #TestDePerforación #test13PuedeCalcularProfundidadDelSuelo stamp: 'LK 9/24/2023 23:37:06'!
FAILURE!

!testRun: #TestDePerforación #test14PuedeContarLasCapasDeTipoArenoso stamp: 'LK 9/24/2023 23:37:06'!
PASSED!

!testRun: #TestDePerforación #test15PuedeContarLasCapasDeTipoTierra stamp: 'LK 9/24/2023 23:37:07'!
PASSED!

!testRun: #TestDePerforación #test16PuedeContarLasCapasDeTipoConcreto stamp: 'LK 9/24/2023 23:37:07'!
PASSED!

!testRun: #TestDePerforación #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'LK 9/24/2023 23:37:07'!
PASSED!

!testRun: #TestDePerforación #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'LK 9/24/2023 23:37:07'!
PASSED!

!testRun: #TestDePerforación #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'LK 9/24/2023 23:37:07'!
PASSED!

!testRun: #TestDePerforación #test13PuedeCalcularProfundidadDelSuelo stamp: 'LK 9/24/2023 23:37:25'!
FAILURE!
!Perforadora methodsFor: 'scan' stamp: 'LK 9/24/2023 23:38:28' prior: 50666457!
calcularProfundidadDelSuelo
	
	| acc altura |

	acc := 0.
	
	capasDeSueloDebajo do: [:capaActual | 	altura := capaActual altura.
									altura = nil ifTrue: [ altura := 0 ]. 
									acc := acc + altura.].
								
	^acc.

	
	 ! !

!testRun: #TestDePerforación #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'LK 9/24/2023 23:38:32'!
PASSED!

!testRun: #TestDePerforación #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'LK 9/24/2023 23:38:32'!
PASSED!

!testRun: #TestDePerforación #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'LK 9/24/2023 23:38:32'!
PASSED!

!testRun: #TestDePerforación #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'LK 9/24/2023 23:38:33'!
PASSED!

!testRun: #TestDePerforación #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'LK 9/24/2023 23:38:33'!
PASSED!

!testRun: #TestDePerforación #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'LK 9/24/2023 23:38:33'!
PASSED!

!testRun: #TestDePerforación #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'LK 9/24/2023 23:38:33'!
PASSED!

!testRun: #TestDePerforación #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'LK 9/24/2023 23:38:33'!
PASSED!

!testRun: #TestDePerforación #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'LK 9/24/2023 23:38:33'!
PASSED!

!testRun: #TestDePerforación #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'LK 9/24/2023 23:38:33'!
PASSED!

!testRun: #TestDePerforación #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'LK 9/24/2023 23:38:33'!
PASSED!

!testRun: #TestDePerforación #test12NoPuedePerforarSinMecha stamp: 'LK 9/24/2023 23:38:33'!
FAILURE!

!testRun: #TestDePerforación #test13PuedeCalcularProfundidadDelSuelo stamp: 'LK 9/24/2023 23:38:33'!
PASSED!

!testRun: #TestDePerforación #test14PuedeContarLasCapasDeTipoArenoso stamp: 'LK 9/24/2023 23:38:33'!
PASSED!

!testRun: #TestDePerforación #test15PuedeContarLasCapasDeTipoTierra stamp: 'LK 9/24/2023 23:38:33'!
PASSED!

!testRun: #TestDePerforación #test16PuedeContarLasCapasDeTipoConcreto stamp: 'LK 9/24/2023 23:38:33'!
PASSED!

!testRun: #TestDePerforación #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'LK 9/24/2023 23:38:33'!
PASSED!

!testRun: #TestDePerforación #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'LK 9/24/2023 23:38:33'!
PASSED!

!testRun: #TestDePerforación #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'LK 9/24/2023 23:38:33'!
PASSED!

!testRun: #TestDePerforación #test12NoPuedePerforarSinMecha stamp: 'LK 9/24/2023 23:38:33'!
FAILURE!
!MechaSoft methodsFor: 'excavation' stamp: 'LK 9/24/2023 23:41:29' overrides: 50665790!
darGolpeDeTaladro

	vecesQueGolpeoCapaActual := vecesQueGolpeoCapaActual + 1.
	
	self sobreSueloArenoso ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Widia ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Diamante ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
		^self].
	
	self sobreSueloTierra ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 2 ifTrue: [ ^self transformarCapaEnArenoso ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ ^self pasarAProximaCapa ]].
	
	self sobreSueloConcreto ifTrue: [
		mechaPuesta = #Soft ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió'  ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 3 ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ 
			vecesQueGolpeoCapaActual even ifTrue: [ capasDeSueloDebajo first bajaUnDecimoDeResistencia].
			capasDeSueloDebajo first sinResistencia ifTrue: [ ^self transformarCapaEnArenoso].
			^vecesQueGolpeoCapaActual ]].
	
	self error: 'error'! !
!MechaWidia methodsFor: 'excavation' stamp: 'LK 9/24/2023 23:41:29' overrides: 50665790!
darGolpeDeTaladro

	vecesQueGolpeoCapaActual := vecesQueGolpeoCapaActual + 1.
	
	self sobreSueloArenoso ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Widia ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Diamante ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
		^self].
	
	self sobreSueloTierra ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 2 ifTrue: [ ^self transformarCapaEnArenoso ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ ^self pasarAProximaCapa ]].
	
	self sobreSueloConcreto ifTrue: [
		mechaPuesta = #Soft ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió'  ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 3 ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ 
			vecesQueGolpeoCapaActual even ifTrue: [ capasDeSueloDebajo first bajaUnDecimoDeResistencia].
			capasDeSueloDebajo first sinResistencia ifTrue: [ ^self transformarCapaEnArenoso].
			^vecesQueGolpeoCapaActual ]].
	
	self error: 'error'! !
!MechaDiamante methodsFor: 'excavation' stamp: 'LK 9/24/2023 23:41:29' overrides: 50665790!
darGolpeDeTaladro

	vecesQueGolpeoCapaActual := vecesQueGolpeoCapaActual + 1.
	
	self sobreSueloArenoso ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Widia ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Diamante ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
		^self].
	
	self sobreSueloTierra ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 2 ifTrue: [ ^self transformarCapaEnArenoso ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ ^self pasarAProximaCapa ]].
	
	self sobreSueloConcreto ifTrue: [
		mechaPuesta = #Soft ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió'  ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 3 ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ 
			vecesQueGolpeoCapaActual even ifTrue: [ capasDeSueloDebajo first bajaUnDecimoDeResistencia].
			capasDeSueloDebajo first sinResistencia ifTrue: [ ^self transformarCapaEnArenoso].
			^vecesQueGolpeoCapaActual ]].
	
	self error: 'error'! !
!SinMecha methodsFor: 'excavation' stamp: 'LK 9/24/2023 23:41:29' prior: 50665709 overrides: 50665790!
darGolpeDeTaladro

	vecesQueGolpeoCapaActual := vecesQueGolpeoCapaActual + 1.
	
	self sobreSueloArenoso ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Widia ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Diamante ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
		^self].
	
	self sobreSueloTierra ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 2 ifTrue: [ ^self transformarCapaEnArenoso ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ ^self pasarAProximaCapa ]].
	
	self sobreSueloConcreto ifTrue: [
		mechaPuesta = #Soft ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió'  ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 3 ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ 
			vecesQueGolpeoCapaActual even ifTrue: [ capasDeSueloDebajo first bajaUnDecimoDeResistencia].
			capasDeSueloDebajo first sinResistencia ifTrue: [ ^self transformarCapaEnArenoso].
			^vecesQueGolpeoCapaActual ]].
	
	self error: 'error'! !
!MechaRota methodsFor: 'excavation' stamp: 'LK 9/24/2023 23:41:29' overrides: 50665790!
darGolpeDeTaladro

	vecesQueGolpeoCapaActual := vecesQueGolpeoCapaActual + 1.
	
	self sobreSueloArenoso ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Widia ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Diamante ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
		^self].
	
	self sobreSueloTierra ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 2 ifTrue: [ ^self transformarCapaEnArenoso ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ ^self pasarAProximaCapa ]].
	
	self sobreSueloConcreto ifTrue: [
		mechaPuesta = #Soft ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió'  ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 3 ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ 
			vecesQueGolpeoCapaActual even ifTrue: [ capasDeSueloDebajo first bajaUnDecimoDeResistencia].
			capasDeSueloDebajo first sinResistencia ifTrue: [ ^self transformarCapaEnArenoso].
			^vecesQueGolpeoCapaActual ]].
	
	self error: 'error'! !
!Perforadora methodsFor: 'excavation' stamp: 'LK 9/24/2023 23:41:29' prior: 50665790!
darGolpeDeTaladro

	self subclassResponsibility! !
!SinMecha methodsFor: 'excavation' stamp: 'LK 9/24/2023 22:52:14' prior: 50667154 overrides: 50667230!
darGolpeDeTaladro
		
	self error: SinMecha errorSinMecha.! !
!MechaDiamante methodsFor: 'excavation' stamp: 'LK 9/24/2023 23:42:39' prior: 50667115 overrides: 50667230!
darGolpeDeTaladro

	vecesQueGolpeoCapaActual := vecesQueGolpeoCapaActual + 1.
	
	self sobreSueloArenoso ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió'.
		^self].
	
	self sobreSueloTierra ifTrue: [^self pasarAProximaCapa ].
	
	self sobreSueloConcreto ifTrue: [ 
			vecesQueGolpeoCapaActual even ifTrue: [ capasDeSueloDebajo first bajaUnDecimoDeResistencia].
			capasDeSueloDebajo first sinResistencia ifTrue: [ ^self transformarCapaEnArenoso].
			^vecesQueGolpeoCapaActual ].
	
	self error: 'error'! !
!MechaSoft methodsFor: 'excavation' stamp: 'LK 9/24/2023 23:44:20' prior: 50667038 overrides: 50667230!
darGolpeDeTaladro

	vecesQueGolpeoCapaActual := vecesQueGolpeoCapaActual + 1.
	
	self sobreSueloArenoso ifTrue: [^self pasarAProximaCapa].
	
	self sobreSueloTierra ifTrue: [^self].
	
	self sobreSueloConcreto ifTrue: [mechaPuesta := #Rota. self error: 'Se rompió'].
	
	self error: 'error'! !
!MechaWidia methodsFor: 'excavation' stamp: 'LK 9/24/2023 23:44:41' prior: 50667076 overrides: 50667230!
darGolpeDeTaladro

	vecesQueGolpeoCapaActual := vecesQueGolpeoCapaActual + 1.
	
	self sobreSueloArenoso ifTrue: [^self pasarAProximaCapa].
	
	self sobreSueloTierra ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 2 ifTrue: [ ^self transformarCapaEnArenoso ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ ^self pasarAProximaCapa ]].
	
	self sobreSueloConcreto ifTrue: [
		mechaPuesta = #Soft ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió'  ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 3 ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ 
			vecesQueGolpeoCapaActual even ifTrue: [ capasDeSueloDebajo first bajaUnDecimoDeResistencia].
			capasDeSueloDebajo first sinResistencia ifTrue: [ ^self transformarCapaEnArenoso].
			^vecesQueGolpeoCapaActual ]].
	
	self error: 'error'! !
!MechaWidia methodsFor: 'excavation' stamp: 'LK 9/24/2023 23:44:57' prior: 50667274 overrides: 50667230!
darGolpeDeTaladro

	vecesQueGolpeoCapaActual := vecesQueGolpeoCapaActual + 1.
	
	self sobreSueloArenoso ifTrue: [^self pasarAProximaCapa].
	
	self sobreSueloTierra ifTrue: [vecesQueGolpeoCapaActual = 2 ifTrue: [ ^self transformarCapaEnArenoso ].
			^self].
	
	self sobreSueloConcreto ifTrue: [
		mechaPuesta = #Soft ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió'  ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 3 ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ 
			vecesQueGolpeoCapaActual even ifTrue: [ capasDeSueloDebajo first bajaUnDecimoDeResistencia].
			capasDeSueloDebajo first sinResistencia ifTrue: [ ^self transformarCapaEnArenoso].
			^vecesQueGolpeoCapaActual ]].
	
	self error: 'error'! !
!MechaWidia methodsFor: 'excavation' stamp: 'LK 9/24/2023 23:45:17' prior: 50667307 overrides: 50667230!
darGolpeDeTaladro

	vecesQueGolpeoCapaActual := vecesQueGolpeoCapaActual + 1.
	
	self sobreSueloArenoso ifTrue: [^self pasarAProximaCapa].
	
	self sobreSueloTierra ifTrue: [vecesQueGolpeoCapaActual = 2 ifTrue: [ ^self transformarCapaEnArenoso ].
			^self].
	
	self sobreSueloConcreto ifTrue: [
			vecesQueGolpeoCapaActual = 3 ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
			^self ].
	
	self error: 'error'! !

CapaDeSuelo subclass: #Piedras
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classDefinition: #Piedras category: 'ISW1-2023-1C-Parcial-1' stamp: 'LK 9/24/2023 23:51:25'!
CapaDeSuelo subclass: #Piedras
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

Object subclass: #Mechas
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classDefinition: #Mechas category: 'ISW1-2023-1C-Parcial-1' stamp: 'LK 9/24/2023 23:51:41'!
Object subclass: #Mechas
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

Mechas subclass: #Diamante
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classDefinition: #Diamante category: 'ISW1-2023-1C-Parcial-1' stamp: 'LK 9/24/2023 23:59:58'!
Mechas subclass: #Diamante
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

Mechas subclass: #Widia
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classDefinition: #Widia category: 'ISW1-2023-1C-Parcial-1' stamp: 'LK 9/25/2023 00:00:01'!
Mechas subclass: #Widia
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

Mechas subclass: #Rota
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classDefinition: #Rota category: 'ISW1-2023-1C-Parcial-1' stamp: 'LK 9/25/2023 00:00:03'!
Mechas subclass: #Rota
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

Mechas subclass: #Soft
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classDefinition: #Soft category: 'ISW1-2023-1C-Parcial-1' stamp: 'LK 9/25/2023 00:00:16'!
Mechas subclass: #Soft
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

Mechas subclass: #SinMecha
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classDefinition: #SinMecha category: 'ISW1-2023-1C-Parcial-1' stamp: 'LK 9/25/2023 00:00:25'!
Mechas subclass: #SinMecha
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classRemoval: #MechaDiamante stamp: 'LK 9/25/2023 00:01:35'!
Perforadora subclass: #MechaDiamante
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classRemoval: #MechaRota stamp: 'LK 9/25/2023 00:01:37'!
Perforadora subclass: #MechaRota
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classRemoval: #MechaSoft stamp: 'LK 9/25/2023 00:01:39'!
Perforadora subclass: #MechaSoft
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classRemoval: #MechaWidia stamp: 'LK 9/25/2023 00:01:40'!
Perforadora subclass: #MechaWidia
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!
!Perforadora methodsFor: 'accessing' stamp: 'LK 9/25/2023 00:02:28' prior: 50661886!
sinMecha

	^mechaPuesta = SinMecha new.! !
!Perforadora methodsFor: 'accessing' stamp: 'LK 9/25/2023 00:02:45' prior: 50661878!
conMechaRota

	^mechaPuesta = Rota new.! !
!Perforadora methodsFor: 'colocar mecha' stamp: 'LK 9/25/2023 00:03:08' prior: 50661909!
ponerMechaSoft
	mechaPuesta := Soft new! !
!Perforadora methodsFor: 'colocar mecha' stamp: 'LK 9/25/2023 00:03:12' prior: 50661913!
ponerMechaWidia
	mechaPuesta := Widia new! !
!Perforadora methodsFor: 'colocar mecha' stamp: 'LK 9/25/2023 00:03:17' prior: 50661905!
ponerMechaDiamante
	mechaPuesta := Diamante new! !
!Perforadora methodsFor: 'initialization' stamp: 'LK 9/25/2023 00:03:31' prior: 50661865!
initializeSobreSuelo: capasDeSueloAExcavarInicialmente

	capasDeSueloDebajo := capasDeSueloAExcavarInicialmente.
	vecesQueGolpeoCapaActual := 0.
	container := OrderedCollection new.
	mechaPuesta := SinMecha new.! !
!Perforadora methodsFor: 'accessing' stamp: 'LK 9/25/2023 00:04:46' prior: 50667462!
conMechaRota

	^mechaPuesta class = Rota.! !
!Perforadora methodsFor: 'scan' stamp: 'LK 9/25/2023 00:06:27' prior: 50665461!
contarCapas: tipoDeCapa
	
	"Cuenta las capas de tipo tipoDeCapa. Recordar que para identificar cada capa se utiliza el valor de scan que retorna. Por ej. un capa tipo Arenoso retorna 7 al scan"
	
	| capitas valor |
	
	valor := tipoDeCapa scan.
	
	capitas := capasDeSueloDebajo count: [ :capaActual | valor = capaActual scan].
	
	 ^capitas.
! !
!Perforadora methodsFor: 'excavation' stamp: 'LK 9/25/2023 00:07:53' prior: 50667230!
darGolpeDeTaladro

	self sinMecha ifTrue: [self error: 'No puede perforar'].

	vecesQueGolpeoCapaActual := vecesQueGolpeoCapaActual + 1.

	self sobreSueloArenoso ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Widia ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Diamante ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
		^self].
	
	self sobreSueloTierra ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 2 ifTrue: [ ^self transformarCapaEnArenoso ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ ^self pasarAProximaCapa ]].
	
	self sobreSueloConcreto ifTrue: [
		mechaPuesta = #Soft ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió'  ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 3 ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ 
			vecesQueGolpeoCapaActual even ifTrue: [ capasDeSueloDebajo first bajaUnDecimoDeResistencia].
			capasDeSueloDebajo first sinResistencia ifTrue: [ ^self transformarCapaEnArenoso].
			^vecesQueGolpeoCapaActual ]].
	
	self error: 'error'! !
!Perforadora methodsFor: 'excavation' stamp: 'LK 9/25/2023 00:09:57' prior: 50667510!
darGolpeDeTaladro

	^mechaPuesta darGolpeCon: self.
	"
	self sinMecha ifTrue: [self error: 'No puede perforar'].

	vecesQueGolpeoCapaActual := vecesQueGolpeoCapaActual + 1.

	self sobreSueloArenoso ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Widia ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Diamante ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
		^self].
	
	self sobreSueloTierra ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 2 ifTrue: [ ^self transformarCapaEnArenoso ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ ^self pasarAProximaCapa ]].
	
	self sobreSueloConcreto ifTrue: [
		mechaPuesta = #Soft ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió'  ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 3 ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ 
			vecesQueGolpeoCapaActual even ifTrue: [ capasDeSueloDebajo first bajaUnDecimoDeResistencia].
			capasDeSueloDebajo first sinResistencia ifTrue: [ ^self transformarCapaEnArenoso].
			^vecesQueGolpeoCapaActual ]].
	
	self error: 'error'"! !
!SinMecha methodsFor: 'excavation' stamp: 'LK 9/25/2023 00:10:23'!
darGolpeCon: aPerforadora
		
	self error: SinMecha errorSinMecha.! !

!methodRemoval: SinMecha #darGolpeDeTaladro stamp: 'LK 9/25/2023 00:10:26'!
darGolpeDeTaladro
		
	self error: SinMecha errorSinMecha.!
!Rota methodsFor: 'no messages' stamp: 'LK 9/25/2023 00:10:52'!
darGolpeCon: aPerforadora
	^self error: 'no'.! !

Mechas subclass: #Funcional
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classDefinition: #Funcional category: 'ISW1-2023-1C-Parcial-1' stamp: 'LK 9/25/2023 00:11:48'!
Mechas subclass: #Funcional
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classRemoval: #Funcional stamp: 'LK 9/25/2023 00:12:42'!
Mechas subclass: #Funcional
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classDefinition: #Funcional category: 'ISW1-2023-1C-Parcial-1' stamp: 'LK 9/25/2023 00:12:49'!
Mechas subclass: #Funcional
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classDefinition: #Diamante category: 'ISW1-2023-1C-Parcial-1' stamp: 'LK 9/25/2023 00:12:49'!
Funcional subclass: #Diamante
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

Funcional subclass: #Rota
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classDefinition: #Rota category: 'ISW1-2023-1C-Parcial-1' stamp: 'LK 9/25/2023 00:13:19'!
Funcional subclass: #Rota
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

Mechas subclass: #Rota
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classDefinition: #Rota category: 'ISW1-2023-1C-Parcial-1' stamp: 'LK 9/25/2023 00:13:28'!
Mechas subclass: #Rota
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

Funcional subclass: #Soft
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classDefinition: #Soft category: 'ISW1-2023-1C-Parcial-1' stamp: 'LK 9/25/2023 00:13:35'!
Funcional subclass: #Soft
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

Funcional subclass: #Widia
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!

!classDefinition: #Widia category: 'ISW1-2023-1C-Parcial-1' stamp: 'LK 9/25/2023 00:13:38'!
Funcional subclass: #Widia
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-1C-Parcial-1'!
!Funcional methodsFor: 'nil' stamp: 'LK 9/25/2023 00:14:37'!
darGolpeCon: aPerforadora

	^aPerforadora darGolpeConMechaFuncional.! !
!Perforadora methodsFor: 'excavation' stamp: 'LK 9/25/2023 00:18:51'!
darGolpeConMechaFuncional

	vecesQueGolpeoCapaActual := vecesQueGolpeoCapaActual + 1.
	
	^(self capaDeSueloInmediata) darGolpeDesde: self con: mechaPuesta.
! !
!CapaDeSuelo methodsFor: 'comparing' stamp: 'LK 9/25/2023 00:20:48'!
darGolpeDesde: aPerforadora con: aMechaPuesta! !
!Arenoso methodsFor: 'comparing' stamp: 'LK 9/25/2023 00:20:53' overrides: 50667695!
darGolpeDesde: aPerforadora con: aMechaPuesta! !
!Tierra methodsFor: 'comparing' stamp: 'LK 9/25/2023 00:20:53' overrides: 50667695!
darGolpeDesde: aPerforadora con: aMechaPuesta! !
!Concreto methodsFor: 'comparing' stamp: 'LK 9/25/2023 00:20:53' overrides: 50667695!
darGolpeDesde: aPerforadora con: aMechaPuesta! !
!Piedras methodsFor: 'comparing' stamp: 'LK 9/25/2023 00:20:53' overrides: 50667695!
darGolpeDesde: aPerforadora con: aMechaPuesta! !
!CapaDeSuelo methodsFor: 'comparing' stamp: 'LK 9/25/2023 00:20:53' prior: 50667695!
darGolpeDesde: aPerforadora con: aMechaPuesta

	self subclassResponsibility! !
!Arenoso methodsFor: 'comparing' stamp: 'LK 9/25/2023 00:21:44' prior: 50667700 overrides: 50667720!
darGolpeDesde: aPerforadora con: aMechaPuesta
	^aMechaPuesta golpearSueloArenosoCon: aPerforadora.! !
!Concreto methodsFor: 'comparing' stamp: 'LK 9/25/2023 00:22:02' prior: 50667710 overrides: 50667720!
darGolpeDesde: aPerforadora con: aMechaPuesta
	^aMechaPuesta golpearSueloConcretoCon: aPerforadora.! !
!Tierra methodsFor: 'comparing' stamp: 'LK 9/25/2023 00:22:19' prior: 50667705 overrides: 50667720!
darGolpeDesde: aPerforadora con: aMechaPuesta
	^aMechaPuesta golpearSueloTierraCon: aPerforadora.! !
!Diamante methodsFor: 'nil' stamp: 'LK 9/25/2023 00:24:01'!
golpearSueloConcretoCon: aPerforadora
	^aPerforadora golpearSueloConcretoConMechaDiamante.
! !
!Diamante methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 00:24:14'!
golpearSueloArenosoCon: aPerforadora
	^aPerforadora golpearSueloArenosoConMechaDiamante.
! !
!Diamante methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 00:24:22'!
golpearSueloTierraCon: aPerforadora
	^aPerforadora golpearSueloTierraConMechaDiamante.
! !
!Soft methodsFor: 'nil' stamp: 'LK 9/25/2023 00:24:40'!
golpearSueloConcretoCon: aPerforadora
	^aPerforadora golpearSueloConcretoConMechaSoft.! !
!Soft methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 00:24:49'!
golpearSueloArenosoCon: aPerforadora
	^aPerforadora golpearSueloArenosoConMechaSoft.! !
!Soft methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 00:25:01'!
golpearSueloTierraCon: aPerforadora
	^aPerforadora golpearSueloTierraConMechaSoft.! !
!Widia methodsFor: 'no messages' stamp: 'LK 9/25/2023 00:25:37'!
golpearSueloTierraCon: aPerforadora
	^aPerforadora golpearSueloTierraConMechaWidia.! !
!Widia methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 00:25:45'!
golpearSueloArenosoCon: aPerforadora
	^aPerforadora golpearSueloArenosoConMechaWidia.! !
!Widia methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 00:26:00'!
golpearSueloConcretoCon: aPerforadora
	^aPerforadora golpearSueloConcretoConMechaWidia.! !
!Perforadora methodsFor: 'excavation' stamp: 'LK 9/25/2023 00:27:15'!
golpearSueloArenosoConMechaSoft
	^self pasarAProximaCapa
"
	self sobreSueloArenoso ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Widia ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Diamante ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
		^self].
	
	self sobreSueloTierra ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 2 ifTrue: [ ^self transformarCapaEnArenoso ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ ^self pasarAProximaCapa ]].
	
	self sobreSueloConcreto ifTrue: [
		mechaPuesta = #Soft ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió'  ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 3 ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ 
			vecesQueGolpeoCapaActual even ifTrue: [ capasDeSueloDebajo first bajaUnDecimoDeResistencia].
			capasDeSueloDebajo first sinResistencia ifTrue: [ ^self transformarCapaEnArenoso].
			^vecesQueGolpeoCapaActual ]].
	
	self error: 'error'"! !
!Perforadora methodsFor: 'excavation' stamp: 'LK 9/25/2023 00:27:21'!
golpearSueloArenosoConMechaWidia
	^self pasarAProximaCapa
"
	self sobreSueloArenoso ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Widia ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Diamante ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
		^self].
	
	self sobreSueloTierra ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 2 ifTrue: [ ^self transformarCapaEnArenoso ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ ^self pasarAProximaCapa ]].
	
	self sobreSueloConcreto ifTrue: [
		mechaPuesta = #Soft ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió'  ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 3 ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ 
			vecesQueGolpeoCapaActual even ifTrue: [ capasDeSueloDebajo first bajaUnDecimoDeResistencia].
			capasDeSueloDebajo first sinResistencia ifTrue: [ ^self transformarCapaEnArenoso].
			^vecesQueGolpeoCapaActual ]].
	
	self error: 'error'"! !
!Perforadora methodsFor: 'excavation' stamp: 'LK 9/25/2023 00:27:42'!
golpearSueloArenosoConMechaDiamante
	mechaPuesta := #Rota.
	 self error: 'Se rompió' 
"
	self sobreSueloArenoso ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Widia ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Diamante ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
		^self].
	
	self sobreSueloTierra ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 2 ifTrue: [ ^self transformarCapaEnArenoso ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ ^self pasarAProximaCapa ]].
	
	self sobreSueloConcreto ifTrue: [
		mechaPuesta = #Soft ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió'  ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 3 ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ 
			vecesQueGolpeoCapaActual even ifTrue: [ capasDeSueloDebajo first bajaUnDecimoDeResistencia].
			capasDeSueloDebajo first sinResistencia ifTrue: [ ^self transformarCapaEnArenoso].
			^vecesQueGolpeoCapaActual ]].
	
	self error: 'error'"! !
!Perforadora methodsFor: 'excavation' stamp: 'LK 9/25/2023 00:28:19' prior: 50667870!
golpearSueloArenosoConMechaDiamante
	self conMechaRota.
	self error: 'Se rompió'.
	^self
"
	self sobreSueloArenoso ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Widia ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Diamante ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
		^self].
	
	self sobreSueloTierra ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 2 ifTrue: [ ^self transformarCapaEnArenoso ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ ^self pasarAProximaCapa ]].
	
	self sobreSueloConcreto ifTrue: [
		mechaPuesta = #Soft ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió'  ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 3 ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ 
			vecesQueGolpeoCapaActual even ifTrue: [ capasDeSueloDebajo first bajaUnDecimoDeResistencia].
			capasDeSueloDebajo first sinResistencia ifTrue: [ ^self transformarCapaEnArenoso].
			^vecesQueGolpeoCapaActual ]].
	
	self error: 'error'"! !
!Perforadora methodsFor: 'excavation' stamp: 'LK 9/25/2023 00:28:35'!
golpearSueloTierraConMechaDiamante
	^self pasarAProximaCapa
"
	self sobreSueloArenoso ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Widia ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Diamante ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
		^self].
	
	self sobreSueloTierra ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 2 ifTrue: [ ^self transformarCapaEnArenoso ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ ^self pasarAProximaCapa ]].
	
	self sobreSueloConcreto ifTrue: [
		mechaPuesta = #Soft ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió'  ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 3 ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ 
			vecesQueGolpeoCapaActual even ifTrue: [ capasDeSueloDebajo first bajaUnDecimoDeResistencia].
			capasDeSueloDebajo first sinResistencia ifTrue: [ ^self transformarCapaEnArenoso].
			^vecesQueGolpeoCapaActual ]].
	
	self error: 'error'"! !
!Perforadora methodsFor: 'excavation' stamp: 'LK 9/25/2023 00:29:06' prior: 50667947!
golpearSueloTierraConMechaDiamante
	vecesQueGolpeoCapaActual = 2 ifTrue: [ ^self transformarCapaEnArenoso ].
	^self 
"
	self sobreSueloArenoso ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Widia ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Diamante ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
		^self].
	
	self sobreSueloTierra ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 2 ifTrue: [ ^self transformarCapaEnArenoso ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ ^self pasarAProximaCapa ]].
	
	self sobreSueloConcreto ifTrue: [
		mechaPuesta = #Soft ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió'  ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 3 ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ 
			vecesQueGolpeoCapaActual even ifTrue: [ capasDeSueloDebajo first bajaUnDecimoDeResistencia].
			capasDeSueloDebajo first sinResistencia ifTrue: [ ^self transformarCapaEnArenoso].
			^vecesQueGolpeoCapaActual ]].
	
	self error: 'error'"! !
!Perforadora methodsFor: 'excavation' stamp: 'LK 9/25/2023 00:29:26' prior: 50667985!
golpearSueloTierraConMechaDiamante
	^self pasarAProximaCapa.
"
	self sobreSueloArenoso ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Widia ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Diamante ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
		^self].
	
	self sobreSueloTierra ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 2 ifTrue: [ ^self transformarCapaEnArenoso ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ ^self pasarAProximaCapa ]].
	
	self sobreSueloConcreto ifTrue: [
		mechaPuesta = #Soft ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió'  ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 3 ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ 
			vecesQueGolpeoCapaActual even ifTrue: [ capasDeSueloDebajo first bajaUnDecimoDeResistencia].
			capasDeSueloDebajo first sinResistencia ifTrue: [ ^self transformarCapaEnArenoso].
			^vecesQueGolpeoCapaActual ]].
	
	self error: 'error'"! !
!Perforadora methodsFor: 'excavation' stamp: 'LK 9/25/2023 00:29:39'!
golpearSueloTierraConMechaWidia
	vecesQueGolpeoCapaActual = 2 ifTrue: [ ^self transformarCapaEnArenoso ].
	^self
"
	self sobreSueloArenoso ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Widia ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Diamante ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
		^self].
	
	self sobreSueloTierra ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 2 ifTrue: [ ^self transformarCapaEnArenoso ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ ^self pasarAProximaCapa ]].
	
	self sobreSueloConcreto ifTrue: [
		mechaPuesta = #Soft ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió'  ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 3 ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ 
			vecesQueGolpeoCapaActual even ifTrue: [ capasDeSueloDebajo first bajaUnDecimoDeResistencia].
			capasDeSueloDebajo first sinResistencia ifTrue: [ ^self transformarCapaEnArenoso].
			^vecesQueGolpeoCapaActual ]].
	
	self error: 'error'"! !
!Perforadora methodsFor: 'excavation' stamp: 'LK 9/25/2023 00:29:49'!
golpearSueloTierraConMechaSoft
	^self
"
	self sobreSueloArenoso ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Widia ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Diamante ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
		^self].
	
	self sobreSueloTierra ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 2 ifTrue: [ ^self transformarCapaEnArenoso ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ ^self pasarAProximaCapa ]].
	
	self sobreSueloConcreto ifTrue: [
		mechaPuesta = #Soft ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió'  ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 3 ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ 
			vecesQueGolpeoCapaActual even ifTrue: [ capasDeSueloDebajo first bajaUnDecimoDeResistencia].
			capasDeSueloDebajo first sinResistencia ifTrue: [ ^self transformarCapaEnArenoso].
			^vecesQueGolpeoCapaActual ]].
	
	self error: 'error'"! !
!Perforadora methodsFor: 'excavation' stamp: 'LK 9/25/2023 00:30:38'!
golpearSueloConcretoConMechaSoft
	self conMechaRota.
	^self error: 'Se rompió'.
"
	self sobreSueloArenoso ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Widia ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Diamante ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
		^self].
	
	self sobreSueloTierra ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 2 ifTrue: [ ^self transformarCapaEnArenoso ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ ^self pasarAProximaCapa ]].
	
	self sobreSueloConcreto ifTrue: [
		mechaPuesta = #Soft ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió'  ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 3 ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ 
			vecesQueGolpeoCapaActual even ifTrue: [ capasDeSueloDebajo first bajaUnDecimoDeResistencia].
			capasDeSueloDebajo first sinResistencia ifTrue: [ ^self transformarCapaEnArenoso].
			^vecesQueGolpeoCapaActual ]].
	
	self error: 'error'"! !
!Perforadora methodsFor: 'excavation' stamp: 'LK 9/25/2023 00:31:59'!
golpearSueloConcretoConMechaWidia
	vecesQueGolpeoCapaActual = 3 ifTrue: [self conMechaRota . ^self error: 'Se rompió'].
"
	self sobreSueloArenoso ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Widia ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Diamante ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
		^self].
	
	self sobreSueloTierra ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 2 ifTrue: [ ^self transformarCapaEnArenoso ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ ^self pasarAProximaCapa ]].
	
	self sobreSueloConcreto ifTrue: [
		mechaPuesta = #Soft ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió'  ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 3 ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ 
			vecesQueGolpeoCapaActual even ifTrue: [ capasDeSueloDebajo first bajaUnDecimoDeResistencia].
			capasDeSueloDebajo first sinResistencia ifTrue: [ ^self transformarCapaEnArenoso].
			^vecesQueGolpeoCapaActual ]].
	
	self error: 'error'"! !
!Perforadora methodsFor: 'excavation' stamp: 'LK 9/25/2023 00:33:08'!
golpearSueloConcretoConMechaDiamante
	vecesQueGolpeoCapaActual even ifTrue: [ capasDeSueloDebajo first bajaUnDecimoDeResistencia].
	capasDeSueloDebajo first sinResistencia ifTrue: [ ^self transformarCapaEnArenoso].
	^vecesQueGolpeoCapaActual
"
	self sobreSueloArenoso ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Widia ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Diamante ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
		^self].
	
	self sobreSueloTierra ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 2 ifTrue: [ ^self transformarCapaEnArenoso ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ ^self pasarAProximaCapa ]].
	
	self sobreSueloConcreto ifTrue: [
		mechaPuesta = #Soft ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió'  ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 3 ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ 
			vecesQueGolpeoCapaActual even ifTrue: [ capasDeSueloDebajo first bajaUnDecimoDeResistencia].
			capasDeSueloDebajo first sinResistencia ifTrue: [ ^self transformarCapaEnArenoso].
			^vecesQueGolpeoCapaActual ]].
	
	self error: 'error'"! !

!testRun: #TestDePerforación #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'LK 9/25/2023 00:33:40'!
PASSED!

!testRun: #TestDePerforación #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'LK 9/25/2023 00:33:40'!
PASSED!

!testRun: #TestDePerforación #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'LK 9/25/2023 00:33:40'!
FAILURE!

!testRun: #TestDePerforación #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'LK 9/25/2023 00:33:40'!
PASSED!

!testRun: #TestDePerforación #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'LK 9/25/2023 00:33:40'!
PASSED!

!testRun: #TestDePerforación #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'LK 9/25/2023 00:33:40'!
FAILURE!

!testRun: #TestDePerforación #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'LK 9/25/2023 00:33:40'!
FAILURE!

!testRun: #TestDePerforación #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'LK 9/25/2023 00:33:40'!
PASSED!

!testRun: #TestDePerforación #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'LK 9/25/2023 00:33:40'!
PASSED!

!testRun: #TestDePerforación #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'LK 9/25/2023 00:33:40'!
PASSED!

!testRun: #TestDePerforación #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'LK 9/25/2023 00:33:41'!
PASSED!

!testRun: #TestDePerforación #test12NoPuedePerforarSinMecha stamp: 'LK 9/25/2023 00:33:41'!
PASSED!

!testRun: #TestDePerforación #test13PuedeCalcularProfundidadDelSuelo stamp: 'LK 9/25/2023 00:33:41'!
PASSED!

!testRun: #TestDePerforación #test14PuedeContarLasCapasDeTipoArenoso stamp: 'LK 9/25/2023 00:33:41'!
ERROR!

!testRun: #TestDePerforación #test15PuedeContarLasCapasDeTipoTierra stamp: 'LK 9/25/2023 00:33:41'!
ERROR!

!testRun: #TestDePerforación #test16PuedeContarLasCapasDeTipoConcreto stamp: 'LK 9/25/2023 00:33:41'!
ERROR!

!testRun: #TestDePerforación #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'LK 9/25/2023 00:33:41'!
PASSED!

!testRun: #TestDePerforación #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'LK 9/25/2023 00:33:41'!
PASSED!

!testRun: #TestDePerforación #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'LK 9/25/2023 00:33:41'!
PASSED!

!testRun: #TestDePerforación #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'LK 9/25/2023 00:34:00'!
FAILURE!

!testRun: #TestDePerforación #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'LK 9/25/2023 00:34:00'!
FAILURE!
!Perforadora methodsFor: 'scan' stamp: 'LK 9/25/2023 00:34:46' prior: 50666853!
calcularProfundidadDelSueloHasta: tipoDeCapa
	
	| valor acc altura |
	
	valor := tipoDeCapa scan.
	
	acc := 0.
	capasDeSueloDebajo do: [ :capaActual | valor = capaActual scan ifTrue: [ ^ acc ].
							altura := capaActual altura.
							altura = nil ifTrue: [ altura := 0 ].
							acc := acc + altura.].
! !
!Perforadora methodsFor: 'colocar mecha' stamp: 'LK 9/25/2023 00:35:57'!
ponerMechaRota
	mechaPuesta := Rota new! !
!Perforadora methodsFor: 'excavation' stamp: 'LK 9/25/2023 00:36:35' prior: 50668176!
golpearSueloConcretoConMechaWidia
	vecesQueGolpeoCapaActual = 3 ifTrue: [self ponerMechaRota . ^self error: 'Se rompió'].
"
	self sobreSueloArenoso ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Widia ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Diamante ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
		^self].
	
	self sobreSueloTierra ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 2 ifTrue: [ ^self transformarCapaEnArenoso ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ ^self pasarAProximaCapa ]].
	
	self sobreSueloConcreto ifTrue: [
		mechaPuesta = #Soft ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió'  ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 3 ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ 
			vecesQueGolpeoCapaActual even ifTrue: [ capasDeSueloDebajo first bajaUnDecimoDeResistencia].
			capasDeSueloDebajo first sinResistencia ifTrue: [ ^self transformarCapaEnArenoso].
			^vecesQueGolpeoCapaActual ]].
	
	self error: 'error'"! !
!Perforadora methodsFor: 'excavation' stamp: 'LK 9/25/2023 00:36:41' prior: 50668138!
golpearSueloConcretoConMechaSoft
	self ponerMechaRota.
	^self error: 'Se rompió'.
"
	self sobreSueloArenoso ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Widia ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Diamante ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
		^self].
	
	self sobreSueloTierra ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 2 ifTrue: [ ^self transformarCapaEnArenoso ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ ^self pasarAProximaCapa ]].
	
	self sobreSueloConcreto ifTrue: [
		mechaPuesta = #Soft ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió'  ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 3 ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ 
			vecesQueGolpeoCapaActual even ifTrue: [ capasDeSueloDebajo first bajaUnDecimoDeResistencia].
			capasDeSueloDebajo first sinResistencia ifTrue: [ ^self transformarCapaEnArenoso].
			^vecesQueGolpeoCapaActual ]].
	
	self error: 'error'"! !
!Perforadora methodsFor: 'excavation' stamp: 'LK 9/25/2023 00:36:52' prior: 50667909!
golpearSueloArenosoConMechaDiamante
	self ponerMechaRota.
	self error: 'Se rompió'.
	^self
"
	self sobreSueloArenoso ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Widia ifTrue: [ ^self pasarAProximaCapa ].
		mechaPuesta = #Diamante ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
		^self].
	
	self sobreSueloTierra ifTrue: [
		mechaPuesta = #Soft ifTrue: [ ^self ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 2 ifTrue: [ ^self transformarCapaEnArenoso ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ ^self pasarAProximaCapa ]].
	
	self sobreSueloConcreto ifTrue: [
		mechaPuesta = #Soft ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió'  ].
		mechaPuesta = #Widia ifTrue: [ 
			vecesQueGolpeoCapaActual = 3 ifTrue: [ mechaPuesta := #Rota. self error: 'Se rompió' ].
			^self ].
		mechaPuesta = #Diamante ifTrue: [ 
			vecesQueGolpeoCapaActual even ifTrue: [ capasDeSueloDebajo first bajaUnDecimoDeResistencia].
			capasDeSueloDebajo first sinResistencia ifTrue: [ ^self transformarCapaEnArenoso].
			^vecesQueGolpeoCapaActual ]].
	
	self error: 'error'"! !

!testRun: #TestDePerforación #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'LK 9/25/2023 00:36:54'!
PASSED!

!testRun: #TestDePerforación #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'LK 9/25/2023 00:36:54'!
PASSED!

!testRun: #TestDePerforación #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'LK 9/25/2023 00:36:54'!
PASSED!

!testRun: #TestDePerforación #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'LK 9/25/2023 00:36:54'!
PASSED!

!testRun: #TestDePerforación #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'LK 9/25/2023 00:36:54'!
PASSED!

!testRun: #TestDePerforación #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'LK 9/25/2023 00:36:54'!
PASSED!

!testRun: #TestDePerforación #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'LK 9/25/2023 00:36:54'!
PASSED!

!testRun: #TestDePerforación #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'LK 9/25/2023 00:36:54'!
PASSED!

!testRun: #TestDePerforación #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'LK 9/25/2023 00:36:54'!
PASSED!

!testRun: #TestDePerforación #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'LK 9/25/2023 00:36:54'!
PASSED!

!testRun: #TestDePerforación #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'LK 9/25/2023 00:36:54'!
PASSED!

!testRun: #TestDePerforación #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'LK 9/25/2023 00:36:54'!
PASSED!

!testRun: #TestDePerforación #test12NoPuedePerforarSinMecha stamp: 'LK 9/25/2023 00:36:54'!
PASSED!

!testRun: #TestDePerforación #test13PuedeCalcularProfundidadDelSuelo stamp: 'LK 9/25/2023 00:36:54'!
PASSED!

!testRun: #TestDePerforación #test14PuedeContarLasCapasDeTipoArenoso stamp: 'LK 9/25/2023 00:36:54'!
ERROR!

!testRun: #TestDePerforación #test15PuedeContarLasCapasDeTipoTierra stamp: 'LK 9/25/2023 00:36:54'!
ERROR!

!testRun: #TestDePerforación #test16PuedeContarLasCapasDeTipoConcreto stamp: 'LK 9/25/2023 00:36:54'!
ERROR!

!testRun: #TestDePerforación #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'LK 9/25/2023 00:36:54'!
ERROR!

!testRun: #TestDePerforación #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'LK 9/25/2023 00:36:54'!
ERROR!

!testRun: #TestDePerforación #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'LK 9/25/2023 00:36:54'!
ERROR!
!Tierra methodsFor: 'scan' stamp: 'LK 9/25/2023 00:37:47' prior: 50665995 overrides: 50666007!
scan
	^10.! !

!testRun: #TestDePerforación #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'LK 9/25/2023 00:37:56'!
PASSED!

!testRun: #TestDePerforación #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'LK 9/25/2023 00:37:56'!
PASSED!

!testRun: #TestDePerforación #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'LK 9/25/2023 00:37:56'!
PASSED!

!testRun: #TestDePerforación #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'LK 9/25/2023 00:37:56'!
PASSED!

!testRun: #TestDePerforación #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'LK 9/25/2023 00:37:56'!
PASSED!

!testRun: #TestDePerforación #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'LK 9/25/2023 00:37:56'!
PASSED!

!testRun: #TestDePerforación #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'LK 9/25/2023 00:37:56'!
PASSED!

!testRun: #TestDePerforación #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'LK 9/25/2023 00:37:56'!
PASSED!

!testRun: #TestDePerforación #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'LK 9/25/2023 00:37:56'!
PASSED!

!testRun: #TestDePerforación #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'LK 9/25/2023 00:37:56'!
PASSED!

!testRun: #TestDePerforación #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'LK 9/25/2023 00:37:56'!
PASSED!

!testRun: #TestDePerforación #test12NoPuedePerforarSinMecha stamp: 'LK 9/25/2023 00:37:56'!
PASSED!

!testRun: #TestDePerforación #test13PuedeCalcularProfundidadDelSuelo stamp: 'LK 9/25/2023 00:37:56'!
PASSED!

!testRun: #TestDePerforación #test14PuedeContarLasCapasDeTipoArenoso stamp: 'LK 9/25/2023 00:37:56'!
ERROR!

!testRun: #TestDePerforación #test15PuedeContarLasCapasDeTipoTierra stamp: 'LK 9/25/2023 00:37:56'!
ERROR!

!testRun: #TestDePerforación #test16PuedeContarLasCapasDeTipoConcreto stamp: 'LK 9/25/2023 00:37:56'!
ERROR!

!testRun: #TestDePerforación #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'LK 9/25/2023 00:37:56'!
ERROR!

!testRun: #TestDePerforación #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'LK 9/25/2023 00:37:56'!
ERROR!

!testRun: #TestDePerforación #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'LK 9/25/2023 00:37:56'!
ERROR!

!testRun: #TestDePerforación #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'LK 9/25/2023 00:39:19'!
PASSED!

!testRun: #TestDePerforación #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'LK 9/25/2023 00:39:19'!
PASSED!

!testRun: #TestDePerforación #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'LK 9/25/2023 00:39:19'!
PASSED!

!testRun: #TestDePerforación #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'LK 9/25/2023 00:39:19'!
PASSED!

!testRun: #TestDePerforación #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'LK 9/25/2023 00:39:19'!
PASSED!

!testRun: #TestDePerforación #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'LK 9/25/2023 00:39:19'!
PASSED!

!testRun: #TestDePerforación #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'LK 9/25/2023 00:39:19'!
PASSED!

!testRun: #TestDePerforación #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'LK 9/25/2023 00:39:19'!
PASSED!

!testRun: #TestDePerforación #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'LK 9/25/2023 00:39:19'!
PASSED!

!testRun: #TestDePerforación #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'LK 9/25/2023 00:39:19'!
PASSED!

!testRun: #TestDePerforación #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'LK 9/25/2023 00:39:19'!
PASSED!

!testRun: #TestDePerforación #test12NoPuedePerforarSinMecha stamp: 'LK 9/25/2023 00:39:19'!
PASSED!

!testRun: #TestDePerforación #test13PuedeCalcularProfundidadDelSuelo stamp: 'LK 9/25/2023 00:39:19'!
PASSED!

!testRun: #TestDePerforación #test14PuedeContarLasCapasDeTipoArenoso stamp: 'LK 9/25/2023 00:39:19'!
ERROR!

!testRun: #TestDePerforación #test15PuedeContarLasCapasDeTipoTierra stamp: 'LK 9/25/2023 00:39:19'!
ERROR!

!testRun: #TestDePerforación #test16PuedeContarLasCapasDeTipoConcreto stamp: 'LK 9/25/2023 00:39:19'!
ERROR!

!testRun: #TestDePerforación #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'LK 9/25/2023 00:39:19'!
ERROR!

!testRun: #TestDePerforación #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'LK 9/25/2023 00:39:19'!
ERROR!

!testRun: #TestDePerforación #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'LK 9/25/2023 00:39:19'!
ERROR!

!testRun: #TestDePerforación #test14PuedeContarLasCapasDeTipoArenoso stamp: 'LK 9/25/2023 00:39:27'!
ERROR!
!TestDePerforación methodsFor: 'test' stamp: 'LK 9/25/2023 00:42:08' prior: 50661602!
test14PuedeContarLasCapasDeTipoArenoso

	| excavadora sueloAExcavar |
	
	sueloAExcavar := { CapaDeSuelo arenoso setAltura: 2. CapaDeSuelo tierra setAltura: 40. CapaDeSuelo arenoso. CapaDeSuelo concretoConResistencia: 10 }.
	excavadora := Perforadora sobreSuelo: sueloAExcavar.
	
	self assert: 2 equals: (excavadora contarCapas: Arenoso).

	! !

!testRun: #TestDePerforación #test14PuedeContarLasCapasDeTipoArenoso stamp: 'LK 9/25/2023 00:42:09'!
ERROR!

!testRun: #TestDePerforación #test14PuedeContarLasCapasDeTipoArenoso stamp: 'LK 9/25/2023 00:42:09'!
ERROR!

!testRun: #TestDePerforación #test14PuedeContarLasCapasDeTipoArenoso stamp: 'LK 9/25/2023 00:44:18'!
ERROR!
!TestDePerforación methodsFor: 'test' stamp: 'LK 9/25/2023 00:44:47' prior: 50668714!
test14PuedeContarLasCapasDeTipoArenoso

	| excavadora sueloAExcavar |
	
	sueloAExcavar := { CapaDeSuelo arenoso setAltura: 2. CapaDeSuelo tierra setAltura: 40. CapaDeSuelo arenoso. CapaDeSuelo concretoConResistencia: 10 }.
	excavadora := Perforadora sobreSuelo: sueloAExcavar.
	
	self assert: 2 equals: (excavadora contarCapas: Arenoso new).

	! !

!testRun: #TestDePerforación #test14PuedeContarLasCapasDeTipoArenoso stamp: 'LK 9/25/2023 00:44:48'!
PASSED!

!testRun: #TestDePerforación #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'LK 9/25/2023 00:44:48'!
PASSED!

!testRun: #TestDePerforación #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'LK 9/25/2023 00:44:48'!
PASSED!

!testRun: #TestDePerforación #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'LK 9/25/2023 00:44:48'!
PASSED!

!testRun: #TestDePerforación #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'LK 9/25/2023 00:44:48'!
PASSED!

!testRun: #TestDePerforación #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'LK 9/25/2023 00:44:48'!
PASSED!

!testRun: #TestDePerforación #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'LK 9/25/2023 00:44:48'!
PASSED!

!testRun: #TestDePerforación #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'LK 9/25/2023 00:44:48'!
PASSED!

!testRun: #TestDePerforación #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'LK 9/25/2023 00:44:48'!
PASSED!

!testRun: #TestDePerforación #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'LK 9/25/2023 00:44:48'!
PASSED!

!testRun: #TestDePerforación #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'LK 9/25/2023 00:44:48'!
PASSED!

!testRun: #TestDePerforación #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'LK 9/25/2023 00:44:48'!
PASSED!

!testRun: #TestDePerforación #test12NoPuedePerforarSinMecha stamp: 'LK 9/25/2023 00:44:48'!
PASSED!

!testRun: #TestDePerforación #test13PuedeCalcularProfundidadDelSuelo stamp: 'LK 9/25/2023 00:44:48'!
PASSED!

!testRun: #TestDePerforación #test14PuedeContarLasCapasDeTipoArenoso stamp: 'LK 9/25/2023 00:44:48'!
PASSED!

!testRun: #TestDePerforación #test15PuedeContarLasCapasDeTipoTierra stamp: 'LK 9/25/2023 00:44:48'!
ERROR!

!testRun: #TestDePerforación #test16PuedeContarLasCapasDeTipoConcreto stamp: 'LK 9/25/2023 00:44:48'!
ERROR!

!testRun: #TestDePerforación #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'LK 9/25/2023 00:44:48'!
ERROR!

!testRun: #TestDePerforación #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'LK 9/25/2023 00:44:48'!
ERROR!

!testRun: #TestDePerforación #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'LK 9/25/2023 00:44:48'!
ERROR!
!TestDePerforación methodsFor: 'test' stamp: 'LK 9/25/2023 00:44:57' prior: 50661615!
test15PuedeContarLasCapasDeTipoTierra

	| excavadora sueloAExcavar |
	
	sueloAExcavar := { CapaDeSuelo arenoso setAltura: 2. CapaDeSuelo tierra setAltura: 40. CapaDeSuelo arenoso. CapaDeSuelo concretoConResistencia: 10 }.
	excavadora := Perforadora sobreSuelo: sueloAExcavar.
	
	self assert: 1 equals: (excavadora contarCapas: Tierra new).

	! !
!TestDePerforación methodsFor: 'test' stamp: 'LK 9/25/2023 00:45:03' prior: 50661628!
test16PuedeContarLasCapasDeTipoConcreto

	| excavadora sueloAExcavar |
	
	sueloAExcavar := { CapaDeSuelo arenoso setAltura: 2. CapaDeSuelo tierra setAltura: 40. CapaDeSuelo arenoso. CapaDeSuelo concretoConResistencia: 10 }.
	excavadora := Perforadora sobreSuelo: sueloAExcavar.
	
	self assert: 1 equals: (excavadora contarCapas: Concreto new).

	! !
!TestDePerforación methodsFor: 'test' stamp: 'LK 9/25/2023 00:45:10' prior: 50661642!
test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso

	| excavadora sueloAExcavar |
	
	sueloAExcavar := { CapaDeSuelo arenoso setAltura: 2. CapaDeSuelo tierra setAltura: 40. CapaDeSuelo arenoso. CapaDeSuelo concretoConResistencia: 10 }.
	excavadora := Perforadora sobreSuelo: sueloAExcavar.
	
	self assert: 0 equals: (excavadora calcularProfundidadDelSueloHasta: Arenoso new).

	! !
!TestDePerforación methodsFor: 'test' stamp: 'LK 9/25/2023 00:45:18' prior: 50661657!
test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra

	| excavadora sueloAExcavar |
	
	sueloAExcavar := { CapaDeSuelo arenoso setAltura: 2. CapaDeSuelo tierra setAltura: 40. CapaDeSuelo arenoso. CapaDeSuelo concretoConResistencia: 10 }.
	excavadora := Perforadora sobreSuelo: sueloAExcavar.
	
	self assert: 2 equals: (excavadora calcularProfundidadDelSueloHasta: Tierra new).

	! !
!TestDePerforación methodsFor: 'test' stamp: 'LK 9/25/2023 00:45:23' prior: 50661672!
test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto

	| excavadora sueloAExcavar |
	
	sueloAExcavar := { CapaDeSuelo arenoso setAltura: 2. CapaDeSuelo tierra setAltura: 40. CapaDeSuelo arenoso. CapaDeSuelo concretoConResistencia: 10 }.
	excavadora := Perforadora sobreSuelo: sueloAExcavar.
	
	self assert: 42 equals: (excavadora calcularProfundidadDelSueloHasta: Concreto new).

	! !

!testRun: #TestDePerforación #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'LK 9/25/2023 00:45:24'!
PASSED!

!testRun: #TestDePerforación #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'LK 9/25/2023 00:45:24'!
PASSED!

!testRun: #TestDePerforación #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'LK 9/25/2023 00:45:24'!
PASSED!

!testRun: #TestDePerforación #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'LK 9/25/2023 00:45:24'!
PASSED!

!testRun: #TestDePerforación #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'LK 9/25/2023 00:45:24'!
PASSED!

!testRun: #TestDePerforación #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'LK 9/25/2023 00:45:25'!
PASSED!

!testRun: #TestDePerforación #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'LK 9/25/2023 00:45:25'!
PASSED!

!testRun: #TestDePerforación #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'LK 9/25/2023 00:45:25'!
PASSED!

!testRun: #TestDePerforación #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'LK 9/25/2023 00:45:25'!
PASSED!

!testRun: #TestDePerforación #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'LK 9/25/2023 00:45:25'!
PASSED!

!testRun: #TestDePerforación #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'LK 9/25/2023 00:45:25'!
PASSED!

!testRun: #TestDePerforación #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'LK 9/25/2023 00:45:25'!
PASSED!

!testRun: #TestDePerforación #test12NoPuedePerforarSinMecha stamp: 'LK 9/25/2023 00:45:25'!
PASSED!

!testRun: #TestDePerforación #test13PuedeCalcularProfundidadDelSuelo stamp: 'LK 9/25/2023 00:45:25'!
PASSED!

!testRun: #TestDePerforación #test14PuedeContarLasCapasDeTipoArenoso stamp: 'LK 9/25/2023 00:45:25'!
PASSED!

!testRun: #TestDePerforación #test15PuedeContarLasCapasDeTipoTierra stamp: 'LK 9/25/2023 00:45:25'!
PASSED!

!testRun: #TestDePerforación #test16PuedeContarLasCapasDeTipoConcreto stamp: 'LK 9/25/2023 00:45:25'!
PASSED!

!testRun: #TestDePerforación #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'LK 9/25/2023 00:45:25'!
PASSED!

!testRun: #TestDePerforación #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'LK 9/25/2023 00:45:25'!
PASSED!

!testRun: #TestDePerforación #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'LK 9/25/2023 00:45:25'!
PASSED!

!methodRemoval: CapaDeSuelo #hash stamp: 'LK 9/25/2023 00:45:40'!
hash

	^tipo hash + resistencia hash!

!methodRemoval: CapaDeSuelo #tipo stamp: 'LK 9/25/2023 00:45:49'!
tipo

	self subclassResponsibility!

!methodRemoval: Arenoso #tipo stamp: 'LK 9/25/2023 00:45:58'!
tipo
	^#Arenoso!

!methodRemoval: Concreto #tipo stamp: 'LK 9/25/2023 00:46:05'!
tipo

	^#Concreto!

!methodRemoval: Tierra #tipo stamp: 'LK 9/25/2023 00:46:09'!
tipo

	^tipo!

!testRun: #TestDePerforación #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'LK 9/25/2023 00:46:13'!
ERROR!

!testRun: #TestDePerforación #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'LK 9/25/2023 00:46:13'!
ERROR!

!testRun: #TestDePerforación #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'LK 9/25/2023 00:46:13'!
PASSED!

!testRun: #TestDePerforación #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'LK 9/25/2023 00:46:13'!
ERROR!

!testRun: #TestDePerforación #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'LK 9/25/2023 00:46:13'!
ERROR!

!testRun: #TestDePerforación #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'LK 9/25/2023 00:46:13'!
PASSED!

!testRun: #TestDePerforación #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'LK 9/25/2023 00:46:13'!
PASSED!

!testRun: #TestDePerforación #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'LK 9/25/2023 00:46:13'!
ERROR!

!testRun: #TestDePerforación #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'LK 9/25/2023 00:46:13'!
ERROR!

!testRun: #TestDePerforación #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'LK 9/25/2023 00:46:13'!
PASSED!

!testRun: #TestDePerforación #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'LK 9/25/2023 00:46:13'!
PASSED!

!testRun: #TestDePerforación #test12NoPuedePerforarSinMecha stamp: 'LK 9/25/2023 00:46:13'!
ERROR!

!testRun: #TestDePerforación #test13PuedeCalcularProfundidadDelSuelo stamp: 'LK 9/25/2023 00:46:13'!
PASSED!

!testRun: #TestDePerforación #test14PuedeContarLasCapasDeTipoArenoso stamp: 'LK 9/25/2023 00:46:13'!
PASSED!

!testRun: #TestDePerforación #test15PuedeContarLasCapasDeTipoTierra stamp: 'LK 9/25/2023 00:46:13'!
PASSED!

!testRun: #TestDePerforación #test16PuedeContarLasCapasDeTipoConcreto stamp: 'LK 9/25/2023 00:46:13'!
PASSED!

!testRun: #TestDePerforación #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'LK 9/25/2023 00:46:13'!
PASSED!

!testRun: #TestDePerforación #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'LK 9/25/2023 00:46:13'!
PASSED!

!testRun: #TestDePerforación #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'LK 9/25/2023 00:46:13'!
PASSED!

!testRun: #TestDePerforación #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'LK 9/25/2023 00:46:43'!
ERROR!

!testRun: #TestDePerforación #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'LK 9/25/2023 00:46:43'!
ERROR!

!testRun: #TestDePerforación #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'LK 9/25/2023 00:46:43'!
PASSED!

!testRun: #TestDePerforación #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'LK 9/25/2023 00:46:43'!
ERROR!

!testRun: #TestDePerforación #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'LK 9/25/2023 00:46:43'!
ERROR!

!testRun: #TestDePerforación #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'LK 9/25/2023 00:46:43'!
PASSED!

!testRun: #TestDePerforación #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'LK 9/25/2023 00:46:43'!
PASSED!

!testRun: #TestDePerforación #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'LK 9/25/2023 00:46:43'!
ERROR!

!testRun: #TestDePerforación #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'LK 9/25/2023 00:46:43'!
ERROR!

!testRun: #TestDePerforación #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'LK 9/25/2023 00:46:43'!
PASSED!

!testRun: #TestDePerforación #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'LK 9/25/2023 00:46:43'!
PASSED!

!testRun: #TestDePerforación #test12NoPuedePerforarSinMecha stamp: 'LK 9/25/2023 00:46:43'!
ERROR!

!testRun: #TestDePerforación #test13PuedeCalcularProfundidadDelSuelo stamp: 'LK 9/25/2023 00:46:43'!
PASSED!

!testRun: #TestDePerforación #test14PuedeContarLasCapasDeTipoArenoso stamp: 'LK 9/25/2023 00:46:43'!
PASSED!

!testRun: #TestDePerforación #test15PuedeContarLasCapasDeTipoTierra stamp: 'LK 9/25/2023 00:46:43'!
PASSED!

!testRun: #TestDePerforación #test16PuedeContarLasCapasDeTipoConcreto stamp: 'LK 9/25/2023 00:46:43'!
PASSED!

!testRun: #TestDePerforación #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'LK 9/25/2023 00:46:43'!
PASSED!

!testRun: #TestDePerforación #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'LK 9/25/2023 00:46:43'!
PASSED!

!testRun: #TestDePerforación #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'LK 9/25/2023 00:46:43'!
PASSED!
!CapaDeSuelo methodsFor: 'scan' stamp: 'LK 9/25/2023 00:46:51'!
tipo
	self subclassResponsibility ! !
!Arenoso methodsFor: 'scan' stamp: 'LK 9/25/2023 00:47:04' overrides: 50669148!
tipo
	^#Arenoso! !
!Concreto methodsFor: 'comparing' stamp: 'LK 9/25/2023 00:47:18' overrides: 50669148!
tipo
	^#Concreto! !
!Tierra methodsFor: 'tipo' stamp: 'LK 9/25/2023 00:47:32' overrides: 50669148!
tipo
	^#Tierra! !

!testRun: #TestDePerforación #test01CuandoExcavaSueloArenosoConMechaSoftRemueveCapaArenosa stamp: 'LK 9/25/2023 00:47:39'!
PASSED!

!testRun: #TestDePerforación #test02CuandoExcavaSueloTierraConMechaSoftNoModificaElSuelo stamp: 'LK 9/25/2023 00:47:39'!
PASSED!

!testRun: #TestDePerforación #test03CuandoExcavaConcretoConMechaSoftSeRompeLaMecha stamp: 'LK 9/25/2023 00:47:39'!
PASSED!

!testRun: #TestDePerforación #test04CuandoExcavaSueloArenosoConMechaWidiaRemueveCapaArenosa stamp: 'LK 9/25/2023 00:47:39'!
PASSED!

!testRun: #TestDePerforación #test05CuandoExcavaSueloTierraConMechaWidiaEnDosImpactosTransformaLaCapaEnArenoso stamp: 'LK 9/25/2023 00:47:39'!
PASSED!

!testRun: #TestDePerforación #test06CuandoExcavaSueloConcretoConMechaWidiaEnTresImpactosRompeLaMecha stamp: 'LK 9/25/2023 00:47:39'!
PASSED!

!testRun: #TestDePerforación #test07CuandoExcavaSueloArenosoConMechaDiamanteRompeLaMecha stamp: 'LK 9/25/2023 00:47:39'!
PASSED!

!testRun: #TestDePerforación #test08CuandoExcavaSueloTierraConMechaDiamanteRemueveCapa stamp: 'LK 9/25/2023 00:47:39'!
PASSED!

!testRun: #TestDePerforación #test09CuandoExcavaSueloConcretoConMechaDiamanteBajaUnDecimoDeResistencia stamp: 'LK 9/25/2023 00:47:39'!
PASSED!

!testRun: #TestDePerforación #test10CuandoRemueveLaCapaYHayPiedrasLasRecolectaEnSuContainer stamp: 'LK 9/25/2023 00:47:39'!
PASSED!

!testRun: #TestDePerforación #test11CuandoRemueveLaCapaYNoHayNadaNoRecogeNada stamp: 'LK 9/25/2023 00:47:39'!
PASSED!

!testRun: #TestDePerforación #test12NoPuedePerforarSinMecha stamp: 'LK 9/25/2023 00:47:39'!
PASSED!

!testRun: #TestDePerforación #test13PuedeCalcularProfundidadDelSuelo stamp: 'LK 9/25/2023 00:47:39'!
PASSED!

!testRun: #TestDePerforación #test14PuedeContarLasCapasDeTipoArenoso stamp: 'LK 9/25/2023 00:47:39'!
PASSED!

!testRun: #TestDePerforación #test15PuedeContarLasCapasDeTipoTierra stamp: 'LK 9/25/2023 00:47:39'!
PASSED!

!testRun: #TestDePerforación #test16PuedeContarLasCapasDeTipoConcreto stamp: 'LK 9/25/2023 00:47:39'!
PASSED!

!testRun: #TestDePerforación #test17PuedeCalcularProfundidadHastaPrimerCapaDeTipoArenoso stamp: 'LK 9/25/2023 00:47:39'!
PASSED!

!testRun: #TestDePerforación #test18PuedeCalcularProfundidadHastaPrimerCapaDeTipoTierra stamp: 'LK 9/25/2023 00:47:39'!
PASSED!

!testRun: #TestDePerforación #test19PuedeCalcularProfundidadHastaPrimerCapaDeTipoConcreto stamp: 'LK 9/25/2023 00:47:39'!
PASSED!
!Perforadora methodsFor: 'excavation' stamp: 'LK 9/25/2023 00:48:16' prior: 50667550!
darGolpeDeTaladro

	^mechaPuesta darGolpeCon: self.
	! !
!Perforadora methodsFor: 'excavation' stamp: 'LK 9/25/2023 00:48:27' prior: 50668438!
golpearSueloArenosoConMechaDiamante
	self ponerMechaRota.
	self error: 'Se rompió'.
	^self
! !
!Perforadora methodsFor: 'excavation' stamp: 'LK 9/25/2023 00:48:33' prior: 50667796!
golpearSueloArenosoConMechaSoft
	^self pasarAProximaCapa
! !
!Perforadora methodsFor: 'excavation' stamp: 'LK 9/25/2023 00:48:42' prior: 50667833!
golpearSueloArenosoConMechaWidia
	^self pasarAProximaCapa
! !
!Perforadora methodsFor: 'excavation' stamp: 'LK 9/25/2023 00:48:48' prior: 50668215!
golpearSueloConcretoConMechaDiamante
	vecesQueGolpeoCapaActual even ifTrue: [ capasDeSueloDebajo first bajaUnDecimoDeResistencia].
	capasDeSueloDebajo first sinResistencia ifTrue: [ ^self transformarCapaEnArenoso].
	^vecesQueGolpeoCapaActual
! !
!Perforadora methodsFor: 'excavation' stamp: 'LK 9/25/2023 00:48:57' prior: 50668399!
golpearSueloConcretoConMechaSoft
	self ponerMechaRota.
	^self error: 'Se rompió'.
! !
!Perforadora methodsFor: 'excavation' stamp: 'LK 9/25/2023 00:49:02' prior: 50668359!
golpearSueloConcretoConMechaWidia
	vecesQueGolpeoCapaActual = 3 ifTrue: [self ponerMechaRota . ^self error: 'Se rompió'].
! !
!Perforadora methodsFor: 'excavation' stamp: 'LK 9/25/2023 00:49:11' prior: 50668025!
golpearSueloTierraConMechaDiamante
	^self pasarAProximaCapa.
! !
!Perforadora methodsFor: 'excavation' stamp: 'LK 9/25/2023 00:49:17' prior: 50668101!
golpearSueloTierraConMechaSoft
	^self
! !
!Perforadora methodsFor: 'excavation' stamp: 'LK 9/25/2023 00:49:22' prior: 50668062!
golpearSueloTierraConMechaWidia
	vecesQueGolpeoCapaActual = 2 ifTrue: [ ^self transformarCapaEnArenoso ].
	^self
! !

----QUIT----(25 September 2023 00:52:57) CuisUniversity-5981.image priorSource: 10551361!

----STARTUP---- (25 September 2023 11:43:22) as C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\CuisUniversity-5981.image!


----End fileIn of C:\Users\lucas\OneDrive\Desktop\ISW1-2022-2C-1erParcial.st----!
!Map methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 11:54:43' prior: 50669849!
lastPosition
	
	^ startPosition + (steps sum: [ :pasos | pasos]).
	"
	acc := startPosition.
	ix := 1.
	
	[ix <= steps size] whileTrue: [
		acc := acc + (steps at: ix)	.
		ix := ix + 1.
	].

	^ acc"
	
	! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'LK 9/25/2023 11:54:45'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'LK 9/25/2023 11:54:45'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'LK 9/25/2023 11:54:45'!
ERROR!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'LK 9/25/2023 11:54:45'!
ERROR!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'LK 9/25/2023 11:54:45'!
ERROR!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'LK 9/25/2023 11:54:45'!
ERROR!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'LK 9/25/2023 11:54:45'!
ERROR!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'LK 9/25/2023 11:54:45'!
ERROR!
!Map methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 11:55:17' prior: 50669905!
lastPosition
	
	|acc ix|
	
	"^ startPosition + (steps sum: [ :pasos | pasos])."
	
	acc := startPosition.
	ix := 1.
	
	[ix <= steps size] whileTrue: [
		acc := acc + (steps at: ix)	.
		ix := ix + 1.
	].

	^ acc
	
	! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'LK 9/25/2023 11:55:19'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'LK 9/25/2023 11:55:19'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'LK 9/25/2023 11:55:19'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'LK 9/25/2023 11:55:19'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'LK 9/25/2023 11:55:19'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'LK 9/25/2023 11:55:19'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'LK 9/25/2023 11:55:19'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'LK 9/25/2023 11:55:19'!
PASSED!
!Map methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 11:58:59' prior: 50669940!
lastPosition
	
	|acc |
	
	acc := startPosition.
	steps do: [ :algo | acc := acc + algo]. 

	^ acc
	
	! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'LK 9/25/2023 11:59:00'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'LK 9/25/2023 11:59:00'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'LK 9/25/2023 11:59:00'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'LK 9/25/2023 11:59:00'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'LK 9/25/2023 11:59:00'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'LK 9/25/2023 11:59:01'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'LK 9/25/2023 11:59:01'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'LK 9/25/2023 11:59:01'!
PASSED!
!Island methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 12:02:35' prior: 50669753!
clearTerrainAt: aPosition

	| arbol|
	
	arbol = treesAt findFirst: [ :position | aPosition = position].
	^treesAt remove: arbol.
	"ix := 1.
	[ix <= treesAt size] whileTrue: [ | pos |
		pos := treesAt at: ix.
		(aPosition = pos) ifTrue: [ ^ treesAt removeIndex: ix ].
		
		ix := ix + 1.
	].
	
"! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'LK 9/25/2023 12:02:40'!
ERROR!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'LK 9/25/2023 12:02:40'!
ERROR!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'LK 9/25/2023 12:02:40'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'LK 9/25/2023 12:02:40'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'LK 9/25/2023 12:02:40'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'LK 9/25/2023 12:02:40'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'LK 9/25/2023 12:02:40'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'LK 9/25/2023 12:02:40'!
PASSED!
!Island methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 12:03:37' prior: 50670007!
clearTerrainAt: aPosition

	| arbol|
	
	arbol = treesAt findFirst: [ :position | aPosition = position].
	^(treesAt remove: arbol ifAbsent: []).
	
	
	"ix := 1.
	[ix <= treesAt size] whileTrue: [ | pos |
		pos := treesAt at: ix.
		(aPosition = pos) ifTrue: [ ^ treesAt removeIndex: ix ].
		
		ix := ix + 1.
	].
	
"! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'LK 9/25/2023 12:03:43'!
ERROR!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'LK 9/25/2023 12:03:43'!
ERROR!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'LK 9/25/2023 12:03:43'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'LK 9/25/2023 12:03:43'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'LK 9/25/2023 12:03:43'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'LK 9/25/2023 12:03:43'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'LK 9/25/2023 12:03:43'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'LK 9/25/2023 12:03:43'!
PASSED!
!Island methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 12:07:23' prior: 50670045!
clearTerrainAt: aPosition

	| arbol|
	
	arbol = treesAt indexOf: aPosition ifAbsent: [0].
	^treesAt removeIndex: arbol.
	
	
	"ix := 1.
	[ix <= treesAt size] whileTrue: [ | pos |
		pos := treesAt at: ix.
		(aPosition = pos) ifTrue: [ ^ treesAt removeIndex: ix ].
		
		ix := ix + 1.
	].
	
"! !
!Island methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 12:07:31' prior: 50670084!
clearTerrainAt: aPosition

	| arbol|
	
	arbol := treesAt indexOf: aPosition ifAbsent: [0].
	^treesAt removeIndex: arbol.
	
	
	"ix := 1.
	[ix <= treesAt size] whileTrue: [ | pos |
		pos := treesAt at: ix.
		(aPosition = pos) ifTrue: [ ^ treesAt removeIndex: ix ].
		
		ix := ix + 1.
	].
	
"! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'LK 9/25/2023 12:07:40'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'LK 9/25/2023 12:07:40'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'LK 9/25/2023 12:07:40'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'LK 9/25/2023 12:07:40'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'LK 9/25/2023 12:07:40'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'LK 9/25/2023 12:07:40'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'LK 9/25/2023 12:07:40'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'LK 9/25/2023 12:07:40'!
PASSED!
!Island methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 12:08:37' prior: 50670096!
clearTerrainAt: aPosition

	^treesAt remove: aPosition ifAbsent:[].

	
	
	"ix := 1.
	[ix <= treesAt size] whileTrue: [ | pos |
		pos := treesAt at: ix.
		(aPosition = pos) ifTrue: [ ^ treesAt removeIndex: ix ].
		
		ix := ix + 1.
	].
	
"! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'LK 9/25/2023 12:08:38'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'LK 9/25/2023 12:08:38'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'LK 9/25/2023 12:08:38'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'LK 9/25/2023 12:08:38'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'LK 9/25/2023 12:08:38'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'LK 9/25/2023 12:08:38'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'LK 9/25/2023 12:08:39'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'LK 9/25/2023 12:08:39'!
PASSED!
!Island methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 12:08:45' prior: 50670134!
clearTerrainAt: aPosition

	^treesAt remove: aPosition ifAbsent:[].

! !
!Island methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 12:11:01' prior: 50669777!
isEmptyAt: aPosition

	treesAt detect: [:a | a = aPosition] ifNone: [^false].
	^true.
	! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'LK 9/25/2023 12:11:03'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'LK 9/25/2023 12:11:03'!
FAILURE!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'LK 9/25/2023 12:11:03'!
FAILURE!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'LK 9/25/2023 12:11:03'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'LK 9/25/2023 12:11:03'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'LK 9/25/2023 12:11:03'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'LK 9/25/2023 12:11:03'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'LK 9/25/2023 12:11:03'!
PASSED!
!Island methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 12:11:31' prior: 50670176!
isEmptyAt: aPosition

	| x |
	 x := treesAt detect: [:a | a = aPosition] ifNone: [^false].
	^true.
	! !
!Island methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 12:12:33' prior: 50670208!
isEmptyAt: aPosition

	| x |
	 x := treesAt indexOf: aPosition ifAbsent: [^false].
	^true.
	! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'LK 9/25/2023 12:12:39'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'LK 9/25/2023 12:12:39'!
FAILURE!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'LK 9/25/2023 12:12:39'!
FAILURE!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'LK 9/25/2023 12:12:39'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'LK 9/25/2023 12:12:39'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'LK 9/25/2023 12:12:39'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'LK 9/25/2023 12:12:39'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'LK 9/25/2023 12:12:39'!
PASSED!
!Island methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 12:13:38' prior: 50670215!
isEmptyAt: aPosition

	| x |
	 x := treesAt indexOf: aPosition ifAbsent: [0].
	^(x = 0)
	! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'LK 9/25/2023 12:13:40'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'LK 9/25/2023 12:13:40'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'LK 9/25/2023 12:13:40'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'LK 9/25/2023 12:13:40'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'LK 9/25/2023 12:13:40'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'LK 9/25/2023 12:13:40'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'LK 9/25/2023 12:13:40'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'LK 9/25/2023 12:13:40'!
PASSED!
!Island methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 12:18:56' prior: 50669791!
terrainAt: aPosition


	(treesAt includes: aPosition) ifTrue: [ ^#Tree].
	
	(digsAt includes: aPosition) ifTrue: [ ^#Diggable].


	^ #Empty.
	
! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'LK 9/25/2023 12:18:57'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'LK 9/25/2023 12:18:57'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'LK 9/25/2023 12:18:57'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'LK 9/25/2023 12:18:57'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'LK 9/25/2023 12:18:57'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'LK 9/25/2023 12:18:57'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'LK 9/25/2023 12:18:57'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'LK 9/25/2023 12:18:57'!
PASSED!

Pirate subclass: #Bucanero
	instanceVariableNames: 'rank'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #Bucanero category: 'ISW1-2022-2C-1erParcial' stamp: 'LK 9/25/2023 12:44:39'!
Pirate subclass: #Bucanero
	instanceVariableNames: 'rank'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

Pirate subclass: #Corsario
	instanceVariableNames: 'rank map'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #Corsario category: 'ISW1-2022-2C-1erParcial' stamp: 'LK 9/25/2023 12:44:44'!
Pirate subclass: #Corsario
	instanceVariableNames: 'rank map'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

Pirate subclass: #Filibustero
	instanceVariableNames: 'rank'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #Filibustero category: 'ISW1-2022-2C-1erParcial' stamp: 'LK 9/25/2023 12:44:50'!
Pirate subclass: #Filibustero
	instanceVariableNames: 'rank'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

Object subclass: #PirateRank
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #PirateRank category: 'ISW1-2022-2C-1erParcial' stamp: 'LK 9/25/2023 12:45:09'!
Object subclass: #PirateRank
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

PirateRank subclass: #SimplePirate
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #SimplePirate category: 'ISW1-2022-2C-1erParcial' stamp: 'LK 9/25/2023 12:45:38'!
PirateRank subclass: #SimplePirate
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

PirateRank subclass: #Captain
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #Captain category: 'ISW1-2022-2C-1erParcial' stamp: 'LK 9/25/2023 12:45:42'!
PirateRank subclass: #Captain
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #Bucanero category: 'ISW1-2022-2C-1erParcial' stamp: 'LK 9/25/2023 12:48:08'!
Pirate subclass: #Bucanero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #Corsario category: 'ISW1-2022-2C-1erParcial' stamp: 'LK 9/25/2023 12:48:08'!
Pirate subclass: #Corsario
	instanceVariableNames: 'map'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #Filibustero category: 'ISW1-2022-2C-1erParcial' stamp: 'LK 9/25/2023 12:48:08'!
Pirate subclass: #Filibustero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #Pirate category: 'ISW1-2022-2C-1erParcial' stamp: 'LK 9/25/2023 12:48:08'!
Object subclass: #Pirate
	instanceVariableNames: 'rank'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!
!Pirate methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 12:48:08'!
aCaptainIWasMeantToBe

	rank := #Captain! !

!methodRemoval: Bucanero #aCaptainIWasMeantToBe stamp: 'LK 9/25/2023 12:48:08'!
aCaptainIWasMeantToBe

	rank := #Captain!

!methodRemoval: Corsario #aCaptainIWasMeantToBe stamp: 'LK 9/25/2023 12:48:08'!
aCaptainIWasMeantToBe

	rank := #Captain!

!methodRemoval: Filibustero #aCaptainIWasMeantToBe stamp: 'LK 9/25/2023 12:48:08'!
aCaptainIWasMeantToBe

	rank := #Captain!
!Pirate methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 12:48:21' prior: 50670414!
aCaptainIWasMeantToBe

	rank := Captain new.! !
!Bucanero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 12:48:30' prior: 50669524 overrides: 16920235!
initialize

	rank := SimplePirate new! !
!Pirate methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 12:48:56' overrides: 16920235!
initialize

	rank := #NoRank! !

!methodRemoval: Corsario #initialize stamp: 'LK 9/25/2023 12:48:56'!
initialize

	rank := #NoRank!
!Pirate methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 12:49:06' prior: 50670440 overrides: 16920235!
initialize

	rank := SimplePirate new! !

!methodRemoval: Filibustero #initialize stamp: 'LK 9/25/2023 12:49:21'!
initialize

	rank := #SimplePirate!

!methodRemoval: Bucanero #initialize stamp: 'LK 9/25/2023 12:49:54'!
initialize

	rank := SimplePirate new!

Object subclass: #Terreno
	instanceVariableNames: 'rank'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #Terreno category: 'ISW1-2022-2C-1erParcial' stamp: 'LK 9/25/2023 12:50:11'!
Object subclass: #Terreno
	instanceVariableNames: 'rank'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

Terreno subclass: #Tree
	instanceVariableNames: 'rank'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

Terreno subclass: #Tree
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #Tree category: 'ISW1-2022-2C-1erParcial' stamp: 'LK 9/25/2023 12:50:47'!
Terreno subclass: #Tree
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

Terreno subclass: #Dig
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #Dig category: 'ISW1-2022-2C-1erParcial' stamp: 'LK 9/25/2023 12:50:51'!
Terreno subclass: #Dig
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

Terreno subclass: #Empty
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #Empty category: 'ISW1-2022-2C-1erParcial' stamp: 'LK 9/25/2023 12:50:59'!
Terreno subclass: #Empty
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

Object subclass: #Terreno
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #Terreno category: 'ISW1-2022-2C-1erParcial' stamp: 'LK 9/25/2023 12:51:01'!
Object subclass: #Terreno
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!
!Corsario methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 12:53:02' prior: 50669584!
initializeWith: aMap

	rank := SimplePirate new.
	map := aMap! !
!Pirate methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 12:53:52'!
searchTreasureIn: island with: aMap

	rank = #SimplePirate ifTrue: [ self error: 'I am a simple pirate!!' ].
	rank = #Captain ifTrue: [ ^ true "Aye, Aye!! La implementación está fuera del scope del parcial." ].
	! !

!methodRemoval: Corsario #searchTreasureIn:with: stamp: 'LK 9/25/2023 12:53:52'!
searchTreasureIn: island with: aMap

	rank = #SimplePirate ifTrue: [ self error: 'I am a simple pirate!!' ].
	rank = #Captain ifTrue: [ ^ true "Aye, Aye!! La implementación está fuera del scope del parcial." ].
	!

!methodRemoval: Bucanero #searchTreasureIn:with: stamp: 'LK 9/25/2023 12:53:52'!
searchTreasureIn: island with: aMap

	rank = #SimplePirate ifTrue: [ self error: 'I am a simple pirate!!' ].
	rank = #Captain ifTrue: [ ^ true "Aye, Aye!! La implementación está fuera del scope del parcial." ].
	!

!methodRemoval: Filibustero #searchTreasureIn:with: stamp: 'LK 9/25/2023 12:53:52'!
searchTreasureIn: island with: aMap

	rank = #SimplePirate ifTrue: [ self error: 'I am a simple pirate!!' ].
	rank = #Captain ifTrue: [ ^ true "Aye, Aye!! La implementación está fuera del scope del parcial." ].
	!
!Pirate methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 12:54:33' prior: 50670526!
searchTreasureIn: island with: aMap

	rank searchTreasureIn: island with: aMap being: self.
! !
!Captain methodsFor: 'nil' stamp: 'LK 9/25/2023 12:55:11'!
searchTreasureIn: island with: aMap being: rank
	^ true "Aye, Aye!! La implementación está fuera del scope del parcial."
	! !
!SimplePirate methodsFor: 'nil' stamp: 'LK 9/25/2023 12:55:53'!
searchTreasureIn: island with: aMap being: rank
	^self error: 'I am a simple pirate!!'! !
!PirateRank methodsFor: 'nil' stamp: 'LK 9/25/2023 12:56:07'!
searchTreasureIn: island with: aMap being: rank
	self subclassResponsibility ! !
!Island methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 12:59:57' prior: 50670279!
terrainAt: aPosition


	(treesAt includes: aPosition) ifTrue: [ ^Tree new].
	
	(digsAt includes: aPosition) ifTrue: [ ^Dig new].

	^ Empty new.
	
! !
!Crew methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:02:05' prior: 50669623!
buryTreasureAt: aPosition

	| terrain |
	
	terrain := island terrainAt: aPosition.
	
	pirates do: [:pirate | pirate buryTreasureAt: aPosition in: terrain in: island].
	
	"ix := 1.
	[ix <= pirates size] whileTrue: [ | pirate |
		pirate := pirates at: ix.
		
		(pirate isKindOf: Corsario) ifTrue: [ 
			terrain = #Tree ifTrue: [].
			terrain = #Empty ifTrue: [].
			terrain = #Diggable ifTrue: [ 				pirate drawTreasureMarkAt: aPosition ].
		].
		
		(pirate isKindOf: Filibustero) ifTrue: [
			terrain = #Tree ifTrue: [].
			terrain = #Empty ifTrue: [].
			terrain = #Diggable ifTrue: [].
		].
		
		(pirate isKindOf: Bucanero) ifTrue: [
			terrain = #Tree ifTrue: [ self error: 'Arrgh!! I cannot dig this type of terrain!!' ].
			terrain = #Empty ifTrue: [ self error: 'Arrgh!! I cannot dig this type of terrain!!' ]	.
			terrain = #Diggable ifTrue: [ island receiveTreasureAt: aPosition ].
		].
		
		ix := ix + 1.
	]."
	! !
!Pirate methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:10:50'!
buryTreasureAt: aPosition in: terrain in: island! !
!Bucanero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:10:59' overrides: 50670626!
buryTreasureAt: aPosition in: terrain in: island! !
!Corsario methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:10:59' overrides: 50670626!
buryTreasureAt: aPosition in: terrain in: island! !
!Filibustero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:10:59' overrides: 50670626!
buryTreasureAt: aPosition in: terrain in: island! !
!Pirate methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:10:59' prior: 50670626!
buryTreasureAt: aPosition in: terrain in: island

	self subclassResponsibility! !
!Bucanero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:12:19' prior: 50670631 overrides: 50670646!
buryTreasureAt: aPosition in: terrain in: island
	^terrain bucanero: self BuryAt: aPosition in: island! !
!Corsario methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:12:37' prior: 50670636 overrides: 50670646!
buryTreasureAt: aPosition in: terrain in: island
	^terrain corsario: self BuryAt: aPosition in: island! !
!Filibustero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:12:48' prior: 50670641 overrides: 50670646!
buryTreasureAt: aPosition in: terrain in: island
	^terrain filibustero: self BuryAt: aPosition in: island! !
!Terreno methodsFor: 'no messages' stamp: 'LK 9/25/2023 13:13:28'!
bucanero: aPirate BuryAt: aPosition in: island! !
!Terreno methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:13:32'!
corsario: aPirate BuryAt: aPosition in: island! !
!Terreno methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:13:44'!
filibustero: aPirate BuryAt: aPosition in: island! !
!Tree methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:13:51' overrides: 50670673!
bucanero: aPirate BuryAt: aPosition in: island! !
!Dig methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:13:51' overrides: 50670673!
bucanero: aPirate BuryAt: aPosition in: island! !
!Empty methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:13:51' overrides: 50670673!
bucanero: aPirate BuryAt: aPosition in: island! !
!Terreno methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:13:51' prior: 50670673!
bucanero: aPirate BuryAt: aPosition in: island

	self subclassResponsibility! !
!Tree methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:13:55' overrides: 50670677!
corsario: aPirate BuryAt: aPosition in: island! !
!Dig methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:13:55' overrides: 50670677!
corsario: aPirate BuryAt: aPosition in: island! !
!Empty methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:13:55' overrides: 50670677!
corsario: aPirate BuryAt: aPosition in: island! !
!Terreno methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:13:55' prior: 50670677!
corsario: aPirate BuryAt: aPosition in: island

	self subclassResponsibility! !
!Tree methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:14:00' overrides: 50670681!
filibustero: aPirate BuryAt: aPosition in: island! !
!Dig methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:14:00' overrides: 50670681!
filibustero: aPirate BuryAt: aPosition in: island! !
!Empty methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:14:00' overrides: 50670681!
filibustero: aPirate BuryAt: aPosition in: island! !
!Terreno methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:14:00' prior: 50670681!
filibustero: aPirate BuryAt: aPosition in: island

	self subclassResponsibility! !
!Dig methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:14:50' prior: 50670691 overrides: 50670701!
bucanero: aPirate BuryAt: aPosition in: island
	island receiveTreasureAt: aPosition
! !
!Dig methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:15:43' prior: 50670712 overrides: 50670722!
corsario: aPirate BuryAt: aPosition in: island
	aPirate drawTreasureMarkAt: aPosition! !
!Empty methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:16:49' prior: 50670696 overrides: 50670701!
bucanero: aPirate BuryAt: aPosition in: island
	^self error: 'Arrgh!! I cannot dig this type of terrain!!'.
	! !
!Tree methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:17:03' prior: 50670686 overrides: 50670701!
bucanero: aPirate BuryAt: aPosition in: island
	^self error: 'Arrgh!! I cannot dig this type of terrain!!'.! !
!Crew methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:17:24' prior: 50670594!
buryTreasureAt: aPosition

	| terrain |
	
	terrain := island terrainAt: aPosition.
	
	pirates do: [:pirate | pirate buryTreasureAt: aPosition in: terrain in: island].
	
	! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'LK 9/25/2023 13:19:47'!
FAILURE!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'LK 9/25/2023 13:19:47'!
FAILURE!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'LK 9/25/2023 13:19:47'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'LK 9/25/2023 13:19:47'!
FAILURE!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'LK 9/25/2023 13:19:47'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'LK 9/25/2023 13:19:47'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'LK 9/25/2023 13:19:47'!
ERROR!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'LK 9/25/2023 13:19:47'!
PASSED!
!Crew methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:23:10' prior: 50669659!
moveTo: aPosition

	| acc terrain |
	
	terrain := island terrainAt: aPosition.
	
	acc := pirates inject: true into: [:canMove :pirate | canMove & (pirate canMoveTo: aPosition in: island in: terrain)].
	
	"nos movemos si todos pueden moverse"
	acc ifTrue: [ island crewAt: aPosition ].
	
	"[ix <= pirates size] whileTrue: [ | pirate |
		pirate := pirates at: ix.
		
		(pirate isKindOf: Corsario) ifTrue: [ 
			terrain = #Tree ifTrue: [ acc := acc & false ].
			terrain = #Empty ifTrue: [ 
				pirate drawDirectionTo: aPosition.
				acc := acc & true 
			].
			terrain = #Diggable ifTrue: [ acc := acc & true ].
		].
		
		(pirate isKindOf: Filibustero) ifTrue: [
			terrain = #Tree ifTrue: [ 
				island clearTerrainAt: aPosition.
				acc := acc & false
			].
			terrain = #Empty ifTrue: [ acc := acc & true ].
			terrain = #Diggable ifTrue: [ acc := acc & true ].
		].
		
		(pirate isKindOf: Bucanero) ifTrue: [
			terrain = #Tree ifTrue: [ acc := acc & false ].
			terrain = #Empty ifTrue: [ acc := acc & true ].
			terrain = #Diggable ifTrue: [ acc := acc & true ].
		].
		
		ix := ix + 1.
	].

	
	
	"! !
!Crew methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:23:25' prior: 50670811!
moveTo: aPosition

	| moving terrain |
	
	terrain := island terrainAt: aPosition.
	
	moving := pirates inject: true into: [:canMove :pirate | canMove & (pirate canMoveTo: aPosition in: island in: terrain)].
	
	"nos movemos si todos pueden moverse"
	moving ifTrue: [ island crewAt: aPosition ].
	
	"[ix <= pirates size] whileTrue: [ | pirate |
		pirate := pirates at: ix.
		
		(pirate isKindOf: Corsario) ifTrue: [ 
			terrain = #Tree ifTrue: [ acc := acc & false ].
			terrain = #Empty ifTrue: [ 
				pirate drawDirectionTo: aPosition.
				acc := acc & true 
			].
			terrain = #Diggable ifTrue: [ acc := acc & true ].
		].
		
		(pirate isKindOf: Filibustero) ifTrue: [
			terrain = #Tree ifTrue: [ 
				island clearTerrainAt: aPosition.
				acc := acc & false
			].
			terrain = #Empty ifTrue: [ acc := acc & true ].
			terrain = #Diggable ifTrue: [ acc := acc & true ].
		].
		
		(pirate isKindOf: Bucanero) ifTrue: [
			terrain = #Tree ifTrue: [ acc := acc & false ].
			terrain = #Empty ifTrue: [ acc := acc & true ].
			terrain = #Diggable ifTrue: [ acc := acc & true ].
		].
		
		ix := ix + 1.
	].

	
	
	"! !
!Pirate methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:23:50'!
canMoveTo: aPosition in: island in: terrain! !
!Bucanero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:24:11' overrides: 50670887!
canMoveTo: aPosition in: island in: terrain! !
!Corsario methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:24:11' overrides: 50670887!
canMoveTo: aPosition in: island in: terrain! !
!Filibustero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:24:12' overrides: 50670887!
canMoveTo: aPosition in: island in: terrain! !
!Pirate methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:24:12' prior: 50670887!
canMoveTo: aPosition in: island in: terrain

	self subclassResponsibility! !
!Bucanero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:24:48' prior: 50670892 overrides: 50670907!
canMoveTo: aPosition in: island in: terrain
	^terrain bucanero: self canMoveTo: aPosition in: island.! !
!Corsario methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:25:00' prior: 50670897 overrides: 50670907!
canMoveTo: aPosition in: island in: terrain
	^terrain corsario: self canMoveTo: aPosition in: island.! !
!Filibustero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:25:13' prior: 50670902 overrides: 50670907!
canMoveTo: aPosition in: island in: terrain
	^terrain filibustero: self canMoveTo: aPosition in: island.! !
!Terreno methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:25:48'!
bucanero: aPirate canMoveTo: aPosition in: island! !
!Terreno methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:25:52'!
corsario: aPirate canMoveTo: aPosition in: island! !
!Terreno methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:25:57'!
filibustero: aPirate canMoveTo: aPosition in: island! !
!Tree methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:26:07' overrides: 50670933!
bucanero: aPirate canMoveTo: aPosition in: island! !
!Dig methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:26:07' overrides: 50670933!
bucanero: aPirate canMoveTo: aPosition in: island! !
!Empty methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:26:07' overrides: 50670933!
bucanero: aPirate canMoveTo: aPosition in: island! !
!Terreno methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:26:07' prior: 50670933!
bucanero: aPirate canMoveTo: aPosition in: island

	self subclassResponsibility! !
!Tree methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:26:12' overrides: 50670937!
corsario: aPirate canMoveTo: aPosition in: island! !
!Dig methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:26:13' overrides: 50670937!
corsario: aPirate canMoveTo: aPosition in: island! !
!Empty methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:26:13' overrides: 50670937!
corsario: aPirate canMoveTo: aPosition in: island! !
!Terreno methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:26:13' prior: 50670937!
corsario: aPirate canMoveTo: aPosition in: island

	self subclassResponsibility! !
!Tree methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:26:18' overrides: 50670941!
filibustero: aPirate canMoveTo: aPosition in: island! !
!Dig methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:26:18' overrides: 50670941!
filibustero: aPirate canMoveTo: aPosition in: island! !
!Empty methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:26:18' overrides: 50670941!
filibustero: aPirate canMoveTo: aPosition in: island! !
!Terreno methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:26:18' prior: 50670941!
filibustero: aPirate canMoveTo: aPosition in: island

	self subclassResponsibility! !
!Dig methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:27:54' prior: 50670951 overrides: 50670961!
bucanero: aPirate canMoveTo: aPosition in: island
	^true! !
!Dig methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:28:13' prior: 50670972 overrides: 50670982!
corsario: aPirate canMoveTo: aPosition in: island
	^true
! !
!Dig methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:28:35' prior: 50670993 overrides: 50671003!
filibustero: aPirate canMoveTo: aPosition in: island
	^true
! !
!Empty methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:29:49' prior: 50670977 overrides: 50670982!
corsario: aPirate canMoveTo: aPosition in: island
	aPirate drawDirectionTo: aPosition.
	^true! !
!Empty methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:30:04' prior: 50670998 overrides: 50671003!
filibustero: aPirate canMoveTo: aPosition in: island
	^true! !
!Tree methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:30:21' prior: 50670946 overrides: 50670961!
bucanero: aPirate canMoveTo: aPosition in: island
	^false! !
!Tree methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:30:27' prior: 50670967 overrides: 50670982!
corsario: aPirate canMoveTo: aPosition in: island
	^false! !
!Tree methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:30:42' prior: 50670988 overrides: 50671003!
filibustero: aPirate canMoveTo: aPosition in: island
	island clearTerrainAt: aPosition.
	^false.! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'LK 9/25/2023 13:30:44'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'LK 9/25/2023 13:30:44'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'LK 9/25/2023 13:30:44'!
ERROR!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'LK 9/25/2023 13:30:45'!
ERROR!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'LK 9/25/2023 13:30:45'!
ERROR!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'LK 9/25/2023 13:30:45'!
ERROR!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'LK 9/25/2023 13:30:45'!
ERROR!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'LK 9/25/2023 13:30:45'!
ERROR!

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'LK 9/25/2023 13:35:58'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'LK 9/25/2023 13:35:58'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'LK 9/25/2023 13:35:58'!
ERROR!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'LK 9/25/2023 13:35:58'!
ERROR!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'LK 9/25/2023 13:35:58'!
ERROR!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'LK 9/25/2023 13:35:58'!
ERROR!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'LK 9/25/2023 13:35:58'!
ERROR!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'LK 9/25/2023 13:35:58'!
ERROR!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'LK 9/25/2023 13:36:03'!
ERROR!
!Tree methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:37:49' prior: 50671041 overrides: 50670961!
bucanero: aPirate canMoveTo: aPosition in: island
	^true! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'LK 9/25/2023 13:37:51'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'LK 9/25/2023 13:37:51'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'LK 9/25/2023 13:37:51'!
ERROR!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'LK 9/25/2023 13:37:51'!
ERROR!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'LK 9/25/2023 13:37:51'!
ERROR!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'LK 9/25/2023 13:37:51'!
ERROR!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'LK 9/25/2023 13:37:51'!
ERROR!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'LK 9/25/2023 13:37:51'!
ERROR!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'LK 9/25/2023 13:38:03'!
ERROR!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'LK 9/25/2023 13:46:58'!
ERROR!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'LK 9/25/2023 13:46:58'!
ERROR!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'LK 9/25/2023 13:47:57'!
ERROR!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'LK 9/25/2023 13:47:57'!
ERROR!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'LK 9/25/2023 13:48:01'!
ERROR!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'LK 9/25/2023 13:48:01'!
ERROR!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'LK 9/25/2023 13:48:04'!
ERROR!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'LK 9/25/2023 13:48:04'!
ERROR!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'LK 9/25/2023 13:48:06'!
ERROR!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'LK 9/25/2023 13:48:06'!
ERROR!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'LK 9/25/2023 13:48:08'!
ERROR!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'LK 9/25/2023 13:48:08'!
ERROR!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'LK 9/25/2023 13:48:26'!
ERROR!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'LK 9/25/2023 13:48:26'!
ERROR!
!Crew methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 13:49:22' prior: 50670849!
moveTo: aPosition

	| moved terrain |
	
	terrain := island terrainAt: aPosition.
	
	moved := pirates inject: true into: [ :canMove :pirate | canMove & (pirate canMoveTo: aPosition in: island in: terrain)	].

	"nos movemos si todos pueden moverse"
	moved ifTrue: [ island crewAt: aPosition ].! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'LK 9/25/2023 13:49:26'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'LK 9/25/2023 13:49:26'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'LK 9/25/2023 13:49:26'!
ERROR!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'LK 9/25/2023 13:49:26'!
ERROR!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'LK 9/25/2023 13:49:26'!
ERROR!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'LK 9/25/2023 13:49:26'!
ERROR!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'LK 9/25/2023 13:49:26'!
ERROR!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'LK 9/25/2023 13:49:26'!
ERROR!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'LK 9/25/2023 13:49:30'!
ERROR!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'LK 9/25/2023 13:49:30'!
ERROR!

----QUIT----(25 September 2023 13:50:27) CuisUniversity-5981.image priorSource: 10804756!

----STARTUP---- (25 September 2023 15:42:58) as C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\CuisUniversity-5981.image!


----End fileIn of C:\Users\lucas\OneDrive\Desktop\ISW1-2022-1C-Parcial-1.st----!

----QUIT----(25 September 2023 15:47:42) CuisUniversity-5981.image priorSource: 10866591!

----STARTUP---- (25 September 2023 17:29:49) as C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\CuisUniversity-5981.image!


----End fileIn of C:\Users\lucas\OneDrive\Desktop\ISW1-2023-2C-Parcial-1.st----!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 17:39:02'!
conDelantero: unDelantero yArquero: unArquero! !

Object subclass: #Arquero
	instanceVariableNames: 'fuerza'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classDefinition: #Arquero category: 'ISW1-2023-2C-Parcial-1' stamp: 'LK 9/25/2023 17:40:27'!
Object subclass: #Arquero
	instanceVariableNames: 'fuerza'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

Object subclass: #Delantero
	instanceVariableNames: 'fuerza'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classDefinition: #Delantero category: 'ISW1-2023-2C-Parcial-1' stamp: 'LK 9/25/2023 17:40:33'!
Object subclass: #Delantero
	instanceVariableNames: 'fuerza'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!
!Delantero methodsFor: 'nil' stamp: 'LK 9/25/2023 17:41:22'!
decideTirarAColocarSuFuerzaBaseEs: fuerzaJugador

	fuerza := fuerzaJugador.! !
!Arquero methodsFor: 'no messages' stamp: 'LK 9/25/2023 17:41:49'!
esperaPorTiroYSeAdelantaSuFuerzaBaseEs: fuerzaArquero
	fuerza := fuerzaArquero.! !
!Delantero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 17:42:14'!
fuerza
	^fuerza.! !
!Arquero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 17:42:25'!
fuerza
	^fuerza! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 17:44:19' prior: 50673348!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	self assert: (direccionTiro between: 0@0 and: 2@2).
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 17:45:51' prior: 50673483!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	(direccionTiro between: 0@0 and: 2@2) ifFalse: (self error: Penales direccionTiroFueraDeRango)
.	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 17:45:53' prior: 50673553!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	(direccionTiro between: 0@0 and: 2@2) ifFalse: (self error: Penales direccionTiroFueraDeRango).	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'LK 9/25/2023 17:45:58'!
ERROR!

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'LK 9/25/2023 17:45:58'!
ERROR!
!Pelota methodsFor: 'nil' stamp: 'LK 9/25/2023 17:46:37'!
jabulaniSudafricanaRapida! !
!Pelota methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 17:46:58' prior: 50673703!
jabulaniSudafricanaRapida! !
!Pelota methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 17:47:02' prior: 50673707!
jabulaniSudafricanaRapida
	^self.! !

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'LK 9/25/2023 17:47:05'!
ERROR!

Delantero decideTirarAColocarSuFuerzaBaseEs!

!classDefinition: #Penales category: 'ISW1-2023-2C-Parcial-1' stamp: 'LK 9/25/2023 17:51:00'!
Object subclass: #Penales
	instanceVariableNames: 'puntajeDelantero'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 17:50:59'!
puntajeDeDelantero
	^puntajeDelantero! !

!classDefinition: #Penales category: 'ISW1-2023-2C-Parcial-1' stamp: 'LK 9/25/2023 17:51:17'!
Object subclass: #Penales
	instanceVariableNames: 'puntajeDelantero puntajeArquero'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 17:51:15'!
puntajeDeArquero
	^puntajeArquero! !

Object subclass: #Pelota
	instanceVariableNames: 'tipo'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classDefinition: #Pelota category: 'ISW1-2023-2C-Parcial-1' stamp: 'LK 9/25/2023 17:51:56'!
Object subclass: #Pelota
	instanceVariableNames: 'tipo'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!
!Pelota methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 17:52:06' prior: 50673711!
jabulaniSudafricanaRapida
	
	tipo := #Jabulani.! !

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'LK 9/25/2023 17:52:11'!
ERROR!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 17:53:17'!
initializeConDelantero: unDelantero yArquero: unArquero! !

!methodRemoval: Penales #conDelantero:yArquero: stamp: 'LK 9/25/2023 17:53:21'!
conDelantero: unDelantero yArquero: unArquero!
!Pelota methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 17:53:32'!
initializeJabulaniSudafricanaRapida
	
	tipo := #Jabulani.! !

!methodRemoval: Pelota #jabulaniSudafricanaRapida stamp: 'LK 9/25/2023 17:53:35'!
jabulaniSudafricanaRapida
	
	tipo := #Jabulani.!
!Arquero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 17:54:00'!
initializeEsperaPorTiroYSeAdelantaSuFuerzaBaseEs: fuerzaArquero
	fuerza := fuerzaArquero.! !

!methodRemoval: Arquero #esperaPorTiroYSeAdelantaSuFuerzaBaseEs: stamp: 'LK 9/25/2023 17:54:03'!
esperaPorTiroYSeAdelantaSuFuerzaBaseEs: fuerzaArquero
	fuerza := fuerzaArquero.!
!Delantero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 17:54:14'!
initializeDecideTirarAColocarSuFuerzaBaseEs: fuerzaJugador

	fuerza := fuerzaJugador.! !

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'LK 9/25/2023 17:54:20'!
ERROR!
!Delantero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 17:55:57' prior: 50673466!
decideTirarAColocarSuFuerzaBaseEs: fuerzaJugador

	|delantero|
	delantero := Delantero new.
	fuerza := fuerzaJugador.
! !
!Delantero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 17:56:09' prior: 50673804!
decideTirarAColocarSuFuerzaBaseEs: fuerzaJugador

	|delantero|
	delantero := Delantero new.
	fuerza := fuerzaJugador.
	^delantero
! !

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'LK 9/25/2023 17:56:12'!
ERROR!

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'LK 9/25/2023 17:56:12'!
ERROR!

3@0 between: 0@0 and: 2@2!

-1@0 between: 0@0 and: 2@2!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 18:01:40' prior: 50673625!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	(direccionTiro between: 0@0 and: 2@2) ifFalse: (self error: Penales direccionTiroFueraDeRango).	
	
	(direccionArquero between: 0@0 and: 2@2) ifFalse: (self error: Penales direccionArqueroFueraDeRango).	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

Delantero class
	instanceVariableNames: 'fuerza'!

!classDefinition: 'Delantero class' category: 'ISW1-2023-2C-Parcial-1' stamp: 'LK 9/25/2023 18:04:28'!
Delantero class
	instanceVariableNames: 'fuerza'!

Delantero class
	instanceVariableNames: ''!

!classDefinition: 'Delantero class' category: 'ISW1-2023-2C-Parcial-1' stamp: 'LK 9/25/2023 18:04:31'!
Delantero class
	instanceVariableNames: ''!
!Delantero class methodsFor: 'nil' stamp: 'LK 9/25/2023 18:04:36'!
decideTirarAColocarSuFuerzaBaseEs: fuerzaJugador
! !

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'LK 9/25/2023 18:04:40'!
ERROR!

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'LK 9/25/2023 18:04:40'!
ERROR!
!Pelota class methodsFor: 'no messages' stamp: 'LK 9/25/2023 18:05:44'!
jabulaniSudafricanaRapida! !
!Arquero class methodsFor: 'nil' stamp: 'LK 9/25/2023 18:06:06'!
esperaPorTiroYSeAdelantaSuFuerzaBaseEs: fuerzaArquero! !
!Arquero class methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 18:06:57' prior: 50673930!
esperaPorTiroYSeAdelantaSuFuerzaBaseEs: fuerzaArquero
	^self new initializeEsperaPorTiroYSeAdelantaSuFuerzaBaseEs: fuerzaArquero.! !
!Delantero class methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 18:07:18' prior: 50673915!
decideTirarAColocarSuFuerzaBaseEs: fuerzaJugador
	^self new initializeDecideTirarAColocarSuFuerzaBaseEs: fuerzaJugador.
! !
!Pelota class methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 18:07:34' prior: 50673927!
jabulaniSudafricanaRapida
	^self new initializeJabulaniSudafricanaRapida! !
!Penales class methodsFor: 'message errors' stamp: 'LK 9/25/2023 18:08:27'!
conDelantero: unDelantero yArquero: unArquero
	^self new initializeConDelantero: unDelantero yArquero: unArquero! !

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'LK 9/25/2023 18:08:35'!
FAILURE!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 18:09:13' prior: 50673828!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	(direccionTiro between: 0@0 and: 2@2) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(direccionArquero between: 0@0 and: 2@2) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'LK 9/25/2023 18:09:14'!
FAILURE!

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'LK 9/25/2023 18:09:14'!
FAILURE!

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'LK 9/25/2023 18:09:26'!
FAILURE!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 18:10:05' prior: 50673765!
initializeConDelantero: unDelantero yArquero: unArquero
	puntajeDelantero := 0! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 18:10:20' prior: 50674053!
initializeConDelantero: unDelantero yArquero: unArquero
	puntajeDelantero := 0.
	puntajeArquero := 0.! !

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'LK 9/25/2023 18:10:24'!
PASSED!

!testRun: #PenalesTest #test02DelanteroNoPuedeApuntarHaciaAfueraDelPaloDerecho stamp: 'LK 9/25/2023 18:10:28'!
PASSED!

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'LK 9/25/2023 18:10:32'!
PASSED!

!testRun: #PenalesTest #test02DelanteroNoPuedeApuntarHaciaAfueraDelPaloDerecho stamp: 'LK 9/25/2023 18:10:32'!
PASSED!

!testRun: #PenalesTest #test03DelanteroNoPuedeApuntarHaciaAbajoDelArco stamp: 'LK 9/25/2023 18:10:32'!
PASSED!

!testRun: #PenalesTest #test04DelanteroNoPuedeApuntarHaciaArribaDelTravesaño stamp: 'LK 9/25/2023 18:10:32'!
PASSED!

!testRun: #PenalesTest #test05ArqueroNoPuedePasarseDelPaloIzquierdo stamp: 'LK 9/25/2023 18:10:32'!
PASSED!

!testRun: #PenalesTest #test06ArqueroNoPuedePasarseDelPaloDerecho stamp: 'LK 9/25/2023 18:10:32'!
PASSED!

!testRun: #PenalesTest #test07ArqueroNoPuedeMeterseAbajoDeLaTierra stamp: 'LK 9/25/2023 18:10:32'!
PASSED!

!testRun: #PenalesTest #test08ArqueroNoPuedeSaltarPorEncimaDelTravesaño stamp: 'LK 9/25/2023 18:10:32'!
PASSED!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'LK 9/25/2023 18:10:32'!
FAILURE!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'LK 9/25/2023 18:10:32'!
FAILURE!

!testRun: #PenalesTest #test11MismasDireccionesSuficienteFuerzaAtajaArquero stamp: 'LK 9/25/2023 18:10:32'!
FAILURE!

!testRun: #PenalesTest #test12DelanteroQueTiraAColocarPierde50PorcFuerza stamp: 'LK 9/25/2023 18:10:32'!
FAILURE!

!testRun: #PenalesTest #test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra stamp: 'LK 9/25/2023 18:10:32'!
ERROR!

!testRun: #PenalesTest #test14FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAColocar stamp: 'LK 9/25/2023 18:10:32'!
ERROR!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'LK 9/25/2023 18:10:32'!
FAILURE!

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'LK 9/25/2023 18:10:32'!
ERROR!

!testRun: #PenalesTest #test17ArqueroQueEligeAntesDeTiroVsPlayeraAColocarSuma100PorcFuerzaExtra stamp: 'LK 9/25/2023 18:10:33'!
ERROR!

!testRun: #PenalesTest #test18FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsPlayeraAColocar stamp: 'LK 9/25/2023 18:10:33'!
ERROR!

!testRun: #PenalesTest #test19ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAColocarEsDescubiertoYPuntoParaDelantero stamp: 'LK 9/25/2023 18:10:33'!
ERROR!

!testRun: #PenalesTest #test20DelanteroTiraAMatarAlAnguloInferiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 18:10:33'!
ERROR!

!testRun: #PenalesTest #test21DelanteroTiraAMatarAlAnguloSuperiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 18:10:33'!
ERROR!

!testRun: #PenalesTest #test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 18:10:33'!
ERROR!

!testRun: #PenalesTest #test23DelanteroTiraAMatarAlAnguloSuperiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 18:10:33'!
ERROR!

!testRun: #PenalesTest #test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro stamp: 'LK 9/25/2023 18:10:33'!
ERROR!

!testRun: #PenalesTest #test25DelanteroTiraAMatarUsa100PorcFuerzaBase stamp: 'LK 9/25/2023 18:10:33'!
ERROR!

!testRun: #PenalesTest #test26DelanteroTiraAMatarConJabulaniGana20PorcFuerzaExtra stamp: 'LK 9/25/2023 18:10:33'!
ERROR!

!testRun: #PenalesTest #test27FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAMatar stamp: 'LK 9/25/2023 18:10:33'!
ERROR!

!testRun: #PenalesTest #test28ArqueroQueEligeAntesDeTiroVsJabulaniAMatarIgnoraAlturaTiro stamp: 'LK 9/25/2023 18:10:33'!
ERROR!

!testRun: #PenalesTest #test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja stamp: 'LK 9/25/2023 18:10:33'!
ERROR!

!testRun: #PenalesTest #test30DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAdentro stamp: 'LK 9/25/2023 18:10:33'!
ERROR!

!testRun: #PenalesTest #test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera stamp: 'LK 9/25/2023 18:10:33'!
ERROR!

!testRun: #PenalesTest #test32ArqueroQueEligeAntesDeTiroVsPlayeraAMatarAlAnguloIgnoraAnchoTiro stamp: 'LK 9/25/2023 18:10:33'!
ERROR!

!testRun: #PenalesTest #test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro stamp: 'LK 9/25/2023 18:10:33'!
ERROR!

!testRun: #PenalesTest #test34ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAMatarSiempreAtaja stamp: 'LK 9/25/2023 18:10:33'!
ERROR!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 18:12:04' prior: 50673966!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	(direccionTiro between: 0@0 and: 2@2) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(direccionArquero between: 0@0 and: 2@2) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	(direccionTiro = direccionArquero) ifTrue: [puntajeArquero := puntajeArquero + 1] 
								ifFalse: [puntajeDelantero := puntajeDelantero +1].
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'LK 9/25/2023 18:12:07'!
ERROR!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 18:12:52'!
varDireccionRemateResultante
	! !

Object subclass: #Penales
	instanceVariableNames: 'puntajeDelantero puntajeArquero direccionDelantero direccionArquero'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

Object subclass: #Penales
	instanceVariableNames: 'puntajeDelantero puntajeArquero direccionDelTiroDelantero direccionDelArquero'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classDefinition: #Penales category: 'ISW1-2023-2C-Parcial-1' stamp: 'LK 9/25/2023 18:13:28'!
Object subclass: #Penales
	instanceVariableNames: 'puntajeDelantero puntajeArquero direccionDelTiroDelantero direccionDelArquero'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 18:14:42' prior: 50674209!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(direccionTiro between: 0@0 and: 2@2) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(direccionArquero between: 0@0 and: 2@2) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	(direccionTiro = direccionArquero) ifTrue: [puntajeArquero := puntajeArquero + 1] 
								ifFalse: [puntajeDelantero := puntajeDelantero +1].
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 18:14:58' prior: 50674291!
varDireccionRemateResultante
	^direccionDelTiroDelantero .! !

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'LK 9/25/2023 18:15:03'!
PASSED!

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'LK 9/25/2023 18:15:03'!
PASSED!

!testRun: #PenalesTest #test02DelanteroNoPuedeApuntarHaciaAfueraDelPaloDerecho stamp: 'LK 9/25/2023 18:15:03'!
PASSED!

!testRun: #PenalesTest #test03DelanteroNoPuedeApuntarHaciaAbajoDelArco stamp: 'LK 9/25/2023 18:15:03'!
PASSED!

!testRun: #PenalesTest #test04DelanteroNoPuedeApuntarHaciaArribaDelTravesaño stamp: 'LK 9/25/2023 18:15:04'!
PASSED!

!testRun: #PenalesTest #test05ArqueroNoPuedePasarseDelPaloIzquierdo stamp: 'LK 9/25/2023 18:15:04'!
PASSED!

!testRun: #PenalesTest #test06ArqueroNoPuedePasarseDelPaloDerecho stamp: 'LK 9/25/2023 18:15:04'!
PASSED!

!testRun: #PenalesTest #test07ArqueroNoPuedeMeterseAbajoDeLaTierra stamp: 'LK 9/25/2023 18:15:04'!
PASSED!

!testRun: #PenalesTest #test08ArqueroNoPuedeSaltarPorEncimaDelTravesaño stamp: 'LK 9/25/2023 18:15:04'!
PASSED!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'LK 9/25/2023 18:15:04'!
PASSED!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'LK 9/25/2023 18:15:04'!
FAILURE!

!testRun: #PenalesTest #test11MismasDireccionesSuficienteFuerzaAtajaArquero stamp: 'LK 9/25/2023 18:15:04'!
PASSED!

!testRun: #PenalesTest #test12DelanteroQueTiraAColocarPierde50PorcFuerza stamp: 'LK 9/25/2023 18:15:04'!
ERROR!

!testRun: #PenalesTest #test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra stamp: 'LK 9/25/2023 18:15:04'!
ERROR!

!testRun: #PenalesTest #test14FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAColocar stamp: 'LK 9/25/2023 18:15:04'!
ERROR!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'LK 9/25/2023 18:15:04'!
FAILURE!

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'LK 9/25/2023 18:15:04'!
ERROR!

!testRun: #PenalesTest #test17ArqueroQueEligeAntesDeTiroVsPlayeraAColocarSuma100PorcFuerzaExtra stamp: 'LK 9/25/2023 18:15:04'!
ERROR!

!testRun: #PenalesTest #test18FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsPlayeraAColocar stamp: 'LK 9/25/2023 18:15:04'!
ERROR!

!testRun: #PenalesTest #test19ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAColocarEsDescubiertoYPuntoParaDelantero stamp: 'LK 9/25/2023 18:15:04'!
ERROR!

!testRun: #PenalesTest #test20DelanteroTiraAMatarAlAnguloInferiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 18:15:04'!
ERROR!

!testRun: #PenalesTest #test21DelanteroTiraAMatarAlAnguloSuperiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 18:15:04'!
ERROR!

!testRun: #PenalesTest #test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 18:15:04'!
ERROR!

!testRun: #PenalesTest #test23DelanteroTiraAMatarAlAnguloSuperiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 18:15:04'!
ERROR!

!testRun: #PenalesTest #test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro stamp: 'LK 9/25/2023 18:15:04'!
ERROR!

!testRun: #PenalesTest #test25DelanteroTiraAMatarUsa100PorcFuerzaBase stamp: 'LK 9/25/2023 18:15:04'!
ERROR!

!testRun: #PenalesTest #test26DelanteroTiraAMatarConJabulaniGana20PorcFuerzaExtra stamp: 'LK 9/25/2023 18:15:04'!
ERROR!

!testRun: #PenalesTest #test27FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAMatar stamp: 'LK 9/25/2023 18:15:04'!
ERROR!

!testRun: #PenalesTest #test28ArqueroQueEligeAntesDeTiroVsJabulaniAMatarIgnoraAlturaTiro stamp: 'LK 9/25/2023 18:15:04'!
ERROR!

!testRun: #PenalesTest #test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja stamp: 'LK 9/25/2023 18:15:04'!
ERROR!

!testRun: #PenalesTest #test30DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAdentro stamp: 'LK 9/25/2023 18:15:04'!
ERROR!

!testRun: #PenalesTest #test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera stamp: 'LK 9/25/2023 18:15:04'!
ERROR!

!testRun: #PenalesTest #test32ArqueroQueEligeAntesDeTiroVsPlayeraAMatarAlAnguloIgnoraAnchoTiro stamp: 'LK 9/25/2023 18:15:04'!
ERROR!

!testRun: #PenalesTest #test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro stamp: 'LK 9/25/2023 18:15:04'!
ERROR!

!testRun: #PenalesTest #test34ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAMatarSiempreAtaja stamp: 'LK 9/25/2023 18:15:04'!
ERROR!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'LK 9/25/2023 18:15:08'!
PASSED!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'LK 9/25/2023 18:15:22'!
FAILURE!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'LK 9/25/2023 18:16:26'!
FAILURE!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 18:17:19' prior: 50674318!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(direccionTiro between: 0@0 and: 2@2) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(direccionArquero between: 0@0 and: 2@2) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	(direccionTiro = direccionArquero) ifTrue: [puntajeArquero := puntajeArquero + 1] 
								ifFalse: [puntajeDelantero := puntajeDelantero +1].
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

Object subclass: #Penales
	instanceVariableNames: 'puntajeDelantero puntajeArquero direccionDelTiroDelantero direccionDelArquero delantero arquero'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classDefinition: #Penales category: 'ISW1-2023-2C-Parcial-1' stamp: 'LK 9/25/2023 18:18:04'!
Object subclass: #Penales
	instanceVariableNames: 'puntajeDelantero puntajeArquero direccionDelTiroDelantero direccionDelArquero delantero arquero'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 18:18:24' prior: 50674059!
initializeConDelantero: unDelantero yArquero: unArquero

delantero := unDelantero .
arquero :=  unArquero.
	puntajeDelantero := 0.
	puntajeArquero := 0.! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 18:19:51' prior: 50674556!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(direccionTiro between: 0@0 and: 2@2) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(direccionArquero between: 0@0 and: 2@2) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	(direccionTiro = direccionArquero & arquero fuerza > delantero fuerza) 
	ifTrue: [self sumarPuntoArquero].
	
	(direccionTiro = direccionArquero & arquero fuerza < delantero fuerza) 
	ifTrue: [self sumarPuntoDelantero].
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 18:20:16'!
sumarPuntoDelantero
	puntajeDelantero := puntajeDelantero + 1.! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 18:20:30'!
sumarPuntoArquero
	puntajeArquero := puntajeArquero + 1.! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 18:21:16' prior: 50674664!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(direccionTiro between: 0@0 and: 2@2) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(direccionArquero between: 0@0 and: 2@2) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	(direccionTiro = direccionArquero & arquero fuerza > delantero fuerza) 
	ifTrue: [self sumarPuntoArquero].
	
	(direccionTiro = direccionArquero & arquero fuerza < delantero fuerza) 
	ifTrue: [self sumarPuntoDelantero].
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'LK 9/25/2023 18:21:18'!
PASSED!

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'LK 9/25/2023 18:21:18'!
PASSED!

!testRun: #PenalesTest #test02DelanteroNoPuedeApuntarHaciaAfueraDelPaloDerecho stamp: 'LK 9/25/2023 18:21:18'!
PASSED!

!testRun: #PenalesTest #test03DelanteroNoPuedeApuntarHaciaAbajoDelArco stamp: 'LK 9/25/2023 18:21:18'!
PASSED!

!testRun: #PenalesTest #test04DelanteroNoPuedeApuntarHaciaArribaDelTravesaño stamp: 'LK 9/25/2023 18:21:18'!
PASSED!

!testRun: #PenalesTest #test05ArqueroNoPuedePasarseDelPaloIzquierdo stamp: 'LK 9/25/2023 18:21:18'!
PASSED!

!testRun: #PenalesTest #test06ArqueroNoPuedePasarseDelPaloDerecho stamp: 'LK 9/25/2023 18:21:18'!
PASSED!

!testRun: #PenalesTest #test07ArqueroNoPuedeMeterseAbajoDeLaTierra stamp: 'LK 9/25/2023 18:21:18'!
PASSED!

!testRun: #PenalesTest #test08ArqueroNoPuedeSaltarPorEncimaDelTravesaño stamp: 'LK 9/25/2023 18:21:18'!
PASSED!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'LK 9/25/2023 18:21:18'!
ERROR!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'LK 9/25/2023 18:21:18'!
PASSED!

!testRun: #PenalesTest #test11MismasDireccionesSuficienteFuerzaAtajaArquero stamp: 'LK 9/25/2023 18:21:19'!
FAILURE!

!testRun: #PenalesTest #test12DelanteroQueTiraAColocarPierde50PorcFuerza stamp: 'LK 9/25/2023 18:21:19'!
FAILURE!

!testRun: #PenalesTest #test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra stamp: 'LK 9/25/2023 18:21:19'!
ERROR!

!testRun: #PenalesTest #test14FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAColocar stamp: 'LK 9/25/2023 18:21:19'!
ERROR!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'LK 9/25/2023 18:21:19'!
ERROR!

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'LK 9/25/2023 18:21:19'!
ERROR!

!testRun: #PenalesTest #test17ArqueroQueEligeAntesDeTiroVsPlayeraAColocarSuma100PorcFuerzaExtra stamp: 'LK 9/25/2023 18:21:19'!
ERROR!

!testRun: #PenalesTest #test18FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsPlayeraAColocar stamp: 'LK 9/25/2023 18:21:19'!
ERROR!

!testRun: #PenalesTest #test19ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAColocarEsDescubiertoYPuntoParaDelantero stamp: 'LK 9/25/2023 18:21:19'!
ERROR!

!testRun: #PenalesTest #test20DelanteroTiraAMatarAlAnguloInferiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 18:21:19'!
ERROR!

!testRun: #PenalesTest #test21DelanteroTiraAMatarAlAnguloSuperiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 18:21:19'!
ERROR!

!testRun: #PenalesTest #test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 18:21:19'!
ERROR!

!testRun: #PenalesTest #test23DelanteroTiraAMatarAlAnguloSuperiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 18:21:19'!
ERROR!

!testRun: #PenalesTest #test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro stamp: 'LK 9/25/2023 18:21:19'!
ERROR!

!testRun: #PenalesTest #test25DelanteroTiraAMatarUsa100PorcFuerzaBase stamp: 'LK 9/25/2023 18:21:19'!
ERROR!

!testRun: #PenalesTest #test26DelanteroTiraAMatarConJabulaniGana20PorcFuerzaExtra stamp: 'LK 9/25/2023 18:21:19'!
ERROR!

!testRun: #PenalesTest #test27FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAMatar stamp: 'LK 9/25/2023 18:21:19'!
ERROR!

!testRun: #PenalesTest #test28ArqueroQueEligeAntesDeTiroVsJabulaniAMatarIgnoraAlturaTiro stamp: 'LK 9/25/2023 18:21:19'!
ERROR!

!testRun: #PenalesTest #test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja stamp: 'LK 9/25/2023 18:21:19'!
ERROR!

!testRun: #PenalesTest #test30DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAdentro stamp: 'LK 9/25/2023 18:21:19'!
ERROR!

!testRun: #PenalesTest #test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera stamp: 'LK 9/25/2023 18:21:19'!
ERROR!

!testRun: #PenalesTest #test32ArqueroQueEligeAntesDeTiroVsPlayeraAMatarAlAnguloIgnoraAnchoTiro stamp: 'LK 9/25/2023 18:21:19'!
ERROR!

!testRun: #PenalesTest #test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro stamp: 'LK 9/25/2023 18:21:19'!
ERROR!

!testRun: #PenalesTest #test34ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAMatarSiempreAtaja stamp: 'LK 9/25/2023 18:21:19'!
ERROR!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'LK 9/25/2023 18:22:17'!
ERROR!

!methodRemoval: Delantero #decideTirarAColocarSuFuerzaBaseEs: stamp: 'LK 9/25/2023 18:22:40'!
decideTirarAColocarSuFuerzaBaseEs: fuerzaJugador

	|delantero|
	delantero := Delantero new.
	fuerza := fuerzaJugador.
	^delantero
!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 18:23:43' prior: 50674758!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(direccionTiro between: 0@0 and: 2@2) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(direccionArquero between: 0@0 and: 2@2) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	(direccionTiro = direccionArquero & (arquero fuerza > delantero fuerza))
	ifTrue: [self sumarPuntoArquero].
	
	(direccionTiro = direccionArquero & (arquero fuerza = delantero fuerza))
	ifTrue: [self sumarPuntoDelantero].
	
	(direccionTiro = direccionArquero & (arquero fuerza < delantero fuerza)) 
	ifTrue: [self sumarPuntoDelantero].
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'LK 9/25/2023 18:23:49'!
PASSED!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'LK 9/25/2023 18:23:51'!
PASSED!

!testRun: #PenalesTest #test11MismasDireccionesSuficienteFuerzaAtajaArquero stamp: 'LK 9/25/2023 18:23:52'!
FAILURE!

!testRun: #PenalesTest #test11MismasDireccionesSuficienteFuerzaAtajaArquero stamp: 'LK 9/25/2023 18:23:52'!
FAILURE!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 18:24:23' prior: 50674995!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(direccionTiro between: 0@0 and: 2@2) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(direccionArquero between: 0@0 and: 2@2) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	(direccionTiro = direccionArquero & (arquero fuerza >= delantero fuerza))
	ifTrue: [self sumarPuntoArquero].
	
	(direccionTiro = direccionArquero & (arquero fuerza = delantero fuerza))
	ifTrue: [self sumarPuntoDelantero].
	
	(direccionTiro = direccionArquero & (arquero fuerza < delantero fuerza)) 
	ifTrue: [self sumarPuntoDelantero].
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test11MismasDireccionesSuficienteFuerzaAtajaArquero stamp: 'LK 9/25/2023 18:24:25'!
FAILURE!

1 < 0!

1 <1 !

1 <= 1!

!testRun: #PenalesTest #test11MismasDireccionesSuficienteFuerzaAtajaArquero stamp: 'LK 9/25/2023 18:25:07'!
FAILURE!

!testRun: #PenalesTest #test11MismasDireccionesSuficienteFuerzaAtajaArquero stamp: 'LK 9/25/2023 18:25:07'!
FAILURE!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 18:25:45' prior: 50675101!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(direccionTiro between: 0@0 and: 2@2) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(direccionArquero between: 0@0 and: 2@2) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	(direccionTiro = direccionArquero & (arquero fuerza >= delantero fuerza))
	ifTrue: [self sumarPuntoArquero].
	
	(direccionTiro = direccionArquero & (arquero fuerza < delantero fuerza)) 
	ifTrue: [self sumarPuntoDelantero].
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test11MismasDireccionesSuficienteFuerzaAtajaArquero stamp: 'LK 9/25/2023 18:25:46'!
PASSED!

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'LK 9/25/2023 18:25:46'!
PASSED!

!testRun: #PenalesTest #test02DelanteroNoPuedeApuntarHaciaAfueraDelPaloDerecho stamp: 'LK 9/25/2023 18:25:46'!
PASSED!

!testRun: #PenalesTest #test03DelanteroNoPuedeApuntarHaciaAbajoDelArco stamp: 'LK 9/25/2023 18:25:46'!
PASSED!

!testRun: #PenalesTest #test04DelanteroNoPuedeApuntarHaciaArribaDelTravesaño stamp: 'LK 9/25/2023 18:25:46'!
PASSED!

!testRun: #PenalesTest #test05ArqueroNoPuedePasarseDelPaloIzquierdo stamp: 'LK 9/25/2023 18:25:46'!
PASSED!

!testRun: #PenalesTest #test06ArqueroNoPuedePasarseDelPaloDerecho stamp: 'LK 9/25/2023 18:25:46'!
PASSED!

!testRun: #PenalesTest #test07ArqueroNoPuedeMeterseAbajoDeLaTierra stamp: 'LK 9/25/2023 18:25:46'!
PASSED!

!testRun: #PenalesTest #test08ArqueroNoPuedeSaltarPorEncimaDelTravesaño stamp: 'LK 9/25/2023 18:25:46'!
PASSED!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'LK 9/25/2023 18:25:46'!
PASSED!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'LK 9/25/2023 18:25:46'!
PASSED!

!testRun: #PenalesTest #test11MismasDireccionesSuficienteFuerzaAtajaArquero stamp: 'LK 9/25/2023 18:25:46'!
PASSED!

!testRun: #PenalesTest #test12DelanteroQueTiraAColocarPierde50PorcFuerza stamp: 'LK 9/25/2023 18:25:47'!
FAILURE!

!testRun: #PenalesTest #test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra stamp: 'LK 9/25/2023 18:25:47'!
ERROR!

!testRun: #PenalesTest #test14FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAColocar stamp: 'LK 9/25/2023 18:25:47'!
ERROR!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'LK 9/25/2023 18:25:47'!
FAILURE!

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'LK 9/25/2023 18:25:47'!
ERROR!

!testRun: #PenalesTest #test17ArqueroQueEligeAntesDeTiroVsPlayeraAColocarSuma100PorcFuerzaExtra stamp: 'LK 9/25/2023 18:25:47'!
ERROR!

!testRun: #PenalesTest #test18FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsPlayeraAColocar stamp: 'LK 9/25/2023 18:25:47'!
ERROR!

!testRun: #PenalesTest #test19ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAColocarEsDescubiertoYPuntoParaDelantero stamp: 'LK 9/25/2023 18:25:47'!
ERROR!

!testRun: #PenalesTest #test20DelanteroTiraAMatarAlAnguloInferiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 18:25:47'!
ERROR!

!testRun: #PenalesTest #test21DelanteroTiraAMatarAlAnguloSuperiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 18:25:47'!
ERROR!

!testRun: #PenalesTest #test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 18:25:47'!
ERROR!

!testRun: #PenalesTest #test23DelanteroTiraAMatarAlAnguloSuperiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 18:25:47'!
ERROR!

!testRun: #PenalesTest #test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro stamp: 'LK 9/25/2023 18:25:47'!
ERROR!

!testRun: #PenalesTest #test25DelanteroTiraAMatarUsa100PorcFuerzaBase stamp: 'LK 9/25/2023 18:25:47'!
ERROR!

!testRun: #PenalesTest #test26DelanteroTiraAMatarConJabulaniGana20PorcFuerzaExtra stamp: 'LK 9/25/2023 18:25:47'!
ERROR!

!testRun: #PenalesTest #test27FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAMatar stamp: 'LK 9/25/2023 18:25:47'!
ERROR!

!testRun: #PenalesTest #test28ArqueroQueEligeAntesDeTiroVsJabulaniAMatarIgnoraAlturaTiro stamp: 'LK 9/25/2023 18:25:47'!
ERROR!

!testRun: #PenalesTest #test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja stamp: 'LK 9/25/2023 18:25:47'!
ERROR!

!testRun: #PenalesTest #test30DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAdentro stamp: 'LK 9/25/2023 18:25:47'!
ERROR!

!testRun: #PenalesTest #test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera stamp: 'LK 9/25/2023 18:25:47'!
ERROR!

!testRun: #PenalesTest #test32ArqueroQueEligeAntesDeTiroVsPlayeraAMatarAlAnguloIgnoraAnchoTiro stamp: 'LK 9/25/2023 18:25:47'!
ERROR!

!testRun: #PenalesTest #test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro stamp: 'LK 9/25/2023 18:25:47'!
ERROR!

!testRun: #PenalesTest #test34ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAMatarSiempreAtaja stamp: 'LK 9/25/2023 18:25:47'!
ERROR!

!testRun: #PenalesTest #test12DelanteroQueTiraAColocarPierde50PorcFuerza stamp: 'LK 9/25/2023 18:25:52'!
FAILURE!

!testRun: #PenalesTest #test12DelanteroQueTiraAColocarPierde50PorcFuerza stamp: 'LK 9/25/2023 18:25:52'!
FAILURE!

!testRun: #PenalesTest #test12DelanteroQueTiraAColocarPierde50PorcFuerza stamp: 'LK 9/25/2023 18:26:41'!
FAILURE!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 18:27:54'!
varFuerzaResultanteDelTiro
	^ (delantero fuerza / 2)! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 18:28:26' prior: 50675204!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(direccionTiro between: 0@0 and: 2@2) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(direccionArquero between: 0@0 and: 2@2) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	(direccionTiro = direccionArquero & (arquero fuerza >= self varFuerzaResultanteDelTiro ))
	ifTrue: [self sumarPuntoArquero].
	
	(direccionTiro = direccionArquero & (arquero fuerza < self varFuerzaResultanteDelTiro )) 
	ifTrue: [self sumarPuntoDelantero].
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test12DelanteroQueTiraAColocarPierde50PorcFuerza stamp: 'LK 9/25/2023 18:28:28'!
ERROR!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 18:29:00'!
varFuerzaResultanteDeTiro
	^ (delantero fuerza / 2)! !
!Penales methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 18:29:00' prior: 50675446!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(direccionTiro between: 0@0 and: 2@2) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(direccionArquero between: 0@0 and: 2@2) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	(direccionTiro = direccionArquero & (arquero fuerza >= self varFuerzaResultanteDeTiro ))
	ifTrue: [self sumarPuntoArquero].
	
	(direccionTiro = direccionArquero & (arquero fuerza < self varFuerzaResultanteDeTiro )) 
	ifTrue: [self sumarPuntoDelantero].
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!methodRemoval: Penales #varFuerzaResultanteDelTiro stamp: 'LK 9/25/2023 18:29:00'!
varFuerzaResultanteDelTiro
	^ (delantero fuerza / 2)!

!testRun: #PenalesTest #test12DelanteroQueTiraAColocarPierde50PorcFuerza stamp: 'LK 9/25/2023 18:29:06'!
PASSED!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 18:29:58'!
varFuerzaResultanteDeAtajada
	^ (arquero fuerza * 1.5)! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 18:30:33' prior: 50675543!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(direccionTiro between: 0@0 and: 2@2) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(direccionArquero between: 0@0 and: 2@2) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	(direccionTiro = direccionArquero & (self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro ))
	ifTrue: [self sumarPuntoArquero].
	
	(direccionTiro = direccionArquero & (self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro )) 
	ifTrue: [self sumarPuntoDelantero].
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !
!Arquero class methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 18:32:28'!
eligeDireccionAntesDeTiroSuFuerzaBaseEs: fuerzaArquero
	^self new initializeEligeDireccionAntesDeTiroSuFuerzaBaseEs: fuerzaArquero.! !
!Arquero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 18:32:52'!
initializeEligeDireccionAntesDeTiroSuFuerzaBaseEs: fuerzaArquero
	fuerza := fuerzaArquero * 1.5! !

!testRun: #PenalesTest #test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra stamp: 'LK 9/25/2023 18:33:00'!
FAILURE!

!testRun: #PenalesTest #test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra stamp: 'LK 9/25/2023 18:33:00'!
FAILURE!

34 * 1.5!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 18:33:40' prior: 50675639!
varFuerzaResultanteDeAtajada
	^ arquero fuerza.! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 18:33:47' prior: 50675538!
varFuerzaResultanteDeTiro
	^ delantero fuerza! !
!Delantero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 18:33:59' prior: 50673794!
initializeDecideTirarAColocarSuFuerzaBaseEs: fuerzaJugador

	fuerza := fuerzaJugador / 2.! !

!testRun: #PenalesTest #test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra stamp: 'LK 9/25/2023 18:34:00'!
PASSED!

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'LK 9/25/2023 18:34:01'!
PASSED!

!testRun: #PenalesTest #test02DelanteroNoPuedeApuntarHaciaAfueraDelPaloDerecho stamp: 'LK 9/25/2023 18:34:01'!
PASSED!

!testRun: #PenalesTest #test03DelanteroNoPuedeApuntarHaciaAbajoDelArco stamp: 'LK 9/25/2023 18:34:01'!
PASSED!

!testRun: #PenalesTest #test04DelanteroNoPuedeApuntarHaciaArribaDelTravesaño stamp: 'LK 9/25/2023 18:34:01'!
PASSED!

!testRun: #PenalesTest #test05ArqueroNoPuedePasarseDelPaloIzquierdo stamp: 'LK 9/25/2023 18:34:01'!
PASSED!

!testRun: #PenalesTest #test06ArqueroNoPuedePasarseDelPaloDerecho stamp: 'LK 9/25/2023 18:34:01'!
PASSED!

!testRun: #PenalesTest #test07ArqueroNoPuedeMeterseAbajoDeLaTierra stamp: 'LK 9/25/2023 18:34:01'!
PASSED!

!testRun: #PenalesTest #test08ArqueroNoPuedeSaltarPorEncimaDelTravesaño stamp: 'LK 9/25/2023 18:34:01'!
PASSED!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'LK 9/25/2023 18:34:01'!
PASSED!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'LK 9/25/2023 18:34:01'!
PASSED!

!testRun: #PenalesTest #test11MismasDireccionesSuficienteFuerzaAtajaArquero stamp: 'LK 9/25/2023 18:34:01'!
PASSED!

!testRun: #PenalesTest #test12DelanteroQueTiraAColocarPierde50PorcFuerza stamp: 'LK 9/25/2023 18:34:01'!
PASSED!

!testRun: #PenalesTest #test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra stamp: 'LK 9/25/2023 18:34:01'!
PASSED!

!testRun: #PenalesTest #test14FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAColocar stamp: 'LK 9/25/2023 18:34:01'!
PASSED!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'LK 9/25/2023 18:34:01'!
FAILURE!

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'LK 9/25/2023 18:34:01'!
ERROR!

!testRun: #PenalesTest #test17ArqueroQueEligeAntesDeTiroVsPlayeraAColocarSuma100PorcFuerzaExtra stamp: 'LK 9/25/2023 18:34:01'!
ERROR!

!testRun: #PenalesTest #test18FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsPlayeraAColocar stamp: 'LK 9/25/2023 18:34:01'!
ERROR!

!testRun: #PenalesTest #test19ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAColocarEsDescubiertoYPuntoParaDelantero stamp: 'LK 9/25/2023 18:34:01'!
ERROR!

!testRun: #PenalesTest #test20DelanteroTiraAMatarAlAnguloInferiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 18:34:01'!
ERROR!

!testRun: #PenalesTest #test21DelanteroTiraAMatarAlAnguloSuperiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 18:34:01'!
ERROR!

!testRun: #PenalesTest #test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 18:34:01'!
ERROR!

!testRun: #PenalesTest #test23DelanteroTiraAMatarAlAnguloSuperiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 18:34:01'!
ERROR!

!testRun: #PenalesTest #test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro stamp: 'LK 9/25/2023 18:34:01'!
ERROR!

!testRun: #PenalesTest #test25DelanteroTiraAMatarUsa100PorcFuerzaBase stamp: 'LK 9/25/2023 18:34:01'!
ERROR!

!testRun: #PenalesTest #test26DelanteroTiraAMatarConJabulaniGana20PorcFuerzaExtra stamp: 'LK 9/25/2023 18:34:01'!
ERROR!

!testRun: #PenalesTest #test27FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAMatar stamp: 'LK 9/25/2023 18:34:01'!
ERROR!

!testRun: #PenalesTest #test28ArqueroQueEligeAntesDeTiroVsJabulaniAMatarIgnoraAlturaTiro stamp: 'LK 9/25/2023 18:34:01'!
ERROR!

!testRun: #PenalesTest #test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja stamp: 'LK 9/25/2023 18:34:01'!
ERROR!

!testRun: #PenalesTest #test30DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAdentro stamp: 'LK 9/25/2023 18:34:01'!
ERROR!

!testRun: #PenalesTest #test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera stamp: 'LK 9/25/2023 18:34:01'!
ERROR!

!testRun: #PenalesTest #test32ArqueroQueEligeAntesDeTiroVsPlayeraAMatarAlAnguloIgnoraAnchoTiro stamp: 'LK 9/25/2023 18:34:01'!
ERROR!

!testRun: #PenalesTest #test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro stamp: 'LK 9/25/2023 18:34:01'!
ERROR!

!testRun: #PenalesTest #test34ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAMatarSiempreAtaja stamp: 'LK 9/25/2023 18:34:01'!
ERROR!
!Pelota class methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 18:36:44'!
playeraLentaCostaAzul
	^self new initializePlayeraLentaCostaAzul! !
!Pelota methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 18:36:55'!
initializePlayeraLentaCostaAzul
	
	tipo := #Playera.! !
!Pelota methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 18:38:27'!
tipo
	^tipo! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 18:41:01' prior: 50675644!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(direccionTiro between: 0@0 and: 2@2) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(direccionArquero between: 0@0 and: 2@2) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	(direccionTiro = direccionArquero & (self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro ))
	ifTrue: [self sumarPuntoArquero].
	
	(direccionTiro = direccionArquero & (self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro )) 
	ifTrue: [self sumarPuntoDelantero].
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	(pelota tipo = #Jabulani) ifTrue: [direccionTiro x = direccionArquero x ifTrue: [self sumarPuntoArquero]].
	
	
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 18:42:21'!
direccionEnRango: direccionTiro

	^ direccionTiro between: 0@0 and: 2@2! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 18:42:21' prior: 50675926!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(self direccionEnRango: direccionTiro) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(direccionArquero between: 0@0 and: 2@2) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	(direccionTiro = direccionArquero & (self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro ))
	ifTrue: [self sumarPuntoArquero].
	
	(direccionTiro = direccionArquero & (self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro )) 
	ifTrue: [self sumarPuntoDelantero].
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	(pelota tipo = #Jabulani) ifTrue: [direccionTiro x = direccionArquero x ifTrue: [self sumarPuntoArquero]].
	
	
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 18:42:39' prior: 50676025!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(self direccionEnRango: direccionTiro) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(self direccionEnRango: direccionArquero) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	(direccionTiro = direccionArquero & (self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro ))
	ifTrue: [self sumarPuntoArquero].
	
	(direccionTiro = direccionArquero & (self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro )) 
	ifTrue: [self sumarPuntoDelantero].
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	(pelota tipo = #Jabulani) ifTrue: [direccionTiro x = direccionArquero x ifTrue: [self sumarPuntoArquero]].
	
	
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!classDefinition: #Delantero category: 'ISW1-2023-2C-Parcial-1' stamp: 'LK 9/25/2023 18:42:59'!
Object subclass: #Delantero
	instanceVariableNames: 'fuerza tipo'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!
!Delantero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 18:42:58' prior: 50675766!
initializeDecideTirarAColocarSuFuerzaBaseEs: fuerzaJugador
	
	tipo := #AColocar.

	fuerza := fuerzaJugador / 2.! !

!classDefinition: #Arquero category: 'ISW1-2023-2C-Parcial-1' stamp: 'LK 9/25/2023 18:43:27'!
Object subclass: #Arquero
	instanceVariableNames: 'fuerza tipo'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!
!Arquero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 18:43:25' prior: 50675740!
initializeEligeDireccionAntesDeTiroSuFuerzaBaseEs: fuerzaArquero

	tipo := #Adelanta.
	fuerza := fuerzaArquero * 1.5! !
!Arquero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 18:43:34' prior: 50673783!
initializeEsperaPorTiroYSeAdelantaSuFuerzaBaseEs: fuerzaArquero
	tipo := #Espera.
	fuerza := fuerzaArquero.! !

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'LK 9/25/2023 18:43:52'!
FAILURE!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'LK 9/25/2023 18:43:52'!
FAILURE!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 18:46:28' prior: 50676118!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(self direccionEnRango: direccionTiro) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(self direccionEnRango: direccionArquero) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	(pelota tipo = #Jabulani) ifTrue: [].
	
	(direccionTiro = direccionArquero & (self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro ))
	ifTrue: [self sumarPuntoArquero].
	
	(direccionTiro = direccionArquero & (self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro )) 
	ifTrue: [self sumarPuntoDelantero].
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	(pelota tipo = #Jabulani) ifTrue: [direccionTiro x = direccionArquero x ifTrue: [self sumarPuntoArquero]].
	
	
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 18:48:28' prior: 50676256!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(self direccionEnRango: direccionTiro) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(self direccionEnRango: direccionArquero) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	(pelota tipo = #Jabulani) ifTrue: [
		
		(arquero tipo = #Adelanta) ifTrue: [
				(direccionTiro x = direccionArquero x) ifTrue: [self sumarPuntoArquero].
			]
		
		
		].
	
	(direccionTiro = direccionArquero & (self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro ))
	ifTrue: [self sumarPuntoArquero].
	
	(direccionTiro = direccionArquero & (self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro )) 
	ifTrue: [self sumarPuntoDelantero].
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	(pelota tipo = #Jabulani) ifTrue: [direccionTiro x = direccionArquero x ifTrue: [self sumarPuntoArquero]].
	
	
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 18:53:25' prior: 50676351!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(self direccionEnRango: direccionTiro) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(self direccionEnRango: direccionArquero) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	(pelota tipo = #Jabulani) ifTrue: [
		
		(arquero tipo = #Adelanta) ifTrue: [
				(direccionTiro x = direccionArquero x & 
				self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro)
				 	ifTrue: [self sumarPuntoArquero].
			].
		(arquero tipo = #Espera) ifTrue: [
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro ))
					ifTrue: [self sumarPuntoArquero].
			
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro )) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
		].
	(pelota = #Playera) ifTrue: [].
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'LK 9/25/2023 18:53:30'!
PASSED!

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'LK 9/25/2023 18:53:33'!
PASSED!

!testRun: #PenalesTest #test02DelanteroNoPuedeApuntarHaciaAfueraDelPaloDerecho stamp: 'LK 9/25/2023 18:53:33'!
PASSED!

!testRun: #PenalesTest #test03DelanteroNoPuedeApuntarHaciaAbajoDelArco stamp: 'LK 9/25/2023 18:53:33'!
PASSED!

!testRun: #PenalesTest #test04DelanteroNoPuedeApuntarHaciaArribaDelTravesaño stamp: 'LK 9/25/2023 18:53:33'!
PASSED!

!testRun: #PenalesTest #test05ArqueroNoPuedePasarseDelPaloIzquierdo stamp: 'LK 9/25/2023 18:53:33'!
PASSED!

!testRun: #PenalesTest #test06ArqueroNoPuedePasarseDelPaloDerecho stamp: 'LK 9/25/2023 18:53:33'!
PASSED!

!testRun: #PenalesTest #test07ArqueroNoPuedeMeterseAbajoDeLaTierra stamp: 'LK 9/25/2023 18:53:33'!
PASSED!

!testRun: #PenalesTest #test08ArqueroNoPuedeSaltarPorEncimaDelTravesaño stamp: 'LK 9/25/2023 18:53:33'!
PASSED!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'LK 9/25/2023 18:53:33'!
ERROR!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'LK 9/25/2023 18:53:33'!
ERROR!

!testRun: #PenalesTest #test11MismasDireccionesSuficienteFuerzaAtajaArquero stamp: 'LK 9/25/2023 18:53:33'!
ERROR!

!testRun: #PenalesTest #test12DelanteroQueTiraAColocarPierde50PorcFuerza stamp: 'LK 9/25/2023 18:53:33'!
ERROR!

!testRun: #PenalesTest #test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra stamp: 'LK 9/25/2023 18:53:33'!
ERROR!

!testRun: #PenalesTest #test14FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAColocar stamp: 'LK 9/25/2023 18:53:33'!
ERROR!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'LK 9/25/2023 18:53:33'!
ERROR!

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'LK 9/25/2023 18:53:33'!
FAILURE!

!testRun: #PenalesTest #test17ArqueroQueEligeAntesDeTiroVsPlayeraAColocarSuma100PorcFuerzaExtra stamp: 'LK 9/25/2023 18:53:33'!
FAILURE!

!testRun: #PenalesTest #test18FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsPlayeraAColocar stamp: 'LK 9/25/2023 18:53:33'!
FAILURE!

!testRun: #PenalesTest #test19ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAColocarEsDescubiertoYPuntoParaDelantero stamp: 'LK 9/25/2023 18:53:33'!
FAILURE!

!testRun: #PenalesTest #test20DelanteroTiraAMatarAlAnguloInferiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 18:53:33'!
ERROR!

!testRun: #PenalesTest #test21DelanteroTiraAMatarAlAnguloSuperiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 18:53:33'!
ERROR!

!testRun: #PenalesTest #test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 18:53:33'!
ERROR!

!testRun: #PenalesTest #test23DelanteroTiraAMatarAlAnguloSuperiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 18:53:33'!
ERROR!

!testRun: #PenalesTest #test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro stamp: 'LK 9/25/2023 18:53:33'!
ERROR!

!testRun: #PenalesTest #test25DelanteroTiraAMatarUsa100PorcFuerzaBase stamp: 'LK 9/25/2023 18:53:33'!
ERROR!

!testRun: #PenalesTest #test26DelanteroTiraAMatarConJabulaniGana20PorcFuerzaExtra stamp: 'LK 9/25/2023 18:53:33'!
ERROR!

!testRun: #PenalesTest #test27FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAMatar stamp: 'LK 9/25/2023 18:53:33'!
ERROR!

!testRun: #PenalesTest #test28ArqueroQueEligeAntesDeTiroVsJabulaniAMatarIgnoraAlturaTiro stamp: 'LK 9/25/2023 18:53:33'!
ERROR!

!testRun: #PenalesTest #test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja stamp: 'LK 9/25/2023 18:53:33'!
ERROR!

!testRun: #PenalesTest #test30DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAdentro stamp: 'LK 9/25/2023 18:53:33'!
ERROR!

!testRun: #PenalesTest #test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera stamp: 'LK 9/25/2023 18:53:33'!
ERROR!

!testRun: #PenalesTest #test32ArqueroQueEligeAntesDeTiroVsPlayeraAMatarAlAnguloIgnoraAnchoTiro stamp: 'LK 9/25/2023 18:53:33'!
ERROR!

!testRun: #PenalesTest #test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro stamp: 'LK 9/25/2023 18:53:33'!
ERROR!

!testRun: #PenalesTest #test34ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAMatarSiempreAtaja stamp: 'LK 9/25/2023 18:53:33'!
ERROR!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'LK 9/25/2023 18:54:04'!
ERROR!
!Arquero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 18:54:23'!
tipo
	^tipo! !

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'LK 9/25/2023 18:54:27'!
PASSED!

!testRun: #PenalesTest #test02DelanteroNoPuedeApuntarHaciaAfueraDelPaloDerecho stamp: 'LK 9/25/2023 18:54:27'!
PASSED!

!testRun: #PenalesTest #test03DelanteroNoPuedeApuntarHaciaAbajoDelArco stamp: 'LK 9/25/2023 18:54:27'!
PASSED!

!testRun: #PenalesTest #test04DelanteroNoPuedeApuntarHaciaArribaDelTravesaño stamp: 'LK 9/25/2023 18:54:27'!
PASSED!

!testRun: #PenalesTest #test05ArqueroNoPuedePasarseDelPaloIzquierdo stamp: 'LK 9/25/2023 18:54:27'!
PASSED!

!testRun: #PenalesTest #test06ArqueroNoPuedePasarseDelPaloDerecho stamp: 'LK 9/25/2023 18:54:27'!
PASSED!

!testRun: #PenalesTest #test07ArqueroNoPuedeMeterseAbajoDeLaTierra stamp: 'LK 9/25/2023 18:54:27'!
PASSED!

!testRun: #PenalesTest #test08ArqueroNoPuedeSaltarPorEncimaDelTravesaño stamp: 'LK 9/25/2023 18:54:27'!
PASSED!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'LK 9/25/2023 18:54:27'!
PASSED!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'LK 9/25/2023 18:54:27'!
PASSED!

!testRun: #PenalesTest #test11MismasDireccionesSuficienteFuerzaAtajaArquero stamp: 'LK 9/25/2023 18:54:27'!
PASSED!

!testRun: #PenalesTest #test12DelanteroQueTiraAColocarPierde50PorcFuerza stamp: 'LK 9/25/2023 18:54:27'!
PASSED!

!testRun: #PenalesTest #test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra stamp: 'LK 9/25/2023 18:54:27'!
PASSED!

!testRun: #PenalesTest #test14FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAColocar stamp: 'LK 9/25/2023 18:54:27'!
FAILURE!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'LK 9/25/2023 18:54:27'!
FAILURE!

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'LK 9/25/2023 18:54:27'!
FAILURE!

!testRun: #PenalesTest #test17ArqueroQueEligeAntesDeTiroVsPlayeraAColocarSuma100PorcFuerzaExtra stamp: 'LK 9/25/2023 18:54:27'!
FAILURE!

!testRun: #PenalesTest #test18FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsPlayeraAColocar stamp: 'LK 9/25/2023 18:54:27'!
FAILURE!

!testRun: #PenalesTest #test19ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAColocarEsDescubiertoYPuntoParaDelantero stamp: 'LK 9/25/2023 18:54:27'!
FAILURE!

!testRun: #PenalesTest #test20DelanteroTiraAMatarAlAnguloInferiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 18:54:27'!
ERROR!

!testRun: #PenalesTest #test21DelanteroTiraAMatarAlAnguloSuperiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 18:54:27'!
ERROR!

!testRun: #PenalesTest #test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 18:54:27'!
ERROR!

!testRun: #PenalesTest #test23DelanteroTiraAMatarAlAnguloSuperiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 18:54:27'!
ERROR!

!testRun: #PenalesTest #test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro stamp: 'LK 9/25/2023 18:54:27'!
ERROR!

!testRun: #PenalesTest #test25DelanteroTiraAMatarUsa100PorcFuerzaBase stamp: 'LK 9/25/2023 18:54:27'!
ERROR!

!testRun: #PenalesTest #test26DelanteroTiraAMatarConJabulaniGana20PorcFuerzaExtra stamp: 'LK 9/25/2023 18:54:27'!
ERROR!

!testRun: #PenalesTest #test27FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAMatar stamp: 'LK 9/25/2023 18:54:27'!
ERROR!

!testRun: #PenalesTest #test28ArqueroQueEligeAntesDeTiroVsJabulaniAMatarIgnoraAlturaTiro stamp: 'LK 9/25/2023 18:54:27'!
ERROR!

!testRun: #PenalesTest #test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja stamp: 'LK 9/25/2023 18:54:27'!
ERROR!

!testRun: #PenalesTest #test30DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAdentro stamp: 'LK 9/25/2023 18:54:27'!
ERROR!

!testRun: #PenalesTest #test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera stamp: 'LK 9/25/2023 18:54:27'!
ERROR!

!testRun: #PenalesTest #test32ArqueroQueEligeAntesDeTiroVsPlayeraAMatarAlAnguloIgnoraAnchoTiro stamp: 'LK 9/25/2023 18:54:27'!
ERROR!

!testRun: #PenalesTest #test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro stamp: 'LK 9/25/2023 18:54:27'!
ERROR!

!testRun: #PenalesTest #test34ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAMatarSiempreAtaja stamp: 'LK 9/25/2023 18:54:27'!
ERROR!

!testRun: #PenalesTest #test14FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAColocar stamp: 'LK 9/25/2023 18:54:40'!
FAILURE!

!testRun: #PenalesTest #test14FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAColocar stamp: 'LK 9/25/2023 18:55:14'!
FAILURE!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 18:56:33' prior: 50676450!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(self direccionEnRango: direccionTiro) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(self direccionEnRango: direccionArquero) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	(pelota tipo = #Jabulani) ifTrue: [
		
		(arquero tipo = #Adelanta) ifTrue: [
				(direccionTiro x = direccionArquero x & 
				self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro)
				 	ifTrue: [self sumarPuntoArquero].
					
				(direccionTiro = direccionArquero & 
				self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro) 
					ifTrue: [self sumarPuntoDelantero].
					
			].
		(arquero tipo = #Espera) ifTrue: [
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro ))
					ifTrue: [self sumarPuntoArquero].
			
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro )) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
		].
	(pelota = #Playera) ifTrue: [].
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test14FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAColocar stamp: 'LK 9/25/2023 18:56:35'!
PASSED!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'LK 9/25/2023 18:56:37'!
FAILURE!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'LK 9/25/2023 18:56:37'!
FAILURE!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'LK 9/25/2023 18:56:46'!
FAILURE!

0@2 x!

(0@2) x!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 18:57:35' prior: 50676842!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(self direccionEnRango: direccionTiro) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(self direccionEnRango: direccionArquero) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	(pelota tipo = #Jabulani) ifTrue: [
		
		(arquero tipo = #Adelanta) ifTrue: [
				((direccionTiro) x = (direccionArquero) x & 
				self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro)
				 	ifTrue: [self sumarPuntoArquero].
					
				(direccionTiro = direccionArquero & 
				self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro) 
					ifTrue: [self sumarPuntoDelantero].
					
			].
		(arquero tipo = #Espera) ifTrue: [
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro ))
					ifTrue: [self sumarPuntoArquero].
			
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro )) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
		].
	(pelota = #Playera) ifTrue: [].
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'LK 9/25/2023 18:57:37'!
FAILURE!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'LK 9/25/2023 18:57:37'!
FAILURE!
!Arquero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 19:00:16' prior: 50676240!
initializeEsperaPorTiroYSeAdelantaSuFuerzaBaseEs: fuerzaArquero

	tipo := #EsperaYAdelanta.
	fuerza := fuerzaArquero.! !
!Arquero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 19:00:21' prior: 50676233!
initializeEligeDireccionAntesDeTiroSuFuerzaBaseEs: fuerzaArquero

	tipo := #Elige.
	fuerza := fuerzaArquero * 1.5! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 19:00:41' prior: 50676966!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(self direccionEnRango: direccionTiro) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(self direccionEnRango: direccionArquero) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	(pelota tipo = #Jabulani) ifTrue: [
		
		(arquero tipo = #EsperaYAdelanta) ifTrue: [
				((direccionTiro) x = (direccionArquero) x & 
				self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro)
				 	ifTrue: [self sumarPuntoArquero].
					
				(direccionTiro = direccionArquero & 
				self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro) 
					ifTrue: [self sumarPuntoDelantero].
					
			].
		(arquero tipo = #Espera) ifTrue: [
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro ))
					ifTrue: [self sumarPuntoArquero].
			
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro )) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
		].
	(pelota = #Playera) ifTrue: [].
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 19:00:52' prior: 50677095!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(self direccionEnRango: direccionTiro) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(self direccionEnRango: direccionArquero) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	(pelota tipo = #Jabulani) ifTrue: [
		
		(arquero tipo = #EsperaYAdelanta) ifTrue: [
				((direccionTiro) x = (direccionArquero) x & 
				self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro)
				 	ifTrue: [self sumarPuntoArquero].
					
				(direccionTiro = direccionArquero & 
				self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro) 
					ifTrue: [self sumarPuntoDelantero].
					
			].
		(arquero tipo = #Elige) ifTrue: [
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro ))
					ifTrue: [self sumarPuntoArquero].
			
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro )) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
		].
	(pelota = #Playera) ifTrue: [].
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'LK 9/25/2023 19:01:00'!
PASSED!

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'LK 9/25/2023 19:01:02'!
PASSED!

!testRun: #PenalesTest #test02DelanteroNoPuedeApuntarHaciaAfueraDelPaloDerecho stamp: 'LK 9/25/2023 19:01:02'!
PASSED!

!testRun: #PenalesTest #test03DelanteroNoPuedeApuntarHaciaAbajoDelArco stamp: 'LK 9/25/2023 19:01:02'!
PASSED!

!testRun: #PenalesTest #test04DelanteroNoPuedeApuntarHaciaArribaDelTravesaño stamp: 'LK 9/25/2023 19:01:02'!
PASSED!

!testRun: #PenalesTest #test05ArqueroNoPuedePasarseDelPaloIzquierdo stamp: 'LK 9/25/2023 19:01:02'!
PASSED!

!testRun: #PenalesTest #test06ArqueroNoPuedePasarseDelPaloDerecho stamp: 'LK 9/25/2023 19:01:02'!
PASSED!

!testRun: #PenalesTest #test07ArqueroNoPuedeMeterseAbajoDeLaTierra stamp: 'LK 9/25/2023 19:01:03'!
PASSED!

!testRun: #PenalesTest #test08ArqueroNoPuedeSaltarPorEncimaDelTravesaño stamp: 'LK 9/25/2023 19:01:03'!
PASSED!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'LK 9/25/2023 19:01:03'!
ERROR!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'LK 9/25/2023 19:01:03'!
PASSED!

!testRun: #PenalesTest #test11MismasDireccionesSuficienteFuerzaAtajaArquero stamp: 'LK 9/25/2023 19:01:03'!
PASSED!

!testRun: #PenalesTest #test12DelanteroQueTiraAColocarPierde50PorcFuerza stamp: 'LK 9/25/2023 19:01:03'!
PASSED!

!testRun: #PenalesTest #test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra stamp: 'LK 9/25/2023 19:01:03'!
PASSED!

!testRun: #PenalesTest #test14FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAColocar stamp: 'LK 9/25/2023 19:01:03'!
PASSED!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'LK 9/25/2023 19:01:03'!
ERROR!

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'LK 9/25/2023 19:01:03'!
FAILURE!

!testRun: #PenalesTest #test17ArqueroQueEligeAntesDeTiroVsPlayeraAColocarSuma100PorcFuerzaExtra stamp: 'LK 9/25/2023 19:01:03'!
FAILURE!

!testRun: #PenalesTest #test18FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsPlayeraAColocar stamp: 'LK 9/25/2023 19:01:03'!
FAILURE!

!testRun: #PenalesTest #test19ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAColocarEsDescubiertoYPuntoParaDelantero stamp: 'LK 9/25/2023 19:01:03'!
FAILURE!

!testRun: #PenalesTest #test20DelanteroTiraAMatarAlAnguloInferiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:01:03'!
ERROR!

!testRun: #PenalesTest #test21DelanteroTiraAMatarAlAnguloSuperiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:01:03'!
ERROR!

!testRun: #PenalesTest #test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:01:03'!
ERROR!

!testRun: #PenalesTest #test23DelanteroTiraAMatarAlAnguloSuperiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:01:03'!
ERROR!

!testRun: #PenalesTest #test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro stamp: 'LK 9/25/2023 19:01:03'!
ERROR!

!testRun: #PenalesTest #test25DelanteroTiraAMatarUsa100PorcFuerzaBase stamp: 'LK 9/25/2023 19:01:03'!
ERROR!

!testRun: #PenalesTest #test26DelanteroTiraAMatarConJabulaniGana20PorcFuerzaExtra stamp: 'LK 9/25/2023 19:01:03'!
ERROR!

!testRun: #PenalesTest #test27FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAMatar stamp: 'LK 9/25/2023 19:01:03'!
ERROR!

!testRun: #PenalesTest #test28ArqueroQueEligeAntesDeTiroVsJabulaniAMatarIgnoraAlturaTiro stamp: 'LK 9/25/2023 19:01:03'!
ERROR!

!testRun: #PenalesTest #test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja stamp: 'LK 9/25/2023 19:01:03'!
ERROR!

!testRun: #PenalesTest #test30DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAdentro stamp: 'LK 9/25/2023 19:01:03'!
ERROR!

!testRun: #PenalesTest #test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera stamp: 'LK 9/25/2023 19:01:03'!
ERROR!

!testRun: #PenalesTest #test32ArqueroQueEligeAntesDeTiroVsPlayeraAMatarAlAnguloIgnoraAnchoTiro stamp: 'LK 9/25/2023 19:01:03'!
ERROR!

!testRun: #PenalesTest #test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro stamp: 'LK 9/25/2023 19:01:03'!
ERROR!

!testRun: #PenalesTest #test34ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAMatarSiempreAtaja stamp: 'LK 9/25/2023 19:01:03'!
ERROR!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'LK 9/25/2023 19:01:35'!
ERROR!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'LK 9/25/2023 19:02:11'!
ERROR!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'LK 9/25/2023 19:02:11'!
ERROR!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 19:02:32' prior: 50677201!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(self direccionEnRango: direccionTiro) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(self direccionEnRango: direccionArquero) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	(pelota tipo = #Jabulani) ifTrue: [
		
		(arquero tipo = #EsperaYAdelanta) ifTrue: [
				((direccionTiro) x = (direccionArquero) x & 
				(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro))
				 	ifTrue: [self sumarPuntoArquero].
					
				(direccionTiro = direccionArquero & 
				self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro) 
					ifTrue: [self sumarPuntoDelantero].
					
			].
		(arquero tipo = #Elige) ifTrue: [
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro ))
					ifTrue: [self sumarPuntoArquero].
			
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro )) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
		].
	(pelota = #Playera) ifTrue: [].
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'LK 9/25/2023 19:02:33'!
ERROR!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'LK 9/25/2023 19:02:33'!
ERROR!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 19:04:19' prior: 50677457!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(self direccionEnRango: direccionTiro) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(self direccionEnRango: direccionArquero) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	(pelota tipo = #Jabulani) ifTrue: [
		
		(arquero tipo = #EsperaYAdelanta) ifTrue: [
				((direccionTiro x = direccionArquero x) & 
				(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro))
				 	ifTrue: [self sumarPuntoArquero].
					
				(direccionTiro = direccionArquero & 
				self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro) 
					ifTrue: [self sumarPuntoDelantero].
					
			].
		(arquero tipo = #Elige) ifTrue: [
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro ))
					ifTrue: [self sumarPuntoArquero].
			
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro )) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
		].
	(pelota = #Playera) ifTrue: [].
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra stamp: 'LK 9/25/2023 19:04:20'!
PASSED!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'LK 9/25/2023 19:04:25'!
ERROR!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'LK 9/25/2023 19:04:25'!
ERROR!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'LK 9/25/2023 19:05:30'!
ERROR!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'LK 9/25/2023 19:05:30'!
ERROR!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 19:05:57' prior: 50677570!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(self direccionEnRango: direccionTiro) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(self direccionEnRango: direccionArquero) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	(pelota tipo = #Jabulani) ifTrue: [
		
		(arquero tipo = #EsperaYAdelanta) ifTrue: [
				((direccionTiro) x = (direccionArquero) x) & 
				(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro)
				 	ifTrue: [self sumarPuntoArquero].
					
				(direccionTiro = direccionArquero) & 
				(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro) 
					ifTrue: [self sumarPuntoDelantero].
					
			].
		(arquero tipo = #Elige) ifTrue: [
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro ))
					ifTrue: [self sumarPuntoArquero].
			
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro )) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
		].
	(pelota = #Playera) ifTrue: [].
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'LK 9/25/2023 19:05:59'!
PASSED!

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'LK 9/25/2023 19:06:02'!
PASSED!

!testRun: #PenalesTest #test02DelanteroNoPuedeApuntarHaciaAfueraDelPaloDerecho stamp: 'LK 9/25/2023 19:06:02'!
PASSED!

!testRun: #PenalesTest #test03DelanteroNoPuedeApuntarHaciaAbajoDelArco stamp: 'LK 9/25/2023 19:06:02'!
PASSED!

!testRun: #PenalesTest #test04DelanteroNoPuedeApuntarHaciaArribaDelTravesaño stamp: 'LK 9/25/2023 19:06:02'!
PASSED!

!testRun: #PenalesTest #test05ArqueroNoPuedePasarseDelPaloIzquierdo stamp: 'LK 9/25/2023 19:06:02'!
PASSED!

!testRun: #PenalesTest #test06ArqueroNoPuedePasarseDelPaloDerecho stamp: 'LK 9/25/2023 19:06:02'!
PASSED!

!testRun: #PenalesTest #test07ArqueroNoPuedeMeterseAbajoDeLaTierra stamp: 'LK 9/25/2023 19:06:02'!
PASSED!

!testRun: #PenalesTest #test08ArqueroNoPuedeSaltarPorEncimaDelTravesaño stamp: 'LK 9/25/2023 19:06:02'!
PASSED!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'LK 9/25/2023 19:06:02'!
PASSED!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'LK 9/25/2023 19:06:02'!
PASSED!

!testRun: #PenalesTest #test11MismasDireccionesSuficienteFuerzaAtajaArquero stamp: 'LK 9/25/2023 19:06:02'!
PASSED!

!testRun: #PenalesTest #test12DelanteroQueTiraAColocarPierde50PorcFuerza stamp: 'LK 9/25/2023 19:06:02'!
PASSED!

!testRun: #PenalesTest #test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra stamp: 'LK 9/25/2023 19:06:02'!
PASSED!

!testRun: #PenalesTest #test14FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAColocar stamp: 'LK 9/25/2023 19:06:02'!
PASSED!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'LK 9/25/2023 19:06:02'!
FAILURE!

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'LK 9/25/2023 19:06:02'!
FAILURE!

!testRun: #PenalesTest #test17ArqueroQueEligeAntesDeTiroVsPlayeraAColocarSuma100PorcFuerzaExtra stamp: 'LK 9/25/2023 19:06:02'!
FAILURE!

!testRun: #PenalesTest #test18FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsPlayeraAColocar stamp: 'LK 9/25/2023 19:06:02'!
FAILURE!

!testRun: #PenalesTest #test19ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAColocarEsDescubiertoYPuntoParaDelantero stamp: 'LK 9/25/2023 19:06:02'!
FAILURE!

!testRun: #PenalesTest #test20DelanteroTiraAMatarAlAnguloInferiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:06:02'!
ERROR!

!testRun: #PenalesTest #test21DelanteroTiraAMatarAlAnguloSuperiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:06:02'!
ERROR!

!testRun: #PenalesTest #test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:06:02'!
ERROR!

!testRun: #PenalesTest #test23DelanteroTiraAMatarAlAnguloSuperiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:06:02'!
ERROR!

!testRun: #PenalesTest #test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro stamp: 'LK 9/25/2023 19:06:02'!
ERROR!

!testRun: #PenalesTest #test25DelanteroTiraAMatarUsa100PorcFuerzaBase stamp: 'LK 9/25/2023 19:06:02'!
ERROR!

!testRun: #PenalesTest #test26DelanteroTiraAMatarConJabulaniGana20PorcFuerzaExtra stamp: 'LK 9/25/2023 19:06:02'!
ERROR!

!testRun: #PenalesTest #test27FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAMatar stamp: 'LK 9/25/2023 19:06:02'!
ERROR!

!testRun: #PenalesTest #test28ArqueroQueEligeAntesDeTiroVsJabulaniAMatarIgnoraAlturaTiro stamp: 'LK 9/25/2023 19:06:02'!
ERROR!

!testRun: #PenalesTest #test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja stamp: 'LK 9/25/2023 19:06:02'!
ERROR!

!testRun: #PenalesTest #test30DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAdentro stamp: 'LK 9/25/2023 19:06:02'!
ERROR!

!testRun: #PenalesTest #test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera stamp: 'LK 9/25/2023 19:06:03'!
ERROR!

!testRun: #PenalesTest #test32ArqueroQueEligeAntesDeTiroVsPlayeraAMatarAlAnguloIgnoraAnchoTiro stamp: 'LK 9/25/2023 19:06:03'!
ERROR!

!testRun: #PenalesTest #test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro stamp: 'LK 9/25/2023 19:06:03'!
ERROR!

!testRun: #PenalesTest #test34ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAMatarSiempreAtaja stamp: 'LK 9/25/2023 19:06:03'!
ERROR!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 19:06:54' prior: 50677694!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(self direccionEnRango: direccionTiro) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(self direccionEnRango: direccionArquero) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	(pelota tipo = #Jabulani) ifTrue: [
		
		(arquero tipo = #EsperaYAdelanta) ifTrue: [
				(((direccionTiro) x = (direccionArquero) x )& 
				(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro))
				 	ifTrue: [self sumarPuntoArquero].
					
				(direccionTiro = direccionArquero) & 
				(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro) 
					ifTrue: [self sumarPuntoDelantero].
					
			].
		(arquero tipo = #Elige) ifTrue: [
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro ))
					ifTrue: [self sumarPuntoArquero].
			
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro )) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
		].
	(pelota = #Playera) ifTrue: [].
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'LK 9/25/2023 19:06:55'!
FAILURE!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'LK 9/25/2023 19:06:55'!
FAILURE!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'LK 9/25/2023 19:07:11'!
FAILURE!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 19:08:20' prior: 50677940!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(self direccionEnRango: direccionTiro) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(self direccionEnRango: direccionArquero) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	(pelota tipo = #Jabulani) ifTrue: [
		
		(arquero tipo = #EsperaYAdelanta) ifTrue: [
				(((direccionTiro) x = (direccionArquero) x )& 
				(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro))
				 	ifTrue: [self sumarPuntoArquero].
					
				(direccionTiro = direccionArquero) & 
				(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro) 
					ifTrue: [self sumarPuntoDelantero].
					
			].
		
		(arquero tipo = #Elige) ifTrue: [
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro ))
					ifTrue: [self sumarPuntoArquero].
			
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro )) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
		].
	(pelota = #Playera) ifTrue: [].
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 19:08:23' prior: 50678060!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(self direccionEnRango: direccionTiro) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(self direccionEnRango: direccionArquero) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	(pelota tipo = #Jabulani) ifTrue: [
		
		(arquero tipo = #EsperaYAdelanta) ifTrue: [
				(((direccionTiro) x = (direccionArquero) x)& 
				(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro))
				 	ifTrue: [self sumarPuntoArquero].
					
				(direccionTiro = direccionArquero) & 
				(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro) 
					ifTrue: [self sumarPuntoDelantero].
					
			].
		
		(arquero tipo = #Elige) ifTrue: [
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro ))
					ifTrue: [self sumarPuntoArquero].
			
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro )) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
		].
	(pelota = #Playera) ifTrue: [].
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'LK 9/25/2023 19:08:25'!
FAILURE!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'LK 9/25/2023 19:08:25'!
FAILURE!

((0@2) x = (0@3) x)!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 19:09:41' prior: 50678167!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(self direccionEnRango: direccionTiro) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(self direccionEnRango: direccionArquero) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	(pelota tipo = #Jabulani) ifTrue: [
		
		(arquero tipo = #EsperaYAdelanta) ifTrue: [
				((direccionTiro) x = (direccionArquero x) & 
				self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro)
				 	ifTrue: [self sumarPuntoArquero].
					
				(direccionTiro = direccionArquero) & 
				(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro) 
					ifTrue: [self sumarPuntoDelantero].
					
			].
		
		(arquero tipo = #Elige) ifTrue: [
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro ))
					ifTrue: [self sumarPuntoArquero].
			
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro )) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
		].
	(pelota = #Playera) ifTrue: [].
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'LK 9/25/2023 19:09:43'!
FAILURE!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'LK 9/25/2023 19:09:43'!
FAILURE!

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'LK 9/25/2023 19:10:21'!
PASSED!

!testRun: #PenalesTest #test02DelanteroNoPuedeApuntarHaciaAfueraDelPaloDerecho stamp: 'LK 9/25/2023 19:10:21'!
PASSED!

!testRun: #PenalesTest #test03DelanteroNoPuedeApuntarHaciaAbajoDelArco stamp: 'LK 9/25/2023 19:10:22'!
PASSED!

!testRun: #PenalesTest #test04DelanteroNoPuedeApuntarHaciaArribaDelTravesaño stamp: 'LK 9/25/2023 19:10:22'!
PASSED!

!testRun: #PenalesTest #test05ArqueroNoPuedePasarseDelPaloIzquierdo stamp: 'LK 9/25/2023 19:10:22'!
PASSED!

!testRun: #PenalesTest #test06ArqueroNoPuedePasarseDelPaloDerecho stamp: 'LK 9/25/2023 19:10:22'!
PASSED!

!testRun: #PenalesTest #test07ArqueroNoPuedeMeterseAbajoDeLaTierra stamp: 'LK 9/25/2023 19:10:22'!
PASSED!

!testRun: #PenalesTest #test08ArqueroNoPuedeSaltarPorEncimaDelTravesaño stamp: 'LK 9/25/2023 19:10:22'!
PASSED!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'LK 9/25/2023 19:10:22'!
ERROR!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'LK 9/25/2023 19:10:22'!
PASSED!

!testRun: #PenalesTest #test11MismasDireccionesSuficienteFuerzaAtajaArquero stamp: 'LK 9/25/2023 19:10:22'!
PASSED!

!testRun: #PenalesTest #test12DelanteroQueTiraAColocarPierde50PorcFuerza stamp: 'LK 9/25/2023 19:10:22'!
PASSED!

!testRun: #PenalesTest #test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra stamp: 'LK 9/25/2023 19:10:22'!
PASSED!

!testRun: #PenalesTest #test14FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAColocar stamp: 'LK 9/25/2023 19:10:22'!
PASSED!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'LK 9/25/2023 19:10:22'!
FAILURE!

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'LK 9/25/2023 19:10:22'!
FAILURE!

!testRun: #PenalesTest #test17ArqueroQueEligeAntesDeTiroVsPlayeraAColocarSuma100PorcFuerzaExtra stamp: 'LK 9/25/2023 19:10:22'!
FAILURE!

!testRun: #PenalesTest #test18FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsPlayeraAColocar stamp: 'LK 9/25/2023 19:10:22'!
FAILURE!

!testRun: #PenalesTest #test19ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAColocarEsDescubiertoYPuntoParaDelantero stamp: 'LK 9/25/2023 19:10:22'!
FAILURE!

!testRun: #PenalesTest #test20DelanteroTiraAMatarAlAnguloInferiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:10:22'!
ERROR!

!testRun: #PenalesTest #test21DelanteroTiraAMatarAlAnguloSuperiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:10:22'!
ERROR!

!testRun: #PenalesTest #test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:10:22'!
ERROR!

!testRun: #PenalesTest #test23DelanteroTiraAMatarAlAnguloSuperiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:10:22'!
ERROR!

!testRun: #PenalesTest #test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro stamp: 'LK 9/25/2023 19:10:22'!
ERROR!

!testRun: #PenalesTest #test25DelanteroTiraAMatarUsa100PorcFuerzaBase stamp: 'LK 9/25/2023 19:10:22'!
ERROR!

!testRun: #PenalesTest #test26DelanteroTiraAMatarConJabulaniGana20PorcFuerzaExtra stamp: 'LK 9/25/2023 19:10:22'!
ERROR!

!testRun: #PenalesTest #test27FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAMatar stamp: 'LK 9/25/2023 19:10:22'!
ERROR!

!testRun: #PenalesTest #test28ArqueroQueEligeAntesDeTiroVsJabulaniAMatarIgnoraAlturaTiro stamp: 'LK 9/25/2023 19:10:22'!
ERROR!

!testRun: #PenalesTest #test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja stamp: 'LK 9/25/2023 19:10:22'!
ERROR!

!testRun: #PenalesTest #test30DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAdentro stamp: 'LK 9/25/2023 19:10:22'!
ERROR!

!testRun: #PenalesTest #test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera stamp: 'LK 9/25/2023 19:10:22'!
ERROR!

!testRun: #PenalesTest #test32ArqueroQueEligeAntesDeTiroVsPlayeraAMatarAlAnguloIgnoraAnchoTiro stamp: 'LK 9/25/2023 19:10:22'!
ERROR!

!testRun: #PenalesTest #test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro stamp: 'LK 9/25/2023 19:10:22'!
ERROR!

!testRun: #PenalesTest #test34ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAMatarSiempreAtaja stamp: 'LK 9/25/2023 19:10:22'!
ERROR!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'LK 9/25/2023 19:10:28'!
ERROR!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'LK 9/25/2023 19:10:28'!
ERROR!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 19:12:28' prior: 50678283!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(self direccionEnRango: direccionTiro) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(self direccionEnRango: direccionArquero) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	(pelota tipo = #Jabulani) ifTrue: [
		
		(arquero tipo = #EsperaYAdelanta) ifTrue: [
				((direccionTiro) x = (direccionArquero x) & 
				self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro)
				 	ifTrue: [self sumarPuntoArquero].
					
				(direccionTiro = direccionArquero) & 
				(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro) 
					ifTrue: [self sumarPuntoDelantero].
					
			].
		
		(arquero tipo = #Elige) ifTrue: [
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro ))
					ifTrue: [self sumarPuntoArquero].
			
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro )) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
		].
	(pelota = #Playera) ifTrue: [].
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!classDefinition: #Penales category: 'ISW1-2023-2C-Parcial-1' stamp: 'LK 9/25/2023 19:15:15'!
Object subclass: #Penales
	instanceVariableNames: 'puntajeDelantero puntajeArquero direccionDelTiroDelantero direccionDelArquero delantero arquero penalPelota'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 19:15:13' prior: 50678541!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(self direccionEnRango: direccionTiro) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(self direccionEnRango: direccionArquero) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	(pelota tipo = #Jabulani) ifTrue: [
			penalPelota := #Jabulani.
		
		(arquero tipo = #EsperaYAdelanta) ifTrue: [
				((direccionTiro) x = (direccionArquero x) & 
				self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro)
				 	ifTrue: [self sumarPuntoArquero].
					
				(direccionTiro = direccionArquero) & 
				(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro) 
					ifTrue: [self sumarPuntoDelantero].
					
			].
		
		(arquero tipo = #Elige) ifTrue: [
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro ))
					ifTrue: [self sumarPuntoArquero].
			
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro )) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
		].
	(pelota = #Playera) ifTrue: [penalPelota := #Playera].
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 19:15:55' prior: 50675761!
varFuerzaResultanteDeTiro
	(penalPelota := #Playera) ifTrue: [^delantero fuerza * 0.8].
	^ delantero fuerza! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 19:17:00' prior: 50678658!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(self direccionEnRango: direccionTiro) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(self direccionEnRango: direccionArquero) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	(pelota tipo = #Jabulani) ifTrue: [
			penalPelota := #Jabulani.
		
		(arquero tipo = #EsperaYAdelanta) ifTrue: [
				((direccionTiro) x = (direccionArquero x) & 
				self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro)
				 	ifTrue: [self sumarPuntoArquero].
					
				(direccionTiro = direccionArquero) & 
				(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro) 
					ifTrue: [self sumarPuntoDelantero].
					
			].
		
		(arquero tipo = #Elige) ifTrue: [
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro ))
					ifTrue: [self sumarPuntoArquero].
			
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro )) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
		].
	(pelota = #Playera) ifTrue: [
			
			penalPelota := #Playera.
		
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro ))
					ifTrue: [self sumarPuntoArquero].
			
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro )) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'LK 9/25/2023 19:17:02'!
FAILURE!

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'LK 9/25/2023 19:20:09'!
FAILURE!

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'LK 9/25/2023 19:20:09'!
FAILURE!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 19:25:17' prior: 50674656!
initializeConDelantero: unDelantero yArquero: unArquero

	delantero := unDelantero.
	arquero :=  unArquero.
	puntajeDelantero := 0.
	puntajeArquero := 0.! !

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'LK 9/25/2023 19:26:43'!
PASSED!

!testRun: #PenalesTest #test02DelanteroNoPuedeApuntarHaciaAfueraDelPaloDerecho stamp: 'LK 9/25/2023 19:26:43'!
PASSED!

!testRun: #PenalesTest #test03DelanteroNoPuedeApuntarHaciaAbajoDelArco stamp: 'LK 9/25/2023 19:26:43'!
PASSED!

!testRun: #PenalesTest #test04DelanteroNoPuedeApuntarHaciaArribaDelTravesaño stamp: 'LK 9/25/2023 19:26:43'!
PASSED!

!testRun: #PenalesTest #test05ArqueroNoPuedePasarseDelPaloIzquierdo stamp: 'LK 9/25/2023 19:26:43'!
PASSED!

!testRun: #PenalesTest #test06ArqueroNoPuedePasarseDelPaloDerecho stamp: 'LK 9/25/2023 19:26:43'!
PASSED!

!testRun: #PenalesTest #test07ArqueroNoPuedeMeterseAbajoDeLaTierra stamp: 'LK 9/25/2023 19:26:43'!
PASSED!

!testRun: #PenalesTest #test08ArqueroNoPuedeSaltarPorEncimaDelTravesaño stamp: 'LK 9/25/2023 19:26:43'!
PASSED!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'LK 9/25/2023 19:26:43'!
ERROR!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'LK 9/25/2023 19:26:43'!
ERROR!

!testRun: #PenalesTest #test11MismasDireccionesSuficienteFuerzaAtajaArquero stamp: 'LK 9/25/2023 19:26:43'!
ERROR!

!testRun: #PenalesTest #test12DelanteroQueTiraAColocarPierde50PorcFuerza stamp: 'LK 9/25/2023 19:26:43'!
ERROR!

!testRun: #PenalesTest #test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra stamp: 'LK 9/25/2023 19:26:43'!
ERROR!

!testRun: #PenalesTest #test14FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAColocar stamp: 'LK 9/25/2023 19:26:43'!
ERROR!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'LK 9/25/2023 19:26:43'!
ERROR!

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'LK 9/25/2023 19:26:43'!
FAILURE!

!testRun: #PenalesTest #test17ArqueroQueEligeAntesDeTiroVsPlayeraAColocarSuma100PorcFuerzaExtra stamp: 'LK 9/25/2023 19:26:43'!
FAILURE!

!testRun: #PenalesTest #test18FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsPlayeraAColocar stamp: 'LK 9/25/2023 19:26:43'!
FAILURE!

!testRun: #PenalesTest #test19ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAColocarEsDescubiertoYPuntoParaDelantero stamp: 'LK 9/25/2023 19:26:43'!
FAILURE!

!testRun: #PenalesTest #test20DelanteroTiraAMatarAlAnguloInferiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:26:43'!
ERROR!

!testRun: #PenalesTest #test21DelanteroTiraAMatarAlAnguloSuperiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:26:43'!
ERROR!

!testRun: #PenalesTest #test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:26:43'!
ERROR!

!testRun: #PenalesTest #test23DelanteroTiraAMatarAlAnguloSuperiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:26:43'!
ERROR!

!testRun: #PenalesTest #test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro stamp: 'LK 9/25/2023 19:26:43'!
ERROR!

!testRun: #PenalesTest #test25DelanteroTiraAMatarUsa100PorcFuerzaBase stamp: 'LK 9/25/2023 19:26:43'!
ERROR!

!testRun: #PenalesTest #test26DelanteroTiraAMatarConJabulaniGana20PorcFuerzaExtra stamp: 'LK 9/25/2023 19:26:43'!
ERROR!

!testRun: #PenalesTest #test27FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAMatar stamp: 'LK 9/25/2023 19:26:43'!
ERROR!

!testRun: #PenalesTest #test28ArqueroQueEligeAntesDeTiroVsJabulaniAMatarIgnoraAlturaTiro stamp: 'LK 9/25/2023 19:26:43'!
ERROR!

!testRun: #PenalesTest #test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja stamp: 'LK 9/25/2023 19:26:43'!
ERROR!

!testRun: #PenalesTest #test30DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAdentro stamp: 'LK 9/25/2023 19:26:43'!
ERROR!

!testRun: #PenalesTest #test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera stamp: 'LK 9/25/2023 19:26:43'!
ERROR!

!testRun: #PenalesTest #test32ArqueroQueEligeAntesDeTiroVsPlayeraAMatarAlAnguloIgnoraAnchoTiro stamp: 'LK 9/25/2023 19:26:43'!
ERROR!

!testRun: #PenalesTest #test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro stamp: 'LK 9/25/2023 19:26:43'!
ERROR!

!testRun: #PenalesTest #test34ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAMatarSiempreAtaja stamp: 'LK 9/25/2023 19:26:43'!
ERROR!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'LK 9/25/2023 19:27:43'!
ERROR!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'LK 9/25/2023 19:27:43'!
ERROR!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 19:27:56' prior: 50678766!
varFuerzaResultanteDeTiro
	(penalPelota = #Playera) ifTrue: [^delantero fuerza * 0.8].
	^ delantero fuerza! !

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'LK 9/25/2023 19:27:59'!
PASSED!

!testRun: #PenalesTest #test02DelanteroNoPuedeApuntarHaciaAfueraDelPaloDerecho stamp: 'LK 9/25/2023 19:27:59'!
PASSED!

!testRun: #PenalesTest #test03DelanteroNoPuedeApuntarHaciaAbajoDelArco stamp: 'LK 9/25/2023 19:27:59'!
PASSED!

!testRun: #PenalesTest #test04DelanteroNoPuedeApuntarHaciaArribaDelTravesaño stamp: 'LK 9/25/2023 19:27:59'!
PASSED!

!testRun: #PenalesTest #test05ArqueroNoPuedePasarseDelPaloIzquierdo stamp: 'LK 9/25/2023 19:27:59'!
PASSED!

!testRun: #PenalesTest #test06ArqueroNoPuedePasarseDelPaloDerecho stamp: 'LK 9/25/2023 19:27:59'!
PASSED!

!testRun: #PenalesTest #test07ArqueroNoPuedeMeterseAbajoDeLaTierra stamp: 'LK 9/25/2023 19:27:59'!
PASSED!

!testRun: #PenalesTest #test08ArqueroNoPuedeSaltarPorEncimaDelTravesaño stamp: 'LK 9/25/2023 19:27:59'!
PASSED!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'LK 9/25/2023 19:27:59'!
ERROR!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'LK 9/25/2023 19:27:59'!
PASSED!

!testRun: #PenalesTest #test11MismasDireccionesSuficienteFuerzaAtajaArquero stamp: 'LK 9/25/2023 19:27:59'!
PASSED!

!testRun: #PenalesTest #test12DelanteroQueTiraAColocarPierde50PorcFuerza stamp: 'LK 9/25/2023 19:27:59'!
PASSED!

!testRun: #PenalesTest #test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra stamp: 'LK 9/25/2023 19:27:59'!
PASSED!

!testRun: #PenalesTest #test14FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAColocar stamp: 'LK 9/25/2023 19:27:59'!
PASSED!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'LK 9/25/2023 19:27:59'!
FAILURE!

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'LK 9/25/2023 19:27:59'!
FAILURE!

!testRun: #PenalesTest #test17ArqueroQueEligeAntesDeTiroVsPlayeraAColocarSuma100PorcFuerzaExtra stamp: 'LK 9/25/2023 19:27:59'!
FAILURE!

!testRun: #PenalesTest #test18FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsPlayeraAColocar stamp: 'LK 9/25/2023 19:27:59'!
FAILURE!

!testRun: #PenalesTest #test19ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAColocarEsDescubiertoYPuntoParaDelantero stamp: 'LK 9/25/2023 19:27:59'!
FAILURE!

!testRun: #PenalesTest #test20DelanteroTiraAMatarAlAnguloInferiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:27:59'!
ERROR!

!testRun: #PenalesTest #test21DelanteroTiraAMatarAlAnguloSuperiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:27:59'!
ERROR!

!testRun: #PenalesTest #test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:27:59'!
ERROR!

!testRun: #PenalesTest #test23DelanteroTiraAMatarAlAnguloSuperiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:27:59'!
ERROR!

!testRun: #PenalesTest #test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro stamp: 'LK 9/25/2023 19:27:59'!
ERROR!

!testRun: #PenalesTest #test25DelanteroTiraAMatarUsa100PorcFuerzaBase stamp: 'LK 9/25/2023 19:27:59'!
ERROR!

!testRun: #PenalesTest #test26DelanteroTiraAMatarConJabulaniGana20PorcFuerzaExtra stamp: 'LK 9/25/2023 19:27:59'!
ERROR!

!testRun: #PenalesTest #test27FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAMatar stamp: 'LK 9/25/2023 19:27:59'!
ERROR!

!testRun: #PenalesTest #test28ArqueroQueEligeAntesDeTiroVsJabulaniAMatarIgnoraAlturaTiro stamp: 'LK 9/25/2023 19:27:59'!
ERROR!

!testRun: #PenalesTest #test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja stamp: 'LK 9/25/2023 19:27:59'!
ERROR!

!testRun: #PenalesTest #test30DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAdentro stamp: 'LK 9/25/2023 19:27:59'!
ERROR!

!testRun: #PenalesTest #test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera stamp: 'LK 9/25/2023 19:27:59'!
ERROR!

!testRun: #PenalesTest #test32ArqueroQueEligeAntesDeTiroVsPlayeraAMatarAlAnguloIgnoraAnchoTiro stamp: 'LK 9/25/2023 19:27:59'!
ERROR!

!testRun: #PenalesTest #test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro stamp: 'LK 9/25/2023 19:27:59'!
ERROR!

!testRun: #PenalesTest #test34ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAMatarSiempreAtaja stamp: 'LK 9/25/2023 19:27:59'!
ERROR!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'LK 9/25/2023 19:28:02'!
ERROR!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 19:28:43' prior: 50678773!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(self direccionEnRango: direccionTiro) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(self direccionEnRango: direccionArquero) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	(pelota tipo = #Jabulani) ifTrue: [
			penalPelota := #Jabulani.
		
		(arquero tipo = #EsperaYAdelanta) ifTrue: [
				((direccionTiro) x = (direccionArquero x) & 
				(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro))
				 	ifTrue: [self sumarPuntoArquero].
					
				(direccionTiro = direccionArquero) & 
				(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro) 
					ifTrue: [self sumarPuntoDelantero].
					
			].
		
		(arquero tipo = #Elige) ifTrue: [
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro ))
					ifTrue: [self sumarPuntoArquero].
			
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro )) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
		].
	(pelota = #Playera) ifTrue: [
			
			penalPelota := #Playera.
		
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro ))
					ifTrue: [self sumarPuntoArquero].
			
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro )) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'LK 9/25/2023 19:28:44'!
PASSED!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'LK 9/25/2023 19:28:47'!
FAILURE!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'LK 9/25/2023 19:28:47'!
FAILURE!

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'LK 9/25/2023 19:28:52'!
PASSED!

!testRun: #PenalesTest #test02DelanteroNoPuedeApuntarHaciaAfueraDelPaloDerecho stamp: 'LK 9/25/2023 19:28:52'!
PASSED!

!testRun: #PenalesTest #test03DelanteroNoPuedeApuntarHaciaAbajoDelArco stamp: 'LK 9/25/2023 19:28:52'!
PASSED!

!testRun: #PenalesTest #test04DelanteroNoPuedeApuntarHaciaArribaDelTravesaño stamp: 'LK 9/25/2023 19:28:52'!
PASSED!

!testRun: #PenalesTest #test05ArqueroNoPuedePasarseDelPaloIzquierdo stamp: 'LK 9/25/2023 19:28:52'!
PASSED!

!testRun: #PenalesTest #test06ArqueroNoPuedePasarseDelPaloDerecho stamp: 'LK 9/25/2023 19:28:52'!
PASSED!

!testRun: #PenalesTest #test07ArqueroNoPuedeMeterseAbajoDeLaTierra stamp: 'LK 9/25/2023 19:28:52'!
PASSED!

!testRun: #PenalesTest #test08ArqueroNoPuedeSaltarPorEncimaDelTravesaño stamp: 'LK 9/25/2023 19:28:52'!
PASSED!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'LK 9/25/2023 19:28:52'!
PASSED!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'LK 9/25/2023 19:28:52'!
PASSED!

!testRun: #PenalesTest #test11MismasDireccionesSuficienteFuerzaAtajaArquero stamp: 'LK 9/25/2023 19:28:52'!
PASSED!

!testRun: #PenalesTest #test12DelanteroQueTiraAColocarPierde50PorcFuerza stamp: 'LK 9/25/2023 19:28:52'!
PASSED!

!testRun: #PenalesTest #test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra stamp: 'LK 9/25/2023 19:28:52'!
PASSED!

!testRun: #PenalesTest #test14FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAColocar stamp: 'LK 9/25/2023 19:28:52'!
PASSED!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'LK 9/25/2023 19:28:52'!
FAILURE!

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'LK 9/25/2023 19:28:52'!
FAILURE!

!testRun: #PenalesTest #test17ArqueroQueEligeAntesDeTiroVsPlayeraAColocarSuma100PorcFuerzaExtra stamp: 'LK 9/25/2023 19:28:52'!
FAILURE!

!testRun: #PenalesTest #test18FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsPlayeraAColocar stamp: 'LK 9/25/2023 19:28:52'!
FAILURE!

!testRun: #PenalesTest #test19ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAColocarEsDescubiertoYPuntoParaDelantero stamp: 'LK 9/25/2023 19:28:52'!
FAILURE!

!testRun: #PenalesTest #test20DelanteroTiraAMatarAlAnguloInferiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:28:52'!
ERROR!

!testRun: #PenalesTest #test21DelanteroTiraAMatarAlAnguloSuperiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:28:52'!
ERROR!

!testRun: #PenalesTest #test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:28:52'!
ERROR!

!testRun: #PenalesTest #test23DelanteroTiraAMatarAlAnguloSuperiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:28:52'!
ERROR!

!testRun: #PenalesTest #test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro stamp: 'LK 9/25/2023 19:28:52'!
ERROR!

!testRun: #PenalesTest #test25DelanteroTiraAMatarUsa100PorcFuerzaBase stamp: 'LK 9/25/2023 19:28:52'!
ERROR!

!testRun: #PenalesTest #test26DelanteroTiraAMatarConJabulaniGana20PorcFuerzaExtra stamp: 'LK 9/25/2023 19:28:52'!
ERROR!

!testRun: #PenalesTest #test27FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAMatar stamp: 'LK 9/25/2023 19:28:52'!
ERROR!

!testRun: #PenalesTest #test28ArqueroQueEligeAntesDeTiroVsJabulaniAMatarIgnoraAlturaTiro stamp: 'LK 9/25/2023 19:28:52'!
ERROR!

!testRun: #PenalesTest #test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja stamp: 'LK 9/25/2023 19:28:52'!
ERROR!

!testRun: #PenalesTest #test30DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAdentro stamp: 'LK 9/25/2023 19:28:52'!
ERROR!

!testRun: #PenalesTest #test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera stamp: 'LK 9/25/2023 19:28:52'!
ERROR!

!testRun: #PenalesTest #test32ArqueroQueEligeAntesDeTiroVsPlayeraAMatarAlAnguloIgnoraAnchoTiro stamp: 'LK 9/25/2023 19:28:52'!
ERROR!

!testRun: #PenalesTest #test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro stamp: 'LK 9/25/2023 19:28:52'!
ERROR!

!testRun: #PenalesTest #test34ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAMatarSiempreAtaja stamp: 'LK 9/25/2023 19:28:52'!
ERROR!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'LK 9/25/2023 19:28:56'!
FAILURE!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'LK 9/25/2023 19:28:56'!
FAILURE!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'LK 9/25/2023 19:30:24'!
FAILURE!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'LK 9/25/2023 19:30:24'!
FAILURE!

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'LK 9/25/2023 19:30:28'!
PASSED!

!testRun: #PenalesTest #test02DelanteroNoPuedeApuntarHaciaAfueraDelPaloDerecho stamp: 'LK 9/25/2023 19:30:28'!
PASSED!

!testRun: #PenalesTest #test03DelanteroNoPuedeApuntarHaciaAbajoDelArco stamp: 'LK 9/25/2023 19:30:28'!
PASSED!

!testRun: #PenalesTest #test04DelanteroNoPuedeApuntarHaciaArribaDelTravesaño stamp: 'LK 9/25/2023 19:30:28'!
PASSED!

!testRun: #PenalesTest #test05ArqueroNoPuedePasarseDelPaloIzquierdo stamp: 'LK 9/25/2023 19:30:28'!
PASSED!

!testRun: #PenalesTest #test06ArqueroNoPuedePasarseDelPaloDerecho stamp: 'LK 9/25/2023 19:30:28'!
PASSED!

!testRun: #PenalesTest #test07ArqueroNoPuedeMeterseAbajoDeLaTierra stamp: 'LK 9/25/2023 19:30:28'!
PASSED!

!testRun: #PenalesTest #test08ArqueroNoPuedeSaltarPorEncimaDelTravesaño stamp: 'LK 9/25/2023 19:30:28'!
PASSED!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'LK 9/25/2023 19:30:28'!
PASSED!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'LK 9/25/2023 19:30:28'!
PASSED!

!testRun: #PenalesTest #test11MismasDireccionesSuficienteFuerzaAtajaArquero stamp: 'LK 9/25/2023 19:30:28'!
PASSED!

!testRun: #PenalesTest #test12DelanteroQueTiraAColocarPierde50PorcFuerza stamp: 'LK 9/25/2023 19:30:28'!
PASSED!

!testRun: #PenalesTest #test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra stamp: 'LK 9/25/2023 19:30:28'!
PASSED!

!testRun: #PenalesTest #test14FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAColocar stamp: 'LK 9/25/2023 19:30:28'!
PASSED!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'LK 9/25/2023 19:30:28'!
FAILURE!

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'LK 9/25/2023 19:30:28'!
FAILURE!

!testRun: #PenalesTest #test17ArqueroQueEligeAntesDeTiroVsPlayeraAColocarSuma100PorcFuerzaExtra stamp: 'LK 9/25/2023 19:30:28'!
FAILURE!

!testRun: #PenalesTest #test18FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsPlayeraAColocar stamp: 'LK 9/25/2023 19:30:28'!
FAILURE!

!testRun: #PenalesTest #test19ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAColocarEsDescubiertoYPuntoParaDelantero stamp: 'LK 9/25/2023 19:30:28'!
FAILURE!

!testRun: #PenalesTest #test20DelanteroTiraAMatarAlAnguloInferiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:30:28'!
ERROR!

!testRun: #PenalesTest #test21DelanteroTiraAMatarAlAnguloSuperiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:30:28'!
ERROR!

!testRun: #PenalesTest #test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:30:28'!
ERROR!

!testRun: #PenalesTest #test23DelanteroTiraAMatarAlAnguloSuperiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:30:28'!
ERROR!

!testRun: #PenalesTest #test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro stamp: 'LK 9/25/2023 19:30:28'!
ERROR!

!testRun: #PenalesTest #test25DelanteroTiraAMatarUsa100PorcFuerzaBase stamp: 'LK 9/25/2023 19:30:28'!
ERROR!

!testRun: #PenalesTest #test26DelanteroTiraAMatarConJabulaniGana20PorcFuerzaExtra stamp: 'LK 9/25/2023 19:30:28'!
ERROR!

!testRun: #PenalesTest #test27FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAMatar stamp: 'LK 9/25/2023 19:30:28'!
ERROR!

!testRun: #PenalesTest #test28ArqueroQueEligeAntesDeTiroVsJabulaniAMatarIgnoraAlturaTiro stamp: 'LK 9/25/2023 19:30:28'!
ERROR!

!testRun: #PenalesTest #test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja stamp: 'LK 9/25/2023 19:30:28'!
ERROR!

!testRun: #PenalesTest #test30DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAdentro stamp: 'LK 9/25/2023 19:30:28'!
ERROR!

!testRun: #PenalesTest #test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera stamp: 'LK 9/25/2023 19:30:28'!
ERROR!

!testRun: #PenalesTest #test32ArqueroQueEligeAntesDeTiroVsPlayeraAMatarAlAnguloIgnoraAnchoTiro stamp: 'LK 9/25/2023 19:30:28'!
ERROR!

!testRun: #PenalesTest #test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro stamp: 'LK 9/25/2023 19:30:28'!
ERROR!

!testRun: #PenalesTest #test34ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAMatarSiempreAtaja stamp: 'LK 9/25/2023 19:30:28'!
ERROR!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 19:31:11' prior: 50679202!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(self direccionEnRango: direccionTiro) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(self direccionEnRango: direccionArquero) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	(pelota tipo = #Jabulani) ifTrue: [
			penalPelota := #Jabulani.
		
		(arquero tipo = #EsperaYAdelanta) ifTrue: [
				((direccionTiro) x = (direccionArquero x) & 
				(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro))
				 	ifTrue: [self sumarPuntoArquero]]
					
				ifFalse: [(direccionTiro = direccionArquero) & 
				(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro) 
					ifTrue: [self sumarPuntoDelantero].
					
			].
		
		(arquero tipo = #Elige) ifTrue: [
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro ))
					ifTrue: [self sumarPuntoArquero].
			
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro )) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
		].
	(pelota = #Playera) ifTrue: [
			
			penalPelota := #Playera.
		
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro ))
					ifTrue: [self sumarPuntoArquero].
			
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro )) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 19:31:48' prior: 50679056!
varFuerzaResultanteDeTiro

	(penalPelota = #Playera) ifTrue: [^delantero fuerza * 4/5].
	^ delantero fuerza! !

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'LK 9/25/2023 19:32:28'!
FAILURE!

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'LK 9/25/2023 19:32:28'!
FAILURE!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 19:33:32' prior: 50679622!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(self direccionEnRango: direccionTiro) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(self direccionEnRango: direccionArquero) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	(pelota tipo = #Jabulani) ifTrue: [
			penalPelota := #Jabulani.
		
		(arquero tipo = #EsperaYAdelanta) ifTrue: [
				((direccionTiro) x = (direccionArquero x) & 
				(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro))
				 	ifTrue: [self sumarPuntoArquero]]
					
				ifFalse: [(direccionTiro = direccionArquero) & 
				(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro) 
					ifTrue: [self sumarPuntoDelantero].
					
			].
		
		(arquero tipo = #Elige) ifTrue: [
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro ))
					ifTrue: [self sumarPuntoArquero].
			
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro )) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
		].
	(pelota = #Playera) ifTrue: [
			
			penalPelota := #Playera.
		
			(direccionTiro = direccionArquero & 
			self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro)
					ifTrue: [self sumarPuntoArquero].
			
			(direccionTiro = direccionArquero & 
			self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'LK 9/25/2023 19:33:35'!
FAILURE!

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'LK 9/25/2023 19:33:35'!
FAILURE!

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'LK 9/25/2023 19:34:42'!
PASSED!

!testRun: #PenalesTest #test02DelanteroNoPuedeApuntarHaciaAfueraDelPaloDerecho stamp: 'LK 9/25/2023 19:34:43'!
PASSED!

!testRun: #PenalesTest #test03DelanteroNoPuedeApuntarHaciaAbajoDelArco stamp: 'LK 9/25/2023 19:34:43'!
PASSED!

!testRun: #PenalesTest #test04DelanteroNoPuedeApuntarHaciaArribaDelTravesaño stamp: 'LK 9/25/2023 19:34:43'!
PASSED!

!testRun: #PenalesTest #test05ArqueroNoPuedePasarseDelPaloIzquierdo stamp: 'LK 9/25/2023 19:34:43'!
PASSED!

!testRun: #PenalesTest #test06ArqueroNoPuedePasarseDelPaloDerecho stamp: 'LK 9/25/2023 19:34:43'!
PASSED!

!testRun: #PenalesTest #test07ArqueroNoPuedeMeterseAbajoDeLaTierra stamp: 'LK 9/25/2023 19:34:43'!
PASSED!

!testRun: #PenalesTest #test08ArqueroNoPuedeSaltarPorEncimaDelTravesaño stamp: 'LK 9/25/2023 19:34:43'!
PASSED!

!testRun: #PenalesTest #test09DireccionesDiferentesGolDelantero stamp: 'LK 9/25/2023 19:34:43'!
PASSED!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'LK 9/25/2023 19:34:43'!
FAILURE!

!testRun: #PenalesTest #test11MismasDireccionesSuficienteFuerzaAtajaArquero stamp: 'LK 9/25/2023 19:34:43'!
PASSED!

!testRun: #PenalesTest #test12DelanteroQueTiraAColocarPierde50PorcFuerza stamp: 'LK 9/25/2023 19:34:43'!
PASSED!

!testRun: #PenalesTest #test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra stamp: 'LK 9/25/2023 19:34:43'!
PASSED!

!testRun: #PenalesTest #test14FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAColocar stamp: 'LK 9/25/2023 19:34:43'!
FAILURE!

!testRun: #PenalesTest #test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro stamp: 'LK 9/25/2023 19:34:43'!
FAILURE!

!testRun: #PenalesTest #test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero stamp: 'LK 9/25/2023 19:34:43'!
FAILURE!

!testRun: #PenalesTest #test17ArqueroQueEligeAntesDeTiroVsPlayeraAColocarSuma100PorcFuerzaExtra stamp: 'LK 9/25/2023 19:34:43'!
FAILURE!

!testRun: #PenalesTest #test18FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsPlayeraAColocar stamp: 'LK 9/25/2023 19:34:43'!
FAILURE!

!testRun: #PenalesTest #test19ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAColocarEsDescubiertoYPuntoParaDelantero stamp: 'LK 9/25/2023 19:34:43'!
FAILURE!

!testRun: #PenalesTest #test20DelanteroTiraAMatarAlAnguloInferiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:34:43'!
ERROR!

!testRun: #PenalesTest #test21DelanteroTiraAMatarAlAnguloSuperiorIzquierdoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:34:43'!
ERROR!

!testRun: #PenalesTest #test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:34:43'!
ERROR!

!testRun: #PenalesTest #test23DelanteroTiraAMatarAlAnguloSuperiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:34:43'!
ERROR!

!testRun: #PenalesTest #test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro stamp: 'LK 9/25/2023 19:34:43'!
ERROR!

!testRun: #PenalesTest #test25DelanteroTiraAMatarUsa100PorcFuerzaBase stamp: 'LK 9/25/2023 19:34:43'!
ERROR!

!testRun: #PenalesTest #test26DelanteroTiraAMatarConJabulaniGana20PorcFuerzaExtra stamp: 'LK 9/25/2023 19:34:43'!
ERROR!

!testRun: #PenalesTest #test27FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAMatar stamp: 'LK 9/25/2023 19:34:43'!
ERROR!

!testRun: #PenalesTest #test28ArqueroQueEligeAntesDeTiroVsJabulaniAMatarIgnoraAlturaTiro stamp: 'LK 9/25/2023 19:34:43'!
ERROR!

!testRun: #PenalesTest #test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja stamp: 'LK 9/25/2023 19:34:43'!
ERROR!

!testRun: #PenalesTest #test30DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAdentro stamp: 'LK 9/25/2023 19:34:43'!
ERROR!

!testRun: #PenalesTest #test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera stamp: 'LK 9/25/2023 19:34:43'!
ERROR!

!testRun: #PenalesTest #test32ArqueroQueEligeAntesDeTiroVsPlayeraAMatarAlAnguloIgnoraAnchoTiro stamp: 'LK 9/25/2023 19:34:43'!
ERROR!

!testRun: #PenalesTest #test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro stamp: 'LK 9/25/2023 19:34:43'!
ERROR!

!testRun: #PenalesTest #test34ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAMatarSiempreAtaja stamp: 'LK 9/25/2023 19:34:43'!
ERROR!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'LK 9/25/2023 19:34:52'!
FAILURE!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'LK 9/25/2023 19:35:03'!
FAILURE!

!testRun: #PenalesTest #test10MismasDireccionesInsuficienteFuerzaGolDelantero stamp: 'LK 9/25/2023 19:35:03'!
FAILURE!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 19:36:37' prior: 50679757!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(self direccionEnRango: direccionTiro) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(self direccionEnRango: direccionArquero) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	(pelota tipo = #Jabulani) ifTrue: [
			penalPelota := #Jabulani.
		
		(arquero tipo = #EsperaYAdelanta) ifTrue: [
				((direccionTiro) x = (direccionArquero x) & 
				(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro))
				 	ifTrue: [self sumarPuntoArquero]]
					
				ifFalse: [(direccionTiro = direccionArquero) & 
				(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro) 
					ifTrue: [self sumarPuntoDelantero].
					
			].
		
		(arquero tipo = #Elige) ifTrue: [
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro ))
					ifTrue: [self sumarPuntoArquero].
			
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro )) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
		].
	(pelota = #Playera) ifTrue: [
			
			penalPelota := #Playera.
			
				
			(direccionTiro = direccionArquero & 
			self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro)
					ifTrue: [self sumarPuntoArquero].
			
			(direccionTiro = direccionArquero & 
			self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 19:37:37' prior: 50675756!
varFuerzaResultanteDeAtajada
	(penalPelota = #Playera & arquero tipo = #Elige) ifTrue: [^arquero fuerza * 2].
	^ arquero fuerza.! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 19:40:55' prior: 50680032!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(self direccionEnRango: direccionTiro) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(self direccionEnRango: direccionArquero) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	(pelota tipo = #Jabulani) ifTrue: [
			penalPelota := #Jabulani.
		
		(arquero tipo = #EsperaYAdelanta) ifTrue: [
				((direccionTiro) x = (direccionArquero x) & 
				(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro))
				 	ifTrue: [self sumarPuntoArquero]]
					
				ifFalse: [(direccionTiro = direccionArquero) & 
				(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro) 
					ifTrue: [self sumarPuntoDelantero].
					
			].
		
		(arquero tipo = #Elige) ifTrue: [
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro ))
					ifTrue: [self sumarPuntoArquero].
			
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro )) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
		].
	(pelota = #Playera) ifTrue: [
			
			penalPelota := #Playera.
			
			(arquero tipo = #Elige) ifTrue: [
				
				(direccionTiro = direccionArquero & 
				self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro)
					ifTrue: [self sumarPuntoArquero].
			
				(direccionTiro = direccionArquero & 
				self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
			(arquero tipo = #EsperaYadelanta) ifTrue: [self sumarPuntoDelantero].
				
		].
			
		
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 19:41:56' prior: 50674401!
varDireccionRemateResultante

	
	^direccionDelTiroDelantero .! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 19:42:27' prior: 50680282!
varDireccionRemateResultante

	(direccionDelTiroDelantero = 0@0) ifTrue: [^0@1.].
	^direccionDelTiroDelantero .! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 19:42:29' prior: 50680288!
varDireccionRemateResultante

	(direccionDelTiroDelantero = 0@0) ifTrue: [^0@1].
	^direccionDelTiroDelantero .! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 19:44:00' prior: 50680295!
varDireccionRemateResultante

	(direccionDelTiroDelantero = 0@0) ifTrue: [^0@1].
	(direccionDelTiroDelantero = 0@2) ifTrue: [^0@1].
	(direccionDelTiroDelantero = 2@0) ifTrue: [^2@1].
	^direccionDelTiroDelantero .! !

!testRun: #PenalesTest #test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:44:01'!
ERROR!

!testRun: #PenalesTest #test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:44:01'!
ERROR!
!Delantero class methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 19:45:07'!
decideTirarAMatarSuFuerzaBaseEs: d
	^self new initializeDecideTirarAMatarSuFuerzaBaseEs: d! !
!Delantero class methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 19:45:23' prior: 50680320!
decideTirarAMatarSuFuerzaBaseEs: fuerzaJugador
	^self new initializeDecideTirarAMatarSuFuerzaBaseEs: fuerzaJugador ! !
!Delantero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 19:45:40'!
initializeDecideTirarAMatarSuFuerzaBaseEs: fuerzaJugador
	
	tipo := #AMatar.

	fuerza := fuerzaJugador.! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 19:46:47' prior: 50680302!
varDireccionRemateResultante
	
	(delantero tipo = #AMatar) ifTrue:[
		
		(direccionDelTiroDelantero = 0@0) ifTrue: [^0@1].
		(direccionDelTiroDelantero = 0@2) ifTrue: [^0@1].
		(direccionDelTiroDelantero = 2@0) ifTrue: [^2@1].
		(direccionDelTiroDelantero = 2@2) ifTrue: [^2@1].
	].

	^direccionDelTiroDelantero .! !

!testRun: #PenalesTest #test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:46:51'!
ERROR!

!testRun: #PenalesTest #test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:46:51'!
ERROR!
!Delantero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 19:47:16'!
tipo
	^tipo.! !

!testRun: #PenalesTest #test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:47:30'!
ERROR!

!testRun: #PenalesTest #test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:47:30'!
ERROR!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 19:48:51' prior: 50680341!
varDireccionRemateResultante
	
	(delantero tipo = #AMatar) ifTrue: [
		
		(direccionDelTiroDelantero = (0@0)) ifTrue: [^0@1].
		(direccionDelTiroDelantero = (0@2)) ifTrue: [^0@1].
		(direccionDelTiroDelantero = (2@0)) ifTrue: [^2@1].
		(direccionDelTiroDelantero = (2@2)) ifTrue: [^2@1].
	].

	^direccionDelTiroDelantero .! !

!testRun: #PenalesTest #test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio stamp: 'LK 9/25/2023 19:48:53'!
PASSED!

!testRun: #PenalesTest #test25DelanteroTiraAMatarUsa100PorcFuerzaBase stamp: 'LK 9/25/2023 19:49:53'!
FAILURE!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 19:51:16' prior: 50679741!
varFuerzaResultanteDeTiro

	(penalPelota = #Playera) ifTrue: [^delantero fuerza * 4/5].
	(penalPelota = #Jabulani & delantero tipo = #AMatar) ifTrue: [^delantero fuerza * 1.2].
	^ delantero fuerza! !

!testRun: #PenalesTest #test26DelanteroTiraAMatarConJabulaniGana20PorcFuerzaExtra stamp: 'LK 9/25/2023 19:51:19'!
FAILURE!

!testRun: #PenalesTest #test26DelanteroTiraAMatarConJabulaniGana20PorcFuerzaExtra stamp: 'LK 9/25/2023 19:51:19'!
FAILURE!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 19:53:25' prior: 50680159!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(self direccionEnRango: direccionTiro) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(self direccionEnRango: direccionArquero) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	(pelota tipo = #Jabulani) ifTrue: [
			penalPelota := #Jabulani.
			
		(delantero tipo = #AMatar) ifTrue: [self sumarPuntoDelantero].
		
		(arquero tipo = #EsperaYAdelanta) ifTrue: [
				((direccionTiro) x = (direccionArquero x) & 
				(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro))
				 	ifTrue: [self sumarPuntoArquero]]
					
				ifFalse: [(direccionTiro = direccionArquero) & 
				(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro) 
					ifTrue: [self sumarPuntoDelantero].
					
			].
		
		(arquero tipo = #Elige) ifTrue: [
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro ))
					ifTrue: [self sumarPuntoArquero].
			
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro )) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
		].
	(pelota = #Playera) ifTrue: [
			
			penalPelota := #Playera.
			
			(arquero tipo = #Elige) ifTrue: [
				
				(direccionTiro = direccionArquero & 
				self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro)
					ifTrue: [self sumarPuntoArquero].
			
				(direccionTiro = direccionArquero & 
				self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
			(arquero tipo = #EsperaYadelanta) ifTrue: [self sumarPuntoDelantero].
				
		].
			
		
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

Pelota subclass: #Jabulani
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classDefinition: #Jabulani category: 'ISW1-2023-2C-Parcial-1' stamp: 'LK 9/25/2023 19:59:38'!
Pelota subclass: #Jabulani
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

Pelota subclass: #Playera
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classDefinition: #Playera category: 'ISW1-2023-2C-Parcial-1' stamp: 'LK 9/25/2023 19:59:43'!
Pelota subclass: #Playera
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

Object subclass: #Pelota
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classDefinition: #Pelota category: 'ISW1-2023-2C-Parcial-1' stamp: 'LK 9/25/2023 19:59:48'!
Object subclass: #Pelota
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!
!Playera methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:00:01' overrides: 50675917!
initializePlayeraLentaCostaAzul
	
	tipo := #Playera.! !

!methodRemoval: Pelota #initializePlayeraLentaCostaAzul stamp: 'LK 9/25/2023 20:00:01'!
initializePlayeraLentaCostaAzul
	
	tipo := #Playera.!
!Jabulani methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:00:09' overrides: 50673774!
initializeJabulaniSudafricanaRapida
	
	tipo := #Jabulani.! !

!methodRemoval: Pelota #initializeJabulaniSudafricanaRapida stamp: 'LK 9/25/2023 20:00:09'!
initializeJabulaniSudafricanaRapida
	
	tipo := #Jabulani.!

!methodRemoval: Pelota #tipo stamp: 'LK 9/25/2023 20:00:15'!
tipo
	^tipo!
!Jabulani class methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:00:36' overrides: 50673950!
jabulaniSudafricanaRapida
	^self new initializeJabulaniSudafricanaRapida! !

!methodRemoval: Pelota class #jabulaniSudafricanaRapida stamp: 'LK 9/25/2023 20:00:36'!
jabulaniSudafricanaRapida
	^self new initializeJabulaniSudafricanaRapida!
!Playera class methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:00:49' overrides: 50675912!
playeraLentaCostaAzul
	^self new initializePlayeraLentaCostaAzul! !

!methodRemoval: Pelota class #playeraLentaCostaAzul stamp: 'LK 9/25/2023 20:00:49'!
playeraLentaCostaAzul
	^self new initializePlayeraLentaCostaAzul!

Delantero subclass: #AMatar
	instanceVariableNames: 'fuerza tipo'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

Delantero subclass: #AMatar
	instanceVariableNames: 'fuerza'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

Delantero subclass: #AMatar
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classDefinition: #AMatar category: 'ISW1-2023-2C-Parcial-1' stamp: 'LK 9/25/2023 20:01:27'!
Delantero subclass: #AMatar
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

Object subclass: #Delantero
	instanceVariableNames: 'fuerza'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classDefinition: #Delantero category: 'ISW1-2023-2C-Parcial-1' stamp: 'LK 9/25/2023 20:01:31'!
Object subclass: #Delantero
	instanceVariableNames: 'fuerza'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!methodRemoval: Delantero #tipo stamp: 'LK 9/25/2023 20:01:36'!
tipo
	^tipo.!
!Delantero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:02:01' prior: 50676219!
initializeDecideTirarAColocarSuFuerzaBaseEs: fuerzaJugador

	fuerza := fuerzaJugador / 2.! !
!Delantero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:02:06' prior: 50680334!
initializeDecideTirarAMatarSuFuerzaBaseEs: fuerzaJugador
	
	fuerza := fuerzaJugador.! !

Delantero subclass: #AColocar
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classDefinition: #AColocar category: 'ISW1-2023-2C-Parcial-1' stamp: 'LK 9/25/2023 20:02:15'!
Delantero subclass: #AColocar
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!
!AColocar methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:02:37' overrides: 50680655!
initializeDecideTirarAColocarSuFuerzaBaseEs: fuerzaJugador

	fuerza := fuerzaJugador / 2.! !

!methodRemoval: Delantero #initializeDecideTirarAColocarSuFuerzaBaseEs: stamp: 'LK 9/25/2023 20:02:37'!
initializeDecideTirarAColocarSuFuerzaBaseEs: fuerzaJugador

	fuerza := fuerzaJugador / 2.!
!AMatar methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:02:49' overrides: 50680661!
initializeDecideTirarAMatarSuFuerzaBaseEs: fuerzaJugador
	
	fuerza := fuerzaJugador.! !

!methodRemoval: Delantero #initializeDecideTirarAMatarSuFuerzaBaseEs: stamp: 'LK 9/25/2023 20:02:49'!
initializeDecideTirarAMatarSuFuerzaBaseEs: fuerzaJugador
	
	fuerza := fuerzaJugador.!
!Delantero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:05:15' prior: 50673476!
fuerza
	self subclassResponsibility ! !
!AMatar methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:08:44' overrides: 50680703!
fuerza
	^fuerza * 1.2! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 20:10:46' prior: 50680415!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(self direccionEnRango: direccionTiro) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(self direccionEnRango: direccionArquero) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	(direccionTiro = direccionArquero) ifTrue: [].
	
	
	
	(pelota tipo = #Jabulani) ifTrue: [
			penalPelota := #Jabulani.
			
		(delantero tipo = #AMatar) ifTrue: [self sumarPuntoDelantero].
		
		(arquero tipo = #EsperaYAdelanta) ifTrue: [
				((direccionTiro) x = (direccionArquero x) & 
				(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro))
				 	ifTrue: [self sumarPuntoArquero]]
					
				ifFalse: [(direccionTiro = direccionArquero) & 
				(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro) 
					ifTrue: [self sumarPuntoDelantero].
					
			].
		
		(arquero tipo = #Elige) ifTrue: [
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro ))
					ifTrue: [self sumarPuntoArquero].
			
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro )) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
		].
	(pelota = #Playera) ifTrue: [
			
			penalPelota := #Playera.
			
			(arquero tipo = #Elige) ifTrue: [
				
				(direccionTiro = direccionArquero & 
				self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro)
					ifTrue: [self sumarPuntoArquero].
			
				(direccionTiro = direccionArquero & 
				self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
			(arquero tipo = #EsperaYadelanta) ifTrue: [self sumarPuntoDelantero].
				
		].
			
		
	
	
	
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 20:10:51' prior: 50680712!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(self direccionEnRango: direccionTiro) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(self direccionEnRango: direccionArquero) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	(direccionTiro = direccionArquero) ifTrue: [].
	
	(pelota tipo = #Jabulani) ifTrue: [
			penalPelota := #Jabulani.
			
		(delantero tipo = #AMatar) ifTrue: [self sumarPuntoDelantero].
		
		(arquero tipo = #EsperaYAdelanta) ifTrue: [
				((direccionTiro) x = (direccionArquero x) & 
				(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro))
				 	ifTrue: [self sumarPuntoArquero]]
					
				ifFalse: [(direccionTiro = direccionArquero) & 
				(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro) 
					ifTrue: [self sumarPuntoDelantero].
					
			].
		
		(arquero tipo = #Elige) ifTrue: [
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro ))
					ifTrue: [self sumarPuntoArquero].
			
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro )) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
		].
	(pelota = #Playera) ifTrue: [
			
			penalPelota := #Playera.
			
			(arquero tipo = #Elige) ifTrue: [
				
				(direccionTiro = direccionArquero & 
				self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro)
					ifTrue: [self sumarPuntoArquero].
			
				(direccionTiro = direccionArquero & 
				self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
			(arquero tipo = #EsperaYadelanta) ifTrue: [self sumarPuntoDelantero].
				
		].
			
		
	
	
	
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 20:14:43' prior: 50680151!
varFuerzaResultanteDeAtajada
	^penalPelota verFuerzaConFuerzaDeArquero: arquero.
	
	
"	(penalPelota = #Playera & arquero tipo = #Elige) ifTrue: [^arquero fuerza * 2].
	^ arquero fuerza."! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 20:14:58' prior: 50680966!
varFuerzaResultanteDeAtajada
	^penalPelota verFuerzaConArquero: arquero.
	
	
"	(penalPelota = #Playera & arquero tipo = #Elige) ifTrue: [^arquero fuerza * 2].
	^ arquero fuerza."! !
!Jabulani methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:15:54'!
verFuerzaConArquero: unArquero
	^unArquero fuerzaResultanteContraJabulani.! !

Arquero subclass: #EsperaYAdelanta
	instanceVariableNames: 'fuerza tipo'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

Arquero subclass: #EsperaYAdelanta
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classDefinition: #EsperaYAdelanta category: 'ISW1-2023-2C-Parcial-1' stamp: 'LK 9/25/2023 20:16:35'!
Arquero subclass: #EsperaYAdelanta
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

Arquero subclass: #Elige
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classDefinition: #Elige category: 'ISW1-2023-2C-Parcial-1' stamp: 'LK 9/25/2023 20:16:40'!
Arquero subclass: #Elige
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

Object subclass: #Arquero
	instanceVariableNames: 'fuerza'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classDefinition: #Arquero category: 'ISW1-2023-2C-Parcial-1' stamp: 'LK 9/25/2023 20:16:45'!
Object subclass: #Arquero
	instanceVariableNames: 'fuerza'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!
!Arquero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:17:12' prior: 50677081!
initializeEsperaPorTiroYSeAdelantaSuFuerzaBaseEs: fuerzaArquero
	fuerza := fuerzaArquero! !
!Arquero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:17:24' prior: 50677088!
initializeEligeDireccionAntesDeTiroSuFuerzaBaseEs: fuerzaArquero

	fuerza := fuerzaArquero * 1.5! !

!methodRemoval: Arquero #tipo stamp: 'LK 9/25/2023 20:17:37'!
tipo
	^tipo!
!Arquero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:18:16'!
fuerzaResultanteContraJabulani
	self subclassResponsibility ! !
!EsperaYAdelanta methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:18:20' overrides: 50681044!
fuerzaResultanteContraJabulani
	self subclassResponsibility ! !
!Elige methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:18:21' overrides: 50681044!
fuerzaResultanteContraJabulani
	self subclassResponsibility ! !
!Arquero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:18:21' prior: 50681044!
fuerzaResultanteContraJabulani

	self subclassResponsibility! !
!Arquero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:18:48'!
fuerzaResultanteContraPlayera

	self subclassResponsibility! !
!EsperaYAdelanta methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:18:54' overrides: 50681065!
fuerzaResultanteContraPlayera

	self subclassResponsibility! !
!Elige methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:18:54' overrides: 50681065!
fuerzaResultanteContraPlayera

	self subclassResponsibility! !
!Arquero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:18:54' prior: 50681065!
fuerzaResultanteContraPlayera

	self subclassResponsibility! !
!Elige methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:19:44' prior: 50681076 overrides: 50681081!
fuerzaResultanteContraPlayera

	^fuerza * 2! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 20:20:09' prior: 50680975!
varFuerzaResultanteDeAtajada
	^penalPelota verFuerzaConArquero: arquero.
	
	! !
!Elige methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:20:24' prior: 50681055 overrides: 50681060!
fuerzaResultanteContraJabulani
	^fuerza! !
!EsperaYAdelanta methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:20:35' prior: 50681071 overrides: 50681081!
fuerzaResultanteContraPlayera

	^fuerza! !
!EsperaYAdelanta methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:20:40' prior: 50681050 overrides: 50681060!
fuerzaResultanteContraJabulani
	
	
	^fuerza! !
!Elige methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:20:47' prior: 50681098 overrides: 50681060!
fuerzaResultanteContraJabulani

	^fuerza! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 20:21:30' prior: 50680397!
varFuerzaResultanteDeTiro
	^penalPelota verFuerzaConTirador: delantero.
	"
	(penalPelota = #Playera) ifTrue: [^delantero fuerza * 4/5].
	(penalPelota = #Jabulani & delantero tipo = #AMatar) ifTrue: [^delantero fuerza * 1.2].
	^ delantero fuerza"! !
!Pelota methodsFor: 'nil' stamp: 'LK 9/25/2023 20:21:48'!
verFuerzaConTirador! !
!Jabulani methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:21:53' overrides: 50681130!
verFuerzaConTirador! !
!Playera methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:21:54' overrides: 50681130!
verFuerzaConTirador! !
!Pelota methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:21:54' prior: 50681130!
verFuerzaConTirador

	self subclassResponsibility! !
!Pelota methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:22:23'!
verFuerzaConTirador: unTirador

	self subclassResponsibility! !

!methodRemoval: Pelota #verFuerzaConTirador stamp: 'LK 9/25/2023 20:22:24'!
verFuerzaConTirador

	self subclassResponsibility!
!Jabulani methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:22:49' overrides: 50681146!
verFuerzaConTirador: unTirador! !

!methodRemoval: Jabulani #verFuerzaConTirador stamp: 'LK 9/25/2023 20:22:51'!
verFuerzaConTirador!
!Playera methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:22:56' overrides: 50681146!
verFuerzaConTirador: unTirador! !

!methodRemoval: Playera #verFuerzaConTirador stamp: 'LK 9/25/2023 20:22:58'!
verFuerzaConTirador!
!Playera methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:23:48' prior: 50681163 overrides: 50681146!
verFuerzaConTirador: unTirador
	^unTirador fuerzaResultanteConPlayera.! !
!Jabulani methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:24:07' prior: 50681155 overrides: 50681146!
verFuerzaConTirador: unTirador
	^unTirador fuerzaResultanteConJabulani.! !
!Delantero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:24:27'!
fuerzaResultanteConJabulani! !
!Delantero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:24:34'!
fuerzaResultanteConPlayera! !
!AMatar methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:24:42' overrides: 50681182!
fuerzaResultanteConJabulani! !
!AColocar methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:24:42' overrides: 50681182!
fuerzaResultanteConJabulani! !
!Delantero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:24:42' prior: 50681182!
fuerzaResultanteConJabulani

	self subclassResponsibility! !
!AMatar methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:24:46' overrides: 50681186!
fuerzaResultanteConPlayera! !
!AColocar methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:24:46' overrides: 50681186!
fuerzaResultanteConPlayera! !
!Delantero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:24:46' prior: 50681186!
fuerzaResultanteConPlayera

	self subclassResponsibility! !
!AMatar methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:25:17' prior: 50681190 overrides: 50681198!
fuerzaResultanteConJabulani
	^fuerza * 1.2! !
!AMatar methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:25:54' prior: 50681203 overrides: 50681211!
fuerzaResultanteConPlayera
	^fuerza * 0.8! !
!AColocar methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:26:15' prior: 50681207 overrides: 50681211!
fuerzaResultanteConPlayera
	^fuerza * 4/5! !
!AMatar methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:26:21' prior: 50681222 overrides: 50681211!
fuerzaResultanteConPlayera
	^fuerza * 4/5! !
!AMatar methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:26:31' prior: 50680708 overrides: 50680703!
fuerza
	^fuerza! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 20:27:26' prior: 50680375!
varDireccionRemateResultante
	
	^delantero direccionFinalDeTiroA: direccionDelTiroDelantero.
	"
	(delantero tipo = #AMatar) ifTrue: [
		
		(direccionDelTiroDelantero = (0@0)) ifTrue: [^0@1].
		(direccionDelTiroDelantero = (0@2)) ifTrue: [^0@1].
		(direccionDelTiroDelantero = (2@0)) ifTrue: [^2@1].
		(direccionDelTiroDelantero = (2@2)) ifTrue: [^2@1].
	].

	^direccionDelTiroDelantero ."! !
!Delantero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:28:08'!
direccionFinalDeTiroA: unaDireccion
	! !
!AMatar methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:28:11' overrides: 50681256!
direccionFinalDeTiroA: unaDireccion
	! !
!AColocar methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:28:12' overrides: 50681256!
direccionFinalDeTiroA: unaDireccion
	! !
!Delantero methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:28:12' prior: 50681256!
direccionFinalDeTiroA: unaDireccion

	self subclassResponsibility! !
!AMatar methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:29:37' prior: 50681261 overrides: 50681271!
direccionFinalDeTiroA: unaDireccion

	(unaDireccion = (0@0) | unaDireccion = (0@2)) ifTrue : [^0@1].
	(unaDireccion = (2@0) | unaDireccion = (2@2)) ifTrue: [^2@1].
	^unaDireccion.! !
!AMatar methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:29:44' prior: 50681277 overrides: 50681271!
direccionFinalDeTiroA: unaDireccion

	(unaDireccion = (0@0) | unaDireccion = (0@2)) ifTrue: [^0@1].
	(unaDireccion = (2@0) | unaDireccion = (2@2)) ifTrue: [^2@1].
	^unaDireccion.! !
!AColocar methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:30:00' prior: 50681266 overrides: 50681271!
direccionFinalDeTiroA: unaDireccion
	
	^unaDireccion! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 20:30:08' prior: 50681120!
varFuerzaResultanteDeTiro

	^penalPelota verFuerzaConTirador: delantero.
! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 20:30:11' prior: 50681092!
varFuerzaResultanteDeAtajada

	^penalPelota verFuerzaConArquero: arquero.
	
	! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 20:30:17' prior: 50681241!
varDireccionRemateResultante
	
	^delantero direccionFinalDeTiroA: direccionDelTiroDelantero.
! !
!Playera methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:30:39' prior: 50680575!
initializePlayeraLentaCostaAzul! !
!Jabulani methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:30:44' prior: 50680585!
initializeJabulaniSudafricanaRapida! !
!EsperaYAdelanta methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:31:34' overrides: 50681030!
initializeEsperaPorTiroYSeAdelantaSuFuerzaBaseEs: fuerzaArquero
	fuerza := fuerzaArquero! !

!methodRemoval: Arquero #initializeEsperaPorTiroYSeAdelantaSuFuerzaBaseEs: stamp: 'LK 9/25/2023 20:31:34'!
initializeEsperaPorTiroYSeAdelantaSuFuerzaBaseEs: fuerzaArquero
	fuerza := fuerzaArquero!
!Elige methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:31:47' overrides: 50681036!
initializeEligeDireccionAntesDeTiroSuFuerzaBaseEs: fuerzaArquero

	fuerza := fuerzaArquero * 1.5! !

!methodRemoval: Arquero #initializeEligeDireccionAntesDeTiroSuFuerzaBaseEs: stamp: 'LK 9/25/2023 20:31:47'!
initializeEligeDireccionAntesDeTiroSuFuerzaBaseEs: fuerzaArquero

	fuerza := fuerzaArquero * 1.5!

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'LK 9/25/2023 20:32:46'!
ERROR!

!testRun: #PenalesTest #test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo stamp: 'LK 9/25/2023 20:32:46'!
ERROR!

Object subclass: #DelanteroConTactica
	instanceVariableNames: 'fuerza'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classDefinition: #DelanteroConTactica category: 'ISW1-2023-2C-Parcial-1' stamp: 'LK 9/25/2023 20:33:47'!
Object subclass: #DelanteroConTactica
	instanceVariableNames: 'fuerza'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

DelanteroConTactica subclass: #AColoccar
	instanceVariableNames: 'fuerza'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

DelanteroConTactica subclass: #AColoccar
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classDefinition: #AColoccar category: 'ISW1-2023-2C-Parcial-1' stamp: 'LK 9/25/2023 20:34:09'!
DelanteroConTactica subclass: #AColoccar
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

DelanteroConTactica subclass: #AMattar
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classDefinition: #AMattar category: 'ISW1-2023-2C-Parcial-1' stamp: 'LK 9/25/2023 20:34:17'!
DelanteroConTactica subclass: #AMattar
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!
!AColocar methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:34:36' prior: 50681194 overrides: 50681198!
fuerzaResultanteConJabulani
	^fuerza! !

!classRemoval: #AColoccar stamp: 'LK 9/25/2023 20:34:54'!
DelanteroConTactica subclass: #AColoccar
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classRemoval: #AMattar stamp: 'LK 9/25/2023 20:34:55'!
DelanteroConTactica subclass: #AMattar
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classRemoval: #DelanteroConTactica stamp: 'LK 9/25/2023 20:34:55'!
Object subclass: #DelanteroConTactica
	instanceVariableNames: 'fuerza'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classRenamed: #Delantero as: #DelanteroConTactica stamp: 'LK 9/25/2023 20:35:06'!
Smalltalk renameClassNamed: #Delantero as: #DelanteroConTactica!
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:35:06' prior: 50672341!
test05ArqueroNoPuedePasarseDelPaloIzquierdo
	
	| arquero delantero juegoPenales pelota |
	
	delantero := DelanteroConTactica decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	self 
		should: [ juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@0 arqueroSeLanzaEnDirección: -1@0.] 
		raise: Error
		withExceptionDo: [ :error |
			self assert: Penales direccionArqueroFueraDeRango equals: error messageText.
			self assert: 0 equals: juegoPenales puntajeDeDelantero.
			self assert: 0 equals: juegoPenales puntajeDeArquero.]
	! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:35:06' prior: 50672416!
test08ArqueroNoPuedeSaltarPorEncimaDelTravesaño
	
	| arquero delantero juegoPenales pelota |
	
	delantero := DelanteroConTactica decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	self 
		should: [ juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@0 arqueroSeLanzaEnDirección: 0@3.] 
		raise: Error
		withExceptionDo: [ :error |
			self assert: Penales direccionArqueroFueraDeRango equals: error messageText.
			self assert: 0 equals: juegoPenales puntajeDeDelantero.
			self assert: 0 equals: juegoPenales puntajeDeArquero.]
	! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:35:06' prior: 50672794!
test20DelanteroTiraAMatarAlAnguloInferiorIzquierdoLaAlturaDelTiroPasaAMedio
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"(tirar a matar no es tan preciso como tirar a colocar, hay desvios de altura. Sin embargo se usa el 100% de fuerza del jugador)"
	
	delantero := DelanteroConTactica decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@0 arqueroSeLanzaEnDirección: 0@0.
	.
	self assert: 0@1 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:35:07' prior: 50672291!
test03DelanteroNoPuedeApuntarHaciaAbajoDelArco
	
	| arquero delantero juegoPenales pelota |
	
	delantero := DelanteroConTactica decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	self 
		should: [ juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@-1 arqueroSeLanzaEnDirección: 0@0.] 
		raise: Error
		withExceptionDo: [ :error |
			self assert: Penales direccionTiroFueraDeRango equals: error messageText.
			self assert: 0 equals: juegoPenales puntajeDeDelantero.
			self assert: 0 equals: juegoPenales puntajeDeArquero.]
	! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:35:07' prior: 50673041!
test28ArqueroQueEligeAntesDeTiroVsJabulaniAMatarIgnoraAlturaTiro
	
	| arquero delantero juegoPenales pelota |
	
	"El Arquero que elige donde tirarse antes de un tiro de jabulani a matar, ignora la 2da coordenada (altura) al atajar..."		
	
	delantero := DelanteroConTactica decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@2 arqueroSeLanzaEnDirección: 0@0.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 0@1 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:35:07' prior: 50672614!
test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro
	
	| arquero delantero juegoPenales pelota |
	
	"La fuerza del Delantero se reduce en 50% siempre que tira a colocar... (no importa pelota, ni arquero)"
	"El Arquero que espera y se adelanta ante un tiro de jabulani a colocar ignora la 2da coordenada (altura) al atajar..."	
	"(al adelanterse encara la pelota antes de que su elevación se transforme en un problema)"
	
	delantero := DelanteroConTactica decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero  esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 50.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@2 arqueroSeLanzaEnDirección: 0@0.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 0@2 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:35:07' prior: 50673005!
test27FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAMatar
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' el Delantero usa el 100% de su fuerza... (no importa pelota, ni arquero)"
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"Si se tira 'a matar' usando la jabulani rápida, el Delantero gana un 20% de fuerza extra... (no importa arquero)"
	
	delantero := DelanteroConTactica decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 119.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@2 arqueroSeLanzaEnDirección: 2@1.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 2@1 equals: juegoPenales varDireccionRemateResultante.
	self assert: 120 equals: juegoPenales varFuerzaResultanteDeTiro.! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:35:07' prior: 50673224!
test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' el Delantero usa el 100% de su fuerza... (no importa pelota, ni arquero)"
	"Si se tira 'a matar' usando una pelota playera a una dirección que no es un ángulo, la 2da coordenada del remate (altura) suma 2, es decir sale volando producto de su liviandez (y que quiere retornar al mar). Si la pelota se va fuera del arco, el puntaje va al arquero... (no importa arquero)"
	"Si el arquero elige donde tirarse antes del tiro a matar de la pelota playera, ignora la 1ra coordenada del remate (ancho) al atajar..."
	"(con agacharse, quedarse parado, o saltar le alcanza...)"
	
	delantero := DelanteroConTactica decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 1@0 arqueroSeLanzaEnDirección: 0@2.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 1@2 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:35:07' prior: 50673187!
test32ArqueroQueEligeAntesDeTiroVsPlayeraAMatarAlAnguloIgnoraAnchoTiro
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' el Delantero usa el 100% de su fuerza... (no importa pelota, ni arquero)"
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"Si el arquero elige donde tirarse antes del tiro a matar de la pelota playera, ignora la 1ra coordenada del remate (ancho) al atajar..."
	"(con agacharse, quedarse parado, o saltar le alcanza...)"
	
	delantero := DelanteroConTactica decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@0 arqueroSeLanzaEnDirección: 2@1.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 0@1 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:35:07' prior: 50672241!
test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo
	
	| arquero delantero juegoPenales pelota |
	
	delantero := DelanteroConTactica decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	self 
		should: [ juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: -1@0 arqueroSeLanzaEnDirección: 0@0.] 
		raise: Error
		withExceptionDo: [ :error |
			self assert: Penales direccionTiroFueraDeRango equals: error messageText.
			self assert: 0 equals: juegoPenales puntajeDeDelantero.
			self assert: 0 equals: juegoPenales puntajeDeArquero.]
	! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:35:07' prior: 50672967!
test26DelanteroTiraAMatarConJabulaniGana20PorcFuerzaExtra
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' el Delantero usa el 100% de su fuerza... (no importa pelota, ni arquero)"
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"Si se tira 'a matar' usando la jabulani rápida, el Delantero gana un 20% de fuerza extra... (no importa arquero)"
	"(Jabulani a matar es la elección de los guerreros Z)"
	
	delantero := DelanteroConTactica decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 120.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@2 arqueroSeLanzaEnDirección: 2@1.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 2@1 equals: juegoPenales varDireccionRemateResultante.
	self assert: 120 equals: juegoPenales varFuerzaResultanteDeTiro.! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:35:07' prior: 50672366!
test06ArqueroNoPuedePasarseDelPaloDerecho
	
	| arquero delantero juegoPenales pelota |
	
	delantero := DelanteroConTactica decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	self 
		should: [ juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@0 arqueroSeLanzaEnDirección: 3@0.] 
		raise: Error
		withExceptionDo: [ :error |
			self assert: Penales direccionArqueroFueraDeRango equals: error messageText.
			self assert: 0 equals: juegoPenales puntajeDeDelantero.
			self assert: 0 equals: juegoPenales puntajeDeArquero.]
	! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:35:07' prior: 50672466!
test10MismasDireccionesInsuficienteFuerzaGolDelantero
	
	| arquero delantero juegoPenales pelota |
	
	"Caso general del juego..."
	
	delantero := DelanteroConTactica decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 10.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@2 arqueroSeLanzaEnDirección: 2@2.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 2@2 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:35:07' prior: 50672544!
test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra
	
	| arquero delantero juegoPenales pelota |
	
	"La fuerza del Delantero se reduce en 50% siempre que tira a colocar... (no importa pelota, ni arquero)"
	"El Arquero que elige donde tirarse antes de un tiro a colocar de jabulani gana 50% de su fuerza extra..."
	"(el arquero llega más cómodo y aprovecha mejor su fuerza)"
	
	delantero := DelanteroConTactica decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 34.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@2 arqueroSeLanzaEnDirección: 0@2.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 0@2 equals: juegoPenales varDireccionRemateResultante.
	self assert: 50 equals: juegoPenales varFuerzaResultanteDeTiro.
	self assert: 51 equals: juegoPenales varFuerzaResultanteDeAtajada.! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:35:07' prior: 50672878!
test23DelanteroTiraAMatarAlAnguloSuperiorDerechoLaAlturaDelTiroPasaAMedio
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"(tirar a matar no es tan preciso como tirar a colocar, hay desvios de altura. Sin embargo se usa el 100% de fuerza del jugador)"
	
	delantero := DelanteroConTactica decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@2 arqueroSeLanzaEnDirección: 2@2.
	
	self assert: 2@1 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:35:07' prior: 50672722!
test18FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsPlayeraAColocar
	
	| arquero delantero juegoPenales pelota |
	
	"La fuerza del Delantero se reduce en 50% siempre que tira a colocar... (no importa pelota, ni arquero)"
	"La humilde pelota playera le hace perder un 20% adicional de fuerza al delantero que la use para colocar... (no importa el arquero)"
	"Arquero que elige donde lanzarse antes de un remate de una pelota playera lenta a colocar, gana un 100% de su fuerza extra..."
	
	delantero := DelanteroConTactica decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 19.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@0 arqueroSeLanzaEnDirección: 0@0.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 0@0 equals: juegoPenales varDireccionRemateResultante.
	self assert: 40 equals: juegoPenales varFuerzaResultanteDeTiro.
	self assert: 38 equals: juegoPenales varFuerzaResultanteDeAtajada! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:35:07' prior: 50672441!
test09DireccionesDiferentesGolDelantero
	
	| arquero delantero juegoPenales pelota |
	
	"Caso general del juego..."
	
	delantero := DelanteroConTactica decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@2 arqueroSeLanzaEnDirección: 0@1.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 2@2 equals: juegoPenales varDireccionRemateResultante
	"varXXXX es por VAR, de 'Video Assistant Referee'"! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:35:07' prior: 50672316!
test04DelanteroNoPuedeApuntarHaciaArribaDelTravesaño
	
	| arquero delantero juegoPenales pelota |
	
	delantero := DelanteroConTactica decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	self 
		should: [ juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@3 arqueroSeLanzaEnDirección: 0@0.] 
		raise: Error
		withExceptionDo: [ :error |
			self assert: Penales direccionTiroFueraDeRango equals: error messageText.
			self assert: 0 equals: juegoPenales puntajeDeDelantero.
			self assert: 0 equals: juegoPenales puntajeDeArquero.]
	! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:35:07' prior: 50673100!
test30DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAdentro
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' el Delantero usa el 100% de su fuerza... (no importa pelota, ni arquero)"
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"Si se tira 'a matar' usando una pelota playera a una dirección que no es un ángulo, la 2da coordenada del remate (altura) suma 2, es decir sale volando producto de su liviandez (y que quiere retornar al mar). Si la pelota se va fuera del arco, el puntaje va al arquero... (no importa arquero)"
	"(y voló.. y me hizo volar... y yo volé de él...  pero acá por la arbolada... y el voló.. y se estrelló por acá por la pared...)"
	
	delantero := DelanteroConTactica decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 1@0 arqueroSeLanzaEnDirección: 1@0.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 1@2 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:35:07' prior: 50673266!
test34ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAMatarSiempreAtaja
	
	| arquero delantero juegoPenales pelota |
	
	"El Arquero que espera y se adelanta ante una pelota playera lenta a matar, siempre la ataja sin importar nada..."	
	"(como la pelota es taaaan lentaaa, el arquero se puede ir a tomar un cafe, verse una serie, volver y aún atajar la pelota habiendose tirado a cualquier lado. Pero igual es más rapida que cuando se la tira a colocar, donde indefectiblemente el arbitro lo detecta...)"
	
	delantero := DelanteroConTactica decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 1.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@2 arqueroSeLanzaEnDirección: 0@0.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 2@1 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:35:07' prior: 50672580!
test14FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAColocar
	
	| arquero delantero juegoPenales pelota |
	
	"La fuerza del Delantero se reduce en 50% siempre que tira a colocar... (no importa pelota, ni arquero)"
	"El Arquero que elige adonde tirarse antes de un tiro a colocar de jabulani gana 50% de su fuerza extra..."
	
	delantero := DelanteroConTactica decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 32.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@2 arqueroSeLanzaEnDirección: 0@2.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 0@2 equals: juegoPenales varDireccionRemateResultante.
	self assert: 50 equals: juegoPenales varFuerzaResultanteDeTiro.
	self assert: 48 equals: juegoPenales varFuerzaResultanteDeAtajada.! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:35:07' prior: 50672490!
test11MismasDireccionesSuficienteFuerzaAtajaArquero
	
	| arquero delantero juegoPenales pelota |
	
	"Caso general del juego..."
	
	delantero := DelanteroConTactica decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@2 arqueroSeLanzaEnDirección: 2@2.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 2@2 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:35:07' prior: 50672906!
test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"(tirar a matar no es tan preciso como tirar a colocar, hay desvios de altura. Sin embargo se usa el 100% de fuerza del jugador)"
	
	delantero := DelanteroConTactica decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 1@2 arqueroSeLanzaEnDirección: 1@1.

	self assert: 1@2 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:35:07' prior: 50672391!
test07ArqueroNoPuedeMeterseAbajoDeLaTierra
	
	| arquero delantero juegoPenales pelota |
	
	delantero := DelanteroConTactica decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	self 
		should: [ juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@0 arqueroSeLanzaEnDirección: 0@-1.] 
		raise: Error
		withExceptionDo: [ :error |
			self assert: Penales direccionArqueroFueraDeRango equals: error messageText.
			self assert: 0 equals: juegoPenales puntajeDeDelantero.
			self assert: 0 equals: juegoPenales puntajeDeArquero.]
	! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:35:07' prior: 50673145!
test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' el Delantero usa el 100% de su fuerza... (no importa pelota, ni arquero)"
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"Si se tira 'a matar' usando una pelota playera a una dirección que no es un ángulo, la 2da coordenada del remate (altura) suma 2, es decir sale volando producto de su liviandez (y que quiere retornar al mar). Si la pelota se va fuera del arco, el puntaje va al arquero... (no importa arquero)"
	"(El caso auspiciado por el Pipita...)"
	
	delantero := DelanteroConTactica decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@1 arqueroSeLanzaEnDirección: 0@0.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 0@3 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:35:08' prior: 50672266!
test02DelanteroNoPuedeApuntarHaciaAfueraDelPaloDerecho
	
	| arquero delantero juegoPenales pelota |
	
	delantero := DelanteroConTactica decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	self 
		should: [ juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 3@0 arqueroSeLanzaEnDirección: 0@0.] 
		raise: Error
		withExceptionDo: [ :error |
			self assert: Penales direccionTiroFueraDeRango equals: error messageText.
			self assert: 0 equals: juegoPenales puntajeDeDelantero.
			self assert: 0 equals: juegoPenales puntajeDeArquero.]
	! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:35:08' prior: 50672682!
test17ArqueroQueEligeAntesDeTiroVsPlayeraAColocarSuma100PorcFuerzaExtra
	
	| arquero delantero juegoPenales pelota |
	
	"La fuerza del Delantero se reduce en 50% siempre que tira a colocar... (no importa pelota, ni arquero)"
	"La humilde pelota playera le hace perder un 20% adicional de fuerza al delantero que la use para colocar... (no importa el arquero)"
	"Arquero que elige donde lanzarse antes de un remate de una pelota playera lenta a colocar, gana un 100% de su fuerza extra..."
	"(a quien madruga...)"
	
	delantero := DelanteroConTactica decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 20.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@0 arqueroSeLanzaEnDirección: 0@0.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 0@0 equals: juegoPenales varDireccionRemateResultante.
	self assert: 40 equals: juegoPenales varFuerzaResultanteDeTiro.
	self assert: 40 equals: juegoPenales varFuerzaResultanteDeAtajada! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:35:08' prior: 50672647!
test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero
	
	| arquero delantero juegoPenales pelota |
	
	"La fuerza del Delantero se reduce en 50% siempre que tira a colocar... (no importa pelota, ni arquero)"
	"La humilde pelota playera le hace perder un 20% de fuerza adicional al delantero que la use para colocar... (no importa el arquero)"
	"(no debería ser reglamentaria... al menos no es de trapo, nos responden)"
	
	delantero := DelanteroConTactica decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 1.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 1@2 arqueroSeLanzaEnDirección: 1@2.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 1@2 equals: juegoPenales varDireccionRemateResultante.
	self assert: 40 equals: juegoPenales varFuerzaResultanteDeTiro! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:35:08' prior: 50673068!
test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja
	
	| arquero delantero juegoPenales pelota |
	
	"El Arquero que espera a ver la dirección del remate de una pelota jabulani rápida a matar antes de lanzarse, nunca la ataja sin importar nada, siquiera que se adelantó..."	
	"(su poder era de más de 9000!! era impresionante, no podía moverme, sólo la ví pasar... f )"
	
	delantero := DelanteroConTactica decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 1@1 arqueroSeLanzaEnDirección: 1@1.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 1@1 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:35:08' prior: 50672514!
test12DelanteroQueTiraAColocarPierde50PorcFuerza
	
	| arquero delantero juegoPenales pelota |
	
	"La fuerza del Delantero se reduce en 50% siempre que tira a colocar... (no importa pelota, ni arquero)"
	"(delantero sacrificia potencia para ganar mayor precisión)"
	
	delantero := DelanteroConTactica decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 50.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@2 arqueroSeLanzaEnDirección: 2@2.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 2@2 equals: juegoPenales varDireccionRemateResultante.
	self assert: 50 equals: juegoPenales varFuerzaResultanteDeTiro.! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:35:08' prior: 50672822!
test21DelanteroTiraAMatarAlAnguloSuperiorIzquierdoLaAlturaDelTiroPasaAMedio
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"(tirar a matar no es tan preciso como tirar a colocar, hay desvios de altura. Sin embargo se usa el 100% de fuerza del jugador)"
	
	delantero := DelanteroConTactica decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@2 arqueroSeLanzaEnDirección: 0@2.
	
	self assert: 0@1 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:35:08' prior: 50672934!
test25DelanteroTiraAMatarUsa100PorcFuerzaBase
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"(tirar a matar no es tan preciso como tirar a colocar, hay desvios de altura. Sin embargo se usa el 100% de fuerza del jugador)"
	
	delantero := DelanteroConTactica decideTirarAMatarSuFuerzaBaseEs:150.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@0 arqueroSeLanzaEnDirección: 2@0.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 2@1 equals: juegoPenales varDireccionRemateResultante.
	self assert: 150 equals: juegoPenales varFuerzaResultanteDeTiro! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:35:08' prior: 50672850!
test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"(tirar a matar no es tan preciso como tirar a colocar, hay desvios de altura. Sin embargo se usa el 100% de fuerza del jugador)"
	
	delantero := DelanteroConTactica decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@0 arqueroSeLanzaEnDirección: 2@0.
	
	self assert: 2@1 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:35:08' prior: 50672761!
test19ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAColocarEsDescubiertoYPuntoParaDelantero
	
	| arquero delantero juegoPenales pelota |
	
	"Arquero que espera y se adelanta ante tiro con la lenta pelota playera, siempre es descubierto por el Árbitro, y el punto se le otorga al Delantero..."
	"(lo que servía de ventaja ante la Jabulani rápida, acá es tan obvio por lo que tarda en llegar la pelota al arco, que marchás preso...)"
	
	delantero := DelanteroConTactica decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero  esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@0 arqueroSeLanzaEnDirección: 0@0.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 0@0 equals: juegoPenales varDireccionRemateResultante! !

!classRenamed: #DelanteroConTactica as: #DelanteroConTacticaa stamp: 'LK 9/25/2023 20:36:01'!
Smalltalk renameClassNamed: #DelanteroConTactica as: #DelanteroConTacticaa!
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:36:01' prior: 50681434!
test05ArqueroNoPuedePasarseDelPaloIzquierdo
	
	| arquero delantero juegoPenales pelota |
	
	delantero := DelanteroConTacticaa decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	self 
		should: [ juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@0 arqueroSeLanzaEnDirección: -1@0.] 
		raise: Error
		withExceptionDo: [ :error |
			self assert: Penales direccionArqueroFueraDeRango equals: error messageText.
			self assert: 0 equals: juegoPenales puntajeDeDelantero.
			self assert: 0 equals: juegoPenales puntajeDeArquero.]
	! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:36:02' prior: 50681460!
test08ArqueroNoPuedeSaltarPorEncimaDelTravesaño
	
	| arquero delantero juegoPenales pelota |
	
	delantero := DelanteroConTacticaa decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	self 
		should: [ juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@0 arqueroSeLanzaEnDirección: 0@3.] 
		raise: Error
		withExceptionDo: [ :error |
			self assert: Penales direccionArqueroFueraDeRango equals: error messageText.
			self assert: 0 equals: juegoPenales puntajeDeDelantero.
			self assert: 0 equals: juegoPenales puntajeDeArquero.]
	! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:36:02' prior: 50681486!
test20DelanteroTiraAMatarAlAnguloInferiorIzquierdoLaAlturaDelTiroPasaAMedio
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"(tirar a matar no es tan preciso como tirar a colocar, hay desvios de altura. Sin embargo se usa el 100% de fuerza del jugador)"
	
	delantero := DelanteroConTacticaa decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@0 arqueroSeLanzaEnDirección: 0@0.
	.
	self assert: 0@1 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:36:02' prior: 50681516!
test03DelanteroNoPuedeApuntarHaciaAbajoDelArco
	
	| arquero delantero juegoPenales pelota |
	
	delantero := DelanteroConTacticaa decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	self 
		should: [ juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@-1 arqueroSeLanzaEnDirección: 0@0.] 
		raise: Error
		withExceptionDo: [ :error |
			self assert: Penales direccionTiroFueraDeRango equals: error messageText.
			self assert: 0 equals: juegoPenales puntajeDeDelantero.
			self assert: 0 equals: juegoPenales puntajeDeArquero.]
	! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:36:02' prior: 50681542!
test28ArqueroQueEligeAntesDeTiroVsJabulaniAMatarIgnoraAlturaTiro
	
	| arquero delantero juegoPenales pelota |
	
	"El Arquero que elige donde tirarse antes de un tiro de jabulani a matar, ignora la 2da coordenada (altura) al atajar..."		
	
	delantero := DelanteroConTacticaa decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@2 arqueroSeLanzaEnDirección: 0@0.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 0@1 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:36:02' prior: 50681570!
test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro
	
	| arquero delantero juegoPenales pelota |
	
	"La fuerza del Delantero se reduce en 50% siempre que tira a colocar... (no importa pelota, ni arquero)"
	"El Arquero que espera y se adelanta ante un tiro de jabulani a colocar ignora la 2da coordenada (altura) al atajar..."	
	"(al adelanterse encara la pelota antes de que su elevación se transforme en un problema)"
	
	delantero := DelanteroConTacticaa decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero  esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 50.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@2 arqueroSeLanzaEnDirección: 0@0.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 0@2 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:36:02' prior: 50681605!
test27FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAMatar
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' el Delantero usa el 100% de su fuerza... (no importa pelota, ni arquero)"
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"Si se tira 'a matar' usando la jabulani rápida, el Delantero gana un 20% de fuerza extra... (no importa arquero)"
	
	delantero := DelanteroConTacticaa decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 119.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@2 arqueroSeLanzaEnDirección: 2@1.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 2@1 equals: juegoPenales varDireccionRemateResultante.
	self assert: 120 equals: juegoPenales varFuerzaResultanteDeTiro.! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:36:02' prior: 50681643!
test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' el Delantero usa el 100% de su fuerza... (no importa pelota, ni arquero)"
	"Si se tira 'a matar' usando una pelota playera a una dirección que no es un ángulo, la 2da coordenada del remate (altura) suma 2, es decir sale volando producto de su liviandez (y que quiere retornar al mar). Si la pelota se va fuera del arco, el puntaje va al arquero... (no importa arquero)"
	"Si el arquero elige donde tirarse antes del tiro a matar de la pelota playera, ignora la 1ra coordenada del remate (ancho) al atajar..."
	"(con agacharse, quedarse parado, o saltar le alcanza...)"
	
	delantero := DelanteroConTacticaa decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 1@0 arqueroSeLanzaEnDirección: 0@2.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 1@2 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:36:02' prior: 50681686!
test32ArqueroQueEligeAntesDeTiroVsPlayeraAMatarAlAnguloIgnoraAnchoTiro
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' el Delantero usa el 100% de su fuerza... (no importa pelota, ni arquero)"
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"Si el arquero elige donde tirarse antes del tiro a matar de la pelota playera, ignora la 1ra coordenada del remate (ancho) al atajar..."
	"(con agacharse, quedarse parado, o saltar le alcanza...)"
	
	delantero := DelanteroConTacticaa decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@0 arqueroSeLanzaEnDirección: 2@1.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 0@1 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:36:02' prior: 50681724!
test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo
	
	| arquero delantero juegoPenales pelota |
	
	delantero := DelanteroConTacticaa decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	self 
		should: [ juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: -1@0 arqueroSeLanzaEnDirección: 0@0.] 
		raise: Error
		withExceptionDo: [ :error |
			self assert: Penales direccionTiroFueraDeRango equals: error messageText.
			self assert: 0 equals: juegoPenales puntajeDeDelantero.
			self assert: 0 equals: juegoPenales puntajeDeArquero.]
	! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:36:02' prior: 50681751!
test26DelanteroTiraAMatarConJabulaniGana20PorcFuerzaExtra
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' el Delantero usa el 100% de su fuerza... (no importa pelota, ni arquero)"
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"Si se tira 'a matar' usando la jabulani rápida, el Delantero gana un 20% de fuerza extra... (no importa arquero)"
	"(Jabulani a matar es la elección de los guerreros Z)"
	
	delantero := DelanteroConTacticaa decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 120.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@2 arqueroSeLanzaEnDirección: 2@1.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 2@1 equals: juegoPenales varDireccionRemateResultante.
	self assert: 120 equals: juegoPenales varFuerzaResultanteDeTiro.! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:36:02' prior: 50681790!
test06ArqueroNoPuedePasarseDelPaloDerecho
	
	| arquero delantero juegoPenales pelota |
	
	delantero := DelanteroConTacticaa decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	self 
		should: [ juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@0 arqueroSeLanzaEnDirección: 3@0.] 
		raise: Error
		withExceptionDo: [ :error |
			self assert: Penales direccionArqueroFueraDeRango equals: error messageText.
			self assert: 0 equals: juegoPenales puntajeDeDelantero.
			self assert: 0 equals: juegoPenales puntajeDeArquero.]
	! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:36:02' prior: 50681816!
test10MismasDireccionesInsuficienteFuerzaGolDelantero
	
	| arquero delantero juegoPenales pelota |
	
	"Caso general del juego..."
	
	delantero := DelanteroConTacticaa decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 10.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@2 arqueroSeLanzaEnDirección: 2@2.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 2@2 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:36:02' prior: 50681841!
test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra
	
	| arquero delantero juegoPenales pelota |
	
	"La fuerza del Delantero se reduce en 50% siempre que tira a colocar... (no importa pelota, ni arquero)"
	"El Arquero que elige donde tirarse antes de un tiro a colocar de jabulani gana 50% de su fuerza extra..."
	"(el arquero llega más cómodo y aprovecha mejor su fuerza)"
	
	delantero := DelanteroConTacticaa decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 34.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@2 arqueroSeLanzaEnDirección: 0@2.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 0@2 equals: juegoPenales varDireccionRemateResultante.
	self assert: 50 equals: juegoPenales varFuerzaResultanteDeTiro.
	self assert: 51 equals: juegoPenales varFuerzaResultanteDeAtajada.! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:36:02' prior: 50681878!
test23DelanteroTiraAMatarAlAnguloSuperiorDerechoLaAlturaDelTiroPasaAMedio
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"(tirar a matar no es tan preciso como tirar a colocar, hay desvios de altura. Sin embargo se usa el 100% de fuerza del jugador)"
	
	delantero := DelanteroConTacticaa decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@2 arqueroSeLanzaEnDirección: 2@2.
	
	self assert: 2@1 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:36:02' prior: 50681908!
test18FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsPlayeraAColocar
	
	| arquero delantero juegoPenales pelota |
	
	"La fuerza del Delantero se reduce en 50% siempre que tira a colocar... (no importa pelota, ni arquero)"
	"La humilde pelota playera le hace perder un 20% adicional de fuerza al delantero que la use para colocar... (no importa el arquero)"
	"Arquero que elige donde lanzarse antes de un remate de una pelota playera lenta a colocar, gana un 100% de su fuerza extra..."
	
	delantero := DelanteroConTacticaa decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 19.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@0 arqueroSeLanzaEnDirección: 0@0.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 0@0 equals: juegoPenales varDireccionRemateResultante.
	self assert: 40 equals: juegoPenales varFuerzaResultanteDeTiro.
	self assert: 38 equals: juegoPenales varFuerzaResultanteDeAtajada! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:36:02' prior: 50681948!
test09DireccionesDiferentesGolDelantero
	
	| arquero delantero juegoPenales pelota |
	
	"Caso general del juego..."
	
	delantero := DelanteroConTacticaa decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@2 arqueroSeLanzaEnDirección: 0@1.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 2@2 equals: juegoPenales varDireccionRemateResultante
	"varXXXX es por VAR, de 'Video Assistant Referee'"! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:36:02' prior: 50681974!
test04DelanteroNoPuedeApuntarHaciaArribaDelTravesaño
	
	| arquero delantero juegoPenales pelota |
	
	delantero := DelanteroConTacticaa decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	self 
		should: [ juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@3 arqueroSeLanzaEnDirección: 0@0.] 
		raise: Error
		withExceptionDo: [ :error |
			self assert: Penales direccionTiroFueraDeRango equals: error messageText.
			self assert: 0 equals: juegoPenales puntajeDeDelantero.
			self assert: 0 equals: juegoPenales puntajeDeArquero.]
	! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:36:02' prior: 50682000!
test30DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAdentro
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' el Delantero usa el 100% de su fuerza... (no importa pelota, ni arquero)"
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"Si se tira 'a matar' usando una pelota playera a una dirección que no es un ángulo, la 2da coordenada del remate (altura) suma 2, es decir sale volando producto de su liviandez (y que quiere retornar al mar). Si la pelota se va fuera del arco, el puntaje va al arquero... (no importa arquero)"
	"(y voló.. y me hizo volar... y yo volé de él...  pero acá por la arbolada... y el voló.. y se estrelló por acá por la pared...)"
	
	delantero := DelanteroConTacticaa decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 1@0 arqueroSeLanzaEnDirección: 1@0.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 1@2 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:36:02' prior: 50682046!
test34ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAMatarSiempreAtaja
	
	| arquero delantero juegoPenales pelota |
	
	"El Arquero que espera y se adelanta ante una pelota playera lenta a matar, siempre la ataja sin importar nada..."	
	"(como la pelota es taaaan lentaaa, el arquero se puede ir a tomar un cafe, verse una serie, volver y aún atajar la pelota habiendose tirado a cualquier lado. Pero igual es más rapida que cuando se la tira a colocar, donde indefectiblemente el arbitro lo detecta...)"
	
	delantero := DelanteroConTacticaa decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 1.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@2 arqueroSeLanzaEnDirección: 0@0.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 2@1 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:36:03' prior: 50682082!
test14FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAColocar
	
	| arquero delantero juegoPenales pelota |
	
	"La fuerza del Delantero se reduce en 50% siempre que tira a colocar... (no importa pelota, ni arquero)"
	"El Arquero que elige adonde tirarse antes de un tiro a colocar de jabulani gana 50% de su fuerza extra..."
	
	delantero := DelanteroConTacticaa decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 32.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@2 arqueroSeLanzaEnDirección: 0@2.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 0@2 equals: juegoPenales varDireccionRemateResultante.
	self assert: 50 equals: juegoPenales varFuerzaResultanteDeTiro.
	self assert: 48 equals: juegoPenales varFuerzaResultanteDeAtajada.! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:36:03' prior: 50682117!
test11MismasDireccionesSuficienteFuerzaAtajaArquero
	
	| arquero delantero juegoPenales pelota |
	
	"Caso general del juego..."
	
	delantero := DelanteroConTacticaa decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@2 arqueroSeLanzaEnDirección: 2@2.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 2@2 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:36:03' prior: 50682142!
test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"(tirar a matar no es tan preciso como tirar a colocar, hay desvios de altura. Sin embargo se usa el 100% de fuerza del jugador)"
	
	delantero := DelanteroConTacticaa decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 1@2 arqueroSeLanzaEnDirección: 1@1.

	self assert: 1@2 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:36:03' prior: 50682171!
test07ArqueroNoPuedeMeterseAbajoDeLaTierra
	
	| arquero delantero juegoPenales pelota |
	
	delantero := DelanteroConTacticaa decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	self 
		should: [ juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@0 arqueroSeLanzaEnDirección: 0@-1.] 
		raise: Error
		withExceptionDo: [ :error |
			self assert: Penales direccionArqueroFueraDeRango equals: error messageText.
			self assert: 0 equals: juegoPenales puntajeDeDelantero.
			self assert: 0 equals: juegoPenales puntajeDeArquero.]
	! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:36:03' prior: 50682197!
test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' el Delantero usa el 100% de su fuerza... (no importa pelota, ni arquero)"
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"Si se tira 'a matar' usando una pelota playera a una dirección que no es un ángulo, la 2da coordenada del remate (altura) suma 2, es decir sale volando producto de su liviandez (y que quiere retornar al mar). Si la pelota se va fuera del arco, el puntaje va al arquero... (no importa arquero)"
	"(El caso auspiciado por el Pipita...)"
	
	delantero := DelanteroConTacticaa decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@1 arqueroSeLanzaEnDirección: 0@0.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 0@3 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:36:03' prior: 50682240!
test02DelanteroNoPuedeApuntarHaciaAfueraDelPaloDerecho
	
	| arquero delantero juegoPenales pelota |
	
	delantero := DelanteroConTacticaa decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	self 
		should: [ juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 3@0 arqueroSeLanzaEnDirección: 0@0.] 
		raise: Error
		withExceptionDo: [ :error |
			self assert: Penales direccionTiroFueraDeRango equals: error messageText.
			self assert: 0 equals: juegoPenales puntajeDeDelantero.
			self assert: 0 equals: juegoPenales puntajeDeArquero.]
	! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:36:03' prior: 50682266!
test17ArqueroQueEligeAntesDeTiroVsPlayeraAColocarSuma100PorcFuerzaExtra
	
	| arquero delantero juegoPenales pelota |
	
	"La fuerza del Delantero se reduce en 50% siempre que tira a colocar... (no importa pelota, ni arquero)"
	"La humilde pelota playera le hace perder un 20% adicional de fuerza al delantero que la use para colocar... (no importa el arquero)"
	"Arquero que elige donde lanzarse antes de un remate de una pelota playera lenta a colocar, gana un 100% de su fuerza extra..."
	"(a quien madruga...)"
	
	delantero := DelanteroConTacticaa decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 20.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@0 arqueroSeLanzaEnDirección: 0@0.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 0@0 equals: juegoPenales varDireccionRemateResultante.
	self assert: 40 equals: juegoPenales varFuerzaResultanteDeTiro.
	self assert: 40 equals: juegoPenales varFuerzaResultanteDeAtajada! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:36:03' prior: 50682307!
test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero
	
	| arquero delantero juegoPenales pelota |
	
	"La fuerza del Delantero se reduce en 50% siempre que tira a colocar... (no importa pelota, ni arquero)"
	"La humilde pelota playera le hace perder un 20% de fuerza adicional al delantero que la use para colocar... (no importa el arquero)"
	"(no debería ser reglamentaria... al menos no es de trapo, nos responden)"
	
	delantero := DelanteroConTacticaa decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 1.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 1@2 arqueroSeLanzaEnDirección: 1@2.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 1@2 equals: juegoPenales varDireccionRemateResultante.
	self assert: 40 equals: juegoPenales varFuerzaResultanteDeTiro! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:36:03' prior: 50682343!
test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja
	
	| arquero delantero juegoPenales pelota |
	
	"El Arquero que espera a ver la dirección del remate de una pelota jabulani rápida a matar antes de lanzarse, nunca la ataja sin importar nada, siquiera que se adelantó..."	
	"(su poder era de más de 9000!! era impresionante, no podía moverme, sólo la ví pasar... f )"
	
	delantero := DelanteroConTacticaa decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 1@1 arqueroSeLanzaEnDirección: 1@1.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 1@1 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:36:03' prior: 50682376!
test12DelanteroQueTiraAColocarPierde50PorcFuerza
	
	| arquero delantero juegoPenales pelota |
	
	"La fuerza del Delantero se reduce en 50% siempre que tira a colocar... (no importa pelota, ni arquero)"
	"(delantero sacrificia potencia para ganar mayor precisión)"
	
	delantero := DelanteroConTacticaa decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 50.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@2 arqueroSeLanzaEnDirección: 2@2.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 2@2 equals: juegoPenales varDireccionRemateResultante.
	self assert: 50 equals: juegoPenales varFuerzaResultanteDeTiro.! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:36:03' prior: 50682407!
test21DelanteroTiraAMatarAlAnguloSuperiorIzquierdoLaAlturaDelTiroPasaAMedio
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"(tirar a matar no es tan preciso como tirar a colocar, hay desvios de altura. Sin embargo se usa el 100% de fuerza del jugador)"
	
	delantero := DelanteroConTacticaa decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@2 arqueroSeLanzaEnDirección: 0@2.
	
	self assert: 0@1 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:36:03' prior: 50682437!
test25DelanteroTiraAMatarUsa100PorcFuerzaBase
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"(tirar a matar no es tan preciso como tirar a colocar, hay desvios de altura. Sin embargo se usa el 100% de fuerza del jugador)"
	
	delantero := DelanteroConTacticaa decideTirarAMatarSuFuerzaBaseEs:150.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@0 arqueroSeLanzaEnDirección: 2@0.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 2@1 equals: juegoPenales varDireccionRemateResultante.
	self assert: 150 equals: juegoPenales varFuerzaResultanteDeTiro! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:36:03' prior: 50682471!
test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"(tirar a matar no es tan preciso como tirar a colocar, hay desvios de altura. Sin embargo se usa el 100% de fuerza del jugador)"
	
	delantero := DelanteroConTacticaa decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@0 arqueroSeLanzaEnDirección: 2@0.
	
	self assert: 2@1 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:36:03' prior: 50682501!
test19ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAColocarEsDescubiertoYPuntoParaDelantero
	
	| arquero delantero juegoPenales pelota |
	
	"Arquero que espera y se adelanta ante tiro con la lenta pelota playera, siempre es descubierto por el Árbitro, y el punto se le otorga al Delantero..."
	"(lo que servía de ventaja ante la Jabulani rápida, acá es tan obvio por lo que tarda en llegar la pelota al arco, que marchás preso...)"
	
	delantero := DelanteroConTacticaa decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero  esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@0 arqueroSeLanzaEnDirección: 0@0.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 0@0 equals: juegoPenales varDireccionRemateResultante! !

Object subclass: #Delantero
	instanceVariableNames: 'fuerza'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classDefinition: #Delantero category: 'ISW1-2023-2C-Parcial-1' stamp: 'LK 9/25/2023 20:36:22'!
Object subclass: #Delantero
	instanceVariableNames: 'fuerza'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!
!PenalesTest methodsFor: 'tests' stamp: 'LK 9/25/2023 20:36:36' prior: 50682831!
test01DelanteroNoPuedeApuntarHaciaAfueraDelPaloIzquierdo
	
	| arquero delantero juegoPenales pelota |
	
	delantero := Delantero decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	self 
		should: [ juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: -1@0 arqueroSeLanzaEnDirección: 0@0.] 
		raise: Error
		withExceptionDo: [ :error |
			self assert: Penales direccionTiroFueraDeRango equals: error messageText.
			self assert: 0 equals: juegoPenales puntajeDeDelantero.
			self assert: 0 equals: juegoPenales puntajeDeArquero.]
	! !
!PenalesTest methodsFor: 'tests' stamp: 'LK 9/25/2023 20:36:41' prior: 50683348!
test02DelanteroNoPuedeApuntarHaciaAfueraDelPaloDerecho
	
	| arquero delantero juegoPenales pelota |
	
	delantero := Delantero decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	self 
		should: [ juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 3@0 arqueroSeLanzaEnDirección: 0@0.] 
		raise: Error
		withExceptionDo: [ :error |
			self assert: Penales direccionTiroFueraDeRango equals: error messageText.
			self assert: 0 equals: juegoPenales puntajeDeDelantero.
			self assert: 0 equals: juegoPenales puntajeDeArquero.]
	! !
!PenalesTest methodsFor: 'tests' stamp: 'LK 9/25/2023 20:36:46' prior: 50682623!
test03DelanteroNoPuedeApuntarHaciaAbajoDelArco
	
	| arquero delantero juegoPenales pelota |
	
	delantero := Delantero decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	self 
		should: [ juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@-1 arqueroSeLanzaEnDirección: 0@0.] 
		raise: Error
		withExceptionDo: [ :error |
			self assert: Penales direccionTiroFueraDeRango equals: error messageText.
			self assert: 0 equals: juegoPenales puntajeDeDelantero.
			self assert: 0 equals: juegoPenales puntajeDeArquero.]
	! !
!PenalesTest methodsFor: 'tests' stamp: 'LK 9/25/2023 20:36:50' prior: 50683081!
test04DelanteroNoPuedeApuntarHaciaArribaDelTravesaño
	
	| arquero delantero juegoPenales pelota |
	
	delantero := Delantero decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	self 
		should: [ juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@3 arqueroSeLanzaEnDirección: 0@0.] 
		raise: Error
		withExceptionDo: [ :error |
			self assert: Penales direccionTiroFueraDeRango equals: error messageText.
			self assert: 0 equals: juegoPenales puntajeDeDelantero.
			self assert: 0 equals: juegoPenales puntajeDeArquero.]
	! !
!PenalesTest methodsFor: 'tests' stamp: 'LK 9/25/2023 20:37:01' prior: 50682541!
test05ArqueroNoPuedePasarseDelPaloIzquierdo
	
	| arquero delantero juegoPenales pelota |
	
	delantero := Delantero decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	self 
		should: [ juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@0 arqueroSeLanzaEnDirección: -1@0.] 
		raise: Error
		withExceptionDo: [ :error |
			self assert: Penales direccionArqueroFueraDeRango equals: error messageText.
			self assert: 0 equals: juegoPenales puntajeDeDelantero.
			self assert: 0 equals: juegoPenales puntajeDeArquero.]
	! !
!PenalesTest methodsFor: 'tests' stamp: 'LK 9/25/2023 20:37:06' prior: 50682897!
test06ArqueroNoPuedePasarseDelPaloDerecho
	
	| arquero delantero juegoPenales pelota |
	
	delantero := Delantero decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	self 
		should: [ juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@0 arqueroSeLanzaEnDirección: 3@0.] 
		raise: Error
		withExceptionDo: [ :error |
			self assert: Penales direccionArqueroFueraDeRango equals: error messageText.
			self assert: 0 equals: juegoPenales puntajeDeDelantero.
			self assert: 0 equals: juegoPenales puntajeDeArquero.]
	! !
!Delantero class methodsFor: 'no messages' stamp: 'LK 9/25/2023 20:38:21'!
decideTirarAColocarSuFuerzaBaseEs: fuerzaJugador
	^DelanteroConTacticaa new initializeDecideTirarAColocarSuFuerzaBaseEs: fuerzaJugador.
! !
!Delantero class methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:39:10'!
decideTirarAMatarSuFuerzaBaseEs: fuerzaJugador
	^self new initializeDecideTirarAMatarSuFuerzaBaseEs: fuerzaJugador ! !

Object subclass: #Delantero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classDefinition: #Delantero category: 'ISW1-2023-2C-Parcial-1' stamp: 'LK 9/25/2023 20:39:54'!
Object subclass: #Delantero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

Object subclass: #ArqueroConTactica
	instanceVariableNames: 'fuerza'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classDefinition: #ArqueroConTactica category: 'ISW1-2023-2C-Parcial-1' stamp: 'LK 9/25/2023 20:40:32'!
Object subclass: #ArqueroConTactica
	instanceVariableNames: 'fuerza'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

ArqueroConTactica subclass: #Elige
	instanceVariableNames: 'fuerza'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

ArqueroConTactica subclass: #Eligee
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classDefinition: #Eligee category: 'ISW1-2023-2C-Parcial-1' stamp: 'LK 9/25/2023 20:41:29'!
ArqueroConTactica subclass: #Eligee
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

ArqueroConTactica subclass: #EesperaYAdelanta
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classDefinition: #EesperaYAdelanta category: 'ISW1-2023-2C-Parcial-1' stamp: 'LK 9/25/2023 20:41:36'!
ArqueroConTactica subclass: #EesperaYAdelanta
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!
!Eligee methodsFor: 'no messages' stamp: 'LK 9/25/2023 20:41:48'!
fuerzaResultanteContraJabulani

	^fuerza! !
!Eligee methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:41:58'!
fuerzaResultanteContraPlayera

	^fuerza * 2! !
!EesperaYAdelanta methodsFor: 'no messages' stamp: 'LK 9/25/2023 20:42:20'!
fuerzaResultanteContraPlayera

	^fuerza * 2! !
!EesperaYAdelanta methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:42:42'!
fuerzaResultanteContraJabulani

	^fuerza! !
!EesperaYAdelanta methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:42:50' prior: 50683887!
fuerzaResultanteContraPlayera

	^fuerza! !
!EesperaYAdelanta methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:43:18'!
initializeEsperaPorTiroYSeAdelantaSuFuerzaBaseEs: fuerzaArquero
	fuerza := fuerzaArquero! !
!Eligee methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:43:29'!
initializeEligeDireccionAntesDeTiroSuFuerzaBaseEs: fuerzaArquero

	fuerza := fuerzaArquero * 1.5! !
!Arquero class methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:43:49' prior: 50675733!
eligeDireccionAntesDeTiroSuFuerzaBaseEs: fuerzaArquero
	^EesperaYAdelanta new initializeEligeDireccionAntesDeTiroSuFuerzaBaseEs: fuerzaArquero.! !
!Arquero class methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:43:59' prior: 50683914!
eligeDireccionAntesDeTiroSuFuerzaBaseEs: fuerzaArquero
	^Eligee new initializeEligeDireccionAntesDeTiroSuFuerzaBaseEs: fuerzaArquero.! !
!Arquero class methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:44:09' prior: 50673935!
esperaPorTiroYSeAdelantaSuFuerzaBaseEs: fuerzaArquero
	^EesperaYAdelanta new initializeEsperaPorTiroYSeAdelantaSuFuerzaBaseEs: fuerzaArquero.! !

!classRemoval: #EsperaYAdelanta stamp: 'LK 9/25/2023 20:44:15'!
Arquero subclass: #EsperaYAdelanta
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classRemoval: #Elige stamp: 'LK 9/25/2023 20:44:23'!
Arquero subclass: #Elige
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classRenamed: #EesperaYAdelanta as: #EsperaYAdelanta stamp: 'LK 9/25/2023 20:44:35'!
Smalltalk renameClassNamed: #EesperaYAdelanta as: #EsperaYAdelanta!
!Penales methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:44:36' prior: 50680839!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(self direccionEnRango: direccionTiro) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(self direccionEnRango: direccionArquero) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	(direccionTiro = direccionArquero) ifTrue: [].
	
	(pelota tipo = #Jabulani) ifTrue: [
			penalPelota := #Jabulani.
			
		(delantero tipo = #AMatar) ifTrue: [self sumarPuntoDelantero].
		
		(arquero tipo = #EsperaYAdelanta) ifTrue: [
				((direccionTiro) x = (direccionArquero x) & 
				(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro))
				 	ifTrue: [self sumarPuntoArquero]]
					
				ifFalse: [(direccionTiro = direccionArquero) & 
				(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro) 
					ifTrue: [self sumarPuntoDelantero].
					
			].
		
		(arquero tipo = #Elige) ifTrue: [
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro ))
					ifTrue: [self sumarPuntoArquero].
			
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro )) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
		].
	(pelota = #Playera) ifTrue: [
			
			penalPelota := #Playera.
			
			(arquero tipo = #Elige) ifTrue: [
				
				(direccionTiro = direccionArquero & 
				self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro)
					ifTrue: [self sumarPuntoArquero].
			
				(direccionTiro = direccionArquero & 
				self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
			(arquero tipo = #EsperaYadelanta) ifTrue: [self sumarPuntoDelantero].
				
		].
			
		
	
	
	
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !
!Arquero class methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:44:36' prior: 50683930!
esperaPorTiroYSeAdelantaSuFuerzaBaseEs: fuerzaArquero
	^EsperaYAdelanta new initializeEsperaPorTiroYSeAdelantaSuFuerzaBaseEs: fuerzaArquero.! !

!classRenamed: #Eligee as: #Elige stamp: 'LK 9/25/2023 20:44:47'!
Smalltalk renameClassNamed: #Eligee as: #Elige!
!Penales methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:44:47' prior: 50683955!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(self direccionEnRango: direccionTiro) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(self direccionEnRango: direccionArquero) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	(direccionTiro = direccionArquero) ifTrue: [].
	
	(pelota tipo = #Jabulani) ifTrue: [
			penalPelota := #Jabulani.
			
		(delantero tipo = #AMatar) ifTrue: [self sumarPuntoDelantero].
		
		(arquero tipo = #EsperaYAdelanta) ifTrue: [
				((direccionTiro) x = (direccionArquero x) & 
				(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro))
				 	ifTrue: [self sumarPuntoArquero]]
					
				ifFalse: [(direccionTiro = direccionArquero) & 
				(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro) 
					ifTrue: [self sumarPuntoDelantero].
					
			].
		
		(arquero tipo = #Elige) ifTrue: [
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro ))
					ifTrue: [self sumarPuntoArquero].
			
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro )) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
		].
	(pelota = #Playera) ifTrue: [
			
			penalPelota := #Playera.
			
			(arquero tipo = #Elige) ifTrue: [
				
				(direccionTiro = direccionArquero & 
				self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro)
					ifTrue: [self sumarPuntoArquero].
			
				(direccionTiro = direccionArquero & 
				self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
			(arquero tipo = #EsperaYadelanta) ifTrue: [self sumarPuntoDelantero].
				
		].
			
		
	
	
	
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !
!Arquero class methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:44:47' prior: 50683922!
eligeDireccionAntesDeTiroSuFuerzaBaseEs: fuerzaArquero
	^Elige new initializeEligeDireccionAntesDeTiroSuFuerzaBaseEs: fuerzaArquero.! !

!classRenamed: #DelanteroConTacticaa as: #DelanteroConTactic stamp: 'LK 9/25/2023 20:45:17'!
Smalltalk renameClassNamed: #DelanteroConTacticaa as: #DelanteroConTactic!
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:45:17' prior: 50683485!
test12DelanteroQueTiraAColocarPierde50PorcFuerza
	
	| arquero delantero juegoPenales pelota |
	
	"La fuerza del Delantero se reduce en 50% siempre que tira a colocar... (no importa pelota, ni arquero)"
	"(delantero sacrificia potencia para ganar mayor precisión)"
	
	delantero := DelanteroConTactic decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 50.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@2 arqueroSeLanzaEnDirección: 2@2.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 2@2 equals: juegoPenales varDireccionRemateResultante.
	self assert: 50 equals: juegoPenales varFuerzaResultanteDeTiro.! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:45:17' prior: 50683416!
test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero
	
	| arquero delantero juegoPenales pelota |
	
	"La fuerza del Delantero se reduce en 50% siempre que tira a colocar... (no importa pelota, ni arquero)"
	"La humilde pelota playera le hace perder un 20% de fuerza adicional al delantero que la use para colocar... (no importa el arquero)"
	"(no debería ser reglamentaria... al menos no es de trapo, nos responden)"
	
	delantero := DelanteroConTactic decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 1.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 1@2 arqueroSeLanzaEnDirección: 1@2.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 1@2 equals: juegoPenales varDireccionRemateResultante.
	self assert: 40 equals: juegoPenales varFuerzaResultanteDeTiro! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:45:17' prior: 50683610!
test19ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAColocarEsDescubiertoYPuntoParaDelantero
	
	| arquero delantero juegoPenales pelota |
	
	"Arquero que espera y se adelanta ante tiro con la lenta pelota playera, siempre es descubierto por el Árbitro, y el punto se le otorga al Delantero..."
	"(lo que servía de ventaja ante la Jabulani rápida, acá es tan obvio por lo que tarda en llegar la pelota al arco, que marchás preso...)"
	
	delantero := DelanteroConTactic decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero  esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@0 arqueroSeLanzaEnDirección: 0@0.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 0@0 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:45:17' prior: 50683516!
test21DelanteroTiraAMatarAlAnguloSuperiorIzquierdoLaAlturaDelTiroPasaAMedio
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"(tirar a matar no es tan preciso como tirar a colocar, hay desvios de altura. Sin embargo se usa el 100% de fuerza del jugador)"
	
	delantero := DelanteroConTactic decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@2 arqueroSeLanzaEnDirección: 0@2.
	
	self assert: 0@1 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:45:17' prior: 50682649!
test28ArqueroQueEligeAntesDeTiroVsJabulaniAMatarIgnoraAlturaTiro
	
	| arquero delantero juegoPenales pelota |
	
	"El Arquero que elige donde tirarse antes de un tiro de jabulani a matar, ignora la 2da coordenada (altura) al atajar..."		
	
	delantero := DelanteroConTactic decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@2 arqueroSeLanzaEnDirección: 0@0.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 0@1 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:45:17' prior: 50683107!
test30DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAdentro
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' el Delantero usa el 100% de su fuerza... (no importa pelota, ni arquero)"
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"Si se tira 'a matar' usando una pelota playera a una dirección que no es un ángulo, la 2da coordenada del remate (altura) suma 2, es decir sale volando producto de su liviandez (y que quiere retornar al mar). Si la pelota se va fuera del arco, el puntaje va al arquero... (no importa arquero)"
	"(y voló.. y me hizo volar... y yo volé de él...  pero acá por la arbolada... y el voló.. y se estrelló por acá por la pared...)"
	
	delantero := DelanteroConTactic decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 1@0 arqueroSeLanzaEnDirección: 1@0.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 1@2 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:45:17' prior: 50683189!
test14FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAColocar
	
	| arquero delantero juegoPenales pelota |
	
	"La fuerza del Delantero se reduce en 50% siempre que tira a colocar... (no importa pelota, ni arquero)"
	"El Arquero que elige adonde tirarse antes de un tiro a colocar de jabulani gana 50% de su fuerza extra..."
	
	delantero := DelanteroConTactic decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 32.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@2 arqueroSeLanzaEnDirección: 0@2.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 0@2 equals: juegoPenales varDireccionRemateResultante.
	self assert: 50 equals: juegoPenales varFuerzaResultanteDeTiro.
	self assert: 48 equals: juegoPenales varFuerzaResultanteDeAtajada.! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:45:17' prior: 50683055!
test09DireccionesDiferentesGolDelantero
	
	| arquero delantero juegoPenales pelota |
	
	"Caso general del juego..."
	
	delantero := DelanteroConTactic decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@2 arqueroSeLanzaEnDirección: 0@1.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 2@2 equals: juegoPenales varDireccionRemateResultante
	"varXXXX es por VAR, de 'Video Assistant Referee'"! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:45:17' prior: 50682712!
test27FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAMatar
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' el Delantero usa el 100% de su fuerza... (no importa pelota, ni arquero)"
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"Si se tira 'a matar' usando la jabulani rápida, el Delantero gana un 20% de fuerza extra... (no importa arquero)"
	
	delantero := DelanteroConTactic decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 119.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@2 arqueroSeLanzaEnDirección: 2@1.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 2@1 equals: juegoPenales varDireccionRemateResultante.
	self assert: 120 equals: juegoPenales varFuerzaResultanteDeTiro.! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:45:17' prior: 50682593!
test20DelanteroTiraAMatarAlAnguloInferiorIzquierdoLaAlturaDelTiroPasaAMedio
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"(tirar a matar no es tan preciso como tirar a colocar, hay desvios de altura. Sin embargo se usa el 100% de fuerza del jugador)"
	
	delantero := DelanteroConTactic decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@0 arqueroSeLanzaEnDirección: 0@0.
	.
	self assert: 0@1 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:45:17' prior: 50682858!
test26DelanteroTiraAMatarConJabulaniGana20PorcFuerzaExtra
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' el Delantero usa el 100% de su fuerza... (no importa pelota, ni arquero)"
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"Si se tira 'a matar' usando la jabulani rápida, el Delantero gana un 20% de fuerza extra... (no importa arquero)"
	"(Jabulani a matar es la elección de los guerreros Z)"
	
	delantero := DelanteroConTactic decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 120.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@2 arqueroSeLanzaEnDirección: 2@1.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 2@1 equals: juegoPenales varDireccionRemateResultante.
	self assert: 120 equals: juegoPenales varFuerzaResultanteDeTiro.! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:45:17' prior: 50683305!
test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' el Delantero usa el 100% de su fuerza... (no importa pelota, ni arquero)"
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"Si se tira 'a matar' usando una pelota playera a una dirección que no es un ángulo, la 2da coordenada del remate (altura) suma 2, es decir sale volando producto de su liviandez (y que quiere retornar al mar). Si la pelota se va fuera del arco, el puntaje va al arquero... (no importa arquero)"
	"(El caso auspiciado por el Pipita...)"
	
	delantero := DelanteroConTactic decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@1 arqueroSeLanzaEnDirección: 0@0.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 0@3 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:45:17' prior: 50682750!
test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' el Delantero usa el 100% de su fuerza... (no importa pelota, ni arquero)"
	"Si se tira 'a matar' usando una pelota playera a una dirección que no es un ángulo, la 2da coordenada del remate (altura) suma 2, es decir sale volando producto de su liviandez (y que quiere retornar al mar). Si la pelota se va fuera del arco, el puntaje va al arquero... (no importa arquero)"
	"Si el arquero elige donde tirarse antes del tiro a matar de la pelota playera, ignora la 1ra coordenada del remate (ancho) al atajar..."
	"(con agacharse, quedarse parado, o saltar le alcanza...)"
	
	delantero := DelanteroConTactic decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 1@0 arqueroSeLanzaEnDirección: 0@2.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 1@2 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:45:17' prior: 50683546!
test25DelanteroTiraAMatarUsa100PorcFuerzaBase
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"(tirar a matar no es tan preciso como tirar a colocar, hay desvios de altura. Sin embargo se usa el 100% de fuerza del jugador)"
	
	delantero := DelanteroConTactic decideTirarAMatarSuFuerzaBaseEs:150.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@0 arqueroSeLanzaEnDirección: 2@0.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 2@1 equals: juegoPenales varDireccionRemateResultante.
	self assert: 150 equals: juegoPenales varFuerzaResultanteDeTiro! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:45:18' prior: 50682948!
test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra
	
	| arquero delantero juegoPenales pelota |
	
	"La fuerza del Delantero se reduce en 50% siempre que tira a colocar... (no importa pelota, ni arquero)"
	"El Arquero que elige donde tirarse antes de un tiro a colocar de jabulani gana 50% de su fuerza extra..."
	"(el arquero llega más cómodo y aprovecha mejor su fuerza)"
	
	delantero := DelanteroConTactic decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 34.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@2 arqueroSeLanzaEnDirección: 0@2.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 0@2 equals: juegoPenales varDireccionRemateResultante.
	self assert: 50 equals: juegoPenales varFuerzaResultanteDeTiro.
	self assert: 51 equals: juegoPenales varFuerzaResultanteDeAtajada.! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:45:18' prior: 50683225!
test11MismasDireccionesSuficienteFuerzaAtajaArquero
	
	| arquero delantero juegoPenales pelota |
	
	"Caso general del juego..."
	
	delantero := DelanteroConTactic decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@2 arqueroSeLanzaEnDirección: 2@2.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 2@2 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:45:18' prior: 50683580!
test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"(tirar a matar no es tan preciso como tirar a colocar, hay desvios de altura. Sin embargo se usa el 100% de fuerza del jugador)"
	
	delantero := DelanteroConTactic decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@0 arqueroSeLanzaEnDirección: 2@0.
	
	self assert: 2@1 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:45:18' prior: 50683250!
test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"(tirar a matar no es tan preciso como tirar a colocar, hay desvios de altura. Sin embargo se usa el 100% de fuerza del jugador)"
	
	delantero := DelanteroConTactic decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 1@2 arqueroSeLanzaEnDirección: 1@1.

	self assert: 1@2 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:45:18' prior: 50683375!
test17ArqueroQueEligeAntesDeTiroVsPlayeraAColocarSuma100PorcFuerzaExtra
	
	| arquero delantero juegoPenales pelota |
	
	"La fuerza del Delantero se reduce en 50% siempre que tira a colocar... (no importa pelota, ni arquero)"
	"La humilde pelota playera le hace perder un 20% adicional de fuerza al delantero que la use para colocar... (no importa el arquero)"
	"Arquero que elige donde lanzarse antes de un remate de una pelota playera lenta a colocar, gana un 100% de su fuerza extra..."
	"(a quien madruga...)"
	
	delantero := DelanteroConTactic decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 20.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@0 arqueroSeLanzaEnDirección: 0@0.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 0@0 equals: juegoPenales varDireccionRemateResultante.
	self assert: 40 equals: juegoPenales varFuerzaResultanteDeTiro.
	self assert: 40 equals: juegoPenales varFuerzaResultanteDeAtajada! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:45:18' prior: 50682923!
test10MismasDireccionesInsuficienteFuerzaGolDelantero
	
	| arquero delantero juegoPenales pelota |
	
	"Caso general del juego..."
	
	delantero := DelanteroConTactic decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 10.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@2 arqueroSeLanzaEnDirección: 2@2.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 2@2 equals: juegoPenales varDireccionRemateResultante! !
!Delantero class methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:45:18' prior: 50683811!
decideTirarAColocarSuFuerzaBaseEs: fuerzaJugador
	^DelanteroConTactic new initializeDecideTirarAColocarSuFuerzaBaseEs: fuerzaJugador.
! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:45:18' prior: 50683015!
test18FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsPlayeraAColocar
	
	| arquero delantero juegoPenales pelota |
	
	"La fuerza del Delantero se reduce en 50% siempre que tira a colocar... (no importa pelota, ni arquero)"
	"La humilde pelota playera le hace perder un 20% adicional de fuerza al delantero que la use para colocar... (no importa el arquero)"
	"Arquero que elige donde lanzarse antes de un remate de una pelota playera lenta a colocar, gana un 100% de su fuerza extra..."
	
	delantero := DelanteroConTactic decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 19.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@0 arqueroSeLanzaEnDirección: 0@0.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 0@0 equals: juegoPenales varDireccionRemateResultante.
	self assert: 40 equals: juegoPenales varFuerzaResultanteDeTiro.
	self assert: 38 equals: juegoPenales varFuerzaResultanteDeAtajada! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:45:18' prior: 50682793!
test32ArqueroQueEligeAntesDeTiroVsPlayeraAMatarAlAnguloIgnoraAnchoTiro
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' el Delantero usa el 100% de su fuerza... (no importa pelota, ni arquero)"
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"Si el arquero elige donde tirarse antes del tiro a matar de la pelota playera, ignora la 1ra coordenada del remate (ancho) al atajar..."
	"(con agacharse, quedarse parado, o saltar le alcanza...)"
	
	delantero := DelanteroConTactic decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@0 arqueroSeLanzaEnDirección: 2@1.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 0@1 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:45:18' prior: 50682985!
test23DelanteroTiraAMatarAlAnguloSuperiorDerechoLaAlturaDelTiroPasaAMedio
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"(tirar a matar no es tan preciso como tirar a colocar, hay desvios de altura. Sin embargo se usa el 100% de fuerza del jugador)"
	
	delantero := DelanteroConTactic decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@2 arqueroSeLanzaEnDirección: 2@2.
	
	self assert: 2@1 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:45:18' prior: 50682677!
test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro
	
	| arquero delantero juegoPenales pelota |
	
	"La fuerza del Delantero se reduce en 50% siempre que tira a colocar... (no importa pelota, ni arquero)"
	"El Arquero que espera y se adelanta ante un tiro de jabulani a colocar ignora la 2da coordenada (altura) al atajar..."	
	"(al adelanterse encara la pelota antes de que su elevación se transforme en un problema)"
	
	delantero := DelanteroConTactic decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero  esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 50.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@2 arqueroSeLanzaEnDirección: 0@0.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 0@2 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:45:18' prior: 50683153!
test34ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAMatarSiempreAtaja
	
	| arquero delantero juegoPenales pelota |
	
	"El Arquero que espera y se adelanta ante una pelota playera lenta a matar, siempre la ataja sin importar nada..."	
	"(como la pelota es taaaan lentaaa, el arquero se puede ir a tomar un cafe, verse una serie, volver y aún atajar la pelota habiendose tirado a cualquier lado. Pero igual es más rapida que cuando se la tira a colocar, donde indefectiblemente el arbitro lo detecta...)"
	
	delantero := DelanteroConTactic decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 1.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@2 arqueroSeLanzaEnDirección: 0@0.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 2@1 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:45:18' prior: 50683279!
test07ArqueroNoPuedeMeterseAbajoDeLaTierra
	
	| arquero delantero juegoPenales pelota |
	
	delantero := DelanteroConTactic decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	self 
		should: [ juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@0 arqueroSeLanzaEnDirección: 0@-1.] 
		raise: Error
		withExceptionDo: [ :error |
			self assert: Penales direccionArqueroFueraDeRango equals: error messageText.
			self assert: 0 equals: juegoPenales puntajeDeDelantero.
			self assert: 0 equals: juegoPenales puntajeDeArquero.]
	! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:45:18' prior: 50683452!
test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja
	
	| arquero delantero juegoPenales pelota |
	
	"El Arquero que espera a ver la dirección del remate de una pelota jabulani rápida a matar antes de lanzarse, nunca la ataja sin importar nada, siquiera que se adelantó..."	
	"(su poder era de más de 9000!! era impresionante, no podía moverme, sólo la ví pasar... f )"
	
	delantero := DelanteroConTactic decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 1@1 arqueroSeLanzaEnDirección: 1@1.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 1@1 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:45:18' prior: 50682567!
test08ArqueroNoPuedeSaltarPorEncimaDelTravesaño
	
	| arquero delantero juegoPenales pelota |
	
	delantero := DelanteroConTactic decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	self 
		should: [ juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@0 arqueroSeLanzaEnDirección: 0@3.] 
		raise: Error
		withExceptionDo: [ :error |
			self assert: Penales direccionArqueroFueraDeRango equals: error messageText.
			self assert: 0 equals: juegoPenales puntajeDeDelantero.
			self assert: 0 equals: juegoPenales puntajeDeArquero.]
	! !

Object subclass: #PelotaDePenalti
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classDefinition: #PelotaDePenalti category: 'ISW1-2023-2C-Parcial-1' stamp: 'LK 9/25/2023 20:45:51'!
Object subclass: #PelotaDePenalti
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

PelotaDePenalti subclass: #PJabulani
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classDefinition: #PJabulani category: 'ISW1-2023-2C-Parcial-1' stamp: 'LK 9/25/2023 20:46:15'!
PelotaDePenalti subclass: #PJabulani
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

PelotaDePenalti subclass: #PPlayera
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classDefinition: #PPlayera category: 'ISW1-2023-2C-Parcial-1' stamp: 'LK 9/25/2023 20:46:20'!
PelotaDePenalti subclass: #PPlayera
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!
!PJabulani methodsFor: 'nil' stamp: 'LK 9/25/2023 20:46:40'!
verFuerzaConArquero: unArquero
	^unArquero fuerzaResultanteContraJabulani.! !
!PJabulani methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:46:49' prior: 50685219!
verFuerzaConArquero: unArquero
	^unArquero fuerzaResultanteContraJabulani.! !
!PJabulani methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:46:56'!
verFuerzaConTirador: unTirador
	^unTirador fuerzaResultanteConJabulani.! !
!PPlayera methodsFor: 'nil' stamp: 'LK 9/25/2023 20:47:05'!
verFuerzaConTirador: unTirador
	^unTirador fuerzaResultanteConPlayera.! !
!PPlayera methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:47:28'!
initializePlayeraLentaCostaAzul! !
!PJabulani methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:47:40'!
initializeJabulaniSudafricanaRapida! !

!classRemoval: #Playera stamp: 'LK 9/25/2023 20:47:44'!
Pelota subclass: #Playera
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classRemoval: #Jabulani stamp: 'LK 9/25/2023 20:47:53'!
Pelota subclass: #Jabulani
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!methodRemoval: Pelota #verFuerzaConTirador: stamp: 'LK 9/25/2023 20:48:33'!
verFuerzaConTirador: unTirador

	self subclassResponsibility!
!Pelota class methodsFor: 'no messages' stamp: 'LK 9/25/2023 20:49:27'!
jabulaniSudafricanaRapida
	^PJabulani new.! !
!Pelota class methodsFor: 'as yet unclassified' stamp: 'LK 9/25/2023 20:49:51'!
playeraLentaCostaAzul
	^PPlayera new.! !
!PenalesTest methodsFor: 'tests' stamp: 'LK 9/25/2023 20:51:14' prior: 50685098!
test07ArqueroNoPuedeMeterseAbajoDeLaTierra
	
	| arquero delantero juegoPenales pelota |
	
	delantero := Delantero decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	self 
		should: [ juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@0 arqueroSeLanzaEnDirección: 0@-1.] 
		raise: Error
		withExceptionDo: [ :error |
			self assert: Penales direccionArqueroFueraDeRango equals: error messageText.
			self assert: 0 equals: juegoPenales puntajeDeDelantero.
			self assert: 0 equals: juegoPenales puntajeDeArquero.]
	! !
!PenalesTest methodsFor: 'tests' stamp: 'LK 9/25/2023 20:51:18' prior: 50685157!
test08ArqueroNoPuedeSaltarPorEncimaDelTravesaño
	
	| arquero delantero juegoPenales pelota |
	
	delantero := Delantero decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	self 
		should: [ juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@0 arqueroSeLanzaEnDirección: 0@3.] 
		raise: Error
		withExceptionDo: [ :error |
			self assert: Penales direccionArqueroFueraDeRango equals: error messageText.
			self assert: 0 equals: juegoPenales puntajeDeDelantero.
			self assert: 0 equals: juegoPenales puntajeDeArquero.]
	! !
!PenalesTest methodsFor: 'tests' stamp: 'LK 9/25/2023 20:51:24' prior: 50684473!
test09DireccionesDiferentesGolDelantero
	
	| arquero delantero juegoPenales pelota |
	
	"Caso general del juego..."
	
	delantero := Delantero decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@2 arqueroSeLanzaEnDirección: 0@1.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 2@2 equals: juegoPenales varDireccionRemateResultante
	"varXXXX es por VAR, de 'Video Assistant Referee'"! !
!PenalesTest methodsFor: 'tests' stamp: 'LK 9/25/2023 20:51:29' prior: 50684887!
test10MismasDireccionesInsuficienteFuerzaGolDelantero
	
	| arquero delantero juegoPenales pelota |
	
	"Caso general del juego..."
	
	delantero := Delantero decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 10.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@2 arqueroSeLanzaEnDirección: 2@2.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 2@2 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'tests' stamp: 'LK 9/25/2023 20:51:32' prior: 50684763!
test11MismasDireccionesSuficienteFuerzaAtajaArquero
	
	| arquero delantero juegoPenales pelota |
	
	"Caso general del juego..."
	
	delantero := Delantero decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@2 arqueroSeLanzaEnDirección: 2@2.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 2@2 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'tests' stamp: 'LK 9/25/2023 20:51:39' prior: 50684233!
test12DelanteroQueTiraAColocarPierde50PorcFuerza
	
	| arquero delantero juegoPenales pelota |
	
	"La fuerza del Delantero se reduce en 50% siempre que tira a colocar... (no importa pelota, ni arquero)"
	"(delantero sacrificia potencia para ganar mayor precisión)"
	
	delantero := Delantero decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 50.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@2 arqueroSeLanzaEnDirección: 2@2.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 2@2 equals: juegoPenales varDireccionRemateResultante.
	self assert: 50 equals: juegoPenales varFuerzaResultanteDeTiro.! !
!PenalesTest methodsFor: 'tests' stamp: 'LK 9/25/2023 20:51:48' prior: 50684726!
test13ArqueroQueEligeAntesDeTiroVsJabulaniAColocarSuma50PorcFuerzaExtra
	
	| arquero delantero juegoPenales pelota |
	
	"La fuerza del Delantero se reduce en 50% siempre que tira a colocar... (no importa pelota, ni arquero)"
	"El Arquero que elige donde tirarse antes de un tiro a colocar de jabulani gana 50% de su fuerza extra..."
	"(el arquero llega más cómodo y aprovecha mejor su fuerza)"
	
	delantero := Delantero decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 34.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@2 arqueroSeLanzaEnDirección: 0@2.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 0@2 equals: juegoPenales varDireccionRemateResultante.
	self assert: 50 equals: juegoPenales varFuerzaResultanteDeTiro.
	self assert: 51 equals: juegoPenales varFuerzaResultanteDeAtajada.! !
!PenalesTest methodsFor: 'tests' stamp: 'LK 9/25/2023 20:51:51' prior: 50684438!
test14FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAColocar
	
	| arquero delantero juegoPenales pelota |
	
	"La fuerza del Delantero se reduce en 50% siempre que tira a colocar... (no importa pelota, ni arquero)"
	"El Arquero que elige adonde tirarse antes de un tiro a colocar de jabulani gana 50% de su fuerza extra..."
	
	delantero := Delantero decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 32.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@2 arqueroSeLanzaEnDirección: 0@2.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 0@2 equals: juegoPenales varDireccionRemateResultante.
	self assert: 50 equals: juegoPenales varFuerzaResultanteDeTiro.
	self assert: 48 equals: juegoPenales varFuerzaResultanteDeAtajada.! !
!PenalesTest methodsFor: 'tests' stamp: 'LK 9/25/2023 20:51:55' prior: 50685027!
test15ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAColocarIgnoraAlturaTiro
	
	| arquero delantero juegoPenales pelota |
	
	"La fuerza del Delantero se reduce en 50% siempre que tira a colocar... (no importa pelota, ni arquero)"
	"El Arquero que espera y se adelanta ante un tiro de jabulani a colocar ignora la 2da coordenada (altura) al atajar..."	
	"(al adelanterse encara la pelota antes de que su elevación se transforme en un problema)"
	
	delantero := Delantero decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero  esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 50.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@2 arqueroSeLanzaEnDirección: 0@0.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 0@2 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'tests' stamp: 'LK 9/25/2023 20:51:59' prior: 50684264!
test16PelotaPlayeraUsadaAColocarLeHacePerder20PorcFuerzaExtraAlDelantero
	
	| arquero delantero juegoPenales pelota |
	
	"La fuerza del Delantero se reduce en 50% siempre que tira a colocar... (no importa pelota, ni arquero)"
	"La humilde pelota playera le hace perder un 20% de fuerza adicional al delantero que la use para colocar... (no importa el arquero)"
	"(no debería ser reglamentaria... al menos no es de trapo, nos responden)"
	
	delantero := Delantero decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 1.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 1@2 arqueroSeLanzaEnDirección: 1@2.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 1@2 equals: juegoPenales varDireccionRemateResultante.
	self assert: 40 equals: juegoPenales varFuerzaResultanteDeTiro! !
!PenalesTest methodsFor: 'tests' stamp: 'LK 9/25/2023 20:52:03' prior: 50684846!
test17ArqueroQueEligeAntesDeTiroVsPlayeraAColocarSuma100PorcFuerzaExtra
	
	| arquero delantero juegoPenales pelota |
	
	"La fuerza del Delantero se reduce en 50% siempre que tira a colocar... (no importa pelota, ni arquero)"
	"La humilde pelota playera le hace perder un 20% adicional de fuerza al delantero que la use para colocar... (no importa el arquero)"
	"Arquero que elige donde lanzarse antes de un remate de una pelota playera lenta a colocar, gana un 100% de su fuerza extra..."
	"(a quien madruga...)"
	
	delantero := Delantero decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 20.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@0 arqueroSeLanzaEnDirección: 0@0.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 0@0 equals: juegoPenales varDireccionRemateResultante.
	self assert: 40 equals: juegoPenales varFuerzaResultanteDeTiro.
	self assert: 40 equals: juegoPenales varFuerzaResultanteDeAtajada! !
!PenalesTest methodsFor: 'tests' stamp: 'LK 9/25/2023 20:52:08' prior: 50684920!
test18FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsPlayeraAColocar
	
	| arquero delantero juegoPenales pelota |
	
	"La fuerza del Delantero se reduce en 50% siempre que tira a colocar... (no importa pelota, ni arquero)"
	"La humilde pelota playera le hace perder un 20% adicional de fuerza al delantero que la use para colocar... (no importa el arquero)"
	"Arquero que elige donde lanzarse antes de un remate de una pelota playera lenta a colocar, gana un 100% de su fuerza extra..."
	
	delantero := Delantero decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 19.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@0 arqueroSeLanzaEnDirección: 0@0.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 0@0 equals: juegoPenales varDireccionRemateResultante.
	self assert: 40 equals: juegoPenales varFuerzaResultanteDeTiro.
	self assert: 38 equals: juegoPenales varFuerzaResultanteDeAtajada! !
!PenalesTest methodsFor: 'tests' stamp: 'LK 9/25/2023 20:52:15' prior: 50684300!
test19ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAColocarEsDescubiertoYPuntoParaDelantero
	
	| arquero delantero juegoPenales pelota |
	
	"Arquero que espera y se adelanta ante tiro con la lenta pelota playera, siempre es descubierto por el Árbitro, y el punto se le otorga al Delantero..."
	"(lo que servía de ventaja ante la Jabulani rápida, acá es tan obvio por lo que tarda en llegar la pelota al arco, que marchás preso...)"
	
	delantero := Delantero decideTirarAColocarSuFuerzaBaseEs: 100.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero  esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@0 arqueroSeLanzaEnDirección: 0@0.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 0@0 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'tests' stamp: 'LK 9/25/2023 20:52:19' prior: 50684537!
test20DelanteroTiraAMatarAlAnguloInferiorIzquierdoLaAlturaDelTiroPasaAMedio
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"(tirar a matar no es tan preciso como tirar a colocar, hay desvios de altura. Sin embargo se usa el 100% de fuerza del jugador)"
	
	delantero := Delantero decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@0 arqueroSeLanzaEnDirección: 0@0.
	.
	self assert: 0@1 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'tests' stamp: 'LK 9/25/2023 20:52:23' prior: 50684334!
test21DelanteroTiraAMatarAlAnguloSuperiorIzquierdoLaAlturaDelTiroPasaAMedio
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"(tirar a matar no es tan preciso como tirar a colocar, hay desvios de altura. Sin embargo se usa el 100% de fuerza del jugador)"
	
	delantero := Delantero decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@2 arqueroSeLanzaEnDirección: 0@2.
	
	self assert: 0@1 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'tests' stamp: 'LK 9/25/2023 20:52:26' prior: 50684788!
test22DelanteroTiraAMatarAlAnguloInferiorDerechoLaAlturaDelTiroPasaAMedio
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"(tirar a matar no es tan preciso como tirar a colocar, hay desvios de altura. Sin embargo se usa el 100% de fuerza del jugador)"
	
	delantero := Delantero decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@0 arqueroSeLanzaEnDirección: 2@0.
	
	self assert: 2@1 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'tests' stamp: 'LK 9/25/2023 20:52:30' prior: 50684998!
test23DelanteroTiraAMatarAlAnguloSuperiorDerechoLaAlturaDelTiroPasaAMedio
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"(tirar a matar no es tan preciso como tirar a colocar, hay desvios de altura. Sin embargo se usa el 100% de fuerza del jugador)"
	
	delantero := Delantero decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@2 arqueroSeLanzaEnDirección: 2@2.
	
	self assert: 2@1 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'tests' stamp: 'LK 9/25/2023 20:52:37' prior: 50684817!
test24DelanteroTiraAMatarNoAlAnguloMantieneDireccionTiro
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"(tirar a matar no es tan preciso como tirar a colocar, hay desvios de altura. Sin embargo se usa el 100% de fuerza del jugador)"
	
	delantero := Delantero decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 1@2 arqueroSeLanzaEnDirección: 1@1.

	self assert: 1@2 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'tests' stamp: 'LK 9/25/2023 20:52:41' prior: 50684692!
test25DelanteroTiraAMatarUsa100PorcFuerzaBase
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"(tirar a matar no es tan preciso como tirar a colocar, hay desvios de altura. Sin embargo se usa el 100% de fuerza del jugador)"
	
	delantero := Delantero decideTirarAMatarSuFuerzaBaseEs:150.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@0 arqueroSeLanzaEnDirección: 2@0.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 2@1 equals: juegoPenales varDireccionRemateResultante.
	self assert: 150 equals: juegoPenales varFuerzaResultanteDeTiro! !
!PenalesTest methodsFor: 'tests' stamp: 'LK 9/25/2023 20:52:45' prior: 50684567!
test26DelanteroTiraAMatarConJabulaniGana20PorcFuerzaExtra
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' el Delantero usa el 100% de su fuerza... (no importa pelota, ni arquero)"
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"Si se tira 'a matar' usando la jabulani rápida, el Delantero gana un 20% de fuerza extra... (no importa arquero)"
	"(Jabulani a matar es la elección de los guerreros Z)"
	
	delantero := Delantero decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 120.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@2 arqueroSeLanzaEnDirección: 2@1.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 2@1 equals: juegoPenales varDireccionRemateResultante.
	self assert: 120 equals: juegoPenales varFuerzaResultanteDeTiro.! !
!PenalesTest methodsFor: 'tests' stamp: 'LK 9/25/2023 20:52:48' prior: 50684499!
test27FuerzaInsuficienteDeArqueroQueEligeAntesDeTiroVsJabulaniAMatar
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' el Delantero usa el 100% de su fuerza... (no importa pelota, ni arquero)"
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"Si se tira 'a matar' usando la jabulani rápida, el Delantero gana un 20% de fuerza extra... (no importa arquero)"
	
	delantero := Delantero decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 119.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@2 arqueroSeLanzaEnDirección: 2@1.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 2@1 equals: juegoPenales varDireccionRemateResultante.
	self assert: 120 equals: juegoPenales varFuerzaResultanteDeTiro.! !
!PenalesTest methodsFor: 'tests' stamp: 'LK 9/25/2023 20:52:51' prior: 50684364!
test28ArqueroQueEligeAntesDeTiroVsJabulaniAMatarIgnoraAlturaTiro
	
	| arquero delantero juegoPenales pelota |
	
	"El Arquero que elige donde tirarse antes de un tiro de jabulani a matar, ignora la 2da coordenada (altura) al atajar..."		
	
	delantero := Delantero decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@2 arqueroSeLanzaEnDirección: 0@0.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 0@1 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'tests' stamp: 'LK 9/25/2023 20:52:55' prior: 50685124!
test29ArqueroQueEsperaPorTiroYSeAdelantaVsJabulaniAMatarNuncaAtaja
	
	| arquero delantero juegoPenales pelota |
	
	"El Arquero que espera a ver la dirección del remate de una pelota jabulani rápida a matar antes de lanzarse, nunca la ataja sin importar nada, siquiera que se adelantó..."	
	"(su poder era de más de 9000!! era impresionante, no podía moverme, sólo la ví pasar... f )"
	
	delantero := Delantero decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota jabulaniSudafricanaRapida.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 1@1 arqueroSeLanzaEnDirección: 1@1.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 1@1 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'tests' stamp: 'LK 9/25/2023 20:52:58' prior: 50684392!
test30DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAdentro
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' el Delantero usa el 100% de su fuerza... (no importa pelota, ni arquero)"
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"Si se tira 'a matar' usando una pelota playera a una dirección que no es un ángulo, la 2da coordenada del remate (altura) suma 2, es decir sale volando producto de su liviandez (y que quiere retornar al mar). Si la pelota se va fuera del arco, el puntaje va al arquero... (no importa arquero)"
	"(y voló.. y me hizo volar... y yo volé de él...  pero acá por la arbolada... y el voló.. y se estrelló por acá por la pared...)"
	
	delantero := Delantero decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 1@0 arqueroSeLanzaEnDirección: 1@0.
	
	self assert: 1 equals: juegoPenales puntajeDeDelantero.
	self assert: 0 equals: juegoPenales puntajeDeArquero.
	self assert: 1@2 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'tests' stamp: 'LK 9/25/2023 20:53:01' prior: 50684606!
test31DelanteroQueNoPateaAlAnguloConPlayeraAMatarSuma2AAlturaDeDireccionPelotaAfuera
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' el Delantero usa el 100% de su fuerza... (no importa pelota, ni arquero)"
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"Si se tira 'a matar' usando una pelota playera a una dirección que no es un ángulo, la 2da coordenada del remate (altura) suma 2, es decir sale volando producto de su liviandez (y que quiere retornar al mar). Si la pelota se va fuera del arco, el puntaje va al arquero... (no importa arquero)"
	"(El caso auspiciado por el Pipita...)"
	
	delantero := Delantero decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 200.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@1 arqueroSeLanzaEnDirección: 0@0.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 0@3 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'tests' stamp: 'LK 9/25/2023 20:53:05' prior: 50684960!
test32ArqueroQueEligeAntesDeTiroVsPlayeraAMatarAlAnguloIgnoraAnchoTiro
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' el Delantero usa el 100% de su fuerza... (no importa pelota, ni arquero)"
	"Si se tira 'a matar' a los ángulos, la 2da coordenada (altura) del remate pasa a 1 (altura media)... (no importa pelota, ni arquero)"	
	"Si el arquero elige donde tirarse antes del tiro a matar de la pelota playera, ignora la 1ra coordenada del remate (ancho) al atajar..."
	"(con agacharse, quedarse parado, o saltar le alcanza...)"
	
	delantero := Delantero decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 0@0 arqueroSeLanzaEnDirección: 2@1.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 0@1 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'tests' stamp: 'LK 9/25/2023 20:53:08' prior: 50684649!
test33ArqueroQueEligeAntesDeTiroVsPlayeraAMatarNoAlAnguloIgnoraAnchoTiro
	
	| arquero delantero juegoPenales pelota |
	
	"Si se tira 'a matar' el Delantero usa el 100% de su fuerza... (no importa pelota, ni arquero)"
	"Si se tira 'a matar' usando una pelota playera a una dirección que no es un ángulo, la 2da coordenada del remate (altura) suma 2, es decir sale volando producto de su liviandez (y que quiere retornar al mar). Si la pelota se va fuera del arco, el puntaje va al arquero... (no importa arquero)"
	"Si el arquero elige donde tirarse antes del tiro a matar de la pelota playera, ignora la 1ra coordenada del remate (ancho) al atajar..."
	"(con agacharse, quedarse parado, o saltar le alcanza...)"
	
	delantero := Delantero decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero eligeDireccionAntesDeTiroSuFuerzaBaseEs: 100.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 1@0 arqueroSeLanzaEnDirección: 0@2.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 1@2 equals: juegoPenales varDireccionRemateResultante! !
!PenalesTest methodsFor: 'tests' stamp: 'LK 9/25/2023 20:53:14' prior: 50685062!
test34ArqueroQueEsperaPorTiroYSeAdelantaVsPlayeraAMatarSiempreAtaja
	
	| arquero delantero juegoPenales pelota |
	
	"El Arquero que espera y se adelanta ante una pelota playera lenta a matar, siempre la ataja sin importar nada..."	
	"(como la pelota es taaaan lentaaa, el arquero se puede ir a tomar un cafe, verse una serie, volver y aún atajar la pelota habiendose tirado a cualquier lado. Pero igual es más rapida que cuando se la tira a colocar, donde indefectiblemente el arbitro lo detecta...)"
	
	delantero := Delantero decideTirarAMatarSuFuerzaBaseEs:100.
	pelota := Pelota playeraLentaCostaAzul.
	arquero := Arquero esperaPorTiroYSeAdelantaSuFuerzaBaseEs: 1.
	
	juegoPenales := Penales conDelantero: delantero yArquero: arquero.
	
	juegoPenales arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: 2@2 arqueroSeLanzaEnDirección: 0@0.
	
	self assert: 0 equals: juegoPenales puntajeDeDelantero.
	self assert: 1 equals: juegoPenales puntajeDeArquero.
	self assert: 2@1 equals: juegoPenales varDireccionRemateResultante! !

Object subclass: #Arquero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classDefinition: #Arquero category: 'ISW1-2023-2C-Parcial-1' stamp: 'LK 9/25/2023 21:00:38'!
Object subclass: #Arquero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!methodRemoval: Arquero #fuerza stamp: 'LK 9/25/2023 21:00:41'!
fuerza
	^fuerza!

!methodRemoval: Arquero #fuerzaResultanteContraJabulani stamp: 'LK 9/25/2023 21:00:47'!
fuerzaResultanteContraJabulani

	self subclassResponsibility!

!methodRemoval: Arquero #fuerzaResultanteContraPlayera stamp: 'LK 9/25/2023 21:00:49'!
fuerzaResultanteContraPlayera

	self subclassResponsibility!

!methodRemoval: DelanteroConTactic class #decideTirarAColocarSuFuerzaBaseEs: stamp: 'LK 9/25/2023 21:01:07'!
decideTirarAColocarSuFuerzaBaseEs: fuerzaJugador
	^self new initializeDecideTirarAColocarSuFuerzaBaseEs: fuerzaJugador.
!

!methodRemoval: DelanteroConTactic class #decideTirarAMatarSuFuerzaBaseEs: stamp: 'LK 9/25/2023 21:01:11'!
decideTirarAMatarSuFuerzaBaseEs: fuerzaJugador
	^self new initializeDecideTirarAMatarSuFuerzaBaseEs: fuerzaJugador !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 21:06:15'!
arqueroSeAdelantaConPlayera
	^self sumarPuntoDelantero! !

!methodRemoval: AMatar #fuerza stamp: 'LK 9/25/2023 21:09:48'!
fuerza
	^fuerza!
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 21:11:39' prior: 50684093!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(self direccionEnRango: direccionTiro) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(self direccionEnRango: direccionArquero) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	(pelota tipo = #Jabulani) ifTrue: [
			penalPelota := #Jabulani.
			
		(delantero tipo = #AMatar) ifTrue: [self sumarPuntoDelantero].
		
		(arquero tipo = #EsperaYAdelanta) ifTrue: [
				((direccionTiro) x = (direccionArquero x) & 
				(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro))
				 	ifTrue: [self sumarPuntoArquero]]
					
				ifFalse: [(direccionTiro = direccionArquero) & 
				(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro) 
					ifTrue: [self sumarPuntoDelantero].
					
			].
		
		(arquero tipo = #Elige) ifTrue: [
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro ))
					ifTrue: [self sumarPuntoArquero].
			
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro )) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
		].
	(pelota = #Playera) ifTrue: [
			
			penalPelota := #Playera.
			
			(arquero tipo = #Elige) ifTrue: [
				
				(direccionTiro = direccionArquero & 
				self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro)
					ifTrue: [self sumarPuntoArquero].
			
				(direccionTiro = direccionArquero & 
				self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
			(arquero tipo = #EsperaYadelanta) ifTrue: [self sumarPuntoDelantero].
				
		].
			
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !
!Penales methodsFor: 'ayuda diseñador del juego' stamp: 'LK 9/25/2023 21:13:21' prior: 50686239!
arbitroPitaConPelota: pelota delanteroRemataAlArcoConDireccion: direccionTiro arqueroSeLanzaEnDirección: direccionArquero

	"Hola de nuevo!!"
	"Bueno, yo soy sólo el diseñador del juego pero ojo que algo de programación sé, eh?"
	"Te tiro una mano... para mi esto sale más o menos así:"
	
	direccionDelTiroDelantero := direccionTiro.
	direccionDelArquero := direccionArquero.
	
	(self direccionEnRango: direccionTiro) ifFalse: [^self error: Penales direccionTiroFueraDeRango].	
	
	(self direccionEnRango: direccionArquero) ifFalse: [^self error: Penales direccionArqueroFueraDeRango].
	
	((direccionTiro = direccionArquero) not) ifTrue: [self sumarPuntoDelantero].
	
	(pelota tipo = #Jabulani) ifTrue: [
		penalPelota := #Jabulani.
		
		(arquero tipo = #EsperaYAdelanta) ifTrue: [
				((direccionTiro) x = (direccionArquero x) & 
				(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro))
				 	ifTrue: [self sumarPuntoArquero]]
					
				ifFalse: [(direccionTiro = direccionArquero) & 
				(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro) 
					ifTrue: [self sumarPuntoDelantero].
					
			].
		
		(arquero tipo = #Elige) ifTrue: [
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro ))
					ifTrue: [self sumarPuntoArquero].
			
			(direccionTiro = direccionArquero & 
			(self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro )) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
		].
	(pelota = #Playera) ifTrue: [
			
			penalPelota := #Playera.
			
			(arquero tipo = #Elige) ifTrue: [
				
				(direccionTiro = direccionArquero & 
				self varFuerzaResultanteDeAtajada >= self varFuerzaResultanteDeTiro)
					ifTrue: [self sumarPuntoArquero].
			
				(direccionTiro = direccionArquero & 
				self varFuerzaResultanteDeAtajada < self varFuerzaResultanteDeTiro) 
					ifTrue: [self sumarPuntoDelantero].
			].
		
			(arquero tipo = #EsperaYadelanta) ifTrue: [self sumarPuntoDelantero].
				
		].
			
	
	"[asserts, chequeos de errores, etc..].
	
	[inicialización de ''cosas'' que se modifican dependiendo de los ifs de abajo... Por ej la fuerza del jugador o del arquero iniciales pueden cambiar segun el escenario del test en cuestión].
	
	xxx = #AColocar ifTrue:[
		[Lo que sea que aplica sólo para estos tiros, si algo...],
		yyy = #Jabulani ifTrue: [
			[lo que sea que aplique para estos tiros y la pelota, si algo...]
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[Caso específico de los tres al mismo tiempo...].
			zzz = #EsperaTiroYSeAdelanta ifTrue: 
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	xxx = #AMatar ifTrue:[
		[...].
		yyy = #Jabulani ifTrue: [
			[...].
			zzz = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz = #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
		yyy = #Playera ifTrue:[
			[...].
			zzz  = #EligeDireccionAntesTiro ifTrue:
				[...].
			zzz= #EsperaTiroYSeAdelanta ifTrue:
				[...].
		].
	].
	
	[Se decide quién ganó en base a como quedaron las ''cosas'' después de los ifs...]
	
	o sea, el caso general sería algo como lo que sigue, no?
	
	[trayectoraFinalTiro between: 0@0 and 2@2] ifFalse:
		[puntajeArquero := 1] ifTrue:
			Esta parte que sigue no me salió...  ayudame vos a mi ;) mi idea es:
			[algo que chequee si las coordenadas finales de ambos quedaron iguales despues de los ifs?]
			[y que la fuerza del arquero final es mayor o igual a la del tiro?] ifTrue:
				[puntajeArquero := 1] ifFalse:
				[puntajeDelantero := 1]."
	
	
	"Bueno, algo así..."
	"jajaj, sí, ya sé, vos seguro lo podes hacer mucho mejor... pero nada, es gratis y lo tenés de referencia si lo queres usar. Por ahí te sirve... ;)"! !

----QUIT----(25 September 2023 21:25:08) CuisUniversity-5981.image priorSource: 10898289!

----STARTUP---- (30 September 2023 00:47:00) as C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\CuisUniversity-5981.image!


!classRemoval: #Penales stamp: 'LK 9/30/2023 00:49:09'!
Object subclass: #Penales
	instanceVariableNames: 'puntajeDelantero puntajeArquero direccionDelTiroDelantero direccionDelArquero delantero arquero penalPelota'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classRemoval: #PPlayera stamp: 'LK 9/30/2023 00:49:10'!
PelotaDePenalti subclass: #PPlayera
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classRemoval: #PJabulani stamp: 'LK 9/30/2023 00:49:10'!
PelotaDePenalti subclass: #PJabulani
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classRemoval: #PelotaDePenalti stamp: 'LK 9/30/2023 00:49:10'!
Object subclass: #PelotaDePenalti
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classRemoval: #Pelota stamp: 'LK 9/30/2023 00:49:10'!
Object subclass: #Pelota
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classRemoval: #AMatar stamp: 'LK 9/30/2023 00:49:10'!
DelanteroConTactic subclass: #AMatar
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classRemoval: #AColocar stamp: 'LK 9/30/2023 00:49:10'!
DelanteroConTactic subclass: #AColocar
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classRemoval: #DelanteroConTactic stamp: 'LK 9/30/2023 00:49:11'!
Object subclass: #DelanteroConTactic
	instanceVariableNames: 'fuerza'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classRemoval: #Delantero stamp: 'LK 9/30/2023 00:49:11'!
Object subclass: #Delantero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classRemoval: #EsperaYAdelanta stamp: 'LK 9/30/2023 00:49:11'!
ArqueroConTactica subclass: #EsperaYAdelanta
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classRemoval: #Elige stamp: 'LK 9/30/2023 00:49:11'!
ArqueroConTactica subclass: #Elige
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classRemoval: #ArqueroConTactica stamp: 'LK 9/30/2023 00:49:11'!
Object subclass: #ArqueroConTactica
	instanceVariableNames: 'fuerza'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classRemoval: #Arquero stamp: 'LK 9/30/2023 00:49:12'!
Object subclass: #Arquero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

!classRemoval: #PenalesTest stamp: 'LK 9/30/2023 00:49:12'!
TestCase subclass: #PenalesTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2023-2C-Parcial-1'!

----End fileIn of C:\Users\lucas\OneDrive\Desktop\ISW1-2023-2C-Parcial-1-Ifs.st----!

----QUIT----(30 September 2023 00:54:32) CuisUniversity-5981.image priorSource: 11354725!

----STARTUP---- (30 September 2023 01:04:04) as C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\CuisUniversity-5981.image!


!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'LK 9/30/2023 01:04:13'!
PASSED!

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'LK 9/30/2023 01:04:15'!
PASSED!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'LK 9/30/2023 01:04:15'!
PASSED!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'LK 9/30/2023 01:04:15'!
PASSED!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'LK 9/30/2023 01:04:15'!
PASSED!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'LK 9/30/2023 01:04:15'!
PASSED!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'LK 9/30/2023 01:04:15'!
PASSED!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'LK 9/30/2023 01:04:15'!
PASSED!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'LK 9/30/2023 01:04:16'!
PASSED!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'LK 9/30/2023 01:04:16'!
PASSED!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'LK 9/30/2023 01:04:16'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test01findEncuentraEnElStack stamp: 'LK 9/30/2023 01:04:19'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test02findNoEncuentraEnElStack stamp: 'LK 9/30/2023 01:04:19'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test03findEsCaseSensitive stamp: 'LK 9/30/2023 01:04:19'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test04findNoAceptaPrefijoVacio stamp: 'LK 9/30/2023 01:04:19'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test05findNoModificaElStack stamp: 'LK 9/30/2023 01:04:19'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test06assertErrorNoAceptaEspaciosEnBlanco stamp: 'LK 9/30/2023 01:04:19'!
PASSED!

!testRun: #SentenceFinderByPrefixTest #test07inicializarConStackVacio stamp: 'LK 9/30/2023 01:04:19'!
PASSED!

----QUIT----(30 September 2023 01:04:58) CuisUniversity-5981.image priorSource: 11403944!

----STARTUP---- (2 October 2023 13:39:31) as C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\CuisUniversity-5981.image!


!testRun: #NumeroTest #test01isCeroReturnsTrueWhenAskToZero stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test02isCeroReturnsFalseWhenAskToOthersButZero stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test03isOneReturnsTrueWhenAskToOne stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test04isOneReturnsFalseWhenAskToOtherThanOne stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test05EnteroAddsWithEnteroCorrectly stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test06EnteroMultipliesWithEnteroCorrectly stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test07EnteroDividesEnteroCorrectly stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test08FraccionAddsWithFraccionCorrectly stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test09FraccionMultipliesWithFraccionCorrectly stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test10FraccionDividesFraccionCorrectly stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test11EnteroAddsFraccionCorrectly stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test12FraccionAddsEnteroCorrectly stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test13EnteroMultipliesFraccionCorrectly stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test14FraccionMultipliesEnteroCorrectly stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test15EnteroDividesFraccionCorrectly stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test16FraccionDividesEnteroCorrectly stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test17AFraccionCanBeEqualToAnEntero stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test18AparentFraccionesAreEqual stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test19AddingFraccionesCanReturnAnEntero stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test20MultiplyingFraccionesCanReturnAnEntero stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test21DividingFraccionesCanReturnAnEntero stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test22DividingEnterosCanReturnAFraccion stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test23CanNotDivideEnteroByZero stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test24CanNotDivideFraccionByZero stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test25AFraccionCanNotBeZero stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test26AFraccionCanNotBeOne stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test27EnteroSubstractsEnteroCorrectly stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test28FraccionSubstractsFraccionCorrectly stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test29EnteroSubstractsFraccionCorrectly stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test30FraccionSubstractsEnteroCorrectly stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test31SubstractingFraccionesCanReturnAnEntero stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test32SubstractingSameEnterosReturnsZero stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test33SubstractingSameFraccionesReturnsZero stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test34SubstractingAHigherValueToANumberReturnsANegativeNumber stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test35FibonacciZeroIsOne stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test36FibonacciOneIsOne stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test37FibonacciEnteroReturnsAddingPreviousTwoFibonacciEnteros stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test38FibonacciNotDefinedForNegativeNumbers stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test39NegationOfEnteroIsCorrect stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test40NegationOfFraccionIsCorrect stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test41SignIsCorrectlyAssignedToFractionWithTwoNegatives stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

!testRun: #NumeroTest #test42SignIsCorrectlyAssignedToFractionWithNegativeDivisor stamp: 'LK 10/2/2023 13:40:56'!
PASSED!

----QUIT----(2 October 2023 15:02:37) CuisUniversity-5981.image priorSource: 11406091!

----STARTUP---- (2 October 2023 20:27:57) as C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\CuisUniversity-5981.image!


Object subclass: #HundredDoors
	VariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: ''!

Object subclass: #HundredDoors
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: ''!

!classDefinition: #HundredDoors category: 'as yet unclassified' stamp: 'LK 10/2/2023 20:28:58'!
Object subclass: #HundredDoors
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'as yet unclassified'!

Object subclass: #HundredDoors
	instanceVariableNames: 'contador puertas'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'as yet unclassified'!

!classDefinition: #HundredDoors category: 'as yet unclassified' stamp: 'LK 10/2/2023 20:30:41'!
Object subclass: #HundredDoors
	instanceVariableNames: 'contador puertas'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'as yet unclassified'!
!HundredDoors methodsFor: 'no messages' stamp: 'LK 10/2/2023 20:31:11' overrides: 16920235!
initialize
	contador := 0.
	puertas := Array new: 100.! !

Object subclass: #HundredDoorsTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'as yet unclassified'!

!classDefinition: #HundredDoorsTest category: 'as yet unclassified' stamp: 'LK 10/2/2023 20:31:33'!
Object subclass: #HundredDoorsTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'as yet unclassified'!
!HundredDoorsTest methodsFor: 'no messages' stamp: 'LK 10/2/2023 20:31:53'!
test01PuertasInicianCerradas
	! !
!HundredDoors methodsFor: 'as yet unclassified' stamp: 'LK 10/2/2023 20:35:57' prior: 50688269 overrides: 16920235!
initialize
	
	|ix|
	
	contador := 0.
	puertas := Array new: 100.
	
	ix := 1.

	[ix < puertas size] whileTrue: [puertas at: ix put: false. ix := ix + 1].
	! !
!HundredDoors methodsFor: 'as yet unclassified' stamp: 'LK 10/2/2023 20:39:24'!
cantidadPuertasCerradas
	
	^(puertas select: [ :a | a = false]) size! !
!HundredDoors methodsFor: 'as yet unclassified' stamp: 'LK 10/2/2023 20:39:40'!
cantidadPuertasAbiertas
	
	^100 - self cantidadPuertasCerradas ! !
!HundredDoorsTest methodsFor: 'as yet unclassified' stamp: 'LK 10/2/2023 20:41:05' prior: 50688286!
test01PuertasInicianCerradas


	| doorsFlipper |
	
	doorsFlipper := HundredDoors new.
	
	self assert: doorsFlipper cantidadPuertasCerradas equals: 100.! !
!HundredDoorsTest methodsFor: 'as yet unclassified' stamp: 'LK 10/2/2023 20:41:16'!
test01puertasInicianCerradas


	| doorsFlipper |
	
	doorsFlipper := HundredDoors new.
	
	self assert: doorsFlipper cantidadPuertasCerradas equals: 100.! !

!methodRemoval: HundredDoorsTest #test01PuertasInicianCerradas stamp: 'LK 10/2/2023 20:41:18'!
test01PuertasInicianCerradas


	| doorsFlipper |
	
	doorsFlipper := HundredDoors new.
	
	self assert: doorsFlipper cantidadPuertasCerradas equals: 100.!
!HundredDoorsTest methodsFor: 'as yet unclassified' stamp: 'LK 10/2/2023 20:42:01' prior: 50688318!
test01puertasInicianCerradas


	| doorsFlipper |
	
	doorsFlipper := HundredDoors new.
	
	self assert: doorsFlipper cantidadPuertasCerradas equals: 100.! !

Object subclass: #HundredDoors
	instanceVariableNames: 'contador puertas'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Hundred Doors'!

!classDefinition: #HundredDoors category: 'Hundred Doors' stamp: 'LK 10/2/2023 20:44:08'!
Object subclass: #HundredDoors
	instanceVariableNames: 'contador puertas'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Hundred Doors'!

Object subclass: #HundredDoorsTests
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Hundred Doors'!

!classDefinition: #HundredDoorsTests category: 'Hundred Doors' stamp: 'LK 10/2/2023 20:44:21'!
Object subclass: #HundredDoorsTests
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Hundred Doors'!

!classRemoval: #HundredDoorsTest stamp: 'LK 10/2/2023 20:44:24'!
Object subclass: #HundredDoorsTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Hundred Doors'!
!HundredDoorsTests methodsFor: 'no messages' stamp: 'LK 10/2/2023 20:45:11'!
test01
	
	| doorFlipper |
	
	doorFlipper := HundredDoors new.
	
	self assert: (doorFlipper isClosed: 1).! !
!HundredDoorsTests methodsFor: 'as yet unclassified' stamp: 'LK 10/2/2023 20:47:30' prior: 50688372!
test01
	
	| doorFlipper |
	
	doorFlipper := HundredDoors new.
	
	self assert: (doorFlipper isClosed: 1)! !
!HundredDoorsTests methodsFor: 'as yet unclassified' stamp: 'LK 10/2/2023 20:47:38'!
test01sadasd 

	| doorFlipper |
	
	doorFlipper := HundredDoors new.
	
	self assert: (doorFlipper isClosed: 1)! !
!HundredDoorsTests methodsFor: 'as yet unclassified' stamp: 'LK 10/2/2023 20:48:43' prior: 50688379!
test01
	
	| hundredDoors |
	
	hundredDoors := HundredDoors new.
	
	self assert: (hundredDoors isClosed: 1)! !

!methodRemoval: HundredDoorsTests #test01sadasd stamp: 'LK 10/2/2023 20:51:25'!
test01sadasd 

	| doorFlipper |
	
	doorFlipper := HundredDoors new.
	
	self assert: (doorFlipper isClosed: 1)!
!HundredDoorsTests methodsFor: 'as yet unclassified' stamp: 'LK 10/2/2023 20:58:41'!
test01AllDoorsStartClosed

	| hundredDoors |
	
	hundredDoors := HundredDoors new.
	
	self assert: (hundredDoors isClosed: 1)! !
!HundredDoorsTests methodsFor: 'as yet unclassified' stamp: 'LK 10/2/2023 20:59:17'!
test01AllClosedDoorsEndOpened

	| hundredDoors |
	
	hundredDoors := HundredDoors new.
	
	hundredDoors flip.
	
	self assert: (hundredDoors isClosed: 1)! !
!HundredDoorsTests methodsFor: 'as yet unclassified' stamp: 'LK 10/2/2023 20:59:36'!
test01AllOpenedDoorsEndClosed

	| hundredDoors |
	
	hundredDoors := HundredDoors new.
	
	hundredDoors flip.
	hundredDoors flip.
	
	self assert: (hundredDoors isClosed: 1)! !
!HundredDoorsTests methodsFor: 'as yet unclassified' stamp: 'LK 10/2/2023 20:59:42'!
test03AllOpenedDoorsEndClosed

	| hundredDoors |
	
	hundredDoors := HundredDoors new.
	
	hundredDoors flip.
	hundredDoors flip.
	
	self assert: (hundredDoors isClosed: 1)! !

!methodRemoval: HundredDoorsTests #test01 stamp: 'LK 10/2/2023 20:59:48'!
test01
	
	| hundredDoors |
	
	hundredDoors := HundredDoors new.
	
	self assert: (hundredDoors isClosed: 1)!
!HundredDoorsTests methodsFor: 'as yet unclassified' stamp: 'LK 10/2/2023 20:59:59'!
test02AllClosedDoorsEndOpened

	| hundredDoors |
	
	hundredDoors := HundredDoors new.
	
	hundredDoors flip.
	
	self deny: (hundredDoors isClosed: 1)! !

!methodRemoval: HundredDoorsTests #test01AllOpenedDoorsEndClosed stamp: 'LK 10/2/2023 21:00:06'!
test01AllOpenedDoorsEndClosed

	| hundredDoors |
	
	hundredDoors := HundredDoors new.
	
	hundredDoors flip.
	hundredDoors flip.
	
	self assert: (hundredDoors isClosed: 1)!

!methodRemoval: HundredDoorsTests #test01AllClosedDoorsEndOpened stamp: 'LK 10/2/2023 21:00:10'!
test01AllClosedDoorsEndOpened

	| hundredDoors |
	
	hundredDoors := HundredDoors new.
	
	hundredDoors flip.
	
	self assert: (hundredDoors isClosed: 1)!
!HundredDoorsTests methodsFor: 'as yet unclassified' stamp: 'LK 10/2/2023 21:02:22' prior: 50688429!
test03AllOpenedDoorsEndClosed

	| hundredDoors |
	
	hundredDoors := HundredDoors with: 2.
	
	hundredDoors flip.
	
	self deny: (hundredDoors isClosed: 1).
	self deny: (hundredDoors isClosed: 2).! !
!HundredDoors methodsFor: 'as yet unclassified' stamp: 'LK 10/2/2023 21:02:49' prior: 50688291 overrides: 16920235!
initialize

"
	
	|ix|
	
	contador := 0.
	puertas := Array new: 100.
	
	ix := 1.

	[ix < puertas size] whileTrue: [puertas at: ix put: false. ix := ix + 1].
"	! !
!HundredDoors class methodsFor: 'nil' stamp: 'LK 10/2/2023 21:04:50'!
with: aNumberDoors

	^self new initializeWith: aNumberDoors.! !

!classDefinition: #HundredDoors category: 'Hundred Doors' stamp: 'LK 10/2/2023 21:05:10'!
Object subclass: #HundredDoors
	instanceVariableNames: 'contador puertas closed'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Hundred Doors'!
!HundredDoors methodsFor: 'as yet unclassified' stamp: 'LK 10/2/2023 21:05:08' prior: 50688478 overrides: 16920235!
initialize

	closed := true.

"
	
	|ix|
	
	contador := 0.
	puertas := Array new: 100.
	
	ix := 1.

	[ix < puertas size] whileTrue: [puertas at: ix put: false. ix := ix + 1].
"	! !
!HundredDoors methodsFor: 'as yet unclassified' stamp: 'LK 10/2/2023 21:05:20'!
initializeWith: aNumberOfDoors

	closed := true.

"
	
	|ix|
	
	contador := 0.
	puertas := Array new: 100.
	
	ix := 1.

	[ix < puertas size] whileTrue: [puertas at: ix put: false. ix := ix + 1].
"	! !
!HundredDoors methodsFor: 'as yet unclassified' stamp: 'LK 10/2/2023 21:05:27'!
flip! !
!HundredDoorsTests methodsFor: 'as yet unclassified' stamp: 'LK 10/2/2023 21:05:53'!
test04AllOpenedDoorsEndClosed

	| hundredDoors |
	
	hundredDoors := HundredDoors with: 2.
	
	hundredDoors flip.
	
	self deny: (hundredDoors isClosed: 1).
	self deny: (hundredDoors isClosed: 2).! !
!HundredDoorsTests methodsFor: 'as yet unclassified' stamp: 'LK 10/2/2023 21:06:26' prior: 50688468!
test03AllOpenedDoorsEndClosed

	| hundredDoors |
	
	hundredDoors := HundredDoors with: 2.
	
	hundredDoors flip.
	hundredDoors flip.
	
	self assert: (hundredDoors isClosed: 1).! !
!HundredDoorsTests methodsFor: 'as yet unclassified' stamp: 'LK 10/2/2023 21:06:35' prior: 50688531!
test03AllOpenedDoorsEndClosed

	| hundredDoors |
	
	hundredDoors := HundredDoors new.
	
	hundredDoors flip.
	hundredDoors flip.
	
	self assert: (hundredDoors isClosed: 1).! !
!HundredDoorsTests methodsFor: 'as yet unclassified' stamp: 'LK 10/2/2023 21:06:50' prior: 50688521!
test04AllOpenedDoorsEndClosed

	| hundredDoors |
	
	hundredDoors := HundredDoors with: 2.
	
	hundredDoors flip.
	hundredDoors flip.
	
	self deny: (hundredDoors isClosed: 1).
	self deny: (hundredDoors isClosed: 2).! !
!HundredDoorsTests methodsFor: 'as yet unclassified' stamp: 'LK 10/2/2023 21:08:54'!
test04TwoOpenedDoorsEndClosed

	| hundredDoors |
	
	hundredDoors := HundredDoors with: 2.
	
	hundredDoors flip.
	hundredDoors flip.
	
	self assert: (hundredDoors isClosed: 1).
	self assert: (hundredDoors isClosed: 2).! !

!methodRemoval: HundredDoorsTests #test04AllOpenedDoorsEndClosed stamp: 'LK 10/2/2023 21:09:03'!
test04AllOpenedDoorsEndClosed

	| hundredDoors |
	
	hundredDoors := HundredDoors with: 2.
	
	hundredDoors flip.
	hundredDoors flip.
	
	self deny: (hundredDoors isClosed: 1).
	self deny: (hundredDoors isClosed: 2).!
!HundredDoorsTests methodsFor: 'as yet unclassified' stamp: 'LK 10/2/2023 21:10:42'!
test05

	|doorsFlipper |
	
	doorsFlipper := HundredDoors with: 4.
	
	doorsFlipper flipBy: 2.
	
	self assert: (doorsFlipper isClosed: 1).
	self deny: (doorsFlipper isClosed: 2).
	self assert: (doorsFlipper isClosed: 3).
	self deny: (doorsFlipper isClosed: 4).

	! !
!HundredDoors methodsFor: 'as yet unclassified' stamp: 'LK 10/2/2023 21:15:05' prior: 50688500 overrides: 16920235!
initialize

	closed := true.

"
	
	|ix|
	
	contador := 0.
	puertas := Array new: 100.
	
	ix := 1.

	[ix < puertas size] whileTrue: [puertas at: ix put: false. ix := ix + 1].
	
	
	1 to puertas size by: aStep do: [ :aDoorNumber | closed at: aDoorNumber put: (closed at: aDoorNumber) not]
"	! !

----QUIT----(2 October 2023 21:34:21) CuisUniversity-5981.image priorSource: 11410667!

----STARTUP---- (5 October 2023 17:40:10) as C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\CuisUniversity-5981.image!


Object subclass: #Calendario
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Calendario-Exercise'!

!classDefinition: #Calendario category: 'Calendario-Exercise' stamp: 'LK 10/5/2023 17:41:28'!
Object subclass: #Calendario
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Calendario-Exercise'!

TestCase subclass: #CalendarioTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Calendario-Exercise'!

!classDefinition: #CalendarioTest category: 'Calendario-Exercise' stamp: 'LK 10/5/2023 17:41:48'!
TestCase subclass: #CalendarioTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Calendario-Exercise'!
!CalendarioTest methodsFor: 'no messages' stamp: 'LK 10/5/2023 17:44:53' overrides: 16961394!
setUp
	
	| calendario |
	
	calendario = Calendario new.! !

TestCase subclass: #CalendarioTest
	instanceVariableNames: 'calendar'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Calendario-Exercise'!

!classDefinition: #CalendarioTest category: 'Calendario-Exercise' stamp: 'LK 10/5/2023 17:46:17'!
TestCase subclass: #CalendarioTest
	instanceVariableNames: 'calendar'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Calendario-Exercise'!
!CalendarioTest methodsFor: 'as yet unclassified' stamp: 'LK 10/5/2023 17:46:26' prior: 50688634 overrides: 16961394!
setUp
	
	calendar = Calendario new.! !
!CalendarioTest methodsFor: 'as yet unclassified' stamp: 'LK 10/5/2023 17:46:33' prior: 50688653 overrides: 16961394!
setUp
	
	calendar := Calendario new.! !
!CalendarioTest methodsFor: 'as yet unclassified' stamp: 'LK 10/5/2023 17:46:37'!
test01! !
!CalendarioTest methodsFor: 'as yet unclassified' stamp: 'LK 10/5/2023 17:47:41' prior: 50688662!
test01
	
	self assert: calendar esFeriado: October/5/2023 equals false.! !

!testRun: #CalendarioTest #test01 stamp: 'LK 10/5/2023 17:47:47'!
ERROR!
!CalendarioTest methodsFor: 'as yet unclassified' stamp: 'LK 10/5/2023 17:48:51' prior: 50688666!
test01
	
	self assert: (calendar esFeriado: October/5/2023 = false).! !

!testRun: #CalendarioTest #test01 stamp: 'LK 10/5/2023 17:48:54'!
ERROR!
!Calendario methodsFor: 'feriados' stamp: 'LK 10/5/2023 17:49:12'!
esFeriado: aRenameMe1 
	self shouldBeImplemented.! !
!Calendario methodsFor: 'feriados' stamp: 'LK 10/5/2023 17:49:25' prior: 50688681!
esFeriado: unaFecha 
	^false! !

!testRun: #CalendarioTest #test01 stamp: 'LK 10/5/2023 17:49:29'!
FAILURE!

!testRun: #CalendarioTest #test01 stamp: 'LK 10/5/2023 17:50:15'!
FAILURE!
!Calendario methodsFor: 'feriados' stamp: 'LK 10/5/2023 17:50:26' prior: 50688686!
esFeriado: unaFecha 

	^false! !
!CalendarioTest methodsFor: 'as yet unclassified' stamp: 'LK 10/5/2023 17:51:18' prior: 50688674!
test01
	
	self deny: (calendar esFeriado: October/5/2023)! !

!testRun: #CalendarioTest #test01 stamp: 'LK 10/5/2023 17:51:19'!
PASSED!

!testRun: #CalendarioTest #test01 stamp: 'LK 10/5/2023 17:51:19'!
PASSED!

GregorianDate!

GregorianDate!

GregorianDate methods!

GregorianDate method!

GregorianDay monday!
!CalendarioTest methodsFor: 'as yet unclassified' stamp: 'LK 10/5/2023 17:56:09'!
test02

	calendar agregarFeriadoPorDiaParticular: October/5/2023.
	
	
	self deny: (calendar esFeriado: October/5/2023)! !
!CalendarioTest methodsFor: 'as yet unclassified' stamp: 'LK 10/5/2023 17:57:43' prior: 50688713!
test02

	calendar agregarFeriadoPorDiaParticular: October/5/2023.
	
	
	self assert: (calendar esFeriado: October/5/2023)! !

!testRun: #CalendarioTest #test02 stamp: 'LK 10/5/2023 17:57:44'!
ERROR!
!Calendario methodsFor: 'feriados' stamp: 'LK 10/5/2023 17:57:49'!
agregarFeriadoPorDiaParticular: aRenameMe1 
	self shouldBeImplemented.! !

!classDefinition: #Calendario category: 'Calendario-Exercise' stamp: 'LK 10/5/2023 17:58:24'!
Object subclass: #Calendario
	instanceVariableNames: 'feriadosExactos'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Calendario-Exercise'!
!Calendario methodsFor: 'feriados' stamp: 'LK 10/5/2023 17:58:22' prior: 50688729!
agregarFeriadoPorDiaParticular: unaFecha

	feriadosExactos add: unaFecha.! !
!Calendario methodsFor: 'feriados' stamp: 'LK 10/5/2023 17:59:06' overrides: 16920235!
initialize
	
	feriadosExactos := Set new.! !
!Calendario methodsFor: 'feriados' stamp: 'LK 10/5/2023 18:01:13' prior: 50688695!
esFeriado: unaFecha 


	(feriadosExactos includes: unaFecha) ifTrue: [^true].
	
	^false! !

!testRun: #CalendarioTest #test02 stamp: 'LK 10/5/2023 18:01:18'!
PASSED!

!testRun: #CalendarioTest #test01 stamp: 'LK 10/5/2023 18:01:18'!
PASSED!

!testRun: #CalendarioTest #test02 stamp: 'LK 10/5/2023 18:01:18'!
PASSED!
!CalendarioTest methodsFor: 'as yet unclassified' stamp: 'LK 10/5/2023 18:29:52'!
test03

	| unDomingo |
	
	calendar.
	unDomingo := October / 8 / 2023.
	
	self assert: (calendar esFeriado: unDomingo)! !
!CalendarioTest methodsFor: 'as yet unclassified' stamp: 'LK 10/5/2023 18:30:11' prior: 50688765!
test03

	| unDomingo |
	
	calendar agregarDiaDeSemanaFeriado: Sunday.
	
	unDomingo := October / 8 / 2023.
	
	self assert: (calendar esFeriado: unDomingo)! !

!testRun: #CalendarioTest #test03 stamp: 'LK 10/5/2023 18:30:17'!
ERROR!

!testRun: #CalendarioTest #test03 stamp: 'LK 10/5/2023 18:30:17'!
ERROR!
!Calendario methodsFor: 'feriados' stamp: 'LK 10/5/2023 18:30:23'!
agregarDiaDeSemanaFeriado: Sunday 
	self shouldBeImplemented.! !
!Calendario methodsFor: 'feriados' stamp: 'LK 10/5/2023 18:31:07' prior: 50688752!
esFeriado: unaFecha 

	(unaFecha day = Sunday) ifTrue: [^true].

	(feriadosExactos includes: unaFecha) ifTrue: [^true].
	
	^false! !

!testRun: #CalendarioTest #test03 stamp: 'LK 10/5/2023 18:31:13'!
ERROR!
!Calendario methodsFor: 'feriados' stamp: 'LK 10/5/2023 18:31:33' prior: 50688784!
agregarDiaDeSemanaFeriado: Sunday 
	! !

!testRun: #CalendarioTest #test03 stamp: 'LK 10/5/2023 18:31:37'!
PASSED!

!testRun: #CalendarioTest #test01 stamp: 'LK 10/5/2023 18:31:37'!
PASSED!

!testRun: #CalendarioTest #test02 stamp: 'LK 10/5/2023 18:31:38'!
PASSED!

!testRun: #CalendarioTest #test03 stamp: 'LK 10/5/2023 18:31:38'!
PASSED!
!Calendario methodsFor: 'feriados' stamp: 'LK 10/5/2023 18:32:05' prior: 50688799!
agregarDiaDeSemanaFeriado: unDiaDeSemana
! !
!CalendarioTest methodsFor: 'as yet unclassified' stamp: 'LK 10/5/2023 18:32:45'!
test04

	| unSabado |
	
	calendar agregarDiaDeSemanaFeriado: Saturday.
	
	unSabado := October / 8 / 2023.
	
	self assert: (calendar esFeriado: unSabado)! !
!Calendario methodsFor: 'feriados' stamp: 'LK 10/5/2023 18:33:11' prior: 50688789!
esFeriado: unaFecha 

	((unaFecha day = Sunday) or: [unaFecha day = Saturday]) ifTrue: [^true].

	(feriadosExactos includes: unaFecha) ifTrue: [^true].
	
	^false! !

!testRun: #CalendarioTest #test04 stamp: 'LK 10/5/2023 18:33:14'!
PASSED!

!testRun: #CalendarioTest #test01 stamp: 'LK 10/5/2023 18:34:00'!
PASSED!

!testRun: #CalendarioTest #test02 stamp: 'LK 10/5/2023 18:34:00'!
PASSED!

!testRun: #CalendarioTest #test03 stamp: 'LK 10/5/2023 18:34:00'!
PASSED!

!testRun: #CalendarioTest #test04 stamp: 'LK 10/5/2023 18:34:00'!
PASSED!

Object subclass: #Calendario
	instanceVariableNames: 'feriadosExactos feriadosDiaDeSemana'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Calendario-Exercise'!

!classDefinition: #Calendario category: 'Calendario-Exercise' stamp: 'LK 10/5/2023 18:34:23'!
Object subclass: #Calendario
	instanceVariableNames: 'feriadosExactos feriadosDiaDeSemana'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Calendario-Exercise'!
!Calendario methodsFor: 'feriados' stamp: 'LK 10/5/2023 18:34:35' prior: 50688748 overrides: 16920235!
initialize
	
	feriadosExactos := Set new.
	
	feriadosDiaDeSemana := Set new.! !
!Calendario methodsFor: 'feriados' stamp: 'LK 10/5/2023 18:34:52' prior: 50688813!
agregarDiaDeSemanaFeriado: unDiaDeSemana

	feriadosDiaDeSemana add: unDiaDeSemana day.! !
!Calendario methodsFor: 'feriados' stamp: 'LK 10/5/2023 18:35:13' prior: 50688825!
esFeriado: unaFecha 

	(feriadosDiaDeSemana includes: unaFecha day) ifTrue: [^true].

	(feriadosExactos includes: unaFecha) ifTrue: [^true].
	
	^false! !

!testRun: #CalendarioTest #test01 stamp: 'LK 10/5/2023 18:35:16'!
PASSED!

!testRun: #CalendarioTest #test02 stamp: 'LK 10/5/2023 18:35:16'!
PASSED!

!testRun: #CalendarioTest #test03 stamp: 'LK 10/5/2023 18:35:16'!
ERROR!

!testRun: #CalendarioTest #test04 stamp: 'LK 10/5/2023 18:35:16'!
ERROR!

!testRun: #CalendarioTest #test03 stamp: 'LK 10/5/2023 18:35:24'!
ERROR!

!testRun: #CalendarioTest #test03 stamp: 'LK 10/5/2023 18:35:24'!
ERROR!

!testRun: #CalendarioTest #test03 stamp: 'LK 10/5/2023 18:35:37'!
ERROR!
!Calendario methodsFor: 'feriados' stamp: 'LK 10/5/2023 18:35:48' prior: 50688865!
agregarDiaDeSemanaFeriado: unDiaDeSemana

	feriadosDiaDeSemana add: unDiaDeSemana.! !

!testRun: #CalendarioTest #test01 stamp: 'LK 10/5/2023 18:35:51'!
PASSED!

!testRun: #CalendarioTest #test02 stamp: 'LK 10/5/2023 18:35:51'!
PASSED!

!testRun: #CalendarioTest #test03 stamp: 'LK 10/5/2023 18:35:51'!
PASSED!

!testRun: #CalendarioTest #test04 stamp: 'LK 10/5/2023 18:35:51'!
FAILURE!

!testRun: #CalendarioTest #test04 stamp: 'LK 10/5/2023 18:35:51'!
FAILURE!

!testRun: #CalendarioTest #test03 stamp: 'LK 10/5/2023 18:36:35'!
PASSED!
!CalendarioTest methodsFor: 'tests' stamp: 'LK 10/5/2023 18:36:44' prior: 50688817!
test04

	| unSabado |
	
	calendar agregarDiaDeSemanaFeriado: Saturday.
	
	unSabado := October / 7 / 2023.
	
	self assert: (calendar esFeriado: unSabado)! !

!testRun: #CalendarioTest #test04 stamp: 'LK 10/5/2023 18:36:46'!
PASSED!

!testRun: #CalendarioTest #test01 stamp: 'LK 10/5/2023 18:36:46'!
PASSED!

!testRun: #CalendarioTest #test02 stamp: 'LK 10/5/2023 18:36:46'!
PASSED!

!testRun: #CalendarioTest #test03 stamp: 'LK 10/5/2023 18:36:46'!
PASSED!

!testRun: #CalendarioTest #test04 stamp: 'LK 10/5/2023 18:36:46'!
PASSED!
!CalendarioTest methodsFor: 'tests' stamp: 'LK 10/5/2023 18:44:30' prior: 50688915!
test04

	| unSabado |
	
	" esta de mas"
	
	calendar agregarDiaDeSemanaFeriado: Saturday.
	
	unSabado := October / 7 / 2023.
	
	self assert: (calendar esFeriado: unSabado)! !
!CalendarioTest methodsFor: 'tests' stamp: 'LK 10/5/2023 18:44:49'!
test01ThereCanBeNoHolidays
	
	self deny: (calendar esFeriado: October/5/2023)! !

!methodRemoval: CalendarioTest #test01 stamp: 'LK 10/5/2023 18:44:54'!
test01
	
	self deny: (calendar esFeriado: October/5/2023)!
!CalendarioTest methodsFor: 'tests' stamp: 'LK 10/5/2023 18:45:54'!
test02OneDateCanBeHoliday

	calendar agregarFeriadoPorDiaParticular: October/5/2023.
	
	
	self assert: (calendar esFeriado: October/5/2023)! !

!methodRemoval: CalendarioTest #test02 stamp: 'LK 10/5/2023 18:45:57'!
test02

	calendar agregarFeriadoPorDiaParticular: October/5/2023.
	
	
	self assert: (calendar esFeriado: October/5/2023)!
!CalendarioTest methodsFor: 'tests' stamp: 'LK 10/5/2023 18:46:09'!
test03OneWeekdayCanBeHoliday

	| unDomingo |
	
	calendar agregarDiaDeSemanaFeriado: Sunday.
	
	unDomingo := October / 8 / 2023.
	
	self assert: (calendar esFeriado: unDomingo)! !

!methodRemoval: CalendarioTest #test03 stamp: 'LK 10/5/2023 18:46:13'!
test03

	| unDomingo |
	
	calendar agregarDiaDeSemanaFeriado: Sunday.
	
	unDomingo := October / 8 / 2023.
	
	self assert: (calendar esFeriado: unDomingo)!
!CalendarioTest methodsFor: 'tests' stamp: 'LK 10/5/2023 18:47:19'!
test04MoreThanOneWeekdayCanBeHoliday

	| unSabado unLunes|
	
	
	calendar agregarDiaDeSemanaFeriado: Saturday.
	calendar agregarDiaDeSemanaFeriado: Monday.
	
	unSabado := October / 7 / 2023.
	
	unLunes := October / 9 / 2023.
	
	self assert: (calendar esFeriado: unSabado).
	
	self assert: (calendar esFeriado: unLunes).! !

!testRun: #CalendarioTest #test04MoreThanOneWeekdayCanBeHoliday stamp: 'LK 10/5/2023 18:47:19'!
PASSED!

!testRun: #CalendarioTest #test01ThereCanBeNoHolidays stamp: 'LK 10/5/2023 18:47:19'!
PASSED!

!testRun: #CalendarioTest #test02OneDateCanBeHoliday stamp: 'LK 10/5/2023 18:47:19'!
PASSED!

!testRun: #CalendarioTest #test03OneWeekdayCanBeHoliday stamp: 'LK 10/5/2023 18:47:19'!
PASSED!

!testRun: #CalendarioTest #test04 stamp: 'LK 10/5/2023 18:47:19'!
PASSED!

!testRun: #CalendarioTest #test04MoreThanOneWeekdayCanBeHoliday stamp: 'LK 10/5/2023 18:47:19'!
PASSED!
!CalendarioTest methodsFor: 'tests' stamp: 'LK 10/5/2023 18:47:59'!
test05! !
!CalendarioTest methodsFor: 'tests' stamp: 'LK 10/5/2023 18:51:26' prior: 50689011!
test05

	| unFeriadoDiaDeMes |
	 
	unFeriadoDiaDeMes := November / 25.
	
	calendar agregarDiaDeMesFeriado: unFeriadoDiaDeMes.
	
	self assert: (calendar esFeriado: unFeriadoDiaDeMes).! !

!testRun: #CalendarioTest #test05 stamp: 'LK 10/5/2023 18:51:29'!
ERROR!
!Calendario methodsFor: 'feriados' stamp: 'LK 10/5/2023 18:51:38'!
agregarDiaDeMesFeriado: unFeriadoDiaDeMes 
	self shouldBeImplemented.! !
!Calendario methodsFor: 'feriados' stamp: 'LK 10/5/2023 18:51:45' prior: 50689025!
agregarDiaDeMesFeriado: unFeriadoDiaDeMes 
	! !

!testRun: #CalendarioTest #test01ThereCanBeNoHolidays stamp: 'LK 10/5/2023 18:51:48'!
PASSED!

!testRun: #CalendarioTest #test02OneDateCanBeHoliday stamp: 'LK 10/5/2023 18:51:48'!
PASSED!

!testRun: #CalendarioTest #test03OneWeekdayCanBeHoliday stamp: 'LK 10/5/2023 18:51:49'!
PASSED!

!testRun: #CalendarioTest #test04 stamp: 'LK 10/5/2023 18:51:49'!
PASSED!

!testRun: #CalendarioTest #test04MoreThanOneWeekdayCanBeHoliday stamp: 'LK 10/5/2023 18:51:49'!
PASSED!

!testRun: #CalendarioTest #test05 stamp: 'LK 10/5/2023 18:51:49'!
ERROR!

!testRun: #CalendarioTest #test05 stamp: 'LK 10/5/2023 18:51:49'!
ERROR!

Object subclass: #Calendario
	instanceVariableNames: 'feriadosExactos feriadosDiaDeSemana feriadosDiaDeMes'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Calendario-Exercise'!

!classDefinition: #Calendario category: 'Calendario-Exercise' stamp: 'LK 10/5/2023 18:52:57'!
Object subclass: #Calendario
	instanceVariableNames: 'feriadosExactos feriadosDiaDeSemana feriadosDiaDeMes'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Calendario-Exercise'!
!Calendario methodsFor: 'feriados' stamp: 'LK 10/5/2023 18:53:05' prior: 50688859 overrides: 16920235!
initialize
	
	feriadosExactos := Set new.
	
	feriadosDiaDeSemana := Set new.
	
	feriadosDiaDeMes := Set new.! !
!Calendario methodsFor: 'feriados' stamp: 'LK 10/5/2023 18:53:19' prior: 50689030!
agregarDiaDeMesFeriado: unFeriadoDiaDeMes 
	
	feriadosDiaDeMes add: unFeriadoDiaDeMes.! !
!Calendario methodsFor: 'feriados' stamp: 'LK 10/5/2023 18:54:04' prior: 50688871!
esFeriado: unaFecha 

	(feriadosDiaDeMes includes: unaFecha) ifTrue: [^true].

	(feriadosExactos includes: unaFecha) ifTrue: [^true].
	
	(feriadosDiaDeSemana includes: unaFecha day) ifTrue: [^true].
	
	^false! !

!testRun: #CalendarioTest #test05 stamp: 'LK 10/5/2023 18:54:11'!
PASSED!

!testRun: #CalendarioTest #test01ThereCanBeNoHolidays stamp: 'LK 10/5/2023 18:54:14'!
PASSED!

!testRun: #CalendarioTest #test02OneDateCanBeHoliday stamp: 'LK 10/5/2023 18:54:14'!
PASSED!

!testRun: #CalendarioTest #test03OneWeekdayCanBeHoliday stamp: 'LK 10/5/2023 18:54:14'!
PASSED!

!testRun: #CalendarioTest #test04 stamp: 'LK 10/5/2023 18:54:14'!
PASSED!

!testRun: #CalendarioTest #test04MoreThanOneWeekdayCanBeHoliday stamp: 'LK 10/5/2023 18:54:14'!
PASSED!

!testRun: #CalendarioTest #test05 stamp: 'LK 10/5/2023 18:54:14'!
PASSED!
!CalendarioTest methodsFor: 'tests' stamp: 'LK 10/5/2023 18:56:34'!
test06

	| unFeriadoDiaDeMes unFeriadoExacto|
	 
	unFeriadoDiaDeMes := November / 25.
	
	calendar agregarDiaDeMesFeriado: unFeriadoDiaDeMes.
	
	self assert: (calendar esFeriado: unFeriadoDiaDeMes).! !
!CalendarioTest methodsFor: 'tests' stamp: 'LK 10/5/2023 18:57:05' prior: 50689110!
test06

	| unFeriadoDiaDeMes unFeriadoExacto|
	 
	unFeriadoDiaDeMes := November / 25.
	unFeriadoExacto := November / 25 / 1999.
	
	calendar agregarDiaDeMesFeriado: unFeriadoDiaDeMes.
	
	self assert: (calendar esFeriado: unFeriadoExacto).! !

!testRun: #CalendarioTest #test06 stamp: 'LK 10/5/2023 18:57:05'!
FAILURE!

November / 25 /1099!

November / 25 /1099 class!

(November / 25 /1999) class!
!Calendario methodsFor: 'feriados' stamp: 'LK 10/5/2023 19:00:07' prior: 50689082!
esFeriado: unaFecha 

	(feriadosDiaDeMes includes: unaFecha dayOfMonth) ifTrue: [^true].

	(feriadosExactos includes: unaFecha) ifTrue: [^true].
	
	(feriadosDiaDeSemana includes: unaFecha day) ifTrue: [^true].
	
	^false! !

!testRun: #CalendarioTest #test06 stamp: 'LK 10/5/2023 19:00:10'!
PASSED!

!testRun: #CalendarioTest #test01ThereCanBeNoHolidays stamp: 'LK 10/5/2023 19:00:15'!
PASSED!

!testRun: #CalendarioTest #test02OneDateCanBeHoliday stamp: 'LK 10/5/2023 19:00:15'!
PASSED!

!testRun: #CalendarioTest #test03OneWeekdayCanBeHoliday stamp: 'LK 10/5/2023 19:00:15'!
PASSED!

!testRun: #CalendarioTest #test04 stamp: 'LK 10/5/2023 19:00:15'!
PASSED!

!testRun: #CalendarioTest #test04MoreThanOneWeekdayCanBeHoliday stamp: 'LK 10/5/2023 19:00:15'!
PASSED!

!testRun: #CalendarioTest #test05 stamp: 'LK 10/5/2023 19:00:15'!
ERROR!

!testRun: #CalendarioTest #test06 stamp: 'LK 10/5/2023 19:00:15'!
PASSED!

!testRun: #CalendarioTest #test05 stamp: 'LK 10/5/2023 19:00:15'!
ERROR!
!Calendario methodsFor: 'feriados' stamp: 'LK 10/5/2023 19:02:16' prior: 50689134!
esFeriado: unaFecha 

	(feriadosExactos includes: unaFecha) ifTrue: [^true].
	
		
	(feriadosDiaDeSemana includes: unaFecha day) ifTrue: [^true].


	(feriadosDiaDeMes includes: unaFecha dayOfMonth) ifTrue: [^true].

	
	^false! !

!testRun: #CalendarioTest #test01ThereCanBeNoHolidays stamp: 'LK 10/5/2023 19:02:20'!
PASSED!

!testRun: #CalendarioTest #test02OneDateCanBeHoliday stamp: 'LK 10/5/2023 19:02:20'!
PASSED!

!testRun: #CalendarioTest #test03OneWeekdayCanBeHoliday stamp: 'LK 10/5/2023 19:02:20'!
PASSED!

!testRun: #CalendarioTest #test04 stamp: 'LK 10/5/2023 19:02:20'!
PASSED!

!testRun: #CalendarioTest #test04MoreThanOneWeekdayCanBeHoliday stamp: 'LK 10/5/2023 19:02:20'!
PASSED!

!testRun: #CalendarioTest #test05 stamp: 'LK 10/5/2023 19:02:20'!
ERROR!

!testRun: #CalendarioTest #test06 stamp: 'LK 10/5/2023 19:02:20'!
PASSED!

!testRun: #CalendarioTest #test05 stamp: 'LK 10/5/2023 19:02:20'!
ERROR!

!methodRemoval: CalendarioTest #test05 stamp: 'LK 10/5/2023 19:02:44'!
test05

	| unFeriadoDiaDeMes |
	 
	unFeriadoDiaDeMes := November / 25.
	
	calendar agregarDiaDeMesFeriado: unFeriadoDiaDeMes.
	
	self assert: (calendar esFeriado: unFeriadoDiaDeMes).!
!CalendarioTest methodsFor: 'tests' stamp: 'LK 10/5/2023 19:02:50'!
test05

	| unFeriadoDiaDeMes unFeriadoExacto|
	 
	unFeriadoDiaDeMes := November / 25.
	unFeriadoExacto := November / 25 / 1999.
	
	calendar agregarDiaDeMesFeriado: unFeriadoDiaDeMes.
	
	self assert: (calendar esFeriado: unFeriadoExacto).! !

!testRun: #CalendarioTest #test05 stamp: 'LK 10/5/2023 19:03:04'!
PASSED!

!testRun: #CalendarioTest #test01ThereCanBeNoHolidays stamp: 'LK 10/5/2023 19:03:09'!
PASSED!

!testRun: #CalendarioTest #test02OneDateCanBeHoliday stamp: 'LK 10/5/2023 19:03:09'!
PASSED!

!testRun: #CalendarioTest #test03OneWeekdayCanBeHoliday stamp: 'LK 10/5/2023 19:03:09'!
PASSED!

!testRun: #CalendarioTest #test04 stamp: 'LK 10/5/2023 19:03:09'!
PASSED!

!testRun: #CalendarioTest #test04MoreThanOneWeekdayCanBeHoliday stamp: 'LK 10/5/2023 19:03:09'!
PASSED!

!testRun: #CalendarioTest #test05 stamp: 'LK 10/5/2023 19:03:09'!
PASSED!

!testRun: #CalendarioTest #test06 stamp: 'LK 10/5/2023 19:03:09'!
PASSED!
!CalendarioTest methodsFor: 'tests' stamp: 'LK 10/5/2023 19:04:01' prior: 50689119!
test06

	| unFeriadoDiaDeMes unFeriadoExacto dos tres|
	 
	unFeriadoDiaDeMes := November / 25.
	
	
	unFeriadoExacto := November / 25 / 1999.
	
	calendar agregarDiaDeMesFeriado: unFeriadoDiaDeMes.
	
	self assert: (calendar esFeriado: unFeriadoExacto).! !

!methodRemoval: CalendarioTest #test06 stamp: 'LK 10/5/2023 19:08:51'!
test06

	| unFeriadoDiaDeMes unFeriadoExacto dos tres|
	 
	unFeriadoDiaDeMes := November / 25.
	
	
	unFeriadoExacto := November / 25 / 1999.
	
	calendar agregarDiaDeMesFeriado: unFeriadoDiaDeMes.
	
	self assert: (calendar esFeriado: unFeriadoExacto).!
!Calendario methodsFor: 'feriados' stamp: 'LK 10/5/2023 19:09:51' prior: 50689168!
esFeriado: unaFecha 

	(feriadosExactos includes: unaFecha) 
		or: [(feriadosDiaDeSemana includes: unaFecha day) 
			or: [(feriadosDiaDeMes includes: unaFecha dayOfMonth)]].
	! !

!testRun: #CalendarioTest #test01ThereCanBeNoHolidays stamp: 'LK 10/5/2023 19:09:56'!
ERROR!

!testRun: #CalendarioTest #test02OneDateCanBeHoliday stamp: 'LK 10/5/2023 19:09:56'!
ERROR!

!testRun: #CalendarioTest #test03OneWeekdayCanBeHoliday stamp: 'LK 10/5/2023 19:09:56'!
ERROR!

!testRun: #CalendarioTest #test04 stamp: 'LK 10/5/2023 19:09:56'!
ERROR!

!testRun: #CalendarioTest #test04MoreThanOneWeekdayCanBeHoliday stamp: 'LK 10/5/2023 19:09:56'!
ERROR!

!testRun: #CalendarioTest #test05 stamp: 'LK 10/5/2023 19:09:56'!
ERROR!

!testRun: #CalendarioTest #test01ThereCanBeNoHolidays stamp: 'LK 10/5/2023 19:10:31'!
ERROR!

!testRun: #CalendarioTest #test01ThereCanBeNoHolidays stamp: 'LK 10/5/2023 19:10:31'!
ERROR!
!Calendario methodsFor: 'feriados' stamp: 'LK 10/5/2023 19:10:52' prior: 50689260!
esFeriado: unaFecha 

	(feriadosExactos includes: unaFecha) 
		or: [(feriadosDiaDeSemana includes: unaFecha day) 
			or: [(feriadosDiaDeMes includes: unaFecha dayOfMonth)]].
		
	^false.
	! !
!Calendario methodsFor: 'feriados' stamp: 'LK 10/5/2023 19:11:31' prior: 50689291!
esFeriado: unaFecha 

	^(feriadosExactos includes: unaFecha) 
		or: [(feriadosDiaDeSemana includes: unaFecha day)
			or: [feriadosDiaDeMes includes: unaFecha dayOfMonth]].! !

!testRun: #CalendarioTest #test05 stamp: 'LK 10/5/2023 19:11:35'!
PASSED!

!testRun: #CalendarioTest #test01ThereCanBeNoHolidays stamp: 'LK 10/5/2023 19:11:39'!
PASSED!

!testRun: #CalendarioTest #test02OneDateCanBeHoliday stamp: 'LK 10/5/2023 19:11:39'!
PASSED!

!testRun: #CalendarioTest #test03OneWeekdayCanBeHoliday stamp: 'LK 10/5/2023 19:11:39'!
PASSED!

!testRun: #CalendarioTest #test04 stamp: 'LK 10/5/2023 19:11:39'!
PASSED!

!testRun: #CalendarioTest #test04MoreThanOneWeekdayCanBeHoliday stamp: 'LK 10/5/2023 19:11:39'!
PASSED!

!testRun: #CalendarioTest #test05 stamp: 'LK 10/5/2023 19:11:39'!
PASSED!
!CalendarioTest methodsFor: 'tests' stamp: 'LK 10/5/2023 19:11:59'!
test05OneDayOfMonthCanBeHoliday

	| unFeriadoDiaDeMes unFeriadoExacto|
	 
	unFeriadoDiaDeMes := November / 25.
	unFeriadoExacto := November / 25 / 1999.
	
	calendar agregarDiaDeMesFeriado: unFeriadoDiaDeMes.
	
	self assert: (calendar esFeriado: unFeriadoExacto).! !

!methodRemoval: CalendarioTest #test05 stamp: 'LK 10/5/2023 19:12:03'!
test05

	| unFeriadoDiaDeMes unFeriadoExacto|
	 
	unFeriadoDiaDeMes := November / 25.
	unFeriadoExacto := November / 25 / 1999.
	
	calendar agregarDiaDeMesFeriado: unFeriadoDiaDeMes.
	
	self assert: (calendar esFeriado: unFeriadoExacto).!
!Calendario methodsFor: 'feriados' stamp: 'LK 10/5/2023 19:15:05'!
esDiaDeSemanaFeriado: unaFecha

	^ feriadosDiaDeSemana includes: unaFecha day! !
!Calendario methodsFor: 'feriados' stamp: 'LK 10/5/2023 19:15:05' prior: 50689300!
esFeriado: unaFecha 

	^(feriadosExactos includes: unaFecha) 
		or: [(self esDiaDeSemanaFeriado: unaFecha)
			or: [feriadosDiaDeMes includes: unaFecha dayOfMonth]].! !
!Calendario methodsFor: 'feriados' stamp: 'LK 10/5/2023 19:15:32'!
esDiaDeMesFeriado: unaFecha

	^ feriadosDiaDeMes includes: unaFecha dayOfMonth! !
!Calendario methodsFor: 'feriados' stamp: 'LK 10/5/2023 19:15:33' prior: 50689354!
esFeriado: unaFecha 

	^(feriadosExactos includes: unaFecha) 
		or: [(self esDiaDeSemanaFeriado: unaFecha)
			or: [self esDiaDeMesFeriado: unaFecha]].! !
!Calendario methodsFor: 'feriados' stamp: 'LK 10/5/2023 19:16:01'!
esFechaFeriado: unaFecha

	^ feriadosExactos includes: unaFecha! !
!Calendario methodsFor: 'feriados' stamp: 'LK 10/5/2023 19:16:01' prior: 50689368!
esFeriado: unaFecha 

	^(self esFechaFeriado: unaFecha) 
		or: [(self esDiaDeSemanaFeriado: unaFecha)
			or: [self esDiaDeMesFeriado: unaFecha]].! !
!Calendario methodsFor: 'feriados' stamp: 'LK 10/5/2023 19:16:29' prior: 50689380!
esFeriado: unPosibleFeriado

	^(self esFechaFeriado: unPosibleFeriado) 
		or: [(self esDiaDeSemanaFeriado: unPosibleFeriado)
			or: [self esDiaDeMesFeriado: unPosibleFeriado]].! !

TestCase subclass: #TextXXX
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!

!classDefinition: #TextXXX category: 'Mars Rover- Exercise' stamp: 'LK 10/5/2023 20:12:42'!
TestCase subclass: #TextXXX
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!

TestCase subclass: #MarsRoverTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!

!classDefinition: #MarsRoverTest category: 'Mars Rover- Exercise' stamp: 'LK 10/5/2023 20:29:24'!
TestCase subclass: #MarsRoverTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!

!classRemoval: #TextXXX stamp: 'LK 10/5/2023 20:29:28'!
TestCase subclass: #TextXXX
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!

----QUIT----(5 October 2023 21:00:10) CuisUniversity-5981.image priorSource: 11422467!

----STARTUP---- (9 October 2023 02:14:22) as C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\CuisUniversity-5981.image!


----QUIT----(9 October 2023 02:21:01) CuisUniversity-5981.image priorSource: 11448802!

----STARTUP---- (9 October 2023 11:38:49) as C:\Users\lucas\OneDrive\Desktop\Facultad\isw1\windows64\CuisUniversity-5981.image!

!MarsRoverTest methodsFor: 'no messages' stamp: 'LK 10/9/2023 11:40:15'!
test01! !

!classDefinition: #MarsRover category: 'Mars Rover- Exercise' stamp: 'LK 10/9/2023 11:42:04'!
Object subclass: #MarsRover
	instanceVariableNames: 'position direction'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 11:41:40' prior: 50689439!
test01
	| marsRover coordinate direction|
	
	coordinate := 0@0.
	direction := #North.
	marsRover := MarsRover withCoord: coordinate pointingTo: direction.
	
	self assert: ((marsRover at: coordinate) and: [marsRover cardinal: direction]).
	! !

!testRun: #MarsRoverTest #test01 stamp: 'LK 10/9/2023 11:42:06'!
ERROR!
!MarsRover class methodsFor: 'instance creation' stamp: 'LK 10/9/2023 11:42:13'!
withCoord: coordinate pointingTo: direction 
	"DO NOT FORGET TO RENAME COLLABORATORS AND REMOVE THIS COMMENT!!!!"
	self shouldBeImplemented.
	^self new initializeWithCoord: coordinate pointingTo: direction ! !

!classDefinition: 'MarsRover class' category: 'Mars Rover- Exercise' stamp: 'LK 10/9/2023 11:43:01'!
MarsRover class
	instanceVariableNames: 'position'!
!MarsRover class methodsFor: 'instance creation' stamp: 'LK 10/9/2023 11:43:11' prior: 50689464!
withCoord: aCoordinate pointingTo: aDirection 
! !
!MarsRover class methodsFor: 'instance creation' stamp: 'LK 10/9/2023 11:43:52' prior: 50689479!
withCoord: aCoordinate pointingTo: aDirection 
	^self new withCoord: aCoordinate pointingTo: aDirection.! !

MarsRover class
	instanceVariableNames: ''!

!classDefinition: 'MarsRover class' category: 'Mars Rover- Exercise' stamp: 'LK 10/9/2023 11:44:01'!
MarsRover class
	instanceVariableNames: ''!
!MarsRover methodsFor: 'no messages' stamp: 'LK 10/9/2023 11:44:17'!
withCoord: aCoordinate pointingTo: aDirection
	position := aCoordinate.
	direction := aDirection 
	! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 11:44:21' prior: 50689496!
withCoord: aCoordinate pointingTo: aDirection
	position := aCoordinate.
	direction := aDirection.
	! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 11:44:41' overrides: 16901507!
at: aPosition
	^position = aPosition.! !
!MarsRover methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 11:44:57'!
cardinal: aDirection
	^direction = aDirection.! !

!testRun: #MarsRoverTest #test01 stamp: 'LK 10/9/2023 11:45:04'!
PASSED!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 11:45:23'!
test02
	|marsRover coordinate direction commands|
	coordinate := 0@0.
	direction := #North.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := ''. 
	marsRover execute: commands.
	self assert: ((marsRover at: coordinate) and: [marsRover cardinal: direction]).
	
	
	! !

!testRun: #MarsRoverTest #test02 stamp: 'LK 10/9/2023 11:45:25'!
ERROR!
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 11:45:42'!
execute: commands 
	self shouldBeImplemented.! !
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 11:45:45' prior: 50689535!
execute: commands 
	! !

!testRun: #MarsRoverTest #test02 stamp: 'LK 10/9/2023 11:45:49'!
PASSED!

!testRun: #MarsRoverTest #test01 stamp: 'LK 10/9/2023 11:45:49'!
PASSED!

!testRun: #MarsRoverTest #test02 stamp: 'LK 10/9/2023 11:45:49'!
PASSED!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 11:46:21'!
test03
	|marsRover coordinate direction commands finalCoordinate|
	coordinate := 0@0.
	direction := #North.
	finalCoordinate := coordinate + (0@1).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	self assert: ((marsRover at: finalCoordinate) and: [marsRover cardinal: direction]).
	
	
	! !
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 11:47:15' prior: 50689551!
test03

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := #North.
	finalCoordinate := coordinate + (0@1).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	self assert: ((marsRover at: finalCoordinate) and: [marsRover cardinal: direction]).
	
	
	! !

!testRun: #MarsRoverTest #test03 stamp: 'LK 10/9/2023 11:47:31'!
FAILURE!
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 11:49:57' prior: 50689540!
execute: commands 
	
	(commands = 'f') ifTrue: [ position = position + (0@1)].! !

!testRun: #MarsRoverTest #test03 stamp: 'LK 10/9/2023 11:50:00'!
ERROR!

!testRun: #MarsRoverTest #test03 stamp: 'LK 10/9/2023 11:50:00'!
ERROR!
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 11:50:21' prior: 50689583!
execute: commands 
	
	(commands = 'f') ifTrue: [ position := position + (0@1)].! !

!testRun: #MarsRoverTest #test01 stamp: 'LK 10/9/2023 11:50:44'!
PASSED!

!testRun: #MarsRoverTest #test02 stamp: 'LK 10/9/2023 11:50:44'!
PASSED!

!testRun: #MarsRoverTest #test03 stamp: 'LK 10/9/2023 11:50:44'!
PASSED!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 11:51:08'!
test04

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := #South.
	finalCoordinate := coordinate - (0@1).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	self assert: ((marsRover at: finalCoordinate) and: [marsRover cardinal: direction]).
	
	
	! !

(0@0) + (0@-1)!
!MarsRoverTest methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 11:51:51' prior: 50689606!
test04

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := #South.
	finalCoordinate := coordinate + (0@-1).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	self assert: ((marsRover at: finalCoordinate) and: [marsRover cardinal: direction]).
	
	
	! !

!testRun: #MarsRoverTest #test04 stamp: 'LK 10/9/2023 11:51:54'!
FAILURE!
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 11:53:39' prior: 50689593!
execute: commands 
	
	(commands = 'f') ifTrue: [ 
		(direction = #South) ifTrue: [ position := position + (0@-1)].
		(direction = #North) ifTrue: [position := position + (0@1)].
		
		]! !

!testRun: #MarsRoverTest #test01 stamp: 'LK 10/9/2023 11:53:45'!
PASSED!

!testRun: #MarsRoverTest #test04 stamp: 'LK 10/9/2023 11:53:49'!
PASSED!

!testRun: #MarsRoverTest #test01 stamp: 'LK 10/9/2023 11:54:18'!
PASSED!

!testRun: #MarsRoverTest #test02 stamp: 'LK 10/9/2023 11:54:18'!
PASSED!

!testRun: #MarsRoverTest #test03 stamp: 'LK 10/9/2023 11:54:18'!
PASSED!

!testRun: #MarsRoverTest #test04 stamp: 'LK 10/9/2023 11:54:18'!
PASSED!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 11:54:34' prior: 50689621!
test04

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := #East.
	finalCoordinate := coordinate + (1@0).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	self assert: ((marsRover at: finalCoordinate) and: [marsRover cardinal: direction]).
	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 11:54:42' prior: 50689661!
test04

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := #West.
	finalCoordinate := coordinate + (-1@0).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	self assert: ((marsRover at: finalCoordinate) and: [marsRover cardinal: direction]).
	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 11:51:51' prior: 50689676!
test04

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := #South.
	finalCoordinate := coordinate + (0@-1).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	self assert: ((marsRover at: finalCoordinate) and: [marsRover cardinal: direction]).
	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 11:55:09'!
test05

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := #West.
	finalCoordinate := coordinate + (-1@0).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	self assert: ((marsRover at: finalCoordinate) and: [marsRover cardinal: direction]).
	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 11:55:28'!
test06

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := #East.
	finalCoordinate := coordinate + (1@0).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	self assert: ((marsRover at: finalCoordinate) and: [marsRover cardinal: direction]).
	
	
	! !

!testRun: #MarsRoverTest #test06 stamp: 'LK 10/9/2023 11:55:31'!
FAILURE!

!testRun: #MarsRoverTest #test05 stamp: 'LK 10/9/2023 11:55:36'!
FAILURE!
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 11:56:08' prior: 50689638!
execute: commands 
	
	(commands = 'f') ifTrue: [ 
		(direction = #South) ifTrue: [ position := position + (0@-1)].
		(direction = #North) ifTrue: [position := position + (0@1)].
		(direction = #West) ifTrue: [position := position + (-1@0)].
		]! !
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 11:56:52' prior: 50689738!
execute: commands 
	
	(commands = 'f') ifTrue: [ 
		(direction = #South) ifTrue: [ position := position + (0@-1)].
		(direction = #North) ifTrue: [position := position + (0@1)].
		(direction = #West) ifTrue: [position := position + (-1@0)].
		(direction = #East) ifTrue: [position := position + (1@0)]. 
		].! !

!testRun: #MarsRoverTest #test01 stamp: 'LK 10/9/2023 11:56:56'!
PASSED!

!testRun: #MarsRoverTest #test02 stamp: 'LK 10/9/2023 11:56:56'!
PASSED!

!testRun: #MarsRoverTest #test03 stamp: 'LK 10/9/2023 11:56:56'!
PASSED!

!testRun: #MarsRoverTest #test04 stamp: 'LK 10/9/2023 11:56:56'!
PASSED!

!testRun: #MarsRoverTest #test05 stamp: 'LK 10/9/2023 11:56:56'!
PASSED!

!testRun: #MarsRoverTest #test06 stamp: 'LK 10/9/2023 11:56:57'!
PASSED!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:06:28' prior: 50689566!
test03

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := #North.
	finalCoordinate := coordinate + (0@1).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate) and: [marsRover cardinal: direction]).
	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:08:32'!
shouldBeIn: finalCoordinate poitingTo: direction marsRover: marsRover

	^ (marsRover at: finalCoordinate) and: [marsRover cardinal: direction]! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:08:32' prior: 50689719!
test06

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := #East.
	finalCoordinate := coordinate + (1@0).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	self assert: (self shouldBeIn: finalCoordinate poitingTo: direction marsRover: marsRover).
	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:08:32' prior: 50689705!
test05

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := #West.
	finalCoordinate := coordinate + (-1@0).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	self assert: (self shouldBeIn: finalCoordinate poitingTo: direction marsRover: marsRover).
	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:08:32' prior: 50689776!
test03

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := #North.
	finalCoordinate := coordinate + (0@1).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	
	self assert: (self shouldBeIn: finalCoordinate poitingTo: direction marsRover: marsRover).
	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:08:32' prior: 50689691!
test04

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := #South.
	finalCoordinate := coordinate + (0@-1).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	self assert: (self shouldBeIn: finalCoordinate poitingTo: direction marsRover: marsRover).
	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:11:04'!
assertThatMarsRover: aMarsRover shouldBeIn: aCoordinate pointingTo: aDirection

	self assert: (aMarsRover at: aCoordinate and: [aMarsRover cardinal: aDirection]).! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:11:34' prior: 50689857!
assertThatMarsRover: aMarsRover shouldBeIn: aCoordinate pointingTo: aDirection

	self assert: (aMarsRover at: aCoordinate and: [aMarsRover cardinal: aDirection]).! !
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 12:13:06' prior: 50689749!
execute: commands 
	
	(commands = 'f') ifTrue: [ 
		(direction = #South) ifTrue: [ position := position + (0@-1)].
		(direction = #North) ifTrue: [position := position + (0@1)].
		(direction = #West) ifTrue: [position := position + (-1@0)].
		(direction = #East) ifTrue: [position := position + (1@0)]. 
		].
	
	(commands = 'b') ifTrue: [ 
		(direction = #South) ifTrue: [ position := position - (0@-1)].
		(direction = #North) ifTrue: [position := position - (0@1)].
		(direction = #West) ifTrue: [position := position - (-1@0)].
		(direction = #East) ifTrue: [position := position - (1@0)]. 
		].! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:13:18' prior: 50689521!
test02
	|marsRover coordinate direction commands|
	coordinate := 0@0.
	direction := #North.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := ''. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: coordinate) and: [marsRover cardinal: direction]).
	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:13:26' prior: 50689828!
test03

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := #North.
	finalCoordinate := coordinate + (0@1).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: coordinate) and: [marsRover cardinal: direction]).	
	
	! !

!testRun: #MarsRoverTest #test01 stamp: 'LK 10/9/2023 12:13:39'!
PASSED!

!testRun: #MarsRoverTest #test01 stamp: 'LK 10/9/2023 12:13:40'!
PASSED!

!testRun: #MarsRoverTest #test02 stamp: 'LK 10/9/2023 12:13:40'!
PASSED!

!testRun: #MarsRoverTest #test03 stamp: 'LK 10/9/2023 12:13:40'!
FAILURE!

!testRun: #MarsRoverTest #test04 stamp: 'LK 10/9/2023 12:13:40'!
PASSED!

!testRun: #MarsRoverTest #test05 stamp: 'LK 10/9/2023 12:13:40'!
PASSED!

!testRun: #MarsRoverTest #test06 stamp: 'LK 10/9/2023 12:13:40'!
PASSED!

!testRun: #MarsRoverTest #test03 stamp: 'LK 10/9/2023 12:13:40'!
FAILURE!

!testRun: #MarsRoverTest #test01 stamp: 'LK 10/9/2023 12:13:55'!
PASSED!

!testRun: #MarsRoverTest #test01 stamp: 'LK 10/9/2023 12:13:55'!
PASSED!

!testRun: #MarsRoverTest #test02 stamp: 'LK 10/9/2023 12:13:55'!
PASSED!

!testRun: #MarsRoverTest #test03 stamp: 'LK 10/9/2023 12:13:55'!
FAILURE!

!testRun: #MarsRoverTest #test04 stamp: 'LK 10/9/2023 12:13:55'!
PASSED!

!testRun: #MarsRoverTest #test05 stamp: 'LK 10/9/2023 12:13:55'!
PASSED!

!testRun: #MarsRoverTest #test06 stamp: 'LK 10/9/2023 12:13:55'!
PASSED!

!testRun: #MarsRoverTest #test03 stamp: 'LK 10/9/2023 12:13:55'!
FAILURE!
!MarsRover methodsFor: 'init' stamp: 'LK 10/9/2023 12:14:05' prior: 50689503!
withCoord: aCoordinate pointingTo: aDirection

	position := aCoordinate.
	direction := aDirection.
	! !

!testRun: #MarsRoverTest #test01 stamp: 'LK 10/9/2023 12:14:13'!
PASSED!

!testRun: #MarsRoverTest #test01 stamp: 'LK 10/9/2023 12:14:13'!
PASSED!

!testRun: #MarsRoverTest #test02 stamp: 'LK 10/9/2023 12:14:13'!
PASSED!

!testRun: #MarsRoverTest #test03 stamp: 'LK 10/9/2023 12:14:13'!
FAILURE!

!testRun: #MarsRoverTest #test04 stamp: 'LK 10/9/2023 12:14:13'!
PASSED!

!testRun: #MarsRoverTest #test05 stamp: 'LK 10/9/2023 12:14:13'!
PASSED!

!testRun: #MarsRoverTest #test06 stamp: 'LK 10/9/2023 12:14:13'!
PASSED!

!testRun: #MarsRoverTest #test03 stamp: 'LK 10/9/2023 12:14:13'!
FAILURE!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:14:47' prior: 50689843!
test04

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := #South.
	finalCoordinate := coordinate + (0@-1).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	
	self assert: (self shouldBeIn: finalCoordinate poitingTo: direction marsRover: marsRover).
	
	
	! !

!testRun: #MarsRoverTest #test01 stamp: 'LK 10/9/2023 12:14:48'!
PASSED!

!testRun: #MarsRoverTest #test02 stamp: 'LK 10/9/2023 12:14:48'!
PASSED!

!testRun: #MarsRoverTest #test03 stamp: 'LK 10/9/2023 12:14:48'!
FAILURE!

!testRun: #MarsRoverTest #test04 stamp: 'LK 10/9/2023 12:14:48'!
PASSED!

!testRun: #MarsRoverTest #test05 stamp: 'LK 10/9/2023 12:14:48'!
PASSED!

!testRun: #MarsRoverTest #test06 stamp: 'LK 10/9/2023 12:14:48'!
PASSED!

!testRun: #MarsRoverTest #test03 stamp: 'LK 10/9/2023 12:14:48'!
FAILURE!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:14:57' prior: 50689908!
test03

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := #North.
	finalCoordinate := coordinate + (0@1).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	! !

!testRun: #MarsRoverTest #test03 stamp: 'LK 10/9/2023 12:14:58'!
PASSED!

!testRun: #MarsRoverTest #test01 stamp: 'LK 10/9/2023 12:14:58'!
PASSED!

!testRun: #MarsRoverTest #test02 stamp: 'LK 10/9/2023 12:14:58'!
PASSED!

!testRun: #MarsRoverTest #test03 stamp: 'LK 10/9/2023 12:14:58'!
PASSED!

!testRun: #MarsRoverTest #test04 stamp: 'LK 10/9/2023 12:14:58'!
PASSED!

!testRun: #MarsRoverTest #test05 stamp: 'LK 10/9/2023 12:14:58'!
PASSED!

!testRun: #MarsRoverTest #test06 stamp: 'LK 10/9/2023 12:14:58'!
PASSED!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:15:16' prior: 50689984!
test04

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := #South.
	finalCoordinate := coordinate + (0@-1).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:15:24' prior: 50689813!
test05

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := #West.
	finalCoordinate := coordinate + (-1@0).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:15:30' prior: 50689798!
test06

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := #East.
	finalCoordinate := coordinate + (1@0).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	
	! !

!testRun: #MarsRoverTest #test01 stamp: 'LK 10/9/2023 12:15:33'!
PASSED!

!testRun: #MarsRoverTest #test02 stamp: 'LK 10/9/2023 12:15:33'!
PASSED!

!testRun: #MarsRoverTest #test03 stamp: 'LK 10/9/2023 12:15:33'!
PASSED!

!testRun: #MarsRoverTest #test04 stamp: 'LK 10/9/2023 12:15:33'!
PASSED!

!testRun: #MarsRoverTest #test05 stamp: 'LK 10/9/2023 12:15:33'!
PASSED!

!testRun: #MarsRoverTest #test06 stamp: 'LK 10/9/2023 12:15:33'!
PASSED!

!methodRemoval: MarsRoverTest #shouldBeIn:poitingTo:marsRover: stamp: 'LK 10/9/2023 12:15:37'!
shouldBeIn: finalCoordinate poitingTo: direction marsRover: marsRover

	^ (marsRover at: finalCoordinate) and: [marsRover cardinal: direction]!

!methodRemoval: MarsRoverTest #assertThatMarsRover:shouldBeIn:pointingTo: stamp: 'LK 10/9/2023 12:15:39'!
assertThatMarsRover: aMarsRover shouldBeIn: aCoordinate pointingTo: aDirection

	self assert: (aMarsRover at: aCoordinate and: [aMarsRover cardinal: aDirection]).!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:17:15'!
test07

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := #North.
	finalCoordinate := coordinate - (0@1).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'b'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:17:31'!
test08

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := #South.
	finalCoordinate := coordinate - (0@-1).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'b'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:19:01'!
test09

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := #West.
	finalCoordinate := coordinate - (0@0).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'b'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:19:51' prior: 50690148!
test09

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := #West.
	finalCoordinate := coordinate - (-1@0).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'b'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:20:21' prior: 50690163!
test09

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := #East.
	finalCoordinate := coordinate - (1@0).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'b'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	! !

!testRun: #MarsRoverTest #test09 stamp: 'LK 10/9/2023 12:20:22'!
PASSED!

!testRun: #MarsRoverTest #test01 stamp: 'LK 10/9/2023 12:20:24'!
PASSED!

!testRun: #MarsRoverTest #test02 stamp: 'LK 10/9/2023 12:20:24'!
PASSED!

!testRun: #MarsRoverTest #test03 stamp: 'LK 10/9/2023 12:20:24'!
PASSED!

!testRun: #MarsRoverTest #test04 stamp: 'LK 10/9/2023 12:20:24'!
PASSED!

!testRun: #MarsRoverTest #test05 stamp: 'LK 10/9/2023 12:20:24'!
PASSED!

!testRun: #MarsRoverTest #test06 stamp: 'LK 10/9/2023 12:20:24'!
PASSED!

!testRun: #MarsRoverTest #test07 stamp: 'LK 10/9/2023 12:20:24'!
PASSED!

!testRun: #MarsRoverTest #test08 stamp: 'LK 10/9/2023 12:20:24'!
PASSED!

!testRun: #MarsRoverTest #test09 stamp: 'LK 10/9/2023 12:20:24'!
PASSED!

Object subclass: #Direction
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!

!classDefinition: #Direction category: 'Mars Rover- Exercise' stamp: 'LK 10/9/2023 12:20:39'!
Object subclass: #Direction
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!

Direction subclass: #West
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!

!classDefinition: #West category: 'Mars Rover- Exercise' stamp: 'LK 10/9/2023 12:20:48'!
Direction subclass: #West
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!

Direction subclass: #East
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!

!classDefinition: #East category: 'Mars Rover- Exercise' stamp: 'LK 10/9/2023 12:20:51'!
Direction subclass: #East
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!

Direction subclass: #South
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!

!classDefinition: #South category: 'Mars Rover- Exercise' stamp: 'LK 10/9/2023 12:20:54'!
Direction subclass: #South
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!

Direction subclass: #North
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!

!classDefinition: #North category: 'Mars Rover- Exercise' stamp: 'LK 10/9/2023 12:20:59'!
Direction subclass: #North
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!
!Direction methodsFor: 'no messages' stamp: 'LK 10/9/2023 12:22:11'!
goFoward! !
!West methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 12:22:15' overrides: 50690272!
goFoward! !
!East methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 12:22:15' overrides: 50690272!
goFoward! !
!South methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 12:22:15' overrides: 50690272!
goFoward! !
!North methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 12:22:15' overrides: 50690272!
goFoward! !
!Direction methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 12:22:15' prior: 50690272!
goFoward

	self subclassResponsibility! !
!East methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 12:22:37' prior: 50690280 overrides: 50690292!
goFoward
	^(1@0).! !
!West methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 12:22:50' prior: 50690276 overrides: 50690292!
goFoward
	^(-1@0).! !
!North methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 12:22:56' prior: 50690288 overrides: 50690292!
goFoward
	^(0@1)! !
!South methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 12:23:06' prior: 50690284 overrides: 50690292!
goFoward
	^(0@-1).! !
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 12:23:50' prior: 50689873!
execute: commands 
	
	(commands = 'f') ifTrue: [	position := position + direction goFoward].
	
	(commands = 'b') ifTrue: [ 
		(direction = #South) ifTrue: [ position := position - (0@-1)].
		(direction = #North) ifTrue: [position := position - (0@1)].
		(direction = #West) ifTrue: [position := position - (-1@0)].
		(direction = #East) ifTrue: [position := position - (1@0)]. 
		].! !
!Direction methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 12:24:34'!
goForward

	self subclassResponsibility! !

!methodRemoval: Direction #goFoward stamp: 'LK 10/9/2023 12:24:34'!
goFoward

	self subclassResponsibility!
!East methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 12:24:47' overrides: 50690331!
goForward
	^(1@0).! !

!methodRemoval: East #goFoward stamp: 'LK 10/9/2023 12:25:34'!
goFoward
	^(1@0).!
!North methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 12:25:38' overrides: 50690331!
goForward
	^(0@1)! !

!methodRemoval: North #goFoward stamp: 'LK 10/9/2023 12:25:40'!
goFoward
	^(0@1)!
!South methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 12:25:45' overrides: 50690331!
goForward
	^(0@-1).! !

!methodRemoval: South #goFoward stamp: 'LK 10/9/2023 12:25:48'!
goFoward
	^(0@-1).!
!West methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 12:25:52' overrides: 50690331!
goForward
	^(-1@0).! !

!methodRemoval: West #goFoward stamp: 'LK 10/9/2023 12:25:54'!
goFoward
	^(-1@0).!
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 12:26:02' prior: 50690316!
execute: commands 
	
	(commands = 'f') ifTrue: [	position := position + direction goForward].
	
	(commands = 'b') ifTrue: [ 
		(direction = #South) ifTrue: [ position := position - (0@-1)].
		(direction = #North) ifTrue: [position := position - (0@1)].
		(direction = #West) ifTrue: [position := position - (-1@0)].
		(direction = #East) ifTrue: [position := position - (1@0)]. 
		].! !
!Direction methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 12:26:12'!
goBackwards! !
!West methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 12:26:16' overrides: 50690381!
goBackwards! !
!East methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 12:26:16' overrides: 50690381!
goBackwards! !
!South methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 12:26:16' overrides: 50690381!
goBackwards! !
!North methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 12:26:16' overrides: 50690381!
goBackwards! !
!Direction methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 12:26:16' prior: 50690381!
goBackwards

	self subclassResponsibility! !

!methodRemoval: East #goBackwards stamp: 'LK 10/9/2023 12:26:40'!
goBackwards!

!classRemoval: #South stamp: 'LK 10/9/2023 12:26:44'!
Direction subclass: #South
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!

!methodRemoval: West #goBackwards stamp: 'LK 10/9/2023 12:26:51'!
goBackwards!

!methodRemoval: North #goBackwards stamp: 'LK 10/9/2023 12:26:53'!
goBackwards!

Direction subclass: #South
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!

!classDefinition: #South category: 'Mars Rover- Exercise' stamp: 'LK 10/9/2023 12:27:04'!
Direction subclass: #South
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!
!South methodsFor: 'no messages' stamp: 'LK 10/9/2023 12:27:19'!
goForwards
	^(0@-1)! !
!Direction methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 12:27:50' prior: 50690401!
goBackwards

	 
		! !
!West methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 12:27:56' overrides: 50690434!
goBackwards

	 
		! !
!East methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 12:27:57' overrides: 50690434!
goBackwards

	 
		! !
!North methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 12:27:57' overrides: 50690434!
goBackwards

	 
		! !
!South methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 12:27:57' overrides: 50690434!
goBackwards

	 
		! !
!Direction methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 12:27:57' prior: 50690434!
goBackwards

	self subclassResponsibility! !
!East methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 12:28:15' prior: 50690442 overrides: 50690454!
goBackwards
	^(-1@0).
		! !
!North methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 12:28:28' prior: 50690446 overrides: 50690454!
goBackwards
	^(0@-1)! !
!South methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 12:28:39' prior: 50690450 overrides: 50690454!
goBackwards

	 ^(0@1)
		! !
!West methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 12:28:50' prior: 50690438 overrides: 50690454!
goBackwards
	^(1@0)
	 
		! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:29:32' prior: 50689451!
test01
	| marsRover coordinate direction|
	
	coordinate := 0@0.
	direction := North.
	marsRover := MarsRover withCoord: coordinate pointingTo: direction.
	
	self assert: ((marsRover at: coordinate) and: [marsRover cardinal: direction]).
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:29:57' prior: 50689895!
test02
	|marsRover coordinate direction commands|
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := ''. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: coordinate) and: [marsRover cardinal: direction]).
	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:30:03' prior: 50690478!
test01
	| marsRover coordinate direction|
	
	coordinate := 0@0.
	direction := North new.
	marsRover := MarsRover withCoord: coordinate pointingTo: direction.
	
	self assert: ((marsRover at: coordinate) and: [marsRover cardinal: direction]).
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:30:10' prior: 50690015!
test03

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := North new.
	finalCoordinate := coordinate + (0@1).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:30:16' prior: 50690046!
test04

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := South new.
	finalCoordinate := coordinate + (0@-1).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:30:22' prior: 50690061!
test05

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := West new.
	finalCoordinate := coordinate + (-1@0).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:30:39' prior: 50690120!
test07

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := North new.
	finalCoordinate := coordinate - (0@1).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'b'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:30:53' prior: 50690178!
test09

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := East new.
	finalCoordinate := coordinate - (1@0).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'b'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	! !

!testRun: #MarsRoverTest #test01 stamp: 'LK 10/9/2023 12:31:14'!
PASSED!

!testRun: #MarsRoverTest #test02 stamp: 'LK 10/9/2023 12:31:16'!
PASSED!

!testRun: #MarsRoverTest #test03 stamp: 'LK 10/9/2023 12:31:18'!
PASSED!

!testRun: #MarsRoverTest #test04 stamp: 'LK 10/9/2023 12:31:19'!
ERROR!

!testRun: #MarsRoverTest #test04 stamp: 'LK 10/9/2023 12:31:19'!
ERROR!

!testRun: #MarsRoverTest #test03 stamp: 'LK 10/9/2023 12:31:34'!
PASSED!

!testRun: #MarsRoverTest #test01 stamp: 'LK 10/9/2023 12:31:34'!
PASSED!

!testRun: #MarsRoverTest #test02 stamp: 'LK 10/9/2023 12:31:34'!
PASSED!

!testRun: #MarsRoverTest #test03 stamp: 'LK 10/9/2023 12:31:34'!
PASSED!

!testRun: #MarsRoverTest #test04 stamp: 'LK 10/9/2023 12:31:34'!
ERROR!

!testRun: #MarsRoverTest #test05 stamp: 'LK 10/9/2023 12:31:34'!
PASSED!

!testRun: #MarsRoverTest #test06 stamp: 'LK 10/9/2023 12:31:34'!
ERROR!

!testRun: #MarsRoverTest #test07 stamp: 'LK 10/9/2023 12:31:34'!
FAILURE!

!testRun: #MarsRoverTest #test08 stamp: 'LK 10/9/2023 12:31:34'!
PASSED!

!testRun: #MarsRoverTest #test09 stamp: 'LK 10/9/2023 12:31:34'!
FAILURE!

!testRun: #MarsRoverTest #test03 stamp: 'LK 10/9/2023 12:31:37'!
PASSED!

!testRun: #MarsRoverTest #test04 stamp: 'LK 10/9/2023 12:31:41'!
ERROR!
!South methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 12:32:12' overrides: 50690331!
goForward
	^(0@-1)! !

!methodRemoval: South #goForwards stamp: 'LK 10/9/2023 12:32:12'!
goForwards
	^(0@-1)!

!testRun: #MarsRoverTest #test01 stamp: 'LK 10/9/2023 12:32:16'!
PASSED!

!testRun: #MarsRoverTest #test02 stamp: 'LK 10/9/2023 12:32:16'!
PASSED!

!testRun: #MarsRoverTest #test03 stamp: 'LK 10/9/2023 12:32:16'!
PASSED!

!testRun: #MarsRoverTest #test04 stamp: 'LK 10/9/2023 12:32:16'!
PASSED!

!testRun: #MarsRoverTest #test05 stamp: 'LK 10/9/2023 12:32:16'!
PASSED!

!testRun: #MarsRoverTest #test06 stamp: 'LK 10/9/2023 12:32:16'!
ERROR!

!testRun: #MarsRoverTest #test07 stamp: 'LK 10/9/2023 12:32:16'!
FAILURE!

!testRun: #MarsRoverTest #test08 stamp: 'LK 10/9/2023 12:32:16'!
PASSED!

!testRun: #MarsRoverTest #test09 stamp: 'LK 10/9/2023 12:32:16'!
FAILURE!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:32:59' prior: 50690134!
test08

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := South new.
	finalCoordinate := coordinate - (0@-1).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'b'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:33:09' prior: 50690076!
test06

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := East new.
	finalCoordinate := coordinate + (1@0).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:33:22' prior: 50690513!
test03

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := #North.
	finalCoordinate := coordinate + (0@1).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	! !

!testRun: #MarsRoverTest #test03 stamp: 'LK 10/9/2023 12:33:24'!
ERROR!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:33:30' prior: 50690684!
test03

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := North new.
	finalCoordinate := coordinate + (0@1).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:33:42'!
test10

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := West new.
	finalCoordinate := coordinate - (1@0).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'b'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:33:51' prior: 50690715!
test10

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := West new.
	finalCoordinate := coordinate - (-1@0).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'b'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	! !
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 12:34:15' prior: 50690366!
execute: commands 
	
	(commands = 'f') ifTrue: [	position := position + direction goForward].
	
	(commands = 'b') ifTrue: [ position := position + direction goBackwards].! !

!testRun: #MarsRoverTest #test01 stamp: 'LK 10/9/2023 12:34:18'!
PASSED!

!testRun: #MarsRoverTest #test02 stamp: 'LK 10/9/2023 12:34:18'!
PASSED!

!testRun: #MarsRoverTest #test03 stamp: 'LK 10/9/2023 12:34:18'!
PASSED!

!testRun: #MarsRoverTest #test04 stamp: 'LK 10/9/2023 12:34:18'!
PASSED!

!testRun: #MarsRoverTest #test05 stamp: 'LK 10/9/2023 12:34:18'!
PASSED!

!testRun: #MarsRoverTest #test06 stamp: 'LK 10/9/2023 12:34:18'!
PASSED!

!testRun: #MarsRoverTest #test07 stamp: 'LK 10/9/2023 12:34:18'!
PASSED!

!testRun: #MarsRoverTest #test08 stamp: 'LK 10/9/2023 12:34:18'!
PASSED!

!testRun: #MarsRoverTest #test09 stamp: 'LK 10/9/2023 12:34:18'!
PASSED!

!testRun: #MarsRoverTest #test10 stamp: 'LK 10/9/2023 12:34:18'!
PASSED!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:34:45'!
test01shouldInitializeInGivenCoordinateAndDirection
	| marsRover coordinate direction|
	
	coordinate := 0@0.
	direction := North new.
	marsRover := MarsRover withCoord: coordinate pointingTo: direction.
	
	self assert: ((marsRover at: coordinate) and: [marsRover cardinal: direction]).
	! !

!methodRemoval: MarsRoverTest #test01 stamp: 'LK 10/9/2023 12:34:48'!
test01
	| marsRover coordinate direction|
	
	coordinate := 0@0.
	direction := North new.
	marsRover := MarsRover withCoord: coordinate pointingTo: direction.
	
	self assert: ((marsRover at: coordinate) and: [marsRover cardinal: direction]).
	!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:35:08'!
test02shouldDoNothingOnEmptyString

	|marsRover coordinate direction commands|
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := ''. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: coordinate) and: [marsRover cardinal: direction]).
	
	
	! !

!methodRemoval: MarsRoverTest #test02 stamp: 'LK 10/9/2023 12:35:10'!
test02
	|marsRover coordinate direction commands|
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := ''. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: coordinate) and: [marsRover cardinal: direction]).
	
	
	!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:36:10'!
test03shouldMoveForwardsPointingNorth

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := North new.
	finalCoordinate := coordinate + (0@1).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:36:34'!
test03shouldMoveForwardsPointingNorthCorrectly

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := North new.
	finalCoordinate := coordinate + (0@1).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	! !

!methodRemoval: MarsRoverTest #test03 stamp: 'LK 10/9/2023 12:36:36'!
test03

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := North new.
	finalCoordinate := coordinate + (0@1).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	!

!methodRemoval: MarsRoverTest #test03shouldMoveForwardsPointingNorth stamp: 'LK 10/9/2023 12:36:37'!
test03shouldMoveForwardsPointingNorth

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := North new.
	finalCoordinate := coordinate + (0@1).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:36:54'!
test04shouldMoveForwardsPointingSouthCorrectly

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := South new.
	finalCoordinate := coordinate + (0@-1).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	
	! !

!methodRemoval: MarsRoverTest #test04 stamp: 'LK 10/9/2023 12:36:55'!
test04

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := South new.
	finalCoordinate := coordinate + (0@-1).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	
	!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:37:16'!
test05shouldMoveForwardsPointingWestCorrectly

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := West new.
	finalCoordinate := coordinate + (-1@0).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	
	! !

!methodRemoval: MarsRoverTest #test05 stamp: 'LK 10/9/2023 12:37:16'!
test05

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := West new.
	finalCoordinate := coordinate + (-1@0).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	
	!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:37:26'!
test06shouldMoveForwardsPointingEastCorrectly

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := East new.
	finalCoordinate := coordinate + (1@0).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	
	! !

!methodRemoval: MarsRoverTest #test06 stamp: 'LK 10/9/2023 12:37:27'!
test06

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := East new.
	finalCoordinate := coordinate + (1@0).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	
	!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:37:45'!
test07shouldMoveBackwardsPointingNorthCorrectly

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := North new.
	finalCoordinate := coordinate - (0@1).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'b'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	! !

!methodRemoval: MarsRoverTest #test07 stamp: 'LK 10/9/2023 12:37:47'!
test07

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := North new.
	finalCoordinate := coordinate - (0@1).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'b'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:37:53'!
test08shouldMoveBackwardsPointingSouthCorrectly

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := South new.
	finalCoordinate := coordinate - (0@-1).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'b'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	! !

!methodRemoval: MarsRoverTest #test08 stamp: 'LK 10/9/2023 12:37:54'!
test08

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := South new.
	finalCoordinate := coordinate - (0@-1).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'b'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:38:01'!
test09shouldMoveBackwardsPointingEastCorrectly

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := East new.
	finalCoordinate := coordinate - (1@0).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'b'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	! !

!methodRemoval: MarsRoverTest #test09 stamp: 'LK 10/9/2023 12:38:02'!
test09

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := East new.
	finalCoordinate := coordinate - (1@0).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'b'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:38:09'!
test10shouldMoveBackwardsPointingWestCorrectly

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := West new.
	finalCoordinate := coordinate - (-1@0).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'b'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	! !

!methodRemoval: MarsRoverTest #test10 stamp: 'LK 10/9/2023 12:38:10'!
test10

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := West new.
	finalCoordinate := coordinate - (-1@0).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'b'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	
	!

!testRun: #MarsRoverTest #test01shouldInitializeInGivenCoordinateAndDirection stamp: 'LK 10/9/2023 12:38:14'!
PASSED!

!testRun: #MarsRoverTest #test02shouldDoNothingOnEmptyString stamp: 'LK 10/9/2023 12:38:14'!
PASSED!

!testRun: #MarsRoverTest #test03shouldMoveForwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 12:38:14'!
PASSED!

!testRun: #MarsRoverTest #test04shouldMoveForwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 12:38:14'!
PASSED!

!testRun: #MarsRoverTest #test05shouldMoveForwardsPointingWestCorrectly stamp: 'LK 10/9/2023 12:38:14'!
PASSED!

!testRun: #MarsRoverTest #test06shouldMoveForwardsPointingEastCorrectly stamp: 'LK 10/9/2023 12:38:14'!
PASSED!

!testRun: #MarsRoverTest #test07shouldMoveBackwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 12:38:14'!
PASSED!

!testRun: #MarsRoverTest #test08shouldMoveBackwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 12:38:14'!
PASSED!

!testRun: #MarsRoverTest #test09shouldMoveBackwardsPointingEastCorrectly stamp: 'LK 10/9/2023 12:38:14'!
PASSED!

!testRun: #MarsRoverTest #test10shouldMoveBackwardsPointingWestCorrectly stamp: 'LK 10/9/2023 12:38:14'!
PASSED!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:39:23'!
test11

	|marsRover coordinate direction commands finalDirection |
	
	coordinate := 0@0.
	direction := North new.
	finalDirection := East new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'r'. 
	marsRover execute: commands.
	
	self assert: ((marsRover at: coordinate ) and: [marsRover cardinal: finalDirection]).	
	
	! !

!testRun: #MarsRoverTest #test11 stamp: 'LK 10/9/2023 12:39:47'!
FAILURE!
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 12:40:11' prior: 50690745!
execute: commands 
	
	(commands = 'f') ifTrue: [	position := position + direction goForward].
	
	(commands = 'b') ifTrue: [ position := position + direction goBackwards].
	
	direction := East new.! !

!testRun: #MarsRoverTest #test11 stamp: 'LK 10/9/2023 12:40:14'!
FAILURE!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 12:40:59' prior: 50691122!
test11

	|marsRover coordinate direction commands finalDirection |
	
	coordinate := 0@0.
	direction := North new.
	finalDirection := East new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'r'. 
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: coordinate ) and: [marsRover cardinal: finalDirection]).	
	
	! !

!testRun: #MarsRoverTest #test11 stamp: 'LK 10/9/2023 12:41:02'!
FAILURE!

East new!

East new = East new!
!MarsRover methodsFor: 'private' stamp: 'LK 10/9/2023 13:08:41' prior: 50689514!
cardinal: aDirection

	^direction = aDirection.! !
!MarsRover methodsFor: 'private' stamp: 'LK 10/9/2023 13:13:13' prior: 50691169!
cardinal: aDirection

	^direction class= aDirection class.! !

!testRun: #MarsRoverTest #test01shouldInitializeInGivenCoordinateAndDirection stamp: 'LK 10/9/2023 13:13:17'!
PASSED!

!testRun: #MarsRoverTest #test02shouldDoNothingOnEmptyString stamp: 'LK 10/9/2023 13:13:17'!
FAILURE!

!testRun: #MarsRoverTest #test03shouldMoveForwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:13:17'!
FAILURE!

!testRun: #MarsRoverTest #test04shouldMoveForwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:13:17'!
FAILURE!

!testRun: #MarsRoverTest #test05shouldMoveForwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:13:17'!
FAILURE!

!testRun: #MarsRoverTest #test06shouldMoveForwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:13:17'!
PASSED!

!testRun: #MarsRoverTest #test07shouldMoveBackwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:13:17'!
FAILURE!

!testRun: #MarsRoverTest #test08shouldMoveBackwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:13:17'!
FAILURE!

!testRun: #MarsRoverTest #test09shouldMoveBackwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:13:17'!
PASSED!

!testRun: #MarsRoverTest #test10shouldMoveBackwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:13:17'!
FAILURE!

!testRun: #MarsRoverTest #test11 stamp: 'LK 10/9/2023 13:13:17'!
PASSED!
!MarsRover methodsFor: 'private' stamp: 'LK 10/9/2023 13:14:00' prior: 50691174!
cardinal: aDirection

	^direction class = aDirection class.! !

!testRun: #MarsRoverTest #test11 stamp: 'LK 10/9/2023 13:14:03'!
PASSED!

!testRun: #MarsRoverTest #test01shouldInitializeInGivenCoordinateAndDirection stamp: 'LK 10/9/2023 13:14:03'!
PASSED!

!testRun: #MarsRoverTest #test02shouldDoNothingOnEmptyString stamp: 'LK 10/9/2023 13:14:03'!
FAILURE!

!testRun: #MarsRoverTest #test03shouldMoveForwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:14:03'!
FAILURE!

!testRun: #MarsRoverTest #test04shouldMoveForwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:14:03'!
FAILURE!

!testRun: #MarsRoverTest #test05shouldMoveForwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:14:03'!
FAILURE!

!testRun: #MarsRoverTest #test06shouldMoveForwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:14:03'!
PASSED!

!testRun: #MarsRoverTest #test07shouldMoveBackwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:14:03'!
FAILURE!

!testRun: #MarsRoverTest #test08shouldMoveBackwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:14:03'!
FAILURE!

!testRun: #MarsRoverTest #test09shouldMoveBackwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:14:03'!
PASSED!

!testRun: #MarsRoverTest #test10shouldMoveBackwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:14:04'!
FAILURE!

!testRun: #MarsRoverTest #test11 stamp: 'LK 10/9/2023 13:14:04'!
PASSED!

!testRun: #MarsRoverTest #test01shouldInitializeInGivenCoordinateAndDirection stamp: 'LK 10/9/2023 13:14:09'!
PASSED!

!testRun: #MarsRoverTest #test01shouldInitializeInGivenCoordinateAndDirection stamp: 'LK 10/9/2023 13:14:09'!
PASSED!

!testRun: #MarsRoverTest #test02shouldDoNothingOnEmptyString stamp: 'LK 10/9/2023 13:14:09'!
FAILURE!

!testRun: #MarsRoverTest #test03shouldMoveForwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:14:09'!
FAILURE!

!testRun: #MarsRoverTest #test04shouldMoveForwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:14:10'!
FAILURE!

!testRun: #MarsRoverTest #test05shouldMoveForwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:14:10'!
FAILURE!

!testRun: #MarsRoverTest #test06shouldMoveForwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:14:10'!
PASSED!

!testRun: #MarsRoverTest #test07shouldMoveBackwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:14:10'!
FAILURE!

!testRun: #MarsRoverTest #test08shouldMoveBackwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:14:10'!
FAILURE!

!testRun: #MarsRoverTest #test09shouldMoveBackwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:14:10'!
PASSED!

!testRun: #MarsRoverTest #test10shouldMoveBackwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:14:10'!
FAILURE!

!testRun: #MarsRoverTest #test11 stamp: 'LK 10/9/2023 13:14:10'!
PASSED!

!testRun: #MarsRoverTest #test01shouldInitializeInGivenCoordinateAndDirection stamp: 'LK 10/9/2023 13:14:14'!
PASSED!

!testRun: #MarsRoverTest #test02shouldDoNothingOnEmptyString stamp: 'LK 10/9/2023 13:14:16'!
FAILURE!

!testRun: #MarsRoverTest #test02shouldDoNothingOnEmptyString stamp: 'LK 10/9/2023 13:14:16'!
FAILURE!

!testRun: #MarsRoverTest #test02shouldDoNothingOnEmptyString stamp: 'LK 10/9/2023 13:14:42'!
FAILURE!

!testRun: #MarsRoverTest #test02shouldDoNothingOnEmptyString stamp: 'LK 10/9/2023 13:14:42'!
FAILURE!

!testRun: #MarsRoverTest #test03shouldMoveForwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:14:44'!
FAILURE!

!testRun: #MarsRoverTest #test03shouldMoveForwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:14:44'!
FAILURE!

!testRun: #MarsRoverTest #test04shouldMoveForwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:14:47'!
FAILURE!

!testRun: #MarsRoverTest #test04shouldMoveForwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:14:47'!
FAILURE!

!testRun: #MarsRoverTest #test05shouldMoveForwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:14:50'!
FAILURE!

!testRun: #MarsRoverTest #test05shouldMoveForwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:14:50'!
FAILURE!

!testRun: #MarsRoverTest #test06shouldMoveForwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:14:53'!
PASSED!

!testRun: #MarsRoverTest #test07shouldMoveBackwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:15:06'!
FAILURE!

!testRun: #MarsRoverTest #test07shouldMoveBackwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:15:06'!
FAILURE!

!testRun: #MarsRoverTest #test06shouldMoveForwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:15:09'!
PASSED!

!testRun: #MarsRoverTest #test09shouldMoveBackwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:15:12'!
PASSED!
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 13:15:25' prior: 50691139!
execute: commands 
	
	(commands = 'f') ifTrue: [	position := position + direction goForward].
	
	(commands = 'b') ifTrue: [ position := position + direction goBackwards].
	
! !

!testRun: #MarsRoverTest #test01shouldInitializeInGivenCoordinateAndDirection stamp: 'LK 10/9/2023 13:15:29'!
PASSED!

!testRun: #MarsRoverTest #test02shouldDoNothingOnEmptyString stamp: 'LK 10/9/2023 13:15:29'!
PASSED!

!testRun: #MarsRoverTest #test03shouldMoveForwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:15:29'!
PASSED!

!testRun: #MarsRoverTest #test04shouldMoveForwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:15:29'!
PASSED!

!testRun: #MarsRoverTest #test05shouldMoveForwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:15:29'!
PASSED!

!testRun: #MarsRoverTest #test06shouldMoveForwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:15:29'!
PASSED!

!testRun: #MarsRoverTest #test07shouldMoveBackwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:15:29'!
PASSED!

!testRun: #MarsRoverTest #test08shouldMoveBackwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:15:29'!
PASSED!

!testRun: #MarsRoverTest #test09shouldMoveBackwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:15:29'!
PASSED!

!testRun: #MarsRoverTest #test10shouldMoveBackwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:15:29'!
PASSED!

!testRun: #MarsRoverTest #test11 stamp: 'LK 10/9/2023 13:15:29'!
FAILURE!

!testRun: #MarsRoverTest #test11 stamp: 'LK 10/9/2023 13:15:29'!
FAILURE!

!testRun: #MarsRoverTest #test01shouldInitializeInGivenCoordinateAndDirection stamp: 'LK 10/9/2023 13:15:32'!
PASSED!

!testRun: #MarsRoverTest #test02shouldDoNothingOnEmptyString stamp: 'LK 10/9/2023 13:15:33'!
PASSED!

!testRun: #MarsRoverTest #test01shouldInitializeInGivenCoordinateAndDirection stamp: 'LK 10/9/2023 13:15:36'!
PASSED!

!testRun: #MarsRoverTest #test02shouldDoNothingOnEmptyString stamp: 'LK 10/9/2023 13:15:36'!
PASSED!

!testRun: #MarsRoverTest #test03shouldMoveForwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:15:36'!
PASSED!

!testRun: #MarsRoverTest #test04shouldMoveForwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:15:36'!
PASSED!

!testRun: #MarsRoverTest #test05shouldMoveForwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:15:36'!
PASSED!

!testRun: #MarsRoverTest #test06shouldMoveForwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:15:36'!
PASSED!

!testRun: #MarsRoverTest #test07shouldMoveBackwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:15:36'!
PASSED!

!testRun: #MarsRoverTest #test08shouldMoveBackwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:15:36'!
PASSED!

!testRun: #MarsRoverTest #test09shouldMoveBackwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:15:36'!
PASSED!

!testRun: #MarsRoverTest #test10shouldMoveBackwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:15:36'!
PASSED!

!testRun: #MarsRoverTest #test11 stamp: 'LK 10/9/2023 13:15:36'!
FAILURE!

!testRun: #MarsRoverTest #test11 stamp: 'LK 10/9/2023 13:15:36'!
FAILURE!

!testRun: #MarsRoverTest #test03shouldMoveForwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:15:39'!
PASSED!

!testRun: #MarsRoverTest #test04shouldMoveForwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:15:40'!
PASSED!

!testRun: #MarsRoverTest #test05shouldMoveForwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:15:42'!
PASSED!

!testRun: #MarsRoverTest #test06shouldMoveForwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:15:44'!
PASSED!

!testRun: #MarsRoverTest #test07shouldMoveBackwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:15:45'!
PASSED!

!testRun: #MarsRoverTest #test08shouldMoveBackwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:15:47'!
PASSED!

!testRun: #MarsRoverTest #test09shouldMoveBackwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:15:48'!
PASSED!

!testRun: #MarsRoverTest #test10shouldMoveBackwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:15:49'!
PASSED!
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 13:16:23' prior: 50691360!
execute: commands 
	
	(commands = 'f') ifTrue: [	position := position + direction goForward].
	
	(commands = 'b') ifTrue: [ position := position + direction goBackwards].
	
	(commands = 'r') ifTrue: [ 	direction := East new].
	
! !

!testRun: #MarsRoverTest #test01shouldInitializeInGivenCoordinateAndDirection stamp: 'LK 10/9/2023 13:16:28'!
PASSED!

!testRun: #MarsRoverTest #test02shouldDoNothingOnEmptyString stamp: 'LK 10/9/2023 13:16:28'!
PASSED!

!testRun: #MarsRoverTest #test03shouldMoveForwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:16:28'!
PASSED!

!testRun: #MarsRoverTest #test04shouldMoveForwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:16:28'!
PASSED!

!testRun: #MarsRoverTest #test05shouldMoveForwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:16:28'!
PASSED!

!testRun: #MarsRoverTest #test06shouldMoveForwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:16:28'!
PASSED!

!testRun: #MarsRoverTest #test07shouldMoveBackwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:16:28'!
PASSED!

!testRun: #MarsRoverTest #test08shouldMoveBackwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:16:28'!
PASSED!

!testRun: #MarsRoverTest #test09shouldMoveBackwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:16:28'!
PASSED!

!testRun: #MarsRoverTest #test10shouldMoveBackwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:16:28'!
PASSED!

!testRun: #MarsRoverTest #test11 stamp: 'LK 10/9/2023 13:16:28'!
PASSED!
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 13:17:10' prior: 50691484!
execute: commands 
	
	(commands = 'f') ifTrue: [	position := position + direction goForward].
	
	(commands = 'b') ifTrue: [ position := position + direction goBackwards].
	
	(commands = 'r') ifTrue: [ 	direction := direction rotateRight].
	
! !
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 13:17:56' prior: 50691532!
execute: commands 
	
	(commands = 'f') ifTrue: [	position := position + direction goForward].
	
	(commands = 'b') ifTrue: [ position := position + direction goBackwards].
	
	(commands = 'r') ifTrue: [	direction := direction rotateRight].
	
! !
!Direction methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 13:18:16'!
rotateRight! !
!West methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 13:18:19' overrides: 50691554!
rotateRight! !
!East methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 13:18:19' overrides: 50691554!
rotateRight! !
!North methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 13:18:19' overrides: 50691554!
rotateRight! !
!South methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 13:18:19' overrides: 50691554!
rotateRight! !
!Direction methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 13:18:19' prior: 50691554!
rotateRight

	self subclassResponsibility! !
!North methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 13:18:32' prior: 50691566 overrides: 50691574!
rotateRight
	^East new.! !

!testRun: #MarsRoverTest #test11 stamp: 'LK 10/9/2023 13:18:43'!
PASSED!
!East methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 13:18:56' prior: 50691562 overrides: 50691574!
rotateRight
	^South new.! !
!South methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 13:19:05' prior: 50691570 overrides: 50691574!
rotateRight
	^West new.! !
!West methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 13:19:15' prior: 50691558 overrides: 50691574!
rotateRight
	^North new.! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:19:44'!
test12

	|marsRover coordinate direction commands finalDirection |
	
	coordinate := 0@0.
	direction := East new.
	finalDirection := South new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'r'. 
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: coordinate ) and: [marsRover cardinal: finalDirection]).	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:19:53'!
test13

	|marsRover coordinate direction commands finalDirection |
	
	coordinate := 0@0.
	direction := South new.
	finalDirection := West new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'r'. 
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: coordinate ) and: [marsRover cardinal: finalDirection]).	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:20:00'!
test14

	|marsRover coordinate direction commands finalDirection |
	
	coordinate := 0@0.
	direction := West new.
	finalDirection := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'r'. 
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: coordinate ) and: [marsRover cardinal: finalDirection]).	
	
	! !

!testRun: #MarsRoverTest #test01shouldInitializeInGivenCoordinateAndDirection stamp: 'LK 10/9/2023 13:20:03'!
PASSED!

!testRun: #MarsRoverTest #test02shouldDoNothingOnEmptyString stamp: 'LK 10/9/2023 13:20:03'!
PASSED!

!testRun: #MarsRoverTest #test03shouldMoveForwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:20:03'!
PASSED!

!testRun: #MarsRoverTest #test04shouldMoveForwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:20:03'!
PASSED!

!testRun: #MarsRoverTest #test05shouldMoveForwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:20:03'!
PASSED!

!testRun: #MarsRoverTest #test06shouldMoveForwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:20:03'!
PASSED!

!testRun: #MarsRoverTest #test07shouldMoveBackwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:20:03'!
PASSED!

!testRun: #MarsRoverTest #test08shouldMoveBackwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:20:03'!
PASSED!

!testRun: #MarsRoverTest #test09shouldMoveBackwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:20:03'!
PASSED!

!testRun: #MarsRoverTest #test10shouldMoveBackwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:20:03'!
PASSED!

!testRun: #MarsRoverTest #test11 stamp: 'LK 10/9/2023 13:20:03'!
PASSED!

!testRun: #MarsRoverTest #test12 stamp: 'LK 10/9/2023 13:20:03'!
PASSED!

!testRun: #MarsRoverTest #test13 stamp: 'LK 10/9/2023 13:20:03'!
PASSED!

!testRun: #MarsRoverTest #test14 stamp: 'LK 10/9/2023 13:20:03'!
PASSED!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:20:19'!
test11shouldRotateRightPointingNorthCorrectly

	|marsRover coordinate direction commands finalDirection |
	
	coordinate := 0@0.
	direction := North new.
	finalDirection := East new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'r'. 
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: coordinate ) and: [marsRover cardinal: finalDirection]).	
	
	! !

!methodRemoval: MarsRoverTest #test11 stamp: 'LK 10/9/2023 13:20:20'!
test11

	|marsRover coordinate direction commands finalDirection |
	
	coordinate := 0@0.
	direction := North new.
	finalDirection := East new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'r'. 
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: coordinate ) and: [marsRover cardinal: finalDirection]).	
	
	!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:20:29'!
test12shouldRotateRightPointingEastCorrectly

	|marsRover coordinate direction commands finalDirection |
	
	coordinate := 0@0.
	direction := East new.
	finalDirection := South new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'r'. 
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: coordinate ) and: [marsRover cardinal: finalDirection]).	
	
	! !

!methodRemoval: MarsRoverTest #test12 stamp: 'LK 10/9/2023 13:20:31'!
test12

	|marsRover coordinate direction commands finalDirection |
	
	coordinate := 0@0.
	direction := East new.
	finalDirection := South new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'r'. 
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: coordinate ) and: [marsRover cardinal: finalDirection]).	
	
	!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:20:42'!
test13shouldRotateRightPointingSouthNew

	|marsRover coordinate direction commands finalDirection |
	
	coordinate := 0@0.
	direction := South new.
	finalDirection := West new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'r'. 
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: coordinate ) and: [marsRover cardinal: finalDirection]).	
	
	! !

!methodRemoval: MarsRoverTest #test13 stamp: 'LK 10/9/2023 13:20:43'!
test13

	|marsRover coordinate direction commands finalDirection |
	
	coordinate := 0@0.
	direction := South new.
	finalDirection := West new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'r'. 
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: coordinate ) and: [marsRover cardinal: finalDirection]).	
	
	!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:20:56'!
test14shouldRotateRightPointingWestCorrectly

	|marsRover coordinate direction commands finalDirection |
	
	coordinate := 0@0.
	direction := West new.
	finalDirection := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'r'. 
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: coordinate ) and: [marsRover cardinal: finalDirection]).	
	
	! !

!methodRemoval: MarsRoverTest #test14 stamp: 'LK 10/9/2023 13:20:57'!
test14

	|marsRover coordinate direction commands finalDirection |
	
	coordinate := 0@0.
	direction := West new.
	finalDirection := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'r'. 
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: coordinate ) and: [marsRover cardinal: finalDirection]).	
	
	!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:21:03'!
test13shouldRotateRightPointingSouthCorrectly
	|marsRover coordinate direction commands finalDirection |
	
	coordinate := 0@0.
	direction := South new.
	finalDirection := West new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'r'. 
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: coordinate ) and: [marsRover cardinal: finalDirection]).	
	
	! !

!methodRemoval: MarsRoverTest #test13shouldRotateRightPointingSouthNew stamp: 'LK 10/9/2023 13:21:04'!
test13shouldRotateRightPointingSouthNew

	|marsRover coordinate direction commands finalDirection |
	
	coordinate := 0@0.
	direction := South new.
	finalDirection := West new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'r'. 
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: coordinate ) and: [marsRover cardinal: finalDirection]).	
	
	!

!testRun: #MarsRoverTest #test01shouldInitializeInGivenCoordinateAndDirection stamp: 'LK 10/9/2023 13:21:07'!
PASSED!

!testRun: #MarsRoverTest #test02shouldDoNothingOnEmptyString stamp: 'LK 10/9/2023 13:21:07'!
PASSED!

!testRun: #MarsRoverTest #test03shouldMoveForwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:21:07'!
PASSED!

!testRun: #MarsRoverTest #test04shouldMoveForwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:21:07'!
PASSED!

!testRun: #MarsRoverTest #test05shouldMoveForwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:21:07'!
PASSED!

!testRun: #MarsRoverTest #test06shouldMoveForwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:21:07'!
PASSED!

!testRun: #MarsRoverTest #test07shouldMoveBackwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:21:07'!
PASSED!

!testRun: #MarsRoverTest #test08shouldMoveBackwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:21:07'!
PASSED!

!testRun: #MarsRoverTest #test09shouldMoveBackwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:21:07'!
PASSED!

!testRun: #MarsRoverTest #test10shouldMoveBackwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:21:07'!
PASSED!

!testRun: #MarsRoverTest #test11shouldRotateRightPointingNorthCorrectly stamp: 'LK 10/9/2023 13:21:07'!
PASSED!

!testRun: #MarsRoverTest #test12shouldRotateRightPointingEastCorrectly stamp: 'LK 10/9/2023 13:21:07'!
PASSED!

!testRun: #MarsRoverTest #test13shouldRotateRightPointingSouthCorrectly stamp: 'LK 10/9/2023 13:21:07'!
PASSED!

!testRun: #MarsRoverTest #test14shouldRotateRightPointingWestCorrectly stamp: 'LK 10/9/2023 13:21:07'!
PASSED!
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 13:22:19' prior: 50691543!
execute: commands 
	
	(commands = 'f') ifTrue: [	position := position + direction goForward].
	
	(commands = 'b') ifTrue: [ position := position + direction goBackwards].
	
	(commands = 'r') ifTrue: [	direction := direction rotateRight].
	
	(commands = 'l') ifTrue: [direction := direction rotateLeft].
	
! !
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 13:23:05' prior: 50691882!
execute: commands 
	
	(commands = 'f') ifTrue: [	position := position + direction goForward].
	
	(commands = 'b') ifTrue: [ position := position + direction goBackwards].
	
	(commands = 'r') ifTrue: [	direction := direction rotateRight].
	
	(commands = 'l') ifTrue: [direction := direction rotateLeft].
	
! !
!Direction methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 13:23:12'!
rotateLeft! !
!West methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 13:23:15' overrides: 50691908!
rotateLeft! !
!East methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 13:23:15' overrides: 50691908!
rotateLeft! !
!North methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 13:23:15' overrides: 50691908!
rotateLeft! !
!South methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 13:23:15' overrides: 50691908!
rotateLeft! !
!Direction methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 13:23:16' prior: 50691908!
rotateLeft

	self subclassResponsibility! !
!East methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 13:23:25' prior: 50691916 overrides: 50691928!
rotateLeft
	^North new.! !
!North methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 13:23:35' prior: 50691920 overrides: 50691928!
rotateLeft
	^West new.! !
!South methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 13:23:46' prior: 50691924 overrides: 50691928!
rotateLeft
	^East new.! !
!West methodsFor: 'as yet unclassified' stamp: 'LK 10/9/2023 13:24:00' prior: 50691912 overrides: 50691928!
rotateLeft
	^South new.! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:24:23'!
test15shouldRotateLeftPointingNorthCorrectly

	|marsRover coordinate direction commands finalDirection |
	
	coordinate := 0@0.
	direction := North new.
	finalDirection := West new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'r'. 
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: coordinate ) and: [marsRover cardinal: finalDirection]).	
	
	! !

!testRun: #MarsRoverTest #test15shouldRotateLeftPointingNorthCorrectly stamp: 'LK 10/9/2023 13:24:25'!
FAILURE!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:24:40' prior: 50691951!
test15shouldRotateLeftPointingNorthCorrectly

	|marsRover coordinate direction commands finalDirection |
	
	coordinate := 0@0.
	direction := North new.
	finalDirection := West new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'l'. 
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: coordinate ) and: [marsRover cardinal: finalDirection]).	
	
	! !

!testRun: #MarsRoverTest #test15shouldRotateLeftPointingNorthCorrectly stamp: 'LK 10/9/2023 13:24:41'!
PASSED!

!testRun: #MarsRoverTest #test01shouldInitializeInGivenCoordinateAndDirection stamp: 'LK 10/9/2023 13:24:41'!
PASSED!

!testRun: #MarsRoverTest #test02shouldDoNothingOnEmptyString stamp: 'LK 10/9/2023 13:24:41'!
PASSED!

!testRun: #MarsRoverTest #test03shouldMoveForwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:24:41'!
PASSED!

!testRun: #MarsRoverTest #test04shouldMoveForwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:24:41'!
PASSED!

!testRun: #MarsRoverTest #test05shouldMoveForwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:24:41'!
PASSED!

!testRun: #MarsRoverTest #test06shouldMoveForwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:24:41'!
PASSED!

!testRun: #MarsRoverTest #test07shouldMoveBackwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:24:41'!
PASSED!

!testRun: #MarsRoverTest #test08shouldMoveBackwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:24:41'!
PASSED!

!testRun: #MarsRoverTest #test09shouldMoveBackwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:24:41'!
PASSED!

!testRun: #MarsRoverTest #test10shouldMoveBackwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:24:41'!
PASSED!

!testRun: #MarsRoverTest #test11shouldRotateRightPointingNorthCorrectly stamp: 'LK 10/9/2023 13:24:41'!
PASSED!

!testRun: #MarsRoverTest #test12shouldRotateRightPointingEastCorrectly stamp: 'LK 10/9/2023 13:24:41'!
PASSED!

!testRun: #MarsRoverTest #test13shouldRotateRightPointingSouthCorrectly stamp: 'LK 10/9/2023 13:24:41'!
PASSED!

!testRun: #MarsRoverTest #test14shouldRotateRightPointingWestCorrectly stamp: 'LK 10/9/2023 13:24:41'!
PASSED!

!testRun: #MarsRoverTest #test15shouldRotateLeftPointingNorthCorrectly stamp: 'LK 10/9/2023 13:24:41'!
PASSED!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:25:08'!
test16shouldRotateLeftPointingSouthCorrectly

	|marsRover coordinate direction commands finalDirection |
	
	coordinate := 0@0.
	direction := South new.
	finalDirection := East new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'l'. 
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: coordinate ) and: [marsRover cardinal: finalDirection]).	
	
	! !

!testRun: #MarsRoverTest #test16shouldRotateLeftPointingSouthCorrectly stamp: 'LK 10/9/2023 13:25:09'!
PASSED!

!testRun: #MarsRoverTest #test01shouldInitializeInGivenCoordinateAndDirection stamp: 'LK 10/9/2023 13:25:09'!
PASSED!

!testRun: #MarsRoverTest #test02shouldDoNothingOnEmptyString stamp: 'LK 10/9/2023 13:25:09'!
PASSED!

!testRun: #MarsRoverTest #test03shouldMoveForwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:25:09'!
PASSED!

!testRun: #MarsRoverTest #test04shouldMoveForwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:25:09'!
PASSED!

!testRun: #MarsRoverTest #test05shouldMoveForwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:25:09'!
PASSED!

!testRun: #MarsRoverTest #test06shouldMoveForwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:25:09'!
PASSED!

!testRun: #MarsRoverTest #test07shouldMoveBackwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:25:09'!
PASSED!

!testRun: #MarsRoverTest #test08shouldMoveBackwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:25:09'!
PASSED!

!testRun: #MarsRoverTest #test09shouldMoveBackwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:25:09'!
PASSED!

!testRun: #MarsRoverTest #test10shouldMoveBackwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:25:09'!
PASSED!

!testRun: #MarsRoverTest #test11shouldRotateRightPointingNorthCorrectly stamp: 'LK 10/9/2023 13:25:09'!
PASSED!

!testRun: #MarsRoverTest #test12shouldRotateRightPointingEastCorrectly stamp: 'LK 10/9/2023 13:25:09'!
PASSED!

!testRun: #MarsRoverTest #test13shouldRotateRightPointingSouthCorrectly stamp: 'LK 10/9/2023 13:25:09'!
PASSED!

!testRun: #MarsRoverTest #test14shouldRotateRightPointingWestCorrectly stamp: 'LK 10/9/2023 13:25:09'!
PASSED!

!testRun: #MarsRoverTest #test15shouldRotateLeftPointingNorthCorrectly stamp: 'LK 10/9/2023 13:25:10'!
PASSED!

!testRun: #MarsRoverTest #test16shouldRotateLeftPointingSouthCorrectly stamp: 'LK 10/9/2023 13:25:10'!
PASSED!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:25:20'!
test17shouldRotateLeftPointingEastCorrectly

	|marsRover coordinate direction commands finalDirection |
	
	coordinate := 0@0.
	direction := East new.
	finalDirection := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'l'. 
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: coordinate ) and: [marsRover cardinal: finalDirection]).	
	
	! !

!testRun: #MarsRoverTest #test17shouldRotateLeftPointingEastCorrectly stamp: 'LK 10/9/2023 13:25:21'!
PASSED!

!testRun: #MarsRoverTest #test01shouldInitializeInGivenCoordinateAndDirection stamp: 'LK 10/9/2023 13:25:21'!
PASSED!

!testRun: #MarsRoverTest #test02shouldDoNothingOnEmptyString stamp: 'LK 10/9/2023 13:25:21'!
PASSED!

!testRun: #MarsRoverTest #test03shouldMoveForwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:25:21'!
PASSED!

!testRun: #MarsRoverTest #test04shouldMoveForwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:25:21'!
PASSED!

!testRun: #MarsRoverTest #test05shouldMoveForwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:25:21'!
PASSED!

!testRun: #MarsRoverTest #test06shouldMoveForwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:25:21'!
PASSED!

!testRun: #MarsRoverTest #test07shouldMoveBackwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:25:21'!
PASSED!

!testRun: #MarsRoverTest #test08shouldMoveBackwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:25:21'!
PASSED!

!testRun: #MarsRoverTest #test09shouldMoveBackwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:25:21'!
PASSED!

!testRun: #MarsRoverTest #test10shouldMoveBackwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:25:21'!
PASSED!

!testRun: #MarsRoverTest #test11shouldRotateRightPointingNorthCorrectly stamp: 'LK 10/9/2023 13:25:21'!
PASSED!

!testRun: #MarsRoverTest #test12shouldRotateRightPointingEastCorrectly stamp: 'LK 10/9/2023 13:25:21'!
PASSED!

!testRun: #MarsRoverTest #test13shouldRotateRightPointingSouthCorrectly stamp: 'LK 10/9/2023 13:25:22'!
PASSED!

!testRun: #MarsRoverTest #test14shouldRotateRightPointingWestCorrectly stamp: 'LK 10/9/2023 13:25:22'!
PASSED!

!testRun: #MarsRoverTest #test15shouldRotateLeftPointingNorthCorrectly stamp: 'LK 10/9/2023 13:25:22'!
PASSED!

!testRun: #MarsRoverTest #test16shouldRotateLeftPointingSouthCorrectly stamp: 'LK 10/9/2023 13:25:22'!
PASSED!

!testRun: #MarsRoverTest #test17shouldRotateLeftPointingEastCorrectly stamp: 'LK 10/9/2023 13:25:22'!
PASSED!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:25:31'!
test17shouldRotateLeftPointingWestCorrectly

	|marsRover coordinate direction commands finalDirection |
	
	coordinate := 0@0.
	direction := West new.
	finalDirection := South new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'l'. 
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: coordinate ) and: [marsRover cardinal: finalDirection]).	
	
	! !

!testRun: #MarsRoverTest #test17shouldRotateLeftPointingWestCorrectly stamp: 'LK 10/9/2023 13:25:32'!
PASSED!

!testRun: #MarsRoverTest #test01shouldInitializeInGivenCoordinateAndDirection stamp: 'LK 10/9/2023 13:25:32'!
PASSED!

!testRun: #MarsRoverTest #test02shouldDoNothingOnEmptyString stamp: 'LK 10/9/2023 13:25:32'!
PASSED!

!testRun: #MarsRoverTest #test03shouldMoveForwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:25:32'!
PASSED!

!testRun: #MarsRoverTest #test04shouldMoveForwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:25:32'!
PASSED!

!testRun: #MarsRoverTest #test05shouldMoveForwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:25:32'!
PASSED!

!testRun: #MarsRoverTest #test06shouldMoveForwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:25:32'!
PASSED!

!testRun: #MarsRoverTest #test07shouldMoveBackwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:25:32'!
PASSED!

!testRun: #MarsRoverTest #test08shouldMoveBackwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:25:32'!
PASSED!

!testRun: #MarsRoverTest #test09shouldMoveBackwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:25:32'!
PASSED!

!testRun: #MarsRoverTest #test10shouldMoveBackwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:25:32'!
PASSED!

!testRun: #MarsRoverTest #test11shouldRotateRightPointingNorthCorrectly stamp: 'LK 10/9/2023 13:25:32'!
PASSED!

!testRun: #MarsRoverTest #test12shouldRotateRightPointingEastCorrectly stamp: 'LK 10/9/2023 13:25:32'!
PASSED!

!testRun: #MarsRoverTest #test13shouldRotateRightPointingSouthCorrectly stamp: 'LK 10/9/2023 13:25:32'!
PASSED!

!testRun: #MarsRoverTest #test14shouldRotateRightPointingWestCorrectly stamp: 'LK 10/9/2023 13:25:32'!
PASSED!

!testRun: #MarsRoverTest #test15shouldRotateLeftPointingNorthCorrectly stamp: 'LK 10/9/2023 13:25:32'!
PASSED!

!testRun: #MarsRoverTest #test16shouldRotateLeftPointingSouthCorrectly stamp: 'LK 10/9/2023 13:25:32'!
PASSED!

!testRun: #MarsRoverTest #test17shouldRotateLeftPointingEastCorrectly stamp: 'LK 10/9/2023 13:25:32'!
PASSED!

!testRun: #MarsRoverTest #test17shouldRotateLeftPointingWestCorrectly stamp: 'LK 10/9/2023 13:25:32'!
PASSED!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:25:51'!
test18shouldRotateLeftPointingWestCorrectly

	|marsRover coordinate direction commands finalDirection |
	
	coordinate := 0@0.
	direction := West new.
	finalDirection := South new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'l'. 
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: coordinate ) and: [marsRover cardinal: finalDirection]).	
	
	! !

!methodRemoval: MarsRoverTest #test17shouldRotateLeftPointingWestCorrectly stamp: 'LK 10/9/2023 13:25:59'!
test17shouldRotateLeftPointingWestCorrectly

	|marsRover coordinate direction commands finalDirection |
	
	coordinate := 0@0.
	direction := West new.
	finalDirection := South new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'l'. 
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: coordinate ) and: [marsRover cardinal: finalDirection]).	
	
	!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:26:03'!
test19! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:26:47' prior: 50692308!
test19! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:27:50' prior: 50692311!
test19

	|marsRover coordinate direction commands |
	
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'fb'. 
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: coordinate ) and: [marsRover cardinal: direction]).	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:27:58'!
test19canHandleMultipleCommands

	|marsRover coordinate direction commands |
	
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'fb'. 
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: coordinate ) and: [marsRover cardinal: direction]).	
	! !

!methodRemoval: MarsRoverTest #test19 stamp: 'LK 10/9/2023 13:28:04'!
test19

	|marsRover coordinate direction commands |
	
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'fb'. 
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: coordinate ) and: [marsRover cardinal: direction]).	
	!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:28:41' prior: 50692326!
test19canHandleMultipleCommands

	|marsRover coordinate direction commands |
	
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'fb'. 
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: coordinate ) and: [marsRover cardinal: direction]).	
	! !

!testRun: #MarsRoverTest #test19canHandleMultipleCommands stamp: 'LK 10/9/2023 13:29:39'!
PASSED!

!testRun: #MarsRoverTest #test01shouldInitializeInGivenCoordinateAndDirection stamp: 'LK 10/9/2023 13:29:39'!
PASSED!

!testRun: #MarsRoverTest #test02shouldDoNothingOnEmptyString stamp: 'LK 10/9/2023 13:29:39'!
PASSED!

!testRun: #MarsRoverTest #test03shouldMoveForwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:29:39'!
PASSED!

!testRun: #MarsRoverTest #test04shouldMoveForwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:29:39'!
PASSED!

!testRun: #MarsRoverTest #test05shouldMoveForwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:29:39'!
PASSED!

!testRun: #MarsRoverTest #test06shouldMoveForwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:29:39'!
PASSED!

!testRun: #MarsRoverTest #test07shouldMoveBackwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:29:39'!
PASSED!

!testRun: #MarsRoverTest #test08shouldMoveBackwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:29:39'!
PASSED!

!testRun: #MarsRoverTest #test09shouldMoveBackwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:29:39'!
PASSED!

!testRun: #MarsRoverTest #test10shouldMoveBackwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:29:39'!
PASSED!

!testRun: #MarsRoverTest #test11shouldRotateRightPointingNorthCorrectly stamp: 'LK 10/9/2023 13:29:39'!
PASSED!

!testRun: #MarsRoverTest #test12shouldRotateRightPointingEastCorrectly stamp: 'LK 10/9/2023 13:29:39'!
PASSED!

!testRun: #MarsRoverTest #test13shouldRotateRightPointingSouthCorrectly stamp: 'LK 10/9/2023 13:29:39'!
PASSED!

!testRun: #MarsRoverTest #test14shouldRotateRightPointingWestCorrectly stamp: 'LK 10/9/2023 13:29:39'!
PASSED!

!testRun: #MarsRoverTest #test15shouldRotateLeftPointingNorthCorrectly stamp: 'LK 10/9/2023 13:29:39'!
PASSED!

!testRun: #MarsRoverTest #test16shouldRotateLeftPointingSouthCorrectly stamp: 'LK 10/9/2023 13:29:39'!
PASSED!

!testRun: #MarsRoverTest #test17shouldRotateLeftPointingEastCorrectly stamp: 'LK 10/9/2023 13:29:40'!
PASSED!

!testRun: #MarsRoverTest #test18shouldRotateLeftPointingWestCorrectly stamp: 'LK 10/9/2023 13:29:40'!
PASSED!

!testRun: #MarsRoverTest #test19canHandleMultipleCommands stamp: 'LK 10/9/2023 13:29:40'!
PASSED!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:29:59' prior: 50692352!
test19canHandleMultipleCommands

	|marsRover coordinate direction commands |
	
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'fbf'. 
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: coordinate ) and: [marsRover cardinal: direction]).	
	! !

!testRun: #MarsRoverTest #test19canHandleMultipleCommands stamp: 'LK 10/9/2023 13:30:00'!
PASSED!

!testRun: #MarsRoverTest #test01shouldInitializeInGivenCoordinateAndDirection stamp: 'LK 10/9/2023 13:30:00'!
PASSED!

!testRun: #MarsRoverTest #test02shouldDoNothingOnEmptyString stamp: 'LK 10/9/2023 13:30:00'!
PASSED!

!testRun: #MarsRoverTest #test03shouldMoveForwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:30:00'!
PASSED!

!testRun: #MarsRoverTest #test04shouldMoveForwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:30:00'!
PASSED!

!testRun: #MarsRoverTest #test05shouldMoveForwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:30:00'!
PASSED!

!testRun: #MarsRoverTest #test06shouldMoveForwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:30:00'!
PASSED!

!testRun: #MarsRoverTest #test07shouldMoveBackwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:30:00'!
PASSED!

!testRun: #MarsRoverTest #test08shouldMoveBackwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:30:00'!
PASSED!

!testRun: #MarsRoverTest #test09shouldMoveBackwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:30:00'!
PASSED!

!testRun: #MarsRoverTest #test10shouldMoveBackwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:30:00'!
PASSED!

!testRun: #MarsRoverTest #test11shouldRotateRightPointingNorthCorrectly stamp: 'LK 10/9/2023 13:30:00'!
PASSED!

!testRun: #MarsRoverTest #test12shouldRotateRightPointingEastCorrectly stamp: 'LK 10/9/2023 13:30:01'!
PASSED!

!testRun: #MarsRoverTest #test13shouldRotateRightPointingSouthCorrectly stamp: 'LK 10/9/2023 13:30:01'!
PASSED!

!testRun: #MarsRoverTest #test14shouldRotateRightPointingWestCorrectly stamp: 'LK 10/9/2023 13:30:01'!
PASSED!

!testRun: #MarsRoverTest #test15shouldRotateLeftPointingNorthCorrectly stamp: 'LK 10/9/2023 13:30:01'!
PASSED!

!testRun: #MarsRoverTest #test16shouldRotateLeftPointingSouthCorrectly stamp: 'LK 10/9/2023 13:30:01'!
PASSED!

!testRun: #MarsRoverTest #test17shouldRotateLeftPointingEastCorrectly stamp: 'LK 10/9/2023 13:30:01'!
PASSED!

!testRun: #MarsRoverTest #test18shouldRotateLeftPointingWestCorrectly stamp: 'LK 10/9/2023 13:30:01'!
PASSED!

!testRun: #MarsRoverTest #test19canHandleMultipleCommands stamp: 'LK 10/9/2023 13:30:01'!
PASSED!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:30:23' prior: 50692435!
test19canHandleMultipleCommands

	|marsRover coordinate direction commands finalCoordinate |
	
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'fbf'. 
	finalCoordinate := 0@1.
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: coordinate ) and: [marsRover cardinal: direction]).	
	! !

!testRun: #MarsRoverTest #test19canHandleMultipleCommands stamp: 'LK 10/9/2023 13:30:33'!
PASSED!

!testRun: #MarsRoverTest #test01shouldInitializeInGivenCoordinateAndDirection stamp: 'LK 10/9/2023 13:30:33'!
PASSED!

!testRun: #MarsRoverTest #test02shouldDoNothingOnEmptyString stamp: 'LK 10/9/2023 13:30:33'!
PASSED!

!testRun: #MarsRoverTest #test03shouldMoveForwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:30:33'!
PASSED!

!testRun: #MarsRoverTest #test04shouldMoveForwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:30:33'!
PASSED!

!testRun: #MarsRoverTest #test05shouldMoveForwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:30:33'!
PASSED!

!testRun: #MarsRoverTest #test06shouldMoveForwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:30:33'!
PASSED!

!testRun: #MarsRoverTest #test07shouldMoveBackwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:30:33'!
PASSED!

!testRun: #MarsRoverTest #test08shouldMoveBackwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:30:33'!
PASSED!

!testRun: #MarsRoverTest #test09shouldMoveBackwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:30:33'!
PASSED!

!testRun: #MarsRoverTest #test10shouldMoveBackwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:30:33'!
PASSED!

!testRun: #MarsRoverTest #test11shouldRotateRightPointingNorthCorrectly stamp: 'LK 10/9/2023 13:30:33'!
PASSED!

!testRun: #MarsRoverTest #test12shouldRotateRightPointingEastCorrectly stamp: 'LK 10/9/2023 13:30:33'!
PASSED!

!testRun: #MarsRoverTest #test13shouldRotateRightPointingSouthCorrectly stamp: 'LK 10/9/2023 13:30:33'!
PASSED!

!testRun: #MarsRoverTest #test14shouldRotateRightPointingWestCorrectly stamp: 'LK 10/9/2023 13:30:33'!
PASSED!

!testRun: #MarsRoverTest #test15shouldRotateLeftPointingNorthCorrectly stamp: 'LK 10/9/2023 13:30:33'!
PASSED!

!testRun: #MarsRoverTest #test16shouldRotateLeftPointingSouthCorrectly stamp: 'LK 10/9/2023 13:30:33'!
PASSED!

!testRun: #MarsRoverTest #test17shouldRotateLeftPointingEastCorrectly stamp: 'LK 10/9/2023 13:30:33'!
PASSED!

!testRun: #MarsRoverTest #test18shouldRotateLeftPointingWestCorrectly stamp: 'LK 10/9/2023 13:30:33'!
PASSED!

!testRun: #MarsRoverTest #test19canHandleMultipleCommands stamp: 'LK 10/9/2023 13:30:33'!
PASSED!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:30:36' prior: 50692518!
test19canHandleMultipleCommands

	|marsRover coordinate direction commands finalCoordinate |
	
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'fbf'. 
	finalCoordinate := 0@1.
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	! !

!testRun: #MarsRoverTest #test19canHandleMultipleCommands stamp: 'LK 10/9/2023 13:30:36'!
FAILURE!

East class = East class!

West class = East class true .!

West class = East class!
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 13:36:14' prior: 50691895!
execute: commands 

	commands do: [:char | self executeChar].
	
	(commands = 'f') ifTrue: [	position := position + direction goForward].
	
	(commands = 'b') ifTrue: [ position := position + direction goBackwards].
	
	(commands = 'r') ifTrue: [	direction := direction rotateRight].
	
	(commands = 'l') ifTrue: [direction := direction rotateLeft].
	
! !
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 13:36:27' prior: 50692624!
execute: commands 

	commands do: [:char | self executeChar: char].
	
	(commands = 'f') ifTrue: [	position := position + direction goForward].
	
	(commands = 'b') ifTrue: [ position := position + direction goBackwards].
	
	(commands = 'r') ifTrue: [	direction := direction rotateRight].
	
	(commands = 'l') ifTrue: [direction := direction rotateLeft].
	
! !
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 13:36:58'!
executeChar: aSingleCommand
	
	(aSingleCommand = 'f') ifTrue: [	position := position + direction goForward].
	
	(aSingleCommand = 'b') ifTrue: [ position := position + direction goBackwards].
	
	(aSingleCommand = 'r') ifTrue: [	direction := direction rotateRight].
	
	(aSingleCommand = 'l') ifTrue: [direction := direction rotateLeft].
	
! !

!testRun: #MarsRoverTest #test19canHandleMultipleCommands stamp: 'LK 10/9/2023 13:37:05'!
FAILURE!
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 13:37:15' prior: 50692638!
execute: commands 

	commands do: [:char | self executeChar: char].

	
! !

!testRun: #MarsRoverTest #test19canHandleMultipleCommands stamp: 'LK 10/9/2023 13:37:18'!
FAILURE!

!testRun: #MarsRoverTest #test19canHandleMultipleCommands stamp: 'LK 10/9/2023 13:37:18'!
FAILURE!
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 13:38:12' prior: 50692652!
executeChar: aSingleCommand
	
	(aSingleCommand = $f) ifTrue: [	position := position + direction goForward].
	
	(aSingleCommand = $b) ifTrue: [ position := position + direction goBackwards].
	
	(aSingleCommand = $r) ifTrue: [	direction := direction rotateRight].
	
	(aSingleCommand = $l) ifTrue: [direction := direction rotateLeft].
	
! !

!testRun: #MarsRoverTest #test19canHandleMultipleCommands stamp: 'LK 10/9/2023 13:38:15'!
PASSED!

!testRun: #MarsRoverTest #test01shouldInitializeInGivenCoordinateAndDirection stamp: 'LK 10/9/2023 13:38:17'!
PASSED!

!testRun: #MarsRoverTest #test02shouldDoNothingOnEmptyString stamp: 'LK 10/9/2023 13:38:17'!
PASSED!

!testRun: #MarsRoverTest #test03shouldMoveForwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:38:17'!
PASSED!

!testRun: #MarsRoverTest #test04shouldMoveForwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:38:17'!
PASSED!

!testRun: #MarsRoverTest #test05shouldMoveForwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:38:17'!
PASSED!

!testRun: #MarsRoverTest #test06shouldMoveForwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:38:17'!
PASSED!

!testRun: #MarsRoverTest #test07shouldMoveBackwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:38:17'!
PASSED!

!testRun: #MarsRoverTest #test08shouldMoveBackwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:38:17'!
PASSED!

!testRun: #MarsRoverTest #test09shouldMoveBackwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:38:17'!
PASSED!

!testRun: #MarsRoverTest #test10shouldMoveBackwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:38:17'!
PASSED!

!testRun: #MarsRoverTest #test11shouldRotateRightPointingNorthCorrectly stamp: 'LK 10/9/2023 13:38:17'!
PASSED!

!testRun: #MarsRoverTest #test12shouldRotateRightPointingEastCorrectly stamp: 'LK 10/9/2023 13:38:17'!
PASSED!

!testRun: #MarsRoverTest #test13shouldRotateRightPointingSouthCorrectly stamp: 'LK 10/9/2023 13:38:17'!
PASSED!

!testRun: #MarsRoverTest #test14shouldRotateRightPointingWestCorrectly stamp: 'LK 10/9/2023 13:38:17'!
PASSED!

!testRun: #MarsRoverTest #test15shouldRotateLeftPointingNorthCorrectly stamp: 'LK 10/9/2023 13:38:17'!
PASSED!

!testRun: #MarsRoverTest #test16shouldRotateLeftPointingSouthCorrectly stamp: 'LK 10/9/2023 13:38:17'!
PASSED!

!testRun: #MarsRoverTest #test17shouldRotateLeftPointingEastCorrectly stamp: 'LK 10/9/2023 13:38:17'!
PASSED!

!testRun: #MarsRoverTest #test18shouldRotateLeftPointingWestCorrectly stamp: 'LK 10/9/2023 13:38:17'!
PASSED!

!testRun: #MarsRoverTest #test19canHandleMultipleCommands stamp: 'LK 10/9/2023 13:38:17'!
PASSED!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:39:32'!
test19shouldHandleMultipleCommands

	|marsRover coordinate direction commands finalCoordinate |
	
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'fbf'. 
	finalCoordinate := 0@1.
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	! !

!methodRemoval: MarsRoverTest #test19canHandleMultipleCommands stamp: 'LK 10/9/2023 13:39:33'!
test19canHandleMultipleCommands

	|marsRover coordinate direction commands finalCoordinate |
	
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'fbf'. 
	finalCoordinate := 0@1.
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:39:45'!
test20shouldHandleInvalidCommand

	|marsRover coordinate direction commands finalCoordinate |
	
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'ds'. 
	finalCoordinate := 0@1.
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:39:57' prior: 50692794!
test20shouldHandleInvalidCommand

	|marsRover coordinate direction commands finalCoordinate |
	
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'ds'. 
	finalCoordinate := 0@0.
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	! !

!testRun: #MarsRoverTest #test20shouldHandleInvalidCommand stamp: 'LK 10/9/2023 13:39:59'!
PASSED!

!testRun: #MarsRoverTest #test01shouldInitializeInGivenCoordinateAndDirection stamp: 'LK 10/9/2023 13:39:59'!
PASSED!

!testRun: #MarsRoverTest #test02shouldDoNothingOnEmptyString stamp: 'LK 10/9/2023 13:39:59'!
PASSED!

!testRun: #MarsRoverTest #test03shouldMoveForwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:39:59'!
PASSED!

!testRun: #MarsRoverTest #test04shouldMoveForwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:39:59'!
PASSED!

!testRun: #MarsRoverTest #test05shouldMoveForwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:39:59'!
PASSED!

!testRun: #MarsRoverTest #test06shouldMoveForwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:39:59'!
PASSED!

!testRun: #MarsRoverTest #test07shouldMoveBackwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:39:59'!
PASSED!

!testRun: #MarsRoverTest #test08shouldMoveBackwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:39:59'!
PASSED!

!testRun: #MarsRoverTest #test09shouldMoveBackwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:39:59'!
PASSED!

!testRun: #MarsRoverTest #test10shouldMoveBackwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:39:59'!
PASSED!

!testRun: #MarsRoverTest #test11shouldRotateRightPointingNorthCorrectly stamp: 'LK 10/9/2023 13:39:59'!
PASSED!

!testRun: #MarsRoverTest #test12shouldRotateRightPointingEastCorrectly stamp: 'LK 10/9/2023 13:39:59'!
PASSED!

!testRun: #MarsRoverTest #test13shouldRotateRightPointingSouthCorrectly stamp: 'LK 10/9/2023 13:39:59'!
PASSED!

!testRun: #MarsRoverTest #test14shouldRotateRightPointingWestCorrectly stamp: 'LK 10/9/2023 13:39:59'!
PASSED!

!testRun: #MarsRoverTest #test15shouldRotateLeftPointingNorthCorrectly stamp: 'LK 10/9/2023 13:39:59'!
PASSED!

!testRun: #MarsRoverTest #test16shouldRotateLeftPointingSouthCorrectly stamp: 'LK 10/9/2023 13:39:59'!
PASSED!

!testRun: #MarsRoverTest #test17shouldRotateLeftPointingEastCorrectly stamp: 'LK 10/9/2023 13:40:00'!
PASSED!

!testRun: #MarsRoverTest #test18shouldRotateLeftPointingWestCorrectly stamp: 'LK 10/9/2023 13:40:00'!
PASSED!

!testRun: #MarsRoverTest #test19shouldHandleMultipleCommands stamp: 'LK 10/9/2023 13:40:00'!
PASSED!

!testRun: #MarsRoverTest #test20shouldHandleInvalidCommand stamp: 'LK 10/9/2023 13:40:00'!
PASSED!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:40:54'!
test20shouldHandleCommandsUntilInvalidCommand

	|marsRover coordinate direction commands finalCoordinate |
	
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'ds'. 
	finalCoordinate := 0@0.
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:41:00' prior: 50692896!
test20shouldHandleCommandsUntilInvalidCommand

	|marsRover coordinate direction commands finalCoordinate |
	
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'fffppp'. 
	finalCoordinate := 0@0.
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:41:04' prior: 50692912!
test20shouldHandleCommandsUntilInvalidCommand

	|marsRover coordinate direction commands finalCoordinate |
	
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'fffppp'. 
	finalCoordinate := 0@3.
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:41:11'!
test21shouldHandleCommandsUntilInvalidCommand

	|marsRover coordinate direction commands finalCoordinate |
	
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'fffppp'. 
	finalCoordinate := 0@3.
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	! !

!methodRemoval: MarsRoverTest #test20shouldHandleCommandsUntilInvalidCommand stamp: 'LK 10/9/2023 13:41:13'!
test20shouldHandleCommandsUntilInvalidCommand

	|marsRover coordinate direction commands finalCoordinate |
	
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'fffppp'. 
	finalCoordinate := 0@3.
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	!

!testRun: #MarsRoverTest #test20shouldHandleInvalidCommand stamp: 'LK 10/9/2023 13:41:25'!
PASSED!

!testRun: #MarsRoverTest #test21shouldHandleCommandsUntilInvalidCommand stamp: 'LK 10/9/2023 13:41:26'!
PASSED!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:41:47' prior: 50692943!
test21shouldHandleCommandsUntilInvalidCommand

	|marsRover coordinate direction commands finalCoordinate |
	
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'fffpppf'. 
	finalCoordinate := 0@3.
	
	marsRover execute: commands.
	
	self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction]).	
	! !

!testRun: #MarsRoverTest #test21shouldHandleCommandsUntilInvalidCommand stamp: 'LK 10/9/2023 13:41:48'!
FAILURE!
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 13:43:25'!
commandForward

	^ position := position + direction goForward! !
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 13:43:25' prior: 50692681!
executeChar: aSingleCommand
	
	(aSingleCommand = $f) ifTrue: [	self commandForward].
	
	(aSingleCommand = $b) ifTrue: [ position := position + direction goBackwards].
	
	(aSingleCommand = $r) ifTrue: [	direction := direction rotateRight].
	
	(aSingleCommand = $l) ifTrue: [direction := direction rotateLeft].
	
! !
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 13:43:37' prior: 50693005!
executeChar: aSingleCommand
	
	(aSingleCommand = $f) ifTrue: [	self commandForward].
	
	(aSingleCommand = $b) ifTrue: [position := position + direction goBackwards].
	
	(aSingleCommand = $r) ifTrue: [	direction := direction rotateRight].
	
	(aSingleCommand = $l) ifTrue: [direction := direction rotateLeft].
	
! !
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 13:43:49'!
commandBackward

	^ position := position + direction goBackwards! !
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 13:43:49' prior: 50693018!
executeChar: aSingleCommand
	
	(aSingleCommand = $f) ifTrue: [	self commandForward].
	
	(aSingleCommand = $b) ifTrue: [self commandBackward].
	
	(aSingleCommand = $r) ifTrue: [	direction := direction rotateRight].
	
	(aSingleCommand = $l) ifTrue: [direction := direction rotateLeft].
	
! !
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 13:44:10'!
commandRotateRight

	^ direction := direction rotateRight! !
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 13:44:10' prior: 50693035!
executeChar: aSingleCommand
	
	(aSingleCommand = $f) ifTrue: [	self commandForward].
	
	(aSingleCommand = $b) ifTrue: [self commandBackward].
	
	(aSingleCommand = $r) ifTrue: [	self commandRotateRight].
	
	(aSingleCommand = $l) ifTrue: [direction := direction rotateLeft].
	
! !
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 13:44:21'!
commandRotateLeft

	^ direction := direction rotateLeft! !
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 13:44:21' prior: 50693052!
executeChar: aSingleCommand
	
	(aSingleCommand = $f) ifTrue: [	self commandForward].
	
	(aSingleCommand = $b) ifTrue: [self commandBackward].
	
	(aSingleCommand = $r) ifTrue: [	self commandRotateRight].
	
	(aSingleCommand = $l) ifTrue: [self commandRotateLeft].
	
! !
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 13:44:55' prior: 50693068!
executeChar: aSingleCommand
	
	(aSingleCommand = $f) ifTrue: [	self commandForward].
	
	(aSingleCommand = $b) ifTrue: [self commandBackward].
	
	(aSingleCommand = $r) ifTrue: [	self commandRotateRight].
	
	(aSingleCommand = $l) ifTrue: [self commandRotateLeft].
	
	^self
	
! !

!testRun: #MarsRoverTest #test19shouldHandleMultipleCommands stamp: 'LK 10/9/2023 13:44:58'!
PASSED!

!testRun: #MarsRoverTest #test20shouldHandleInvalidCommand stamp: 'LK 10/9/2023 13:44:59'!
PASSED!

!testRun: #MarsRoverTest #test21shouldHandleCommandsUntilInvalidCommand stamp: 'LK 10/9/2023 13:45:00'!
FAILURE!

!testRun: #MarsRoverTest #test21shouldHandleCommandsUntilInvalidCommand stamp: 'LK 10/9/2023 13:45:00'!
FAILURE!
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 13:46:36' prior: 50693079!
executeChar: aSingleCommand
	
	(aSingleCommand = $f) ifTrue: [	self commandForward].
	
	(aSingleCommand = $b) ifTrue: [self commandBackward].
	
	(aSingleCommand = $r) ifTrue: [	self commandRotateRight].
	
	(aSingleCommand = $l) ifTrue: [self commandRotateLeft].
	
	
! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:52:37'!
assertMarsRover: marsRover shouldBeIn: finalCoordinate pointingTo: direction

	^ self assert: ((marsRover at: finalCoordinate ) and: [marsRover cardinal: direction])! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:52:37' prior: 50690941!
test06shouldMoveForwardsPointingEastCorrectly

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := East new.
	finalCoordinate := coordinate + (1@0).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	
	self assertMarsRover: marsRover shouldBeIn: finalCoordinate pointingTo: direction.	
	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:52:37' prior: 50691057!
test10shouldMoveBackwardsPointingWestCorrectly

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := West new.
	finalCoordinate := coordinate - (-1@0).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'b'. 
	marsRover execute: commands.
	
	self assertMarsRover: marsRover shouldBeIn: finalCoordinate pointingTo: direction.	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:52:37' prior: 50691028!
test09shouldMoveBackwardsPointingEastCorrectly

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := East new.
	finalCoordinate := coordinate - (1@0).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'b'. 
	marsRover execute: commands.
	
	self assertMarsRover: marsRover shouldBeIn: finalCoordinate pointingTo: direction.	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:52:37' prior: 50692764!
test19shouldHandleMultipleCommands

	|marsRover coordinate direction commands finalCoordinate |
	
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'fbf'. 
	finalCoordinate := 0@1.
	
	marsRover execute: commands.
	
	self assertMarsRover: marsRover shouldBeIn: finalCoordinate pointingTo: direction.	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:52:37' prior: 50690999!
test08shouldMoveBackwardsPointingSouthCorrectly

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := South new.
	finalCoordinate := coordinate - (0@-1).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'b'. 
	marsRover execute: commands.
	
	self assertMarsRover: marsRover shouldBeIn: finalCoordinate pointingTo: direction.	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:52:37' prior: 50690838!
test03shouldMoveForwardsPointingNorthCorrectly

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := North new.
	finalCoordinate := coordinate + (0@1).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	
	self assertMarsRover: marsRover shouldBeIn: finalCoordinate pointingTo: direction.	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:52:37' prior: 50692981!
test21shouldHandleCommandsUntilInvalidCommand

	|marsRover coordinate direction commands finalCoordinate |
	
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'fffpppf'. 
	finalCoordinate := 0@3.
	
	marsRover execute: commands.
	
	self assertMarsRover: marsRover shouldBeIn: finalCoordinate pointingTo: direction.	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:52:37' prior: 50690912!
test05shouldMoveForwardsPointingWestCorrectly

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := West new.
	finalCoordinate := coordinate + (-1@0).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	
	self assertMarsRover: marsRover shouldBeIn: finalCoordinate pointingTo: direction.	
	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:52:37' prior: 50690970!
test07shouldMoveBackwardsPointingNorthCorrectly

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := North new.
	finalCoordinate := coordinate - (0@1).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'b'. 
	marsRover execute: commands.
	
	self assertMarsRover: marsRover shouldBeIn: finalCoordinate pointingTo: direction.	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:52:37' prior: 50692809!
test20shouldHandleInvalidCommand

	|marsRover coordinate direction commands finalCoordinate |
	
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'ds'. 
	finalCoordinate := 0@0.
	
	marsRover execute: commands.
	
	self assertMarsRover: marsRover shouldBeIn: finalCoordinate pointingTo: direction.	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:52:37' prior: 50690883!
test04shouldMoveForwardsPointingSouthCorrectly

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := South new.
	finalCoordinate := coordinate + (0@-1).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	marsRover execute: commands.
	
	self assertMarsRover: marsRover shouldBeIn: finalCoordinate pointingTo: direction.	
	
	
	! !

!testRun: #MarsRoverTest #test01shouldInitializeInGivenCoordinateAndDirection stamp: 'LK 10/9/2023 13:52:46'!
PASSED!

!testRun: #MarsRoverTest #test02shouldDoNothingOnEmptyString stamp: 'LK 10/9/2023 13:52:46'!
PASSED!

!testRun: #MarsRoverTest #test03shouldMoveForwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:52:46'!
PASSED!

!testRun: #MarsRoverTest #test04shouldMoveForwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:52:46'!
PASSED!

!testRun: #MarsRoverTest #test05shouldMoveForwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:52:46'!
PASSED!

!testRun: #MarsRoverTest #test06shouldMoveForwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:52:46'!
PASSED!

!testRun: #MarsRoverTest #test07shouldMoveBackwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:52:46'!
PASSED!

!testRun: #MarsRoverTest #test08shouldMoveBackwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:52:46'!
PASSED!

!testRun: #MarsRoverTest #test09shouldMoveBackwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:52:46'!
PASSED!

!testRun: #MarsRoverTest #test10shouldMoveBackwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:52:46'!
PASSED!

!testRun: #MarsRoverTest #test11shouldRotateRightPointingNorthCorrectly stamp: 'LK 10/9/2023 13:52:46'!
PASSED!

!testRun: #MarsRoverTest #test12shouldRotateRightPointingEastCorrectly stamp: 'LK 10/9/2023 13:52:46'!
PASSED!

!testRun: #MarsRoverTest #test13shouldRotateRightPointingSouthCorrectly stamp: 'LK 10/9/2023 13:52:46'!
PASSED!

!testRun: #MarsRoverTest #test14shouldRotateRightPointingWestCorrectly stamp: 'LK 10/9/2023 13:52:46'!
PASSED!

!testRun: #MarsRoverTest #test15shouldRotateLeftPointingNorthCorrectly stamp: 'LK 10/9/2023 13:52:46'!
PASSED!

!testRun: #MarsRoverTest #test16shouldRotateLeftPointingSouthCorrectly stamp: 'LK 10/9/2023 13:52:46'!
PASSED!

!testRun: #MarsRoverTest #test17shouldRotateLeftPointingEastCorrectly stamp: 'LK 10/9/2023 13:52:46'!
PASSED!

!testRun: #MarsRoverTest #test18shouldRotateLeftPointingWestCorrectly stamp: 'LK 10/9/2023 13:52:46'!
PASSED!

!testRun: #MarsRoverTest #test19shouldHandleMultipleCommands stamp: 'LK 10/9/2023 13:52:46'!
PASSED!

!testRun: #MarsRoverTest #test20shouldHandleInvalidCommand stamp: 'LK 10/9/2023 13:52:46'!
PASSED!

!testRun: #MarsRoverTest #test21shouldHandleCommandsUntilInvalidCommand stamp: 'LK 10/9/2023 13:52:46'!
FAILURE!

!testRun: #MarsRoverTest #test21shouldHandleCommandsUntilInvalidCommand stamp: 'LK 10/9/2023 13:52:46'!
FAILURE!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:52:56' prior: 50693218!
test21shouldHandleCommandsUntilInvalidCommand

	|marsRover coordinate direction commands finalCoordinate |
	
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'fffpppf'. 
	finalCoordinate := 0@3.
	
	marsRover execute: commands.
	
	"self assertMarsRover: marsRover shouldBeIn: finalCoordinate pointingTo: direction.	"
	! !

!testRun: #MarsRoverTest #test21shouldHandleCommandsUntilInvalidCommand stamp: 'LK 10/9/2023 13:52:59'!
PASSED!

!testRun: #MarsRoverTest #test01shouldInitializeInGivenCoordinateAndDirection stamp: 'LK 10/9/2023 13:52:59'!
PASSED!

!testRun: #MarsRoverTest #test02shouldDoNothingOnEmptyString stamp: 'LK 10/9/2023 13:52:59'!
PASSED!

!testRun: #MarsRoverTest #test03shouldMoveForwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:52:59'!
PASSED!

!testRun: #MarsRoverTest #test04shouldMoveForwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:52:59'!
PASSED!

!testRun: #MarsRoverTest #test05shouldMoveForwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:52:59'!
PASSED!

!testRun: #MarsRoverTest #test06shouldMoveForwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:52:59'!
PASSED!

!testRun: #MarsRoverTest #test07shouldMoveBackwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:52:59'!
PASSED!

!testRun: #MarsRoverTest #test08shouldMoveBackwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:52:59'!
PASSED!

!testRun: #MarsRoverTest #test09shouldMoveBackwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:52:59'!
PASSED!

!testRun: #MarsRoverTest #test10shouldMoveBackwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:52:59'!
PASSED!

!testRun: #MarsRoverTest #test11shouldRotateRightPointingNorthCorrectly stamp: 'LK 10/9/2023 13:52:59'!
PASSED!

!testRun: #MarsRoverTest #test12shouldRotateRightPointingEastCorrectly stamp: 'LK 10/9/2023 13:53:00'!
PASSED!

!testRun: #MarsRoverTest #test13shouldRotateRightPointingSouthCorrectly stamp: 'LK 10/9/2023 13:53:00'!
PASSED!

!testRun: #MarsRoverTest #test14shouldRotateRightPointingWestCorrectly stamp: 'LK 10/9/2023 13:53:00'!
PASSED!

!testRun: #MarsRoverTest #test15shouldRotateLeftPointingNorthCorrectly stamp: 'LK 10/9/2023 13:53:00'!
PASSED!

!testRun: #MarsRoverTest #test16shouldRotateLeftPointingSouthCorrectly stamp: 'LK 10/9/2023 13:53:00'!
PASSED!

!testRun: #MarsRoverTest #test17shouldRotateLeftPointingEastCorrectly stamp: 'LK 10/9/2023 13:53:00'!
PASSED!

!testRun: #MarsRoverTest #test18shouldRotateLeftPointingWestCorrectly stamp: 'LK 10/9/2023 13:53:00'!
PASSED!

!testRun: #MarsRoverTest #test19shouldHandleMultipleCommands stamp: 'LK 10/9/2023 13:53:00'!
PASSED!

!testRun: #MarsRoverTest #test20shouldHandleInvalidCommand stamp: 'LK 10/9/2023 13:53:00'!
PASSED!

!testRun: #MarsRoverTest #test21shouldHandleCommandsUntilInvalidCommand stamp: 'LK 10/9/2023 13:53:00'!
PASSED!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:53:29' prior: 50690776!
test01shouldInitializeInGivenCoordinateAndDirection
	| marsRover coordinate direction|
	
	coordinate := 0@0.
	direction := North new.
	marsRover := MarsRover withCoord: coordinate pointingTo: direction.
	
	self assertMarsRover: marsRover shouldBeIn: direction pointingTo: coordinate.
	! !

!testRun: #MarsRoverTest #test01shouldInitializeInGivenCoordinateAndDirection stamp: 'LK 10/9/2023 13:53:29'!
FAILURE!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:53:45' prior: 50693466!
test01shouldInitializeInGivenCoordinateAndDirection
	| marsRover coordinate direction|
	
	coordinate := 0@0.
	direction := North new.
	marsRover := MarsRover withCoord: coordinate pointingTo: direction.
	
	self assertMarsRover: marsRover shouldBeIn: coordinate pointingTo: direction.
	! !

!testRun: #MarsRoverTest #test01shouldInitializeInGivenCoordinateAndDirection stamp: 'LK 10/9/2023 13:53:46'!
PASSED!

!testRun: #MarsRoverTest #test01shouldInitializeInGivenCoordinateAndDirection stamp: 'LK 10/9/2023 13:53:46'!
PASSED!

!testRun: #MarsRoverTest #test02shouldDoNothingOnEmptyString stamp: 'LK 10/9/2023 13:53:46'!
PASSED!

!testRun: #MarsRoverTest #test03shouldMoveForwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:53:46'!
PASSED!

!testRun: #MarsRoverTest #test04shouldMoveForwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:53:46'!
PASSED!

!testRun: #MarsRoverTest #test05shouldMoveForwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:53:46'!
PASSED!

!testRun: #MarsRoverTest #test06shouldMoveForwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:53:46'!
PASSED!

!testRun: #MarsRoverTest #test07shouldMoveBackwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:53:46'!
PASSED!

!testRun: #MarsRoverTest #test08shouldMoveBackwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:53:46'!
PASSED!

!testRun: #MarsRoverTest #test09shouldMoveBackwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:53:46'!
PASSED!

!testRun: #MarsRoverTest #test10shouldMoveBackwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:53:46'!
PASSED!

!testRun: #MarsRoverTest #test11shouldRotateRightPointingNorthCorrectly stamp: 'LK 10/9/2023 13:53:46'!
PASSED!

!testRun: #MarsRoverTest #test12shouldRotateRightPointingEastCorrectly stamp: 'LK 10/9/2023 13:53:46'!
PASSED!

!testRun: #MarsRoverTest #test13shouldRotateRightPointingSouthCorrectly stamp: 'LK 10/9/2023 13:53:46'!
PASSED!

!testRun: #MarsRoverTest #test14shouldRotateRightPointingWestCorrectly stamp: 'LK 10/9/2023 13:53:46'!
PASSED!

!testRun: #MarsRoverTest #test15shouldRotateLeftPointingNorthCorrectly stamp: 'LK 10/9/2023 13:53:46'!
PASSED!

!testRun: #MarsRoverTest #test16shouldRotateLeftPointingSouthCorrectly stamp: 'LK 10/9/2023 13:53:46'!
PASSED!

!testRun: #MarsRoverTest #test17shouldRotateLeftPointingEastCorrectly stamp: 'LK 10/9/2023 13:53:46'!
PASSED!

!testRun: #MarsRoverTest #test18shouldRotateLeftPointingWestCorrectly stamp: 'LK 10/9/2023 13:53:46'!
PASSED!

!testRun: #MarsRoverTest #test19shouldHandleMultipleCommands stamp: 'LK 10/9/2023 13:53:46'!
PASSED!

!testRun: #MarsRoverTest #test20shouldHandleInvalidCommand stamp: 'LK 10/9/2023 13:53:46'!
PASSED!

!testRun: #MarsRoverTest #test21shouldHandleCommandsUntilInvalidCommand stamp: 'LK 10/9/2023 13:53:46'!
PASSED!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:54:06' prior: 50690798!
test02shouldDoNothingOnEmptyString

	|marsRover coordinate direction commands|
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := ''. 
	marsRover execute: commands.
	
	self assertMarsRover: marsRover shouldBeIn: coordinate pointingTo: direction.
	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:54:24' prior: 50693202!
test03shouldMoveForwardsPointingNorthCorrectly

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := North new.
	finalCoordinate := coordinate + (0@1).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	
	marsRover execute: commands.
	
	self assertMarsRover: marsRover shouldBeIn: finalCoordinate pointingTo: direction.	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:54:33' prior: 50693482!
test01shouldInitializeInGivenCoordinateAndDirection

	| marsRover coordinate direction|
	
	coordinate := 0@0.
	direction := North new.
	marsRover := MarsRover withCoord: coordinate pointingTo: direction.
	
	self assertMarsRover: marsRover shouldBeIn: coordinate pointingTo: direction.
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:54:36' prior: 50693571!
test02shouldDoNothingOnEmptyString

	|marsRover coordinate direction commands|
	
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := ''. 
	marsRover execute: commands.
	
	self assertMarsRover: marsRover shouldBeIn: coordinate pointingTo: direction.
	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:54:42' prior: 50693613!
test02shouldDoNothingOnEmptyString

	|marsRover coordinate direction commands|
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := ''. 
	
	marsRover execute: commands.
	
	self assertMarsRover: marsRover shouldBeIn: coordinate pointingTo: direction.
	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:54:49' prior: 50693627!
test02shouldDoNothingOnEmptyString

	|marsRover coordinate direction commands|
	
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := ''. 
	
	marsRover execute: commands.
	
	self assertMarsRover: marsRover shouldBeIn: coordinate pointingTo: direction.
	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:55:01' prior: 50693281!
test04shouldMoveForwardsPointingSouthCorrectly

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := South new.
	finalCoordinate := coordinate + (0@-1).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	
	marsRover execute: commands.
	
	self assertMarsRover: marsRover shouldBeIn: finalCoordinate pointingTo: direction.	
	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:55:05' prior: 50693234!
test05shouldMoveForwardsPointingWestCorrectly

	|marsRover coordinate direction commands finalCoordinate|
	
	coordinate := 0@0.
	direction := West new.
	finalCoordinate := coordinate + (-1@0).
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'f'. 
	
	marsRover execute: commands.
	
	self assertMarsRover: marsRover shouldBeIn: finalCoordinate pointingTo: direction.	
	
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:55:42' prior: 50691687!
test11shouldRotateRightPointingNorthCorrectly

	|marsRover coordinate direction commands finalDirection |
	
	coordinate := 0@0.
	direction := North new.
	finalDirection := East new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'r'. 
	
	marsRover execute: commands.
	
	self assertMarsRover: marsRover shouldBeIn: coordinate pointingTo: finalDirection.
	
	! !

!testRun: #MarsRoverTest #test11shouldRotateRightPointingNorthCorrectly stamp: 'LK 10/9/2023 13:55:43'!
PASSED!

!testRun: #MarsRoverTest #test01shouldInitializeInGivenCoordinateAndDirection stamp: 'LK 10/9/2023 13:55:43'!
PASSED!

!testRun: #MarsRoverTest #test02shouldDoNothingOnEmptyString stamp: 'LK 10/9/2023 13:55:43'!
PASSED!

!testRun: #MarsRoverTest #test03shouldMoveForwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:55:43'!
PASSED!

!testRun: #MarsRoverTest #test04shouldMoveForwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:55:43'!
PASSED!

!testRun: #MarsRoverTest #test05shouldMoveForwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:55:43'!
PASSED!

!testRun: #MarsRoverTest #test06shouldMoveForwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:55:43'!
PASSED!

!testRun: #MarsRoverTest #test07shouldMoveBackwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:55:43'!
PASSED!

!testRun: #MarsRoverTest #test08shouldMoveBackwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:55:43'!
PASSED!

!testRun: #MarsRoverTest #test09shouldMoveBackwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:55:43'!
PASSED!

!testRun: #MarsRoverTest #test10shouldMoveBackwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:55:43'!
PASSED!

!testRun: #MarsRoverTest #test11shouldRotateRightPointingNorthCorrectly stamp: 'LK 10/9/2023 13:55:43'!
PASSED!

!testRun: #MarsRoverTest #test12shouldRotateRightPointingEastCorrectly stamp: 'LK 10/9/2023 13:55:43'!
PASSED!

!testRun: #MarsRoverTest #test13shouldRotateRightPointingSouthCorrectly stamp: 'LK 10/9/2023 13:55:43'!
PASSED!

!testRun: #MarsRoverTest #test14shouldRotateRightPointingWestCorrectly stamp: 'LK 10/9/2023 13:55:43'!
PASSED!

!testRun: #MarsRoverTest #test15shouldRotateLeftPointingNorthCorrectly stamp: 'LK 10/9/2023 13:55:43'!
PASSED!

!testRun: #MarsRoverTest #test16shouldRotateLeftPointingSouthCorrectly stamp: 'LK 10/9/2023 13:55:43'!
PASSED!

!testRun: #MarsRoverTest #test17shouldRotateLeftPointingEastCorrectly stamp: 'LK 10/9/2023 13:55:43'!
PASSED!

!testRun: #MarsRoverTest #test18shouldRotateLeftPointingWestCorrectly stamp: 'LK 10/9/2023 13:55:43'!
PASSED!

!testRun: #MarsRoverTest #test19shouldHandleMultipleCommands stamp: 'LK 10/9/2023 13:55:43'!
PASSED!

!testRun: #MarsRoverTest #test20shouldHandleInvalidCommand stamp: 'LK 10/9/2023 13:55:43'!
PASSED!

!testRun: #MarsRoverTest #test21shouldHandleCommandsUntilInvalidCommand stamp: 'LK 10/9/2023 13:55:43'!
PASSED!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:55:54' prior: 50691716!
test12shouldRotateRightPointingEastCorrectly

	|marsRover coordinate direction commands finalDirection |
	
	coordinate := 0@0.
	direction := East new.
	finalDirection := South new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'r'. 
	
	marsRover execute: commands.
	
	self assertMarsRover: marsRover shouldBeIn: coordinate pointingTo: finalDirection.
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:55:59' prior: 50691802!
test13shouldRotateRightPointingSouthCorrectly
	|marsRover coordinate direction commands finalDirection |
	
	coordinate := 0@0.
	direction := South new.
	finalDirection := West new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'r'. 
	
	marsRover execute: commands.
	
	self assertMarsRover: marsRover shouldBeIn: coordinate pointingTo: finalDirection.
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:56:04' prior: 50691773!
test14shouldRotateRightPointingWestCorrectly

	|marsRover coordinate direction commands finalDirection |
	
	coordinate := 0@0.
	direction := West new.
	finalDirection := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'r'. 
	
	marsRover execute: commands.
	
	self assertMarsRover: marsRover shouldBeIn: coordinate pointingTo: finalDirection.
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:56:11' prior: 50691970!
test15shouldRotateLeftPointingNorthCorrectly

	|marsRover coordinate direction commands finalDirection |
	
	coordinate := 0@0.
	direction := North new.
	finalDirection := West new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'l'. 
	
	marsRover execute: commands.
	
	self assertMarsRover: marsRover shouldBeIn: coordinate pointingTo: finalDirection.
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:56:15' prior: 50692042!
test16shouldRotateLeftPointingSouthCorrectly

	|marsRover coordinate direction commands finalDirection |
	
	coordinate := 0@0.
	direction := South new.
	finalDirection := East new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'l'. 
	
	marsRover execute: commands.
	
	self assertMarsRover: marsRover shouldBeIn: coordinate pointingTo: finalDirection.
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:56:20' prior: 50692117!
test17shouldRotateLeftPointingEastCorrectly

	|marsRover coordinate direction commands finalDirection |
	
	coordinate := 0@0.
	direction := East new.
	finalDirection := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'l'. 
	
	marsRover execute: commands.
	
	self assertMarsRover: marsRover shouldBeIn: coordinate pointingTo: finalDirection.
	
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 13:56:24' prior: 50692277!
test18shouldRotateLeftPointingWestCorrectly

	|marsRover coordinate direction commands finalDirection |
	
	coordinate := 0@0.
	direction := West new.
	finalDirection := South new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'l'. 
	
	marsRover execute: commands.
	
	self assertMarsRover: marsRover shouldBeIn: coordinate pointingTo: finalDirection.
	
	! !
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 13:58:22' prior: 50693030!
commandBackward

	position := position + direction goBackwards! !
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 13:58:26' prior: 50693000!
commandForward

	position := position + direction goForward! !
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 13:58:28' prior: 50693063!
commandRotateLeft

	direction := direction rotateLeft! !
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 13:58:31' prior: 50693047!
commandRotateRight

	direction := direction rotateRight! !

!testRun: #MarsRoverTest #test01shouldInitializeInGivenCoordinateAndDirection stamp: 'LK 10/9/2023 13:58:36'!
PASSED!

!testRun: #MarsRoverTest #test02shouldDoNothingOnEmptyString stamp: 'LK 10/9/2023 13:58:36'!
PASSED!

!testRun: #MarsRoverTest #test03shouldMoveForwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:58:36'!
PASSED!

!testRun: #MarsRoverTest #test04shouldMoveForwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:58:36'!
PASSED!

!testRun: #MarsRoverTest #test05shouldMoveForwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:58:36'!
PASSED!

!testRun: #MarsRoverTest #test06shouldMoveForwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:58:36'!
PASSED!

!testRun: #MarsRoverTest #test07shouldMoveBackwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 13:58:36'!
PASSED!

!testRun: #MarsRoverTest #test08shouldMoveBackwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 13:58:36'!
PASSED!

!testRun: #MarsRoverTest #test09shouldMoveBackwardsPointingEastCorrectly stamp: 'LK 10/9/2023 13:58:36'!
PASSED!

!testRun: #MarsRoverTest #test10shouldMoveBackwardsPointingWestCorrectly stamp: 'LK 10/9/2023 13:58:36'!
PASSED!

!testRun: #MarsRoverTest #test11shouldRotateRightPointingNorthCorrectly stamp: 'LK 10/9/2023 13:58:36'!
PASSED!

!testRun: #MarsRoverTest #test12shouldRotateRightPointingEastCorrectly stamp: 'LK 10/9/2023 13:58:36'!
PASSED!

!testRun: #MarsRoverTest #test13shouldRotateRightPointingSouthCorrectly stamp: 'LK 10/9/2023 13:58:36'!
PASSED!

!testRun: #MarsRoverTest #test14shouldRotateRightPointingWestCorrectly stamp: 'LK 10/9/2023 13:58:36'!
PASSED!

!testRun: #MarsRoverTest #test15shouldRotateLeftPointingNorthCorrectly stamp: 'LK 10/9/2023 13:58:36'!
PASSED!

!testRun: #MarsRoverTest #test16shouldRotateLeftPointingSouthCorrectly stamp: 'LK 10/9/2023 13:58:36'!
PASSED!

!testRun: #MarsRoverTest #test17shouldRotateLeftPointingEastCorrectly stamp: 'LK 10/9/2023 13:58:36'!
PASSED!

!testRun: #MarsRoverTest #test18shouldRotateLeftPointingWestCorrectly stamp: 'LK 10/9/2023 13:58:36'!
PASSED!

!testRun: #MarsRoverTest #test19shouldHandleMultipleCommands stamp: 'LK 10/9/2023 13:58:36'!
PASSED!

!testRun: #MarsRoverTest #test20shouldHandleInvalidCommand stamp: 'LK 10/9/2023 13:58:36'!
PASSED!

!testRun: #MarsRoverTest #test21shouldHandleCommandsUntilInvalidCommand stamp: 'LK 10/9/2023 13:58:36'!
PASSED!

Object subclass: #Command
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!

!classDefinition: #Command category: 'Mars Rover- Exercise' stamp: 'LK 10/9/2023 13:58:59'!
Object subclass: #Command
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!

Command subclass: #Forward
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!

!classDefinition: #Forward category: 'Mars Rover- Exercise' stamp: 'LK 10/9/2023 13:59:07'!
Command subclass: #Forward
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!

Command subclass: #Backward
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!

!classDefinition: #Backward category: 'Mars Rover- Exercise' stamp: 'LK 10/9/2023 13:59:11'!
Command subclass: #Backward
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!

Command subclass: #RotateLeft
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!

!classDefinition: #RotateLeft category: 'Mars Rover- Exercise' stamp: 'LK 10/9/2023 13:59:26'!
Command subclass: #RotateLeft
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!

Command subclass: #RotateRight
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!

!classDefinition: #RotateRight category: 'Mars Rover- Exercise' stamp: 'LK 10/9/2023 13:59:30'!
Command subclass: #RotateRight
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 14:00:10' prior: 50692669!
execute: commands 

	commands do: [:command | self executeChar: command].

	
! !
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 14:02:24' prior: 50693104!
executeChar: aSingleCommand
	
	(aSingleCommand = $f) ifTrue: [	^self commandForward].
	
	(aSingleCommand = $b) ifTrue: [^self commandBackward].
	
	(aSingleCommand = $r) ifTrue: [^	self commandRotateRight].
	
	(aSingleCommand = $l) ifTrue: [^self commandRotateLeft].
	
	self error: 'comando invalido'.
	
! !

!testRun: #MarsRoverTest #test20shouldHandleInvalidCommand stamp: 'LK 10/9/2023 14:02:28'!
ERROR!

!testRun: #MarsRoverTest #test20shouldHandleInvalidCommand stamp: 'LK 10/9/2023 14:02:28'!
ERROR!

!testRun: #MarsRoverTest #test21shouldHandleCommandsUntilInvalidCommand stamp: 'LK 10/9/2023 14:02:33'!
ERROR!

!testRun: #MarsRoverTest #test21shouldHandleCommandsUntilInvalidCommand stamp: 'LK 10/9/2023 14:02:33'!
ERROR!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 14:03:12' prior: 50693374!
test21shouldHandleCommandsUntilInvalidCommand

	|marsRover coordinate direction commands finalCoordinate |
	
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'fffpppf'. 
	finalCoordinate := 0@3.
	
	marsRover execute: commands.
	

	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 14:05:39' prior: 50693266!
test20shouldHandleInvalidCommand

	|marsRover coordinate direction commands finalCoordinate |
	
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'ds'. 
	finalCoordinate := 0@0.
	
	
	self 
		should: [marsRover execute: commands]
		raise: Error
		withExceptionDo: [ :anError |].
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 14:06:26' prior: 50694080!
test20shouldHandleInvalidCommand

	|marsRover coordinate direction commands finalCoordinate |
	
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'ds'. 
	finalCoordinate := 0@0.
	
	
	self 
		should: [marsRover execute: commands]
		raise: Error
		withExceptionDo: [ :anError | 
			self assert: anError messageText = ''].
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 14:06:38' prior: 50694094!
test20shouldHandleInvalidCommand

	|marsRover coordinate direction commands|
	
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'ds'. 
	
	
	self 
		should: [marsRover execute: commands]
		raise: Error
		withExceptionDo: [ :anError | 
			self assert: anError messageText = ''].
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 14:06:52' prior: 50694110!
test20shouldHandleInvalidCommand

	|marsRover coordinate direction commands|
	
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'ds'. 
	
	
	self 
		should: [marsRover execute: commands]
		raise: Error
		withExceptionDo: [ :anError | 
			self assert: anError messageText = 'comando invalido'].
	! !

!testRun: #MarsRoverTest #test20shouldHandleInvalidCommand stamp: 'LK 10/9/2023 14:06:53'!
PASSED!

!testRun: #MarsRoverTest #test01shouldInitializeInGivenCoordinateAndDirection stamp: 'LK 10/9/2023 14:06:53'!
PASSED!

!testRun: #MarsRoverTest #test02shouldDoNothingOnEmptyString stamp: 'LK 10/9/2023 14:06:53'!
PASSED!

!testRun: #MarsRoverTest #test03shouldMoveForwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 14:06:53'!
PASSED!

!testRun: #MarsRoverTest #test04shouldMoveForwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 14:06:53'!
PASSED!

!testRun: #MarsRoverTest #test05shouldMoveForwardsPointingWestCorrectly stamp: 'LK 10/9/2023 14:06:53'!
PASSED!

!testRun: #MarsRoverTest #test06shouldMoveForwardsPointingEastCorrectly stamp: 'LK 10/9/2023 14:06:53'!
PASSED!

!testRun: #MarsRoverTest #test07shouldMoveBackwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 14:06:53'!
PASSED!

!testRun: #MarsRoverTest #test08shouldMoveBackwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 14:06:53'!
PASSED!

!testRun: #MarsRoverTest #test09shouldMoveBackwardsPointingEastCorrectly stamp: 'LK 10/9/2023 14:06:53'!
PASSED!

!testRun: #MarsRoverTest #test10shouldMoveBackwardsPointingWestCorrectly stamp: 'LK 10/9/2023 14:06:53'!
PASSED!

!testRun: #MarsRoverTest #test11shouldRotateRightPointingNorthCorrectly stamp: 'LK 10/9/2023 14:06:53'!
PASSED!

!testRun: #MarsRoverTest #test12shouldRotateRightPointingEastCorrectly stamp: 'LK 10/9/2023 14:06:53'!
PASSED!

!testRun: #MarsRoverTest #test13shouldRotateRightPointingSouthCorrectly stamp: 'LK 10/9/2023 14:06:53'!
PASSED!

!testRun: #MarsRoverTest #test14shouldRotateRightPointingWestCorrectly stamp: 'LK 10/9/2023 14:06:53'!
PASSED!

!testRun: #MarsRoverTest #test15shouldRotateLeftPointingNorthCorrectly stamp: 'LK 10/9/2023 14:06:54'!
PASSED!

!testRun: #MarsRoverTest #test16shouldRotateLeftPointingSouthCorrectly stamp: 'LK 10/9/2023 14:06:54'!
PASSED!

!testRun: #MarsRoverTest #test17shouldRotateLeftPointingEastCorrectly stamp: 'LK 10/9/2023 14:06:54'!
PASSED!

!testRun: #MarsRoverTest #test18shouldRotateLeftPointingWestCorrectly stamp: 'LK 10/9/2023 14:06:54'!
PASSED!

!testRun: #MarsRoverTest #test19shouldHandleMultipleCommands stamp: 'LK 10/9/2023 14:06:54'!
PASSED!

!testRun: #MarsRoverTest #test20shouldHandleInvalidCommand stamp: 'LK 10/9/2023 14:06:54'!
PASSED!

!testRun: #MarsRoverTest #test21shouldHandleCommandsUntilInvalidCommand stamp: 'LK 10/9/2023 14:06:54'!
ERROR!

!testRun: #MarsRoverTest #test21shouldHandleCommandsUntilInvalidCommand stamp: 'LK 10/9/2023 14:06:54'!
ERROR!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'LK 10/9/2023 14:07:08'!
PASSED!

!testRun: #OOStackTest #test01StackShouldBeEmptyWhenCreated stamp: 'LK 10/9/2023 14:07:08'!
PASSED!

!testRun: #OOStackTest #test02PushAddElementsToTheStack stamp: 'LK 10/9/2023 14:07:08'!
PASSED!

!testRun: #OOStackTest #test03PopRemovesElementsFromTheStack stamp: 'LK 10/9/2023 14:07:08'!
PASSED!

!testRun: #OOStackTest #test04PopReturnsLastPushedObject stamp: 'LK 10/9/2023 14:07:08'!
PASSED!

!testRun: #OOStackTest #test05StackBehavesLIFO stamp: 'LK 10/9/2023 14:07:08'!
PASSED!

!testRun: #OOStackTest #test06TopReturnsLastPushedObject stamp: 'LK 10/9/2023 14:07:08'!
PASSED!

!testRun: #OOStackTest #test07TopDoesNotRemoveObjectFromStack stamp: 'LK 10/9/2023 14:07:08'!
PASSED!

!testRun: #OOStackTest #test08CanNotPopWhenThereAreNoObjectsInTheStack stamp: 'LK 10/9/2023 14:07:08'!
PASSED!

!testRun: #OOStackTest #test09CanNotPopWhenThereAreNoObjectsInTheStackAndTheStackHadObjects stamp: 'LK 10/9/2023 14:07:08'!
PASSED!

!testRun: #OOStackTest #test10CanNotTopWhenThereAreNoObjectsInTheStack stamp: 'LK 10/9/2023 14:07:08'!
PASSED!

!testRun: #MarsRoverTest #test20shouldHandleInvalidCommand stamp: 'LK 10/9/2023 14:08:02'!
PASSED!

!testRun: #MarsRoverTest #test01shouldInitializeInGivenCoordinateAndDirection stamp: 'LK 10/9/2023 14:08:02'!
PASSED!

!testRun: #MarsRoverTest #test02shouldDoNothingOnEmptyString stamp: 'LK 10/9/2023 14:08:02'!
PASSED!

!testRun: #MarsRoverTest #test03shouldMoveForwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 14:08:02'!
PASSED!

!testRun: #MarsRoverTest #test04shouldMoveForwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 14:08:02'!
PASSED!

!testRun: #MarsRoverTest #test05shouldMoveForwardsPointingWestCorrectly stamp: 'LK 10/9/2023 14:08:02'!
PASSED!

!testRun: #MarsRoverTest #test06shouldMoveForwardsPointingEastCorrectly stamp: 'LK 10/9/2023 14:08:02'!
PASSED!

!testRun: #MarsRoverTest #test07shouldMoveBackwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 14:08:02'!
PASSED!

!testRun: #MarsRoverTest #test08shouldMoveBackwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 14:08:02'!
PASSED!

!testRun: #MarsRoverTest #test09shouldMoveBackwardsPointingEastCorrectly stamp: 'LK 10/9/2023 14:08:02'!
PASSED!

!testRun: #MarsRoverTest #test10shouldMoveBackwardsPointingWestCorrectly stamp: 'LK 10/9/2023 14:08:02'!
PASSED!

!testRun: #MarsRoverTest #test11shouldRotateRightPointingNorthCorrectly stamp: 'LK 10/9/2023 14:08:02'!
PASSED!

!testRun: #MarsRoverTest #test12shouldRotateRightPointingEastCorrectly stamp: 'LK 10/9/2023 14:08:02'!
PASSED!

!testRun: #MarsRoverTest #test13shouldRotateRightPointingSouthCorrectly stamp: 'LK 10/9/2023 14:08:02'!
PASSED!

!testRun: #MarsRoverTest #test14shouldRotateRightPointingWestCorrectly stamp: 'LK 10/9/2023 14:08:02'!
PASSED!

!testRun: #MarsRoverTest #test15shouldRotateLeftPointingNorthCorrectly stamp: 'LK 10/9/2023 14:08:02'!
PASSED!

!testRun: #MarsRoverTest #test16shouldRotateLeftPointingSouthCorrectly stamp: 'LK 10/9/2023 14:08:02'!
PASSED!

!testRun: #MarsRoverTest #test17shouldRotateLeftPointingEastCorrectly stamp: 'LK 10/9/2023 14:08:02'!
PASSED!

!testRun: #MarsRoverTest #test18shouldRotateLeftPointingWestCorrectly stamp: 'LK 10/9/2023 14:08:02'!
PASSED!

!testRun: #MarsRoverTest #test19shouldHandleMultipleCommands stamp: 'LK 10/9/2023 14:08:02'!
PASSED!

!testRun: #MarsRoverTest #test20shouldHandleInvalidCommand stamp: 'LK 10/9/2023 14:08:02'!
PASSED!

!testRun: #MarsRoverTest #test21shouldHandleCommandsUntilInvalidCommand stamp: 'LK 10/9/2023 14:08:02'!
ERROR!

!testRun: #MarsRoverTest #test21shouldHandleCommandsUntilInvalidCommand stamp: 'LK 10/9/2023 14:08:02'!
ERROR!

!testRun: #MarsRoverTest #test20shouldHandleInvalidCommand stamp: 'LK 10/9/2023 14:08:11'!
PASSED!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 14:08:17' prior: 50694124!
test20shouldHandleInvalidCommand

	|marsRover coordinate direction commands|
	
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'ds'. 
	
	self 
		should: [marsRover execute: commands]
		raise: Error
		withExceptionDo: [ :anError | 
			self assert: anError messageText = 'comando invalido'].
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 14:08:54' prior: 50694067!
test21shouldHandleCommandsUntilInvalidCommand

	|marsRover coordinate direction commands finalCoordinate |
	
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'fffpppf'. 
	finalCoordinate := 0@3.
	
	self 
		should: [marsRover execute: commands]
		raise: Error
		withExceptionDo: [ :anError | 
			self assert: anError messageText = 'comando invalido'].
	
	self assertMarsRover: marsRover shouldBeIn: finalCoordinate pointingTo: direction.
	

	! !

!testRun: #MarsRoverTest #test21shouldHandleCommandsUntilInvalidCommand stamp: 'LK 10/9/2023 14:08:55'!
PASSED!

!testRun: #MarsRoverTest #test01shouldInitializeInGivenCoordinateAndDirection stamp: 'LK 10/9/2023 14:08:55'!
PASSED!

!testRun: #MarsRoverTest #test02shouldDoNothingOnEmptyString stamp: 'LK 10/9/2023 14:08:55'!
PASSED!

!testRun: #MarsRoverTest #test03shouldMoveForwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 14:08:55'!
PASSED!

!testRun: #MarsRoverTest #test04shouldMoveForwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 14:08:55'!
PASSED!

!testRun: #MarsRoverTest #test05shouldMoveForwardsPointingWestCorrectly stamp: 'LK 10/9/2023 14:08:55'!
PASSED!

!testRun: #MarsRoverTest #test06shouldMoveForwardsPointingEastCorrectly stamp: 'LK 10/9/2023 14:08:55'!
PASSED!

!testRun: #MarsRoverTest #test07shouldMoveBackwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 14:08:55'!
PASSED!

!testRun: #MarsRoverTest #test08shouldMoveBackwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 14:08:55'!
PASSED!

!testRun: #MarsRoverTest #test09shouldMoveBackwardsPointingEastCorrectly stamp: 'LK 10/9/2023 14:08:55'!
PASSED!

!testRun: #MarsRoverTest #test10shouldMoveBackwardsPointingWestCorrectly stamp: 'LK 10/9/2023 14:08:55'!
PASSED!

!testRun: #MarsRoverTest #test11shouldRotateRightPointingNorthCorrectly stamp: 'LK 10/9/2023 14:08:55'!
PASSED!

!testRun: #MarsRoverTest #test12shouldRotateRightPointingEastCorrectly stamp: 'LK 10/9/2023 14:08:55'!
PASSED!

!testRun: #MarsRoverTest #test13shouldRotateRightPointingSouthCorrectly stamp: 'LK 10/9/2023 14:08:55'!
PASSED!

!testRun: #MarsRoverTest #test14shouldRotateRightPointingWestCorrectly stamp: 'LK 10/9/2023 14:08:55'!
PASSED!

!testRun: #MarsRoverTest #test15shouldRotateLeftPointingNorthCorrectly stamp: 'LK 10/9/2023 14:08:55'!
PASSED!

!testRun: #MarsRoverTest #test16shouldRotateLeftPointingSouthCorrectly stamp: 'LK 10/9/2023 14:08:55'!
PASSED!

!testRun: #MarsRoverTest #test17shouldRotateLeftPointingEastCorrectly stamp: 'LK 10/9/2023 14:08:55'!
PASSED!

!testRun: #MarsRoverTest #test18shouldRotateLeftPointingWestCorrectly stamp: 'LK 10/9/2023 14:08:55'!
PASSED!

!testRun: #MarsRoverTest #test19shouldHandleMultipleCommands stamp: 'LK 10/9/2023 14:08:55'!
PASSED!

!testRun: #MarsRoverTest #test20shouldHandleInvalidCommand stamp: 'LK 10/9/2023 14:08:55'!
PASSED!

!testRun: #MarsRoverTest #test21shouldHandleCommandsUntilInvalidCommand stamp: 'LK 10/9/2023 14:08:55'!
PASSED!
!MarsRover methodsFor: 'commands' stamp: 'LK 10/9/2023 14:10:02' prior: 50694041!
executeChar: aSingleCommand
	
	(aSingleCommand = $f) ifTrue: [	^self commandForward].
	
	(aSingleCommand = $b) ifTrue: [^self commandBackward].
	
	(aSingleCommand = $r) ifTrue: [^	self commandRotateRight].
	
	(aSingleCommand = $l) ifTrue: [^self commandRotateLeft].
	
	self error: MarsRover errorInvalidCommand.
	
! !
!MarsRover class methodsFor: 'instance creation' stamp: 'LK 10/9/2023 14:10:17'!
errorInvalidCommand
	^'Command is invalid'.! !

!testRun: #MarsRoverTest #test20shouldHandleInvalidCommand stamp: 'LK 10/9/2023 14:10:21'!
FAILURE!

!testRun: #MarsRoverTest #test20shouldHandleInvalidCommand stamp: 'LK 10/9/2023 14:10:21'!
FAILURE!
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 14:10:42' prior: 50694338!
test20shouldHandleInvalidCommand

	|marsRover coordinate direction commands|
	
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'ds'. 
	
	self 
		should: [marsRover execute: commands]
		raise: Error
		withExceptionDo: [ :anError | 
			self assert: anError messageText = MarsRover errorInvalidCommand].
	! !
!MarsRoverTest methodsFor: 'testing' stamp: 'LK 10/9/2023 14:10:55' prior: 50694353!
test21shouldHandleCommandsUntilInvalidCommand

	|marsRover coordinate direction commands finalCoordinate |
	
	coordinate := 0@0.
	direction := North new.
	marsRover  := MarsRover withCoord: coordinate pointingTo: direction.
	commands := 'fffpppf'. 
	finalCoordinate := 0@3.
	
	self 
		should: [marsRover execute: commands]
		raise: Error
		withExceptionDo: [ :anError | 
			self assert: anError messageText = MarsRover errorInvalidCommand].
	
	self assertMarsRover: marsRover shouldBeIn: finalCoordinate pointingTo: direction.
	

	! !

!testRun: #MarsRoverTest #test21shouldHandleCommandsUntilInvalidCommand stamp: 'LK 10/9/2023 14:10:56'!
PASSED!

!testRun: #MarsRoverTest #test20shouldHandleInvalidCommand stamp: 'LK 10/9/2023 14:10:58'!
PASSED!

!testRun: #MarsRoverTest #test01shouldInitializeInGivenCoordinateAndDirection stamp: 'LK 10/9/2023 14:11:02'!
PASSED!

!testRun: #MarsRoverTest #test02shouldDoNothingOnEmptyString stamp: 'LK 10/9/2023 14:11:02'!
PASSED!

!testRun: #MarsRoverTest #test03shouldMoveForwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 14:11:02'!
PASSED!

!testRun: #MarsRoverTest #test04shouldMoveForwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 14:11:02'!
PASSED!

!testRun: #MarsRoverTest #test05shouldMoveForwardsPointingWestCorrectly stamp: 'LK 10/9/2023 14:11:02'!
PASSED!

!testRun: #MarsRoverTest #test06shouldMoveForwardsPointingEastCorrectly stamp: 'LK 10/9/2023 14:11:02'!
PASSED!

!testRun: #MarsRoverTest #test07shouldMoveBackwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 14:11:02'!
PASSED!

!testRun: #MarsRoverTest #test08shouldMoveBackwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 14:11:02'!
PASSED!

!testRun: #MarsRoverTest #test09shouldMoveBackwardsPointingEastCorrectly stamp: 'LK 10/9/2023 14:11:02'!
PASSED!

!testRun: #MarsRoverTest #test10shouldMoveBackwardsPointingWestCorrectly stamp: 'LK 10/9/2023 14:11:02'!
PASSED!

!testRun: #MarsRoverTest #test11shouldRotateRightPointingNorthCorrectly stamp: 'LK 10/9/2023 14:11:02'!
PASSED!

!testRun: #MarsRoverTest #test12shouldRotateRightPointingEastCorrectly stamp: 'LK 10/9/2023 14:11:02'!
PASSED!

!testRun: #MarsRoverTest #test13shouldRotateRightPointingSouthCorrectly stamp: 'LK 10/9/2023 14:11:02'!
PASSED!

!testRun: #MarsRoverTest #test14shouldRotateRightPointingWestCorrectly stamp: 'LK 10/9/2023 14:11:02'!
PASSED!

!testRun: #MarsRoverTest #test15shouldRotateLeftPointingNorthCorrectly stamp: 'LK 10/9/2023 14:11:02'!
PASSED!

!testRun: #MarsRoverTest #test16shouldRotateLeftPointingSouthCorrectly stamp: 'LK 10/9/2023 14:11:02'!
PASSED!

!testRun: #MarsRoverTest #test17shouldRotateLeftPointingEastCorrectly stamp: 'LK 10/9/2023 14:11:02'!
PASSED!

!testRun: #MarsRoverTest #test18shouldRotateLeftPointingWestCorrectly stamp: 'LK 10/9/2023 14:11:02'!
PASSED!

!testRun: #MarsRoverTest #test19shouldHandleMultipleCommands stamp: 'LK 10/9/2023 14:11:02'!
PASSED!

!testRun: #MarsRoverTest #test20shouldHandleInvalidCommand stamp: 'LK 10/9/2023 14:11:02'!
PASSED!

!testRun: #MarsRoverTest #test21shouldHandleCommandsUntilInvalidCommand stamp: 'LK 10/9/2023 14:11:02'!
PASSED!

!classRemoval: #Forward stamp: 'LK 10/9/2023 14:11:42'!
Command subclass: #Forward
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!

!classRemoval: #Backward stamp: 'LK 10/9/2023 14:11:43'!
Command subclass: #Backward
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!

!classRemoval: #RotateLeft stamp: 'LK 10/9/2023 14:11:43'!
Command subclass: #RotateLeft
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!

!classRemoval: #RotateRight stamp: 'LK 10/9/2023 14:11:43'!
Command subclass: #RotateRight
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!

!classRemoval: #Command stamp: 'LK 10/9/2023 14:11:43'!
Object subclass: #Command
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Mars Rover- Exercise'!

!testRun: #MarsRoverTest #test01shouldInitializeInGivenCoordinateAndDirection stamp: 'LK 10/9/2023 14:11:47'!
PASSED!

!testRun: #MarsRoverTest #test02shouldDoNothingOnEmptyString stamp: 'LK 10/9/2023 14:11:47'!
PASSED!

!testRun: #MarsRoverTest #test03shouldMoveForwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 14:11:47'!
PASSED!

!testRun: #MarsRoverTest #test04shouldMoveForwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 14:11:47'!
PASSED!

!testRun: #MarsRoverTest #test05shouldMoveForwardsPointingWestCorrectly stamp: 'LK 10/9/2023 14:11:47'!
PASSED!

!testRun: #MarsRoverTest #test06shouldMoveForwardsPointingEastCorrectly stamp: 'LK 10/9/2023 14:11:47'!
PASSED!

!testRun: #MarsRoverTest #test07shouldMoveBackwardsPointingNorthCorrectly stamp: 'LK 10/9/2023 14:11:47'!
PASSED!

!testRun: #MarsRoverTest #test08shouldMoveBackwardsPointingSouthCorrectly stamp: 'LK 10/9/2023 14:11:47'!
PASSED!

!testRun: #MarsRoverTest #test09shouldMoveBackwardsPointingEastCorrectly stamp: 'LK 10/9/2023 14:11:47'!
PASSED!

!testRun: #MarsRoverTest #test10shouldMoveBackwardsPointingWestCorrectly stamp: 'LK 10/9/2023 14:11:47'!
PASSED!

!testRun: #MarsRoverTest #test11shouldRotateRightPointingNorthCorrectly stamp: 'LK 10/9/2023 14:11:47'!
PASSED!

!testRun: #MarsRoverTest #test12shouldRotateRightPointingEastCorrectly stamp: 'LK 10/9/2023 14:11:47'!
PASSED!

!testRun: #MarsRoverTest #test13shouldRotateRightPointingSouthCorrectly stamp: 'LK 10/9/2023 14:11:47'!
PASSED!

!testRun: #MarsRoverTest #test14shouldRotateRightPointingWestCorrectly stamp: 'LK 10/9/2023 14:11:47'!
PASSED!

!testRun: #MarsRoverTest #test15shouldRotateLeftPointingNorthCorrectly stamp: 'LK 10/9/2023 14:11:47'!
PASSED!

!testRun: #MarsRoverTest #test16shouldRotateLeftPointingSouthCorrectly stamp: 'LK 10/9/2023 14:11:47'!
PASSED!

!testRun: #MarsRoverTest #test17shouldRotateLeftPointingEastCorrectly stamp: 'LK 10/9/2023 14:11:47'!
PASSED!

!testRun: #MarsRoverTest #test18shouldRotateLeftPointingWestCorrectly stamp: 'LK 10/9/2023 14:11:47'!
PASSED!

!testRun: #MarsRoverTest #test19shouldHandleMultipleCommands stamp: 'LK 10/9/2023 14:11:47'!
PASSED!

!testRun: #MarsRoverTest #test20shouldHandleInvalidCommand stamp: 'LK 10/9/2023 14:11:47'!
PASSED!

!testRun: #MarsRoverTest #test21shouldHandleCommandsUntilInvalidCommand stamp: 'LK 10/9/2023 14:11:47'!
PASSED!